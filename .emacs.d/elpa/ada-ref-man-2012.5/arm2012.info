This is arm2012.info, produced by texi2any version 6.3 from
arm2012.texinfo.

INFO-DIR-SECTION GNU Ada tools
START-INFO-DIR-ENTRY
* Ada Reference Manual TC1: (arm2012).
* Annotated ARM TC1: (arm2012).
END-INFO-DIR-ENTRY


File: arm2012.info,  Node: Top,  Next: Front Matter,  Up: (dir)

Ada Reference Manual
********************

Ada Reference Manual, ISO/IEC 8652:2012(E) with COR.1:2016

                         Ada Reference Manual

                         ISO/IEC 8652:2012(E)

                     with Technical Corrigendum 1

                    Language and Standard Libraries

* Menu:

* Front Matter:: Copyright, Foreword, etc.
* 1 ::        General
* 2 ::        Lexical Elements
* 3 ::        Declarations and Types
* 4 ::        Names and Expressions
* 5 ::        Statements
* 6 ::        Subprograms
* 7 ::        Packages
* 8 ::        Visibility Rules
* 9 ::        Tasks and Synchronization
* 10 ::       Program Structure and Compilation Issues
* 11 ::       Exceptions
* 12 ::       Generic Units
* 13 ::       Representation Issues
* Annex A ::  Predefined Language Environment
* Annex B ::  Interface to Other Languages
* Annex C ::  Systems Programming
* Annex D ::  Real-Time Systems
* Annex E ::  Distributed Systems
* Annex F ::  Information Systems
* Annex G ::  Numerics
* Annex H ::  High Integrity Systems
* Annex J ::  Obsolescent Features
* Annex K ::  Language-Defined Aspects and Attributes
* Annex L ::  Language-Defined Pragmas
* Annex M ::  Summary of Documentation Requirements
* Annex N ::  Glossary
* Annex P ::  Syntax Summary
* Annex Q ::  Language-Defined Entities
* Index ::    Index


File: arm2012.info,  Node: Front Matter,  Next: 1,  Prev: Top,  Up: Top

Front Matter
************

Copyright © 1992, 1993, 1994, 1995 Intermetrics, Inc.

Copyright © 2000 The MITRE Corporation, Inc.

Copyright © 2004, 2005, 2006 AXE Consultants

Copyright © 2004, 2005, 2006 Ada-Europe

Copyright © 2008, 2009, 2010, 2011, 2012, 2013, 2014, 2015, 2016 AXE
Consultants

 





Ada Reference Manual - Language and Standard Libraries

Copyright © 1992, 1993, 1994, 1995, Intermetrics, Inc.

This copyright is assigned to the U.S. Government.  All rights reserved.

This document may be copied, in whole or in part, in any form or by any
means, as is or with alterations, provided that (1) alterations are
clearly marked as alterations and (2) this copyright notice is included
unmodified in any copy.  Compiled copies of standard library units and
examples need not contain this copyright notice so long as the notice is
included in all copies of source code and documentation.

-------  

Technical Corrigendum 1

Copyright © 2000, The MITRE Corporation.  All Rights Reserved.

This document may be copied, in whole or in part, in any form or by any
means, as is, or with alterations, provided that (1) alterations are
clearly marked as alterations and (2) this copyright notice is included
unmodified in any copy.  Any other use or distribution of this document
is prohibited without the prior express permission of MITRE.

You use this document on the condition that you indemnify and hold
harmless MITRE, its Board of Trustees, officers, agents, and employees,
from any and all liability or damages to yourself or your hardware or
software, or third parties, including attorneys' fees, court costs, and
other related costs and expenses, arising out of your use of this
document irrespective of the cause of said liability.

MITRE MAKES THIS DOCUMENT AVAILABLE ON AN "AS IS" BASIS AND MAKES NO
WARRANTY, EXPRESS OR IMPLIED, AS TO THE ACCURACY, CAPABILITY, EFFICIENCY
MERCHANTABILITY, OR FUNCTIONING OF THIS DOCUMENT. IN NO EVENT WILL MITRE
BE LIABLE FOR ANY GENERAL, CONSEQUENTIAL, INDIRECT, INCIDENTAL,
EXEMPLARY, OR SPECIAL DAMAGES, EVEN IF MITRE HAS BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.

 

Amendment 1

Copyright © 2004, 2005, 2006, 2007, AXE Consultants.  All Rights
Reserved.

This document may be copied, in whole or in part, in any form or by any
means, as is, or with alterations, provided that (1) alterations are
clearly marked as alterations and (2) this copyright notice is included
unmodified in any copy.  Any other use or distribution of this document
is prohibited without the prior express permission of AXE.

You use this document on the condition that you indemnify and hold
harmless AXE, its board, officers, agents, and employees, from any and
all liability or damages to yourself or your hardware or software, or
third parties, including attorneys' fees, court costs, and other related
costs and expenses, arising out of your use of this document
irrespective of the cause of said liability.

AXE MAKES THIS DOCUMENT AVAILABLE ON AN "AS IS" BASIS AND MAKES NO
WARRANTY, EXPRESS OR IMPLIED, AS TO THE ACCURACY, CAPABILITY, EFFICIENCY
MERCHANTABILITY, OR FUNCTIONING OF THIS DOCUMENT. IN NO EVENT WILL AXE
BE LIABLE FOR ANY GENERAL, CONSEQUENTIAL, INDIRECT, INCIDENTAL,
EXEMPLARY, OR SPECIAL DAMAGES, EVEN IF AXE HAS BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.

Third Edition

Copyright © 2008, 2009, 2010, 2011, 2012 AXE Consultants.  All Rights
Reserved.

This document may be copied, in whole or in part, in any form or by any
means, as is, or with alterations, provided that (1) alterations are
clearly marked as alterations and (2) this copyright notice is included
unmodified in any copy.  Any other use or distribution of this document
is prohibited without the prior express permission of AXE.

You use this document on the condition that you indemnify and hold
harmless AXE, its board, officers, agents, and employees, from any and
all liability or damages to yourself or your hardware or software, or
third parties, including attorneys' fees, court costs, and other related
costs and expenses, arising out of your use of this document
irrespective of the cause of said liability.

AXE MAKES THIS DOCUMENT AVAILABLE ON AN "AS IS" BASIS AND MAKES NO
WARRANTY, EXPRESS OR IMPLIED, AS TO THE ACCURACY, CAPABILITY, EFFICIENCY
MERCHANTABILITY, OR FUNCTIONING OF THIS DOCUMENT. IN NO EVENT WILL AXE
BE LIABLE FOR ANY GENERAL, CONSEQUENTIAL, INDIRECT, INCIDENTAL,
EXEMPLARY, OR SPECIAL DAMAGES, EVEN IF AXE HAS BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.

Technical Corrigendum 1 for Ada 2012

Copyright © 2013, 2014, 2015, 2016 AXE Consultants.  All Rights
Reserved.

This document may be copied, in whole or in part, in any form or by any
means, as is, or with alterations, provided that (1) alterations are
clearly marked as alterations and (2) this copyright notice is included
unmodified in any copy.  Any other use or distribution of this document
is prohibited without the prior express permission of AXE.

You use this document on the condition that you indemnify and hold
harmless AXE, its board, officers, agents, and employees, from any and
all liability or damages to yourself or your hardware or software, or
third parties, including attorneys' fees, court costs, and other related
costs and expenses, arising out of your use of this document
irrespective of the cause of said liability.

AXE MAKES THIS DOCUMENT AVAILABLE ON AN "AS IS" BASIS AND MAKES NO
WARRANTY, EXPRESS OR IMPLIED, AS TO THE ACCURACY, CAPABILITY, EFFICIENCY
MERCHANTABILITY, OR FUNCTIONING OF THIS DOCUMENT. IN NO EVENT WILL AXE
BE LIABLE FOR ANY GENERAL, CONSEQUENTIAL, INDIRECT, INCIDENTAL,
EXEMPLARY, OR SPECIAL DAMAGES, EVEN IF AXE HAS BEEN ADVISED OF THE
POSSIBILITY OF SUCH DAMAGES.

 

Ada 2005 Consolidated Standard

Copyright © 2004, 2005, 2006, Ada-Europe.

This document may be copied, in whole or in part, in any form or by any
means, as is, or with alterations, provided that (1) alterations are
clearly marked as alterations and (2) this copyright notice is included
unmodified in any copy.  Any other use or distribution of this document
is prohibited without the prior express permission of Ada-Europe.

You use this document on the condition that you indemnify and hold
harmless Ada-Europe and its Board from any and all liability or damages
to yourself or your hardware or software, or third parties, including
attorneys' fees, court costs, and other related costs and expenses,
arising out of your use of this document irrespective of the cause of
said liability.

ADA-EUROPE MAKES THIS DOCUMENT AVAILABLE ON AN "AS IS" BASIS AND MAKES
NO WARRANTY, EXPRESS OR IMPLIED, AS TO THE ACCURACY, CAPABILITY,
EFFICIENCY MERCHANTABILITY, OR FUNCTIONING OF THIS DOCUMENT. IN NO EVENT
WILL ADA-EUROPE BE LIABLE FOR ANY GENERAL, CONSEQUENTIAL, INDIRECT,
INCIDENTAL, EXEMPLARY, OR SPECIAL DAMAGES, EVEN IF ADA-EUROPE HAS BEEN
ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.

* Menu:

* 0.1 :: Foreword to this version of the Ada Reference Manual
* 0.2 :: Foreword
* 0.3 :: Introduction
* 0.99 :: International Standard


File: arm2012.info,  Node: 0.1,  Next: 0.2,  Up: Front Matter

0.1 Foreword to this version of the Ada Reference Manual
========================================================

0.1/4
The International Standard for the programming language Ada is ISO/IEC
8652:2012(E).

0.2/4
The Ada Working Group ISO/IEC JTC 1/SC 22/WG 9 is tasked by ISO with the
work item to interpret and maintain the International Standard and to
produce Technical Corrigenda, as appropriate.  The technical work on the
International Standard is performed by the Ada Rapporteur Group (ARG) of
WG 9.  In June 2015, WG 9 approved and forwarded Technical Corrigendum 1
to SC 22 for ISO approval, which was granted in December 2015.
Technical Corrigendum 1 was published in February 2016.

0.4/4
The Technical Corrigendum lists the individual changes that need to be
made to the text of the International Standard to correct errors,
omissions or inconsistencies.  The corrections specified in Technical
Corrigendum 1 are part of the International Standard ISO/IEC
8652:2012(E).

0.6/4
When ISO published Technical Corrigendum 1, it did not also publish a
document that merges the changes from the Technical Corrigendum into the
text of the International Standard.  However, ISO rules require that the
project editor for the International Standard be able to produce such a
document on demand.

0.7/4
This version of the Ada Reference Manual is what the project editor
would provide to ISO in response to such a request.  It incorporates the
changes specified in the Technical Corrigendum into the text of ISO/IEC
8652:2012(E). It should be understood that the publication of any ISO
document involves changes in general format, boilerplate, headers, etc.,
as well as a review by professional editors that may introduce editorial
changes to the text.  This version of the Ada Reference Manual is
therefore neither an official ISO document, nor a version guaranteed to
be identical to an official ISO document, should ISO decide to reprint
the International Standard incorporating an approved Technical
Corrigendum.  It is nevertheless a best effort to be as close as
possible to the technical content of such an updated document.  In the
case of a conflict between this document and Technical Corrigendum 1 as
approved by ISO (or between this document and the original 8652:2012 in
the case of paragraphs not changed by Technical Corrigendum 1), the
other documents contain the official text of the International Standard
ISO/IEC 8652:2012(E).

0.8/4
As it is very inconvenient to have the Reference Manual for Ada
specified in two documents, this consolidated version of the Ada
Reference Manual is made available to the public.


File: arm2012.info,  Node: 0.2,  Next: 0.3,  Prev: 0.1,  Up: Front Matter

0.2 Foreword
============

1/3
ISO (the International Organization for Standardization) and IEC (the
International Electrotechnical Commission) form the specialized system
for worldwide standardization.  National bodies that are members of ISO
or IEC participate in the development of International Standards through
technical committees established by the respective organization to deal
with particular fields of technical activity.  ISO and IEC technical
committees collaborate in fields of mutual interest.  Other
international organizations, governmental and non-governmental, in
liaison with ISO and IEC, also take part in the work.  In the field of
information technology, ISO and IEC have established a joint technical
committee, ISO/IEC JTC 1.

1.1/3
International Standards are drafted in accordance with the rules given
in the ISO/IEC Directives, Part 2.

2/3
The main task of the joint technical committee is to prepare
International Standards.  Draft International Standards adopted by the
joint technical committee are circulated to national bodies for voting.
Publication as an International Standard requires approval by at least
75 % of the national bodies casting a vote.

2.1/3
Attention is drawn to the possibility that some of the elements of this
document may be the subject of patent rights.  ISO and IEC shall not be
held responsible for identifying any or all such patent rights.

3/3
International Standard ISO/IEC 8652 was prepared by Joint Technical
Committee ISO/IEC JTC 1, <Information Technology> Subcommittee SC22,
<Programming languages, their environments and system software
interfaces>.

4/4
This consolidated edition updates the third edition (ISO/IEC 8652:2012).


File: arm2012.info,  Node: 0.3,  Next: 0.99,  Prev: 0.2,  Up: Front Matter

0.3 Introduction
================

1
This is the Ada Reference Manual.

2
Other available Ada documents include:

3/3
   * Ada 2012 Rationale.  This gives an introduction to the changes and
     new features in Ada 2012, and explains the rationale behind them.
     Programmers should read this rationale before reading this Standard
     in depth.  Rationales for Ada 83, Ada 95, and Ada 2005 are also
     available.

4/1
   * <This paragraph was deleted.>

5/3
   * The Annotated Ada Reference Manual (AARM). The AARM contains all of
     the text in this International Standard, plus various annotations.
     It is intended primarily for compiler writers, validation test
     writers, and others who wish to study the fine details.  The
     annotations include detailed rationale for individual rules and
     explanations of some of the more arcane interactions among the
     rules.

Design Goals

6/3
Ada was originally designed with three overriding concerns: program
reliability and maintenance, programming as a human activity, and
efficiency.  The 1995 revision to the language was designed to provide
greater flexibility and extensibility, additional control over storage
management and synchronization, and standardized packages oriented
toward supporting important application areas, while at the same time
retaining the original emphasis on reliability, maintainability, and
efficiency.  This third edition provides further flexibility and adds
more standardized packages within the framework provided by the 1995
revision.

7
The need for languages that promote reliability and simplify maintenance
is well established.  Hence emphasis was placed on program readability
over ease of writing.  For example, the rules of the language require
that program variables be explicitly declared and that their type be
specified.  Since the type of a variable is invariant, compilers can
ensure that operations on variables are compatible with the properties
intended for objects of the type.  Furthermore, error-prone notations
have been avoided, and the syntax of the language avoids the use of
encoded forms in favor of more English-like constructs.  Finally, the
language offers support for separate compilation of program units in a
way that facilitates program development and maintenance, and which
provides the same degree of checking between units as within a unit.

8
Concern for the human programmer was also stressed during the design.
Above all, an attempt was made to keep to a relatively small number of
underlying concepts integrated in a consistent and systematic way while
continuing to avoid the pitfalls of excessive involution.  The design
especially aims to provide language constructs that correspond
intuitively to the normal expectations of users.

9
Like many other human activities, the development of programs is
becoming ever more decentralized and distributed.  Consequently, the
ability to assemble a program from independently produced software
components continues to be a central idea in the design.  The concepts
of packages, of private types, and of generic units are directly related
to this idea, which has ramifications in many other aspects of the
language.  An allied concern is the maintenance of programs to match
changing requirements; type extension and the hierarchical library
enable a program to be modified while minimizing disturbance to existing
tested and trusted components.

10
No language can avoid the problem of efficiency.  Languages that require
over-elaborate compilers, or that lead to the inefficient use of storage
or execution time, force these inefficiencies on all machines and on all
programs.  Every construct of the language was examined in the light of
present implementation techniques.  Any proposed construct whose
implementation was unclear or that required excessive machine resources
was rejected.

Language Summary

11
An Ada program is composed of one or more program units.  Program units
may be subprograms (which define executable algorithms), packages (which
define collections of entities), task units (which define concurrent
computations), protected units (which define operations for the
coordinated sharing of data between tasks), or generic units (which
define parameterized forms of packages and subprograms).  Each program
unit normally consists of two parts: a specification, containing the
information that must be visible to other units, and a body, containing
the implementation details, which need not be visible to other units.
Most program units can be compiled separately.

12
This distinction of the specification and body, and the ability to
compile units separately, allows a program to be designed, written, and
tested as a set of largely independent software components.

13
An Ada program will normally make use of a library of program units of
general utility.  The language provides means whereby individual
organizations can construct their own libraries.  All libraries are
structured in a hierarchical manner; this enables the logical
decomposition of a subsystem into individual components.  The text of a
separately compiled program unit must name the library units it
requires.

14
<Program Units>

15
A subprogram is the basic unit for expressing an algorithm.  There are
two kinds of subprograms: procedures and functions.  A procedure is the
means of invoking a series of actions.  For example, it may read data,
update variables, or produce some output.  It may have parameters, to
provide a controlled means of passing information between the procedure
and the point of call.  A function is the means of invoking the
computation of a value.  It is similar to a procedure, but in addition
will return a result.

16
A package is the basic unit for defining a collection of logically
related entities.  For example, a package can be used to define a set of
type declarations and associated operations.  Portions of a package can
be hidden from the user, thus allowing access only to the logical
properties expressed by the package specification.

17
Subprogram and package units may be compiled separately and arranged in
hierarchies of parent and child units giving fine control over
visibility of the logical properties and their detailed implementation.

18
A task unit is the basic unit for defining a task whose sequence of
actions may be executed concurrently with those of other tasks.  Such
tasks may be implemented on multicomputers, multiprocessors, or with
interleaved execution on a single processor.  A task unit may define
either a single executing task or a task type permitting the creation of
any number of similar tasks.

19/2
A protected unit is the basic unit for defining protected operations for
the coordinated use of data shared between tasks.  Simple mutual
exclusion is provided automatically, and more elaborate sharing
protocols can be defined.  A protected operation can either be a
subprogram or an entry.  A protected entry specifies a Boolean
expression (an entry barrier) that must be True before the body of the
entry is executed.  A protected unit may define a single protected
object or a protected type permitting the creation of several similar
objects.

20
<Declarations and Statements>

21
The body of a program unit generally contains two parts: a declarative
part, which defines the logical entities to be used in the program unit,
and a sequence of statements, which defines the execution of the program
unit.

22
The declarative part associates names with declared entities.  For
example, a name may denote a type, a constant, a variable, or an
exception.  A declarative part also introduces the names and parameters
of other nested subprograms, packages, task units, protected units, and
generic units to be used in the program unit.

23
The sequence of statements describes a sequence of actions that are to
be performed.  The statements are executed in succession (unless a
transfer of control causes execution to continue from another place).

24
An assignment statement changes the value of a variable.  A procedure
call invokes execution of a procedure after associating any actual
parameters provided at the call with the corresponding formal
parameters.

25
Case statements and if statements allow the selection of an enclosed
sequence of statements based on the value of an expression or on the
value of a condition.

26
The loop statement provides the basic iterative mechanism in the
language.  A loop statement specifies that a sequence of statements is
to be executed repeatedly as directed by an iteration scheme, or until
an exit statement is encountered.

27
A block statement comprises a sequence of statements preceded by the
declaration of local entities used by the statements.

28
Certain statements are associated with concurrent execution.  A delay
statement delays the execution of a task for a specified duration or
until a specified time.  An entry call statement is written as a
procedure call statement; it requests an operation on a task or on a
protected object, blocking the caller until the operation can be
performed.  A called task may accept an entry call by executing a
corresponding accept statement, which specifies the actions then to be
performed as part of the rendezvous with the calling task.  An entry
call on a protected object is processed when the corresponding entry
barrier evaluates to true, whereupon the body of the entry is executed.
The requeue statement permits the provision of a service as a number of
related activities with preference control.  One form of the select
statement allows a selective wait for one of several alternative
rendezvous.  Other forms of the select statement allow conditional or
timed entry calls and the asynchronous transfer of control in response
to some triggering event.

29
Execution of a program unit may encounter error situations in which
normal program execution cannot continue.  For example, an arithmetic
computation may exceed the maximum allowed value of a number, or an
attempt may be made to access an array component by using an incorrect
index value.  To deal with such error situations, the statements of a
program unit can be textually followed by exception handlers that
specify the actions to be taken when the error situation arises.
Exceptions can be raised explicitly by a raise statement.

30
<Data Types>

31
Every object in the language has a type, which characterizes a set of
values and a set of applicable operations.  The main classes of types
are elementary types (comprising enumeration, numeric, and access types)
and composite types (including array and record types).

32/2
An enumeration type defines an ordered set of distinct enumeration
literals, for example a list of states or an alphabet of characters.
The enumeration types Boolean, Character, Wide_Character, and
Wide_Wide_Character are predefined.

33
Numeric types provide a means of performing exact or approximate
numerical computations.  Exact computations use integer types, which
denote sets of consecutive integers.  Approximate computations use
either fixed point types, with absolute bounds on the error, or floating
point types, with relative bounds on the error.  The numeric types
Integer, Float, and Duration are predefined.

34/2
Composite types allow definitions of structured objects with related
components.  The composite types in the language include arrays and
records.  An array is an object with indexed components of the same
type.  A record is an object with named components of possibly different
types.  Task and protected types are also forms of composite types.  The
array types String, Wide_String, and Wide_Wide_String are predefined.

35
Record, task, and protected types may have special components called
discriminants which parameterize the type.  Variant record structures
that depend on the values of discriminants can be defined within a
record type.

36
Access types allow the construction of linked data structures.  A value
of an access type represents a reference to an object declared as
aliased or to an object created by the evaluation of an allocator.
Several variables of an access type may designate the same object, and
components of one object may designate the same or other objects.  Both
the elements in such linked data structures and their relation to other
elements can be altered during program execution.  Access types also
permit references to subprograms to be stored, passed as parameters, and
ultimately dereferenced as part of an indirect call.

37
Private types permit restricted views of a type.  A private type can be
defined in a package so that only the logically necessary properties are
made visible to the users of the type.  The full structural details that
are externally irrelevant are then only available within the package and
any child units.

38
From any type a new type may be defined by derivation.  A type, together
with its derivatives (both direct and indirect) form a derivation class.
Class-wide operations may be defined that accept as a parameter an
operand of any type in a derivation class.  For record and private
types, the derivatives may be extensions of the parent type.  Types that
support these object-oriented capabilities of class-wide operations and
type extension must be tagged, so that the specific type of an operand
within a derivation class can be identified at run time.  When an
operation of a tagged type is applied to an operand whose specific type
is not known until run time, implicit dispatching is performed based on
the tag of the operand.

38.1/2
Interface types provide abstract models from which other interfaces and
types may be composed and derived.  This provides a reliable form of
multiple inheritance.  Interface types may also be implemented by task
types and protected types thereby enabling concurrent programming and
inheritance to be merged.

39
The concept of a type is further refined by the concept of a subtype,
whereby a user can constrain the set of allowed values of a type.
Subtypes can be used to define subranges of scalar types, arrays with a
limited set of index values, and records and private types with
particular discriminant values.

40
<Other Facilities>

41/2
Aspect clauses can be used to specify the mapping between types and
features of an underlying machine.  For example, the user can specify
that objects of a given type must be represented with a given number of
bits, or that the components of a record are to be represented using a
given storage layout.  Other features allow the controlled use of low
level, nonportable, or implementation-dependent aspects, including the
direct insertion of machine code.

42/2
The predefined environment of the language provides for input-output and
other capabilities by means of standard library packages.  Input-output
is supported for values of user-defined as well as of predefined types.
Standard means of representing values in display form are also provided.

42.1/2
The predefined standard library packages provide facilities such as
string manipulation, containers of various kinds (vectors, lists, maps,
etc.), mathematical functions, random number generation, and access to
the execution environment.

42.2/2
The specialized annexes define further predefined library packages and
facilities with emphasis on areas such as real-time scheduling,
interrupt handling, distributed systems, numerical computation, and
high-integrity systems.

43
Finally, the language provides a powerful means of parameterization of
program units, called generic program units.  The generic parameters can
be types and subprograms (as well as objects and packages) and so allow
general algorithms and data structures to be defined that are applicable
to all types of a given class.

Language Changes

<Paragraphs 44 through 57 have been removed as they described
differences from the first edition of Ada (Ada 83).>

57.1/3
This International Standard replaces the second edition of 1995.  It
modifies the previous edition by making changes and additions that
improve the capability of the language and the reliability of programs
written in the language.  This edition incorporates the changes from
Amendment 1 (ISO/IEC 8652:1995:AMD 1:2007), which were designed to
improve the portability of programs, interfacing to other languages, and
both the object-oriented and real-time capabilities.

57.2/3
Significant changes originating in Amendment 1 are incorporated:

57.3/3
   * Support for program text is extended to cover the entire ISO/IEC
     10646:2003 repertoire.  Execution support now includes the 32-bit
     character set.  See subclauses *note 2.1::, *note 3.5.2::, *note
     3.6.3::, *note A.1::, *note A.3::, and *note A.4::.

57.4/3
   * The object-oriented model has been improved by the addition of an
     interface facility which provides multiple inheritance and
     additional flexibility for type extensions.  See subclauses *note
     3.4::, *note 3.9::, and *note 7.3::.  An alternative notation for
     calling operations more akin to that used in other languages has
     also been added.  See subclause *note 4.1.3::.

57.5/3
   * Access types have been further extended to unify properties such as
     the ability to access constants and to exclude null values.  See
     clause *note 3.10::.  Anonymous access types are now permitted more
     freely and anonymous access-to-subprogram types are introduced.
     See subclauses *note 3.3::, *note 3.6::, *note 3.10::, and *note
     8.5.1::.

57.6/3
   * The control of structure and visibility has been enhanced to permit
     mutually dependent references between units and finer control over
     access from the private part of a package.  See subclauses *note
     3.10.1:: and *note 10.1.2::.  In addition, limited types have been
     made more useful by the provision of aggregates, constants, and
     constructor functions.  See subclauses *note 4.3::, *note 6.5::,
     and *note 7.5::.

57.7/3
   * The predefined environment has been extended to include additional
     time and calendar operations, improved string handling, a
     comprehensive container library, file and directory management, and
     access to environment variables.  See subclauses *note 9.6.1::,
     *note A.4::, *note A.16::, *note A.17::, and *note A.18::.

57.8/3
   * Two of the Specialized Needs Annexes have been considerably
     enhanced:

57.9/2
             * The Real-Time Systems Annex now includes the Ravenscar
               profile for high-integrity systems, further dispatching
               policies such as Round Robin and Earliest Deadline First,
               support for timing events, and support for control of CPU
               time utilization.  See subclauses *note D.2::, *note
               D.13::, *note D.14::, and *note D.15::.

57.10/3
             * The Numerics Annex now includes support for real and
               complex vectors and matrices as previously defined in
               ISO/IEC 13813:1997 plus further basic operations for
               linear algebra.  See subclause *note G.3::.

57.11/3
   * The overall reliability of the language has been enhanced by a
     number of improvements.  These include new syntax which detects
     accidental overloading, as well as pragmas for making assertions
     and giving better control over the suppression of checks.  See
     subclauses *note 6.1::, *note 11.4.2::, and *note 11.5::.

57.12/3
In addition, this third edition makes enhancements to address two
important issues, namely, the particular problems of multiprocessor
architectures, and the need to further increase the capabilities
regarding assertions for correctness.  It also makes additional changes
and additions that improve the capability of the language and the
reliability of programs written in the language.

57.13/3
The following significant changes with respect to the 1995 edition as
amended by Amendment 1 are incorporated:

57.14/3
   * New syntax (the aspect specification) is introduced to enable
     properties to be specified for various entities in a more
     structured manner than through pragmas.  See subclause *note
     13.1.1::.

57.15/4
   * The concept of assertions introduced in the 2005 edition is
     extended with the ability to specify preconditions and
     postconditions for subprograms, and invariants for private types
     and interfaces.  The concept of constraints in defining subtypes is
     supplemented with subtype predicates that enable subsets to be
     specified other than as simple ranges.  These properties are all
     indicated using aspect specifications.  See subclauses *note
     3.2.4::, *note 6.1.1::, and *note 7.3.2::.

57.16/4
   * New forms of expressions are introduced.  These are if expressions,
     case expressions, quantified expressions, expression functions, and
     raise expressions.  As well as being useful for programming in
     general by avoiding the introduction of unnecessary assignments,
     they are especially valuable in conditions and invariants since
     they avoid the need to introduce auxiliary functions.  See
     subclauses *note 4.5.7::, *note 4.5.8::, *note 6.8::, and *note
     11.3::.  Membership tests are also made more flexible.  See
     subclauses *note 4.4:: and *note 4.5.2::.

57.17/3
   * A number of changes are made to subprogram parameters.  Functions
     may now have parameters of all modes.  In order to mitigate
     consequent (and indeed existing) problems of inadvertent order
     dependence, rules are introduced to reduce aliasing.  A parameter
     may now be explicitly marked as aliased and the type of a parameter
     may be incomplete in certain circumstances.  See subclauses *note
     3.10.1::, *note 6.1::, and *note 6.4.1::.

57.18/3
   * The use of access types is now more flexible.  The rules for
     accessibility and certain conversions are improved.  See subclauses
     *note 3.10.2::, *note 4.5.2::, *note 4.6::, and *note 8.6::.
     Furthermore, better control of storage pools is provided.  See
     subclause *note 13.11.4::.

57.19/3
   * The Real-Time Systems Annex now includes facilities for defining
     domains of processors and assigning tasks to them.  Improvements
     are made to scheduling and budgeting facilities.  See subclauses
     *note D.10.1::, *note D.14::, and *note D.16::.

57.20/3
   * A number of important improvements are made to the standard
     library.  These include packages for conversions between strings
     and UTF encodings, and classification functions for wide and wide
     wide characters.  Internationalization is catered for by a package
     giving locale information.  See subclauses *note A.3::, *note
     A.4.11::, and *note A.19::.  The container library is extended to
     include bounded forms of the existing containers and new containers
     for indefinite objects, multiway trees, and queues.  See subclause
     *note A.18::.

57.21/3
   * Finally, certain features are added primarily to ease the use of
     containers, such as the ability to iterate over all elements in a
     container without having to encode the iteration.  These can also
     be used for iteration over arrays, and within quantified
     expressions.  See subclauses *note 4.1.5::, *note 4.1.6::, *note
     5.5.1::, and *note 5.5.2::.

Instructions for Comment Submission

58/1
Informal comments on this International Standard may be sent via e-mail
to ada-comment@ada-auth.org.  If appropriate, the Project Editor will
initiate the defect correction procedure.

59
Comments should use the following format:

60/3
        !topic <Title summarizing comment>
        !reference Ada 2012 RM<ss.ss(pp)>
        !from <Author Name yy-mm-dd>
        !keywords <keywords related to topic>
        !discussion

        <text of discussion>

61/3
where <ss.ss> is the clause or subclause number, <pp> is the paragraph
number where applicable, and <yy-mm-dd> is the date the comment was
sent.  The date is optional, as is the !keywords line.

62/1
Please use a descriptive "Subject" in your e-mail message, and limit
each message to a single comment.

63
When correcting typographical errors or making minor wording
suggestions, please put the correction directly as the topic of the
comment; use square brackets [ ] to indicate text to be omitted and
curly braces { } to indicate text to be added, and provide enough
context to make the nature of the suggestion self-evident or put
additional information in the body of the comment, for example:

64
        !topic [c]{C}haracter
        !topic it[']s meaning is not defined

65
Formal requests for interpretations and for reporting defects in this
International Standard may be made in accordance with the ISO/IEC JTC 1
Directives and the ISO/IEC JTC 1/SC 22 policy for interpretations.
National Bodies may submit a Defect Report to ISO/IEC JTC 1/SC 22 for
resolution under the JTC 1 procedures.  A response will be provided and,
if appropriate, a Technical Corrigendum will be issued in accordance
with the procedures.

Acknowledgements for the Ada 83 edition

65.1/3
Ada is the result of a collective effort to design a common language for
programming large scale and real-time systems.

65.2/3
The common high order language program began in 1974.  The requirements
of the United States Department of Defense were formalized in a series
of documents which were extensively reviewed by the Services, industrial
organizations, universities, and foreign military departments.  The Ada
language was designed in accordance with the final (1978) form of these
requirements, embodied in the Steelman specification.

65.3/3
The Ada design team was led by Jean D. Ichbiah and has included Bernd
Krieg-Brueckner, Brian A. Wichmann, Henry F. Ledgard, Jean-Claude
Heliard, Jean-Loup Gailly, Jean-Raymond Abrial, John G.P. Barnes, Mike
Woodger, Olivier Roubine, Paul N. Hilfinger, and Robert Firth.

65.4/3
At various stages of the project, several people closely associated with
the design team made major contributions.  They include J.B. Goodenough,
R.F. Brender, M.W. Davis, G. Ferran, K. Lester, L. MacLaren, E. Morel,
I.R. Nassi, I.C. Pyle, S.A. Schuman, and S.C. Vestal.

65.5/3
Two parallel efforts that were started in the second phase of this
design had a deep influence on the language.  One was the development of
a formal definition using denotational semantics, with the participation
of V. Donzeau-Gouge, G. Kahn, and B. Lang.  The other was the design of
a test translator with the participation of K. Ripken, P. Boullier, P.
Cadiou, J. Holden, J.F. Hueras, R.G. Lange, and D.T. Cornhill.  The
entire effort benefitted from the dedicated assistance of Lyn Churchill
and Marion Myers, and the effective technical support of B. Gravem, W.L.
Heimerdinger, and P. Cleve.  H.G. Schmitz served as program manager.

65.6/3
Over the five years spent on this project, several intense week-long
design reviews were conducted, with the participation of P. Belmont, B.
Brosgol, P. Cohen, R. Dewar, A. Evans, G. Fisher, H. Harte, A.L. Hisgen,
P. Knueven, M. Kronental, N. Lomuto, E. Ploedereder, G. Seegmueller, V.
Stenning, D. Taffs, and also F. Belz, R. Converse, K. Correll, A.N.
Habermann, J. Sammet, S. Squires, J. Teller, P. Wegner, and P.R.
Wetherall.

65.7/3
Several persons had a constructive influence with their comments,
criticisms and suggestions.  They include P. Brinch Hansen, G. Goos,
C.A.R. Hoare, Mark Rain, W.A. Wulf, and also E. Boebert, P. Bonnard, H.
Clausen, M. Cox, G. Dismukes, R. Eachus, T. Froggatt, H. Ganzinger, C.
Hewitt, S. Kamin, R. Kotler, O. Lecarme, J.A.N. Lee, J.L. Mansion, F.
Minel, T. Phinney, J. Roehrich, V. Schneider, A. Singer, D. Slosberg,
I.C. Wand, the reviewers of Ada-Europe, AdaTech, Afcet, those of the
LMSC review team, and those of the Ada Tokyo Study Group.

65.8/3
These reviews and comments, the numerous evaluation reports received at
the end of the first and second phase, the nine hundred language issue
reports and test and evaluation reports received from fifteen different
countries during the third phase of the project, the thousands of
comments received during the ANSI Canvass, and the on-going work of the
IFIP Working Group 2.4 on system implementation languages and that of
the Purdue Europe LTPL-E committee, all had a substantial influence on
the final definition of Ada.

65.9/3
The Military Departments and Agencies have provided a broad base of
support including funding, extensive reviews, and countless individual
contributions by the members of the High Order Language Working Group
and other interested personnel.  In particular, William A. Whitaker
provided leadership for the program during the formative stages.  David
A. Fisher was responsible for the successful development and refinement
of the language requirement documents that led to the Steelman
specification.

65.10/3
The Ada 83 language definition was developed by Cii Honeywell Bull and
later Alsys, and by Honeywell Systems and Research Center, under
contract to the United States Department of Defense.  William E. Carlson
and later Larry E. Druffel served as the technical representatives of
the United States Government and effectively coordinated the efforts of
all participants in the Ada program.

Acknowledgements for the Ada 95 edition

66
This International Standard was prepared by the Ada 9X Mapping/Revision
Team based at Intermetrics, Inc., which has included: W. Carlson,
Program Manager; T. Taft, Technical Director; J. Barnes (consultant); B.
Brosgol (consultant); R. Duff (Oak Tree Software); M. Edwards; C.
Garrity; R. Hilliard; O. Pazy (consultant); D. Rosenfeld; L. Shafer; W.
White; M. Woodger.

67
The following consultants to the Ada 9X Project contributed to the
Specialized Needs Annexes: T. Baker (Real-Time/Systems Programming --
SEI, FSU); K. Dritz (Numerics -- Argonne National Laboratory); A.
Gargaro (Distributed Systems -- Computer Sciences); J. Goodenough
(Real-Time/Systems Programming -- SEI); J. McHugh (Secure Systems --
consultant); B. Wichmann (Safety-Critical Systems -- NPL: UK).

68
This work was regularly reviewed by the Ada 9X Distinguished Reviewers
and the members of the Ada 9X Rapporteur Group (XRG): E. Ploedereder,
Chairman of DRs and XRG (University of Stuttgart: Germany); B. Bardin
(Hughes); J. Barnes (consultant: UK); B. Brett (DEC); B. Brosgol
(consultant); R. Brukardt (RR Software); N. Cohen (IBM); R. Dewar (NYU);
G. Dismukes (TeleSoft); A. Evans (consultant); A. Gargaro (Computer
Sciences); M. Gerhardt (ESL); J. Goodenough (SEI); S. Heilbrunner
(University of Salzburg: Austria); P. Hilfinger (UC/Berkeley); B.
Källberg (CelsiusTech: Sweden); M. Kamrad II (Unisys); J. van Katwijk
(Delft University of Technology: The Netherlands); V. Kaufman (Russia);
P. Kruchten (Rational); R. Landwehr (CCI: Germany); C. Lester
(Portsmouth Polytechnic: UK); L. Månsson (TELIA Research: Sweden); S.
Michell (Multiprocessor Toolsmiths: Canada); M. Mills (US Air Force); D.
Pogge (US Navy); K. Power (Boeing); O. Roubine (Verdix: France); A.
Strohmeier (Swiss Fed Inst of Technology: Switzerland); W. Taylor
(consultant: UK); J. Tokar (Tartan); E. Vasilescu (Grumman); J. Vladik
(Prospeks s.r.o.: Czech Republic); S. Van Vlierberghe (OFFIS: Belgium).

69
Other valuable feedback influencing the revision process was provided by
the Ada 9X Language Precision Team (Odyssey Research Associates), the
Ada 9X User/Implementer Teams (AETECH, Tartan, TeleSoft), the Ada 9X
Implementation Analysis Team (New York University) and the Ada
community-at-large.

70
Special thanks go to R. Mathis, Convenor of ISO/IEC JTC 1/SC 22 Working
Group 9.

71
The Ada 9X Project was sponsored by the Ada Joint Program Office.
Christine M. Anderson at the Air Force Phillips Laboratory (Kirtland
AFB, NM) was the project manager.

Acknowledgements for the Corrigendum version

71.1/3
The editor [R. Brukardt (USA)] would like to thank the many people whose
hard work and assistance has made this update possible.

71.2/1
Thanks go out to all of the members of the ISO/IEC JTC 1/SC 22/WG 9 Ada
Rapporteur Group, whose work on creating and editing the wording
corrections was critical to the entire process.  Especially valuable
contributions came from the chairman of the ARG, E. Ploedereder
(Germany), who kept the process moving; J. Barnes (UK) and K. Ishihata
(Japan), whose extremely detailed reviews kept the editor on his toes;
G. Dismukes (USA), M. Kamrad (USA), P. Leroy (France), S. Michell
(Canada), T. Taft (USA), J. Tokar (USA), and other members too numerous
to mention.

71.3/1
Special thanks go to R. Duff (USA) for his explanations of the previous
system of formatting of these documents during the tedious conversion to
more modern formats.  Special thanks also go to the convenor of ISO/IEC
JTC 1/SC 22/WG 9, J. Moore (USA), without whose help and support the
Corrigendum and this consolidated reference manual would not have been
possible.

Acknowledgements for the Amendment 1 version

71.4/3
The editor [R. Brukardt (USA)] would like to thank the many people whose
hard work and assistance has made this update possible.

71.5/2
Thanks go out to all of the members of the ISO/IEC JTC 1/SC 22/WG 9 Ada
Rapporteur Group, whose work on creating and editing the wording
corrections was critical to the entire process.  Especially valuable
contributions came from the chairman of the ARG, P. Leroy (France), who
kept the process on schedule; J. Barnes (UK) whose careful reviews found
many typographical errors; T. Taft (USA), who always seemed to have a
suggestion when we were stuck, and who also was usually able to provide
the valuable service of explaining why things were as they are; S. Baird
(USA), who found many obscure problems with the proposals; and A. Burns
(UK), who pushed many of the real-time proposals to completion.  Other
ARG members who contributed were: R. Dewar (USA), G. Dismukes (USA), R.
Duff (USA), K. Ishihata (Japan), S. Michell (Canada), E. Ploedereder
(Germany), J.P. Rosen (France), E. Schonberg (USA), J. Tokar (USA), and
T. Vardanega (Italy).

71.6/2
Special thanks go to Ada-Europe and the Ada Resource Association,
without whose help and support the Amendment and this consolidated
reference manual would not have been possible.  M. Heaney (USA) requires
special thanks for his tireless work on the containers packages.
Finally, special thanks go to the convenor of ISO/IEC JTC 1/SC 22/WG 9,
J. Moore (USA), who guided the document through the standardization
process.

Acknowledgements for the Ada 2012 edition

71.7/3
The editor [R. Brukardt (USA)] would like to thank the many people whose
hard work and assistance has made this revision possible.

71.8/3
Thanks go out to all of the members of the ISO/IEC JTC 1/SC 22/WG 9 Ada
Rapporteur Group, whose work on creating and editing the wording changes
was critical to the entire process.  Especially valuable contributions
came from the chairman of the ARG, E. Schonberg (USA), who guided the
work; T. Taft (USA), whose insights broke many logjams, both in design
and wording; J. Barnes (UK) whose careful reviews uncovered many
editorial errors; S. Baird (USA), who repeatedly found obscure
interactions with the proposals that the rest of us missed.  Other ARG
members who substantially contributed were: A. Burns (UK), J. Cousins
(UK), R. Dewar (USA), G. Dismukes (USA), R. Duff (USA), P. Leroy
(France), B. Moore (Canada), E. Ploedereder (Germany), J.P. Rosen
(France), B. Thomas (USA), and T. Vardanega (Italy).

71.9/3
Special thanks go to Ada-Europe and the Ada Resource Association,
without whose help and support this third edition of the Ada Standard
would not have been possible.  A special mention has to go to A.
Beneschan (USA) for his efforts in eliminating sloppiness in our
wording.  M. Heaney (USA) also deserves a mention for his efforts to
improve the containers packages.  Finally, special thanks go to the
convenor of ISO/IEC JTC 1/SC 22/WG 9, J. Tokar (USA), who guided the
document through the standardization process.

Acknowledgements for the Ada 2012 Corrigendum 1 version

71.10/4
The editor [R. Brukardt (USA)] would like to thank the many people whose
hard work and assistance has made this update possible.

71.11/4
Thanks go out to all of the members of the ISO/IEC JTC 1/SC 22/WG 9 Ada
Rapporteur Group, whose work on creating and editing the wording changes
was critical to the entire process.  Especially valuable contributions
came from the chairman of the ARG, J. Cousins (UK), who guided the work;
T. Taft (USA), who seems to have the ability to cut any Gordian knot we
encounter in wording; ; J. Barnes (UK) who continues to be able to find
editorial errors invisible to most; S. Baird (USA), who so frequently
finds obscure interactions that we now have named such things for him.
Other ARG members who substantially contributed were: A. Burns (UK), R.
Dewar (USA), G. Dismukes (USA), R. Duff (USA), B. Moore (Canada), E.
Ploedereder (Germany), J.P. Rosen (France), E. Schonberg (USA), and T.
Vardanega (Italy).

71.12/4
Finally, special thanks go to the convenor of ISO/IEC JTC 1/SC 22/WG 9,
J. Tokar (USA), who guided the document through the standardization
process.

Changes

72
The International Standard is the same as this version of the Reference
Manual, except:

73
   * This list of Changes is not included in the International Standard.

74
   * The "Acknowledgements" page is not included in the International
     Standard.

75
   * The text in the running headers and footers on each page is
     slightly different in the International Standard.

76
   * The title page(s) are different in the International Standard.

77
   * This document is formatted for 8.5-by-11-inch paper, whereas the
     International Standard is formatted for A4 paper (210-by-297mm);
     thus, the page breaks are in different places.

77.1/3
   * <This paragraph was deleted.>

77.2/3
   * The "Using this version of the Ada Reference Manual" subclause is
     not included in the International Standard.

77.3/3
   * Paragraph numbers are not included in the International Standard.

Using this version of the Ada Reference Manual

77.4/4
This document has been revised with the corrections specified in
Technical Corrigendum 1 (ISO/IEC 8652:2012/COR.1:2016).  In addition, a
variety of editorial errors have been corrected.

77.5/4
Changes to the original 8652:1995 can be identified by the version
number following the paragraph number.  Paragraphs with a version number
of /1 were changed by Technical Corrigendum 1 for Ada 95 or were
editorial corrections at that time, while paragraphs with a version
number of /2 were changed by Amendment 1 or were more recent editorial
corrections, and paragraphs with a version number of /3 were changed by
the third (2012) edition of the Standard or were still more recent
editorial corrections.  Paragraphs with a version number of /4 are
changed by Technical Corrigendum 1 for Ada 2012 or were editorial
corrections at that time.  Paragraphs not so marked are unchanged by
Technical Corrigendum 1 for Ada 2012, the third edition, Amendment 1,
Technical Corrigendum 1 for Ada 95, or editorial corrections.  Paragraph
numbers of unchanged paragraphs are the same as in the 1995 edition of
the Ada Reference Manual.  In addition, some versions of this document
include revision bars near the paragraph numbers.  Where paragraphs are
inserted, the paragraph numbers are of the form pp.nn, where pp is the
number of the preceding paragraph, and nn is an insertion number.  For
instance, the first paragraph inserted after paragraph 8 is numbered
8.1, the second paragraph inserted is numbered 8.2, and so on.  Deleted
paragraphs are indicated by the text <This paragraph was deleted.>
Deleted paragraphs include empty paragraphs that were numbered in the
1995 edition of the Ada Reference Manual.


File: arm2012.info,  Node: 0.99,  Prev: 0.3,  Up: Front Matter

0.99
====

========== INTERNATIONAL STANDARD   ISO/IEC 8652:2012(E) with Cor 1:2016

==========  

Information technology -- Programming
Languages -- Ada

 


File: arm2012.info,  Node: 1,  Next: 2,  Prev: Front Matter,  Up: Top

1 General
*********

* Menu:

* 1.1 ::      Scope
* 1.2 ::      Normative References
* 1.3 ::      Terms and Definitions


File: arm2012.info,  Node: 1.1,  Next: 1.2,  Up: 1

1.1 Scope
=========

1/3
This International Standard specifies the form and meaning of programs
written in Ada.  Its purpose is to promote the portability of Ada
programs to a variety of computing systems.

2/3
Ada is a programming language designed to support the construction of
long-lived, highly reliable software systems.  The language includes
facilities to define packages of related types, objects, and operations.
The packages may be parameterized and the types may be extended to
support the construction of libraries of reusable, adaptable software
components.  The operations may be implemented as subprograms using
conventional sequential control structures, or as entries that include
synchronization of concurrent threads of control as part of their
invocation.  Ada supports object-oriented programming by providing
classes and interfaces, inheritance, polymorphism of variables and
methods, and generic units.  The language treats modularity in the
physical sense as well, with a facility to support separate compilation.

3/4
The language provides rich support for real-time, concurrent
programming, and includes facilities for multicore and multiprocessor
programming.  Errors can be signaled as exceptions and handled
explicitly.  The language also covers systems programming; this requires
precise control over the representation of data and access to
system-dependent properties.  Finally, a predefined environment of
standard packages is provided, including facilities for, among others,
input-output, string manipulation, numeric elementary functions, random
number generation, and definition and use of containers.

* Menu:

* 1.1.1 ::    Extent
* 1.1.2 ::    Structure
* 1.1.3 ::    Conformity of an Implementation with the Standard
* 1.1.4 ::    Method of Description and Syntax Notation
* 1.1.5 ::    Classification of Errors


File: arm2012.info,  Node: 1.1.1,  Next: 1.1.2,  Up: 1.1

1.1.1 Extent
------------

1
This International Standard specifies:

2
   * The form of a program written in Ada;

3
   * The effect of translating and executing such a program;

4
   * The manner in which program units may be combined to form Ada
     programs;

5
   * The language-defined library units that a conforming implementation
     is required to supply;

6
   * The permissible variations within the standard, and the manner in
     which they are to be documented;

7
   * Those violations of the standard that a conforming implementation
     is required to detect, and the effect of attempting to translate or
     execute a program containing such violations;

8
   * Those violations of the standard that a conforming implementation
     is not required to detect.

9
This International Standard does not specify:

10
   * The means whereby a program written in Ada is transformed into
     object code executable by a processor;

11
   * The means whereby translation or execution of programs is invoked
     and the executing units are controlled;

12
   * The size or speed of the object code, or the relative execution
     speed of different language constructs;

13
   * The form or contents of any listings produced by implementations;
     in particular, the form or contents of error or warning messages;

14
   * The effect of unspecified execution.

15
   * The size of a program or program unit that will exceed the capacity
     of a particular conforming implementation.


File: arm2012.info,  Node: 1.1.2,  Next: 1.1.3,  Prev: 1.1.1,  Up: 1.1

1.1.2 Structure
---------------

1/3
This International Standard contains thirteen clauses, fifteen annexes,
and an index.

2
The <core> of the Ada language consists of:

3/3
   * Clauses 1 through 13

4
   * *note Annex A::, "*note Annex A:: Predefined Language Environment"

5
   * *note Annex B::, "*note Annex B:: Interface to Other Languages"

6
   * *note Annex J::, "*note Annex J:: Obsolescent Features"

7
The following <Specialized Needs Annexes> define features that are
needed by certain application areas:

8
   * *note Annex C::, "*note Annex C:: Systems Programming"

9
   * *note Annex D::, "*note Annex D:: Real-Time Systems"

10
   * *note Annex E::, "*note Annex E:: Distributed Systems"

11
   * *note Annex F::, "*note Annex F:: Information Systems"

12
   * *note Annex G::, "*note Annex G:: Numerics"

13
   * *note Annex H::, "*note Annex H:: High Integrity Systems"

14
The core language and the Specialized Needs Annexes are normative,
except that the material in each of the items listed below is
informative:

15
   * Text under a NOTES or Examples heading.

16/3
   * Each subclause whose title starts with the word "Example" or
     "Examples".

17
All implementations shall conform to the core language.  In addition, an
implementation may conform separately to one or more Specialized Needs
Annexes.

18
The following Annexes are informative:

19
   * *note Annex K::, "*note Annex K:: Language-Defined Aspects and
     Attributes"

20
   * *note Annex L::, "*note Annex L:: Language-Defined Pragmas"

21/3
   * *note Annex M::, "*note Annex M:: Summary of Documentation
     Requirements"

22
   * *note Annex N::, "*note Annex N:: Glossary"

23
   * *note Annex P::, "*note Annex P:: Syntax Summary"

23.1/3
   * *note Annex Q::, "*note Annex Q:: Language-Defined Entities"

24/4
Each clause is divided into subclauses that have a common structure.
Each clause and subclause first introduces its subject.  After the
introductory text, text is labeled with the following headings:

                               _Syntax_

25
     Syntax rules (indented).

                        _Name Resolution Rules_

26/3
Compile-time rules that are used in name resolution, including overload
resolution.

                           _Legality Rules_

27
Rules that are enforced at compile time.  A construct is <legal> if it
obeys all of the Legality Rules.

                          _Static Semantics_

28
A definition of the compile-time effect of each construct.

                       _Post-Compilation Rules_

29
Rules that are enforced before running a partition.  A partition is
legal if its compilation units are legal and it obeys all of the
Post-Compilation Rules.

                          _Dynamic Semantics_

30
A definition of the run-time effect of each construct.

                      _Bounded (Run-Time) Errors_

31
Situations that result in bounded (run-time) errors (see *note 1.1.5::).

                         _Erroneous Execution_

32
Situations that result in erroneous execution (see *note 1.1.5::).

                     _Implementation Requirements_

33
Additional requirements for conforming implementations.

                     _Documentation Requirements_

34
Documentation requirements for conforming implementations.

                               _Metrics_

35
Metrics that are specified for the time/space properties of the
execution of certain language constructs.

                     _Implementation Permissions_

36
Additional permissions given to the implementer.

                        _Implementation Advice_

37
Optional advice given to the implementer.  The word "should" is used to
indicate that the advice is a recommendation, not a requirement.  It is
implementation defined whether or not a given recommendation is obeyed.

     NOTES

38
     1  Notes emphasize consequences of the rules described in the
     (sub)clause or elsewhere.  This material is informative.

                              _Examples_

39
Examples illustrate the possible forms of the constructs described.
This material is informative.


File: arm2012.info,  Node: 1.1.3,  Next: 1.1.4,  Prev: 1.1.2,  Up: 1.1

1.1.3 Conformity of an Implementation with the Standard
-------------------------------------------------------

                     _Implementation Requirements_

1
A conforming implementation shall:

2
   * Translate and correctly execute legal programs written in Ada,
     provided that they are not so large as to exceed the capacity of
     the implementation;

3
   * Identify all programs or program units that are so large as to
     exceed the capacity of the implementation (or raise an appropriate
     exception at run time);

4
   * Identify all programs or program units that contain errors whose
     detection is required by this International Standard;

5
   * Supply all language-defined library units required by this
     International Standard;

6
   * Contain no variations except those explicitly permitted by this
     International Standard, or those that are impossible or impractical
     to avoid given the implementation's execution environment;

7
   * Specify all such variations in the manner prescribed by this
     International Standard.

8
The <external effect> of the execution of an Ada program is defined in
terms of its interactions with its external environment.  The following
are defined as <external interactions>:

9
   * Any interaction with an external file (see *note A.7::);

10
   * The execution of certain code_statements (see *note 13.8::); which
     code_statements cause external interactions is implementation
     defined.

11
   * Any call on an imported subprogram (see *note Annex B::), including
     any parameters passed to it;

12
   * Any result returned or exception propagated from a main subprogram
     (see *note 10.2::) or an exported subprogram (see *note Annex B::)
     to an external caller;

13
   * Any read or update of an atomic or volatile object (see *note
     C.6::);

14
   * The values of imported and exported objects (see *note Annex B::)
     at the time of any other interaction with the external environment.

15
A conforming implementation of this International Standard shall produce
for the execution of a given Ada program a set of interactions with the
external environment whose order and timing are consistent with the
definitions and requirements of this International Standard for the
semantics of the given program.

16
An implementation that conforms to this Standard shall support each
capability required by the core language as specified.  In addition, an
implementation that conforms to this Standard may conform to one or more
Specialized Needs Annexes (or to none).  Conformance to a Specialized
Needs Annex means that each capability required by the Annex is provided
as specified.

17/3
An implementation conforming to this International Standard may provide
additional aspects, attributes, library units, and pragmas.  However, it
shall not provide any aspect, attribute, library unit, or pragma having
the same name as an aspect, attribute, library unit, or pragma
(respectively) specified in a Specialized Needs Annex unless the
provided construct is either as specified in the Specialized Needs Annex
or is more limited in capability than that required by the Annex.  A
program that attempts to use an unsupported capability of an Annex shall
either be identified by the implementation before run time or shall
raise an exception at run time.

                     _Documentation Requirements_

18
Certain aspects of the semantics are defined to be either
<implementation defined> or <unspecified>.  In such cases, the set of
possible effects is specified, and the implementation may choose any
effect in the set.  Implementations shall document their behavior in
implementation-defined situations, but documentation is not required for
unspecified situations.  The implementation-defined characteristics are
summarized in *note M.2::.

19
The implementation may choose to document implementation-defined
behavior either by documenting what happens in general, or by providing
some mechanism for the user to determine what happens in a particular
case.

                        _Implementation Advice_

20
If an implementation detects the use of an unsupported Specialized Needs
Annex feature at run time, it should raise Program_Error if feasible.

21
If an implementation wishes to provide implementation-defined extensions
to the functionality of a language-defined library unit, it should
normally do so by adding children to the library unit.

     NOTES

22
     2  The above requirements imply that an implementation conforming
     to this Standard may support some of the capabilities required by a
     Specialized Needs Annex without supporting all required
     capabilities.


File: arm2012.info,  Node: 1.1.4,  Next: 1.1.5,  Prev: 1.1.3,  Up: 1.1

1.1.4 Method of Description and Syntax Notation
-----------------------------------------------

1
The form of an Ada program is described by means of a context-free
syntax together with context-dependent requirements expressed by
narrative rules.

2
The meaning of Ada programs is described by means of narrative rules
defining both the effects of each construct and the composition rules
for constructs.

3
The context-free syntax of the language is described using a simple
variant of Backus-Naur Form.  In particular:

4
   * Lower case words in a sans-serif font, some containing embedded
     underlines, are used to denote syntactic categories, for example:

5
          case_statement

6
   * Boldface words are used to denote reserved words, for example:

7
          array

8
   * Square brackets enclose optional items.  Thus the two following
     rules are equivalent.

9/2
          simple_return_statement ::= return [expression];
          simple_return_statement ::= return; | return expression;

10
   * Curly brackets enclose a repeated item.  The item may appear zero
     or more times; the repetitions occur from left to right as with an
     equivalent left-recursive rule.  Thus the two following rules are
     equivalent.

11
          term ::= factor {multiplying_operator factor}
          term ::= factor | term multiplying_operator factor

12
   * A vertical line separates alternative items unless it occurs
     immediately after an opening curly bracket, in which case it stands
     for itself:

13
          constraint ::= scalar_constraint | composite_constraint
          discrete_choice_list ::= discrete_choice {| discrete_choice}

14
   * If the name of any syntactic category starts with an italicized
     part, it is equivalent to the category name without the italicized
     part.  The italicized part is intended to convey some semantic
     information.  For example <subtype_>name and <task_>name are both
     equivalent to name alone.

14.1/3
The delimiters, compound delimiters, reserved words, and
numeric_literals are exclusively made of the characters whose code point
is between 16#20# and 16#7E#, inclusively.  The special characters for
which names are defined in this International Standard (see *note 2.1::)
belong to the same range.  For example, the character E in the
definition of exponent is the character whose name is "LATIN CAPITAL
LETTER E", not "GREEK CAPITAL LETTER EPSILON".

14.2/3
When this International Standard mentions the conversion of some
character or sequence of characters to upper case, it means the
character or sequence of characters obtained by using simple upper case
mapping, as defined by documents referenced in the note in Clause 1 of
ISO/IEC 10646:2011.

15
A <syntactic category> is a nonterminal in the grammar defined in BNF
under "Syntax."  Names of syntactic categories are set in a different
font, like_this.

16
A <construct> is a piece of text (explicit or implicit) that is an
instance of a syntactic category defined under "Syntax".

17
A <constituent> of a construct is the construct itself, or any construct
appearing within it.

18
Whenever the run-time semantics defines certain actions to happen in an
<arbitrary order>, this means that the implementation shall arrange for
these actions to occur in a way that is equivalent to some sequential
order, following the rules that result from that sequential order.  When
evaluations are defined to happen in an arbitrary order, with conversion
of the results to some subtypes, or with some run-time checks, the
evaluations, conversions, and checks may be arbitrarily interspersed, so
long as each expression is evaluated before converting or checking its
value.  Note that the effect of a program can depend on the order chosen
by the implementation.  This can happen, for example, if two actual
parameters of a given call have side effects.

     NOTES

19
     3  The syntax rules describing structured constructs are presented
     in a form that corresponds to the recommended paragraphing.  For
     example, an if_statement is defined as:

20
          if_statement ::=
              if condition then
                sequence_of_statements
             {elsif condition then
                sequence_of_statements}
             [else
                sequence_of_statements]
              end if;

21
     4  The line breaks and indentation in the syntax rules indicate the
     recommended line breaks and indentation in the corresponding
     constructs.  The preferred places for other line breaks are after
     semicolons.


File: arm2012.info,  Node: 1.1.5,  Prev: 1.1.4,  Up: 1.1

1.1.5 Classification of Errors
------------------------------

                     _Implementation Requirements_

1
The language definition classifies errors into several different
categories:

2
   * Errors that are required to be detected prior to run time by every
     Ada implementation;

3
     These errors correspond to any violation of a rule given in this
     International Standard, other than those listed below.  In
     particular, violation of any rule that uses the terms shall,
     allowed, permitted, legal, or illegal belongs to this category.
     Any program that contains such an error is not a legal Ada program;
     on the other hand, the fact that a program is legal does not mean,
     <per se>, that the program is free from other forms of error.

4
     The rules are further classified as either compile time rules, or
     post compilation rules, depending on whether a violation has to be
     detected at the time a compilation unit is submitted to the
     compiler, or may be postponed until the time a compilation unit is
     incorporated into a partition of a program.

5
   * Errors that are required to be detected at run time by the
     execution of an Ada program;

6
     The corresponding error situations are associated with the names of
     the predefined exceptions.  Every Ada compiler is required to
     generate code that raises the corresponding exception if such an
     error situation arises during program execution.  If such an error
     situation is certain to arise in every execution of a construct,
     then an implementation is allowed (although not required) to report
     this fact at compilation time.

7
   * Bounded errors;

8
     The language rules define certain kinds of errors that need not be
     detected either prior to or during run time, but if not detected,
     the range of possible effects shall be bounded.  The errors of this
     category are called <bounded errors>.  The possible effects of a
     given bounded error are specified for each such error, but in any
     case one possible effect of a bounded error is the raising of the
     exception Program_Error.

9
   * Erroneous execution.

10
     In addition to bounded errors, the language rules define certain
     kinds of errors as leading to <erroneous execution>.  Like bounded
     errors, the implementation need not detect such errors either prior
     to or during run time.  Unlike bounded errors, there is no
     language-specified bound on the possible effect of erroneous
     execution; the effect is in general not predictable.

                     _Implementation Permissions_

11
An implementation may provide <nonstandard modes> of operation.
Typically these modes would be selected by a pragma or by a command line
switch when the compiler is invoked.  When operating in a nonstandard
mode, the implementation may reject compilation_units that do not
conform to additional requirements associated with the mode, such as an
excessive number of warnings or violation of coding style guidelines.
Similarly, in a nonstandard mode, the implementation may apply special
optimizations or alternative algorithms that are only meaningful for
programs that satisfy certain criteria specified by the implementation.In any case, an implementation shall support a <standard> mode that
conforms to the requirements of this International Standard; in
particular, in the standard mode, all legal compilation_units shall be
accepted.

                        _Implementation Advice_

12
If an implementation detects a bounded error or erroneous execution, it
should raise Program_Error.


File: arm2012.info,  Node: 1.2,  Next: 1.3,  Prev: 1.1,  Up: 1

1.2 Normative References
========================

1/3
The following documents, in whole or in part, are normatively referenced
in this document and are indispensable for its application.  For dated
references, only the edition cited applies.  For undated references, the
latest edition of the referenced document (including any amendments)
applies.

1.1/3
ISO 639-3:2007, <Codes for the representation of names of languages --
Part 3: Alpha-3 code for comprehensive coverage of languages>.

2
ISO/IEC 646:1991, <Information technology -- ISO 7-bit coded character
set for information interchange>.

3/2
ISO/IEC 1539-1:2004, <Information technology -- Programming languages --
Fortran -- Part 1: Base language>.

4/2
ISO/IEC 1989:2002, <Information technology -- Programming languages --
COBOL>.

4.1/3
ISO/IEC 3166-1:2006, <Codes for the representation of names of countries
and their subdivisions -- Part 1: Country Codes>.

5
ISO/IEC 6429:1992, <Information technology -- Control functions for
coded graphic character sets>.

5.1/2
ISO 8601:2004, <Data elements and interchange formats -- Information
interchange -- Representation of dates and times>.

6/3
ISO/IEC 8859-1:1998, <Information technology -- 8-bit single-byte coded
graphic character sets -- Part 1: Latin alphabet No.  1>.

7/3
ISO/IEC 9899:2011, <Information technology -- Programming languages --
C>.

8/3
ISO/IEC 10646:2011, <Information technology -- Universal Multiple-Octet
Coded Character Set (UCS)>.

9/3
ISO/IEC 14882:2011, <Information technology -- Programming languages --
C++>.

10/2
ISO/IEC TR 19769:2004, <Information technology -- Programming languages,
their environments and system software interfaces -- Extensions for the
programming language C to support new character data types>.


File: arm2012.info,  Node: 1.3,  Prev: 1.2,  Up: 1

1.3 Terms and Definitions
=========================

1/2
Terms are defined throughout this International Standard, indicated by
<italic> type.  Terms explicitly defined in this International Standard
are not to be presumed to refer implicitly to similar terms defined
elsewhere.  Mathematical terms not defined in this International
Standard are to be interpreted according to the <CRC Concise
Encyclopedia of Mathematics, Second Edition>.  Other terms not defined
in this International Standard are to be interpreted according to the
<Webster's Third New International Dictionary of the English Language>.
Informal descriptions of some terms are also given in *note Annex N::,
"*note Annex N:: Glossary".  


File: arm2012.info,  Node: 2,  Next: 3,  Prev: 1,  Up: Top

2 Lexical Elements
******************

1/3
The text of a program consists of the texts of one or more compilations.
The text of a compilation is a sequence of lexical elements, each
composed of characters; the rules of composition are given in this
clause.  Pragmas, which provide certain information for the compiler,
are also described in this clause.

* Menu:

* 2.1 ::      Character Set
* 2.2 ::      Lexical Elements, Separators, and Delimiters
* 2.3 ::      Identifiers
* 2.4 ::      Numeric Literals
* 2.5 ::      Character Literals
* 2.6 ::      String Literals
* 2.7 ::      Comments
* 2.8 ::      Pragmas
* 2.9 ::      Reserved Words


File: arm2012.info,  Node: 2.1,  Next: 2.2,  Up: 2

2.1 Character Set
=================

1/3
The character repertoire for the text of an Ada program consists of the
entire coding space described by the ISO/IEC 10646:2011 Universal
Multiple-Octet Coded Character Set.  This coding space is organized in
<planes>, each plane comprising 65536 characters.  

                               _Syntax_

     <Paragraphs 2 and 3 were deleted.>

3.1/3
     A character is defined by this International Standard for each cell
     in the coding space described by ISO/IEC 10646:2011, regardless of
     whether or not ISO/IEC 10646:2011 allocates a character to that
     cell.

                          _Static Semantics_

4/3
The coded representation for characters is implementation defined (it
need not be a representation defined within ISO/IEC 10646:2011).  A
character whose relative code point in its plane is 16#FFFE# or 16#FFFF#
is not allowed anywhere in the text of a program.  The only characters
allowed outside of comments are those in categories other_format,
format_effector, and graphic_character.

4.1/3
The semantics of an Ada program whose text is not in Normalization Form
KC (as defined by Clause 21 of ISO/IEC 10646:2011) is implementation
defined.

5/3
The description of the language definition in this International
Standard uses the character properties General Category, Simple
Uppercase Mapping, Uppercase Mapping, and Special Case Condition of the
documents referenced by the note in Clause 1 of ISO/IEC 10646:2011.  The
actual set of graphic symbols used by an implementation for the visual
representation of the text of an Ada program is not specified.  

6/3
Characters are categorized as follows:

7/2

               <This paragraph was deleted.>

8/2
letter_uppercase
               Any character whose General Category is defined to be
               "Letter, Uppercase".

9/2
letter_lowercase
               Any character whose General Category is defined to be
               "Letter, Lowercase".

9.1/2
letter_titlecase
               Any character whose General Category is defined to be
               "Letter, Titlecase".

9.2/2
letter_modifier
               Any character whose General Category is defined to be
               "Letter, Modifier".

9.3/2
letter_other
               Any character whose General Category is defined to be
               "Letter, Other".

9.4/2
mark_non_spacing
               Any character whose General Category is defined to be
               "Mark, Non-Spacing".

9.5/2
mark_spacing_combining
               Any character whose General Category is defined to be
               "Mark, Spacing Combining".

10/2
number_decimal
               Any character whose General Category is defined to be
               "Number, Decimal".

10.1/2
number_letter
               Any character whose General Category is defined to be
               "Number, Letter".

10.2/2
punctuation_connector
               Any character whose General Category is defined to be
               "Punctuation, Connector".

10.3/2
other_format
               Any character whose General Category is defined to be
               "Other, Format".

11/2
separator_space
               Any character whose General Category is defined to be
               "Separator, Space".

12/2
separator_line
               Any character whose General Category is defined to be
               "Separator, Line".

12.1/2
separator_paragraph
               Any character whose General Category is defined to be
               "Separator, Paragraph".

13/3
format_effector
               The characters whose code points are 16#09# (CHARACTER
               TABULATION), 16#0A# (LINE FEED), 16#0B# (LINE
               TABULATION), 16#0C# (FORM FEED), 16#0D# (CARRIAGE
               RETURN), 16#85# (NEXT LINE), and the characters in
               categories separator_line and separator_paragraph.  

13.1/2
other_control
               Any character whose General Category is defined to be
               "Other, Control", and which is not defined to be a
               format_effector.

13.2/2
other_private_use
               Any character whose General Category is defined to be
               "Other, Private Use".

13.3/2
other_surrogate
               Any character whose General Category is defined to be
               "Other, Surrogate".

14/3
graphic_character
               Any character that is not in the categories
               other_control, other_private_use, other_surrogate,
               format_effector, and whose relative code point in its
               plane is neither 16#FFFE# nor 16#FFFF#.

15/3
The following names are used when referring to certain characters (the
first name is that given in ISO/IEC 10646:2011): 

  graphic symbol   name                      graphic symbol   name
         "         quotation mark                   :         colon
         #         number sign                      ;         semicolon
         &         ampersand                        <         less-than sign
         '         apostrophe, tick                 =         equals sign
         (         left parenthesis                 >         greater-than sign
         )         right parenthesis                _         low line, underline
         *         asterisk, multiply               |         vertical line
         +         plus sign                        /         solidus, divide
         ,         comma                            !         exclamation point
         -         hyphen-minus, minus              %         percent sign
         .         full stop, dot, point

                     _Implementation Requirements_

16/3
An Ada implementation shall accept Ada source code in UTF-8 encoding,
with or without a BOM (see *note A.4.11::), where every character is
represented by its code point.  The character pair CARRIAGE RETURN/LINE
FEED (code points 16#0D# 16#0A#) signifies a single end of line (see
*note 2.2::); every other occurrence of a format_effector other than the
character whose code point position is 16#09# (CHARACTER TABULATION)
also signifies a single end of line.

                     _Implementation Permissions_

17/3
The categories defined above, as well as case mapping and folding, may
be based on an implementation-defined version of ISO/IEC 10646 (2003
edition or later).

     NOTES

18/2
     1  The characters in categories other_control, other_private_use,
     and other_surrogate are only allowed in comments.


File: arm2012.info,  Node: 2.2,  Next: 2.3,  Prev: 2.1,  Up: 2

2.2 Lexical Elements, Separators, and Delimiters
================================================

                          _Static Semantics_

1
The text of a program consists of the texts of one or more compilations.
The text of each compilation is a sequence of separate <lexical
elements>.  Each lexical element is formed from a sequence of
characters, and is either a delimiter, an identifier, a reserved word, a
numeric_literal, a character_literal, a string_literal, or a comment.
The meaning of a program depends only on the particular sequences of
lexical elements that form its compilations, excluding comments.

2/3
The text of a compilation is divided into <lines>.  In general, the
representation for an end of line is implementation defined.  However, a
sequence of one or more format_effectors other than the character whose
code point is 16#09# (CHARACTER TABULATION) signifies at least one end
of line.

3/2
In some cases an explicit <separator> is required to separate adjacent
lexical elements.  A separator is any of a separator_space, a
format_effector, or the end of a line, as follows:

4/2
   * A separator_space is a separator except within a comment, a
     string_literal, or a character_literal.

5/3
   * The character whose code point is 16#09# (CHARACTER TABULATION) is
     a separator except within a comment.

6
   * The end of a line is always a separator.

7
One or more separators are allowed between any two adjacent lexical
elements, before the first of each compilation, or after the last.  At
least one separator is required between an identifier, a reserved word,
or a numeric_literal and an adjacent identifier, reserved word, or
numeric_literal.

7.1/3
One or more other_format characters are allowed anywhere that a
separator is; any such characters have no effect on the meaning of an
Ada program.

8/2
A <delimiter> is either one of the following characters:

9
     &    '    (    )    *    +    ,    -    .    /    :    ;    <    =    >    |

10
or one of the following <compound delimiters> each composed of two
adjacent special characters

11
     =>    ..    **    :=    /=    >=    <=    <<    >>    <>

12
Each of the special characters listed for single character delimiters is
a single delimiter except if this character is used as a character of a
compound delimiter, or as a character of a comment, string_literal,
character_literal, or numeric_literal.

13
The following names are used when referring to compound delimiters:

delimiter    name
----------------------------------------------------
=>           arrow
..           double dot
**           double star, exponentiate
:=           assignment (pronounced: "becomes")
/=           inequality (pronounced: "not equal")
>=           greater than or equal
<=           less than or equal
<<           left label bracket
>>           right label bracket
<>           box
                     _Implementation Requirements_

14
An implementation shall support lines of at least 200 characters in
length, not counting any characters used to signify the end of a line.
An implementation shall support lexical elements of at least 200
characters in length.  The maximum supported line length and lexical
element length are implementation defined.


File: arm2012.info,  Node: 2.3,  Next: 2.4,  Prev: 2.2,  Up: 2

2.3 Identifiers
===============

1
Identifiers are used as names.

                               _Syntax_

2/2
     identifier ::=
        identifier_start {identifier_start | identifier_extend}

3/2
     identifier_start ::=
          letter_uppercase
        | letter_lowercase
        | letter_titlecase
        | letter_modifier
        | letter_other
        | number_letter

3.1/3
     identifier_extend ::=
          mark_non_spacing
        | mark_spacing_combining
        | number_decimal
        | punctuation_connector

4/3
     An identifier shall not contain two consecutive characters in
     category punctuation_connector, or end with a character in that
     category.

                          _Static Semantics_

5/3
Two identifiers are considered the same if they consist of the same
sequence of characters after applying locale-independent simple case
folding, as defined by documents referenced in the note in Clause 1 of
ISO/IEC 10646:2011.

5.3/3
After applying simple case folding, an identifier shall not be identical
to a reserved word.

                     _Implementation Permissions_

6
In a nonstandard mode, an implementation may support other upper/lower
case equivalence rules for identifiers, to accommodate local
conventions.

     NOTES

6.1/2
     2  Identifiers differing only in the use of corresponding upper and
     lower case letters are considered the same.

                              _Examples_

7
<Examples of identifiers:>

8/2
     Count      X    Get_Symbol   Ethelyn   Marion
     Snobol_4   X1   Page_Count   Store_Next_Item
     [Unicode 928][Unicode 955][Unicode 940][Unicode 964][Unicode 969][Unicode 957]      --< Plato>
     [Unicode 1063][Unicode 1072][Unicode 1081][Unicode 1082][Unicode 1086][Unicode 1074][Unicode 1089][Unicode 1082][Unicode 1080][Unicode 1081]  --< Tchaikovsky>
     [Unicode 952]  [Unicode 966]        --< Angles>


File: arm2012.info,  Node: 2.4,  Next: 2.5,  Prev: 2.3,  Up: 2

2.4 Numeric Literals
====================

1
There are two kinds of numeric_literals, <real literals> and <integer
literals>.  A real literal is a numeric_literal that includes a point;
an integer literal is a numeric_literal without a point.

                               _Syntax_

2
     numeric_literal ::= decimal_literal | based_literal

     NOTES

3
     3  The type of an integer literal is <universal_integer>.  The type
     of a real literal is <universal_real>.

* Menu:

* 2.4.1 ::    Decimal Literals
* 2.4.2 ::    Based Literals


File: arm2012.info,  Node: 2.4.1,  Next: 2.4.2,  Up: 2.4

2.4.1 Decimal Literals
----------------------

1
A decimal_literal is a numeric_literal in the conventional decimal
notation (that is, the base is ten).

                               _Syntax_

2
     decimal_literal ::= numeral [.numeral] [exponent]

3
     numeral ::= digit {[underline] digit}

4
     exponent ::= E [+] numeral | E - numeral

4.1/2
     digit ::= 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9

5
     An exponent for an integer literal shall not have a minus sign.

                          _Static Semantics_

6
An underline character in a numeric_literal does not affect its meaning.
The letter E of an exponent can be written either in lower case or in
upper case, with the same meaning.

7
An exponent indicates the power of ten by which the value of the
decimal_literal without the exponent is to be multiplied to obtain the
value of the decimal_literal with the exponent.

                              _Examples_

8
<Examples of decimal literals:>

9
     12        0      1E6    123_456    --<  integer literals>

     12.0      0.0    0.456  3.14159_26 --<  real literals>


File: arm2012.info,  Node: 2.4.2,  Prev: 2.4.1,  Up: 2.4

2.4.2 Based Literals
--------------------

1
A based_literal is a numeric_literal expressed in a form that specifies
the base explicitly.

                               _Syntax_

2
     based_literal ::=
        base # based_numeral [.based_numeral] # [exponent]

3
     base ::= numeral

4
     based_numeral ::=
        extended_digit {[underline] extended_digit}

5
     extended_digit ::= digit | A | B | C | D | E | F

                           _Legality Rules_

6
The <base> (the numeric value of the decimal numeral preceding the first
#) shall be at least two and at most sixteen.  The extended_digits A
through F represent the digits ten through fifteen, respectively.  The
value of each extended_digit of a based_literal shall be less than the
base.

                          _Static Semantics_

7
The conventional meaning of based notation is assumed.  An exponent
indicates the power of the base by which the value of the based_literal
without the exponent is to be multiplied to obtain the value of the
based_literal with the exponent.  The base and the exponent, if any, are
in decimal notation.

8
The extended_digits A through F can be written either in lower case or
in upper case, with the same meaning.

                              _Examples_

9
<Examples of based literals:>

10
     2#1111_1111#  16#FF#       016#0ff#   --<  integer literals of value 255>
     16#E#E1       2#1110_0000#            --<  integer literals of value 224>
     16#F.FF#E+2   2#1.1111_1111_1110#E11  --<  real literals of value 4095.0>


File: arm2012.info,  Node: 2.5,  Next: 2.6,  Prev: 2.4,  Up: 2

2.5 Character Literals
======================

1
A character_literal is formed by enclosing a graphic character between
two apostrophe characters.

                               _Syntax_

2
     character_literal ::= 'graphic_character'

     NOTES

3
     4  A character_literal is an enumeration literal of a character
     type.  See *note 3.5.2::.

                              _Examples_

4
<Examples of character literals:>

5/2
     'A'     '*'     '''     ' '
     'L'     '[Unicode 1051]'     '[Unicode 923]'    --< Various els.>
     '[Unicode 8734]'     '[Unicode 1488]'            --< Big numbers - infinity and aleph.>


File: arm2012.info,  Node: 2.6,  Next: 2.7,  Prev: 2.5,  Up: 2

2.6 String Literals
===================

1
A string_literal is formed by a sequence of graphic characters (possibly
none) enclosed between two quotation marks used as string brackets.
They are used to represent operator_symbols (see *note 6.1::), values of
a string type (see *note 4.2::), and array subaggregates (see *note
4.3.3::).  

                               _Syntax_

2
     string_literal ::= "{string_element}"

3
     string_element ::= "" | <non_quotation_mark_>graphic_character

4
     A string_element is either a pair of quotation marks (""), or a
     single graphic_character other than a quotation mark.

                          _Static Semantics_

5
The <sequence of characters> of a string_literal is formed from the
sequence of string_elements between the bracketing quotation marks, in
the given order, with a string_element that is "" becoming a single
quotation mark in the sequence of characters, and any other
string_element being reproduced in the sequence.

6
A <null string literal> is a string_literal with no string_elements
between the quotation marks.

     NOTES

7
     5  An end of line cannot appear in a string_literal.

7.1/2
     6  No transformation is performed on the sequence of characters of
     a string_literal.

                              _Examples_

8
<Examples of string literals:>

9/2
     "Message of the day:"

     ""                    --<  a null string literal>
     " "   "A"   """"      --<  three string literals of length 1>

     "Characters such as $, %, and } are allowed in string literals"
     "Archimedes said ""[Unicode 917][Unicode 973][Unicode 961][Unicode 951][Unicode 954][Unicode 945]"""
     "Volume of cylinder (PIr²h) = "


File: arm2012.info,  Node: 2.7,  Next: 2.8,  Prev: 2.6,  Up: 2

2.7 Comments
============

1
A comment starts with two adjacent hyphens and extends up to the end of
the line.

                               _Syntax_

2
     comment ::= --{<non_end_of_line_>character}

3
     A comment may appear on any line of a program.

                          _Static Semantics_

4
The presence or absence of comments has no influence on whether a
program is legal or illegal.  Furthermore, comments do not influence the
meaning of a program; their sole purpose is the enlightenment of the
human reader.

                              _Examples_

5
<Examples of comments:>

6
     --<  the last sentence above echoes the Algol 68 report >

     end;  --<  processing of Line is complete >

     --<  a long comment may be split onto>
     --<  two or more consecutive lines   >

     ----------------<  the first two hyphens start the comment  >


File: arm2012.info,  Node: 2.8,  Next: 2.9,  Prev: 2.7,  Up: 2

2.8 Pragmas
===========

1
A pragma is a compiler directive.  There are language-defined pragmas
that give instructions for optimization, listing control, etc.  An
implementation may support additional (implementation-defined) pragmas.

                               _Syntax_

2
     pragma ::=
        pragma identifier [(pragma_argument_association {, 
     pragma_argument_association})];

3/3
     pragma_argument_association ::=
          [<pragma_argument_>identifier =>] name
        | [<pragma_argument_>identifier =>] expression
        | <pragma_argument_>aspect_mark =>  name
        | <pragma_argument_>aspect_mark =>  expression

4/3
     In a pragma, any pragma_argument_associations without a
     <pragma_argument_>identifier or <pragma_argument_>aspect_mark shall
     precede any associations with a <pragma_argument_>identifier or
     <pragma_argument_>aspect_mark.

5
     Pragmas are only allowed at the following places in a program:

6
        * After a semicolon delimiter, but not within a formal_part or
          discriminant_part.

7/3
        * At any place where the syntax rules allow a construct defined
          by a syntactic category whose name ends with "declaration",
          "item", "statement", "clause", or "alternative", or one of the
          syntactic categories variant or exception_handler; but not in
          place of such a construct if the construct is required, or is
          part of a list that is required to have at least one such
          construct.

7.1/3
        * In place of a statement in a sequence_of_statements.

7.2/3
        * At any place where a compilation_unit is allowed.

8
     Additional syntax rules and placement restrictions exist for
     specific pragmas.

9
The <name> of a pragma is the identifier following the reserved word
pragma.  The name or expression of a pragma_argument_association is a
<pragma argument>.

10/3
An <identifier specific to a pragma> is an identifier or reserved word
that is used in a pragma argument with special meaning for that pragma.

                          _Static Semantics_

11
If an implementation does not recognize the name of a pragma, then it
has no effect on the semantics of the program.  Inside such a pragma,
the only rules that apply are the Syntax Rules.

                          _Dynamic Semantics_

12
Any pragma that appears at the place of an executable construct is
executed.  Unless otherwise specified for a particular pragma, this
execution consists of the evaluation of each evaluable pragma argument
in an arbitrary order.

                     _Implementation Requirements_

13
The implementation shall give a warning message for an unrecognized
pragma name.

                     _Implementation Permissions_

14
An implementation may provide implementation-defined pragmas; the name
of an implementation-defined pragma shall differ from those of the
language-defined pragmas.

15
An implementation may ignore an unrecognized pragma even if it violates
some of the Syntax Rules, if detecting the syntax error is too complex.

                        _Implementation Advice_

16/3
Normally, implementation-defined pragmas should have no semantic effect
for error-free programs; that is, if the implementation-defined pragmas
in a working program are replaced with unrecognized pragmas, the program
should still be legal, and should still have the same semantics.

17
Normally, an implementation should not define pragmas that can make an
illegal program legal, except as follows:

18/3
   * A pragma used to complete a declaration;

19
   * A pragma used to configure the environment by adding, removing, or
     replacing library_items.

                               _Syntax_

20
     The forms of List, Page, and Optimize pragmas are as follows:

21
       pragma List(identifier);

22
       pragma Page;

23
       pragma Optimize(identifier);

24
     Other pragmas are defined throughout this International Standard,
     and are summarized in *note Annex L::.

                          _Static Semantics_

25
A pragma List takes one of the identifiers On or Off as the single
argument.  This pragma is allowed anywhere a pragma is allowed.  It
specifies that listing of the compilation is to be continued or
suspended until a List pragma with the opposite argument is given within
the same compilation.  The pragma itself is always listed if the
compiler is producing a listing.

26
A pragma Page is allowed anywhere a pragma is allowed.  It specifies
that the program text which follows the pragma should start on a new
page (if the compiler is currently producing a listing).

27
A pragma Optimize takes one of the identifiers Time, Space, or Off as
the single argument.  This pragma is allowed anywhere a pragma is
allowed, and it applies until the end of the immediately enclosing
declarative region, or for a pragma at the place of a compilation_unit,
to the end of the compilation.  It gives advice to the implementation as
to whether time or space is the primary optimization criterion, or that
optional optimizations should be turned off.  It is implementation
defined how this advice is followed.

                              _Examples_

28
<Examples of pragmas:>

29/3
     pragma List(Off); -- <turn off listing generation>
     pragma Optimize(Off); -- <turn off optional optimizations>
     pragma Pure(Rational_Numbers); -- <set categorization for package>
     pragma Assert(Exists(File_Name),
                   Message => "Nonexistent file"); -- <assert file exists>


File: arm2012.info,  Node: 2.9,  Prev: 2.8,  Up: 2

2.9 Reserved Words
==================

                               _Syntax_

1/1
     <This paragraph was deleted.>

2/3
     The following are the <reserved words>.  Within a program, some or
     all of the letters of a reserved word may be in upper case.

abort      else        new          return
abs        elsif       not          reverse
abstract   end         null
accept     entry                    select
access     exception   of           separate
aliased    exit        or           some
all                    others       subtype
and        for         out          synchronized
array      function    overriding
at                                  tagged
           generic     package      task
begin      goto        pragma       terminate
body                   private      then
           if          procedure    type
case       in          protected
constant   interface                until
           is          raise        use
declare                range
delay      limited     record       when
delta      loop        rem          while
digits                 renames      with
do         mod         requeue
                                    xor

     NOTES

3
     7  The reserved words appear in lower case boldface in this
     International Standard, except when used in the designator of an
     attribute (see *note 4.1.4::).  Lower case boldface is also used
     for a reserved word in a string_literal used as an operator_symbol.
     This is merely a convention -- programs may be written in whatever
     typeface is desired and available.


File: arm2012.info,  Node: 3,  Next: 4,  Prev: 2,  Up: Top

3 Declarations and Types
************************

1/3
This clause describes the types in the language and the rules for
declaring constants, variables, and named numbers.

* Menu:

* 3.1 ::      Declarations
* 3.2 ::      Types and Subtypes
* 3.3 ::      Objects and Named Numbers
* 3.4 ::      Derived Types and Classes
* 3.5 ::      Scalar Types
* 3.6 ::      Array Types
* 3.7 ::      Discriminants
* 3.8 ::      Record Types
* 3.9 ::      Tagged Types and Type Extensions
* 3.10 ::     Access Types
* 3.11 ::     Declarative Parts


File: arm2012.info,  Node: 3.1,  Next: 3.2,  Up: 3

3.1 Declarations
================

1
The language defines several kinds of named <entities> that are declared
by declarations.  The entity's <name> is defined by the declaration,
usually by a defining_identifier (*note 3.1: S0022.), but sometimes by a
defining_character_literal (*note 3.5.1: S0040.) or
defining_operator_symbol (*note 6.1: S0171.).

2
There are several forms of declaration.  A basic_declaration is a form
of declaration defined as follows.

                               _Syntax_

3/3
     basic_declaration ::=
          type_declaration   | subtype_declaration
        | object_declaration   | number_declaration
        | subprogram_declaration   | abstract_subprogram_declaration
        | null_procedure_declaration   | expression_function_declaration
        | package_declaration   | renaming_declaration
        | exception_declaration   | generic_declaration
        | generic_instantiation

4
     defining_identifier ::= identifier

                          _Static Semantics_

5
A <declaration> is a language construct that associates a name with (a
view of) an entity.  A declaration may appear explicitly in the program
text (an <explicit> declaration), or may be supposed to occur at a given
place in the text as a consequence of the semantics of another construct
(an <implicit> declaration).

6/3
Each of the following is defined to be a declaration: any
basic_declaration (*note 3.1: S0021.); an
enumeration_literal_specification (*note 3.5.1: S0039.); a
discriminant_specification (*note 3.7: S0062.); a component_declaration
(*note 3.8: S0070.); a loop_parameter_specification (*note 5.5: S0158.);
an iterator_specification (*note 5.5.2: S0159.); a
parameter_specification (*note 6.1: S0175.); a subprogram_body (*note
6.3: S0177.); an extended_return_object_declaration (*note 6.5: S0185.);
an entry_declaration (*note 9.5.2: S0218.); an entry_index_specification
(*note 9.5.2: S0224.); a choice_parameter_specification (*note 11.2:
S0267.); a generic_formal_parameter_declaration (*note 12.1: S0275.).

7
All declarations contain a <definition> for a <view> of an entity.  A
view consists of an identification of the entity (the entity <of> the
view), plus view-specific characteristics that affect the use of the
entity through that view (such as mode of access to an object, formal
parameter names and defaults for a subprogram, or visibility to
components of a type).  In most cases, a declaration also contains the
definition for the entity itself (a renaming_declaration is an example
of a declaration that does not define a new entity, but instead defines
a view of an existing entity (see *note 8.5::)).

7.1/3
When it is clear from context, the term <object> is used in place of
<view of an object>.  Similarly, the terms <type> and <subtype> are used
in place of <view of a type> and <view of a subtype>, respectively.

8
For each declaration, the language rules define a certain region of text
called the <scope> of the declaration (see *note 8.2::).  Most
declarations associate an identifier with a declared entity.  Within its
scope, and only there, there are places where it is possible to use the
identifier to refer to the declaration, the view it defines, and the
associated entity; these places are defined by the visibility rules (see
*note 8.3::).  At such places the identifier is said to be a <name> of
the entity (the direct_name or selector_name); the name is said to
<denote> the declaration, the view, and the associated entity (see *note
8.6::).  The declaration is said to <declare> the name, the view, and in
most cases, the entity itself.

9
As an alternative to an identifier, an enumeration literal can be
declared with a character_literal as its name (see *note 3.5.1::), and a
function can be declared with an operator_symbol as its name (see *note
6.1::).

10
The syntax rules use the terms defining_identifier,
defining_character_literal (*note 3.5.1: S0040.), and
defining_operator_symbol (*note 6.1: S0171.) for the defining occurrence
of a name; these are collectively called <defining names>.  The terms
direct_name and selector_name are used for usage occurrences of
identifiers, character_literals, and operator_symbols.  These are
collectively called <usage names>.

                          _Dynamic Semantics_

11
The process by which a construct achieves its run-time effect is called
<execution>.  This process is also called <elaboration> for declarations
and <evaluation> for expressions.  One of the terms execution,
elaboration, or evaluation is defined by this International Standard for
each construct that has a run-time effect.

     NOTES

12
     1  At compile time, the declaration of an entity <declares> the
     entity.  At run time, the elaboration of the declaration <creates>
     the entity.


File: arm2012.info,  Node: 3.2,  Next: 3.3,  Prev: 3.1,  Up: 3

3.2 Types and Subtypes
======================

                          _Static Semantics_

1
A <type> is characterized by a set of values, and a set of <primitive
operations> which implement the fundamental aspects of its semantics.
An <object> of a given type is a run-time entity that contains (has) a
value of the type.

2/2
Types are grouped into <categories> of types.  There exist several
<language-defined categories> of types (see NOTES below), reflecting the
similarity of their values and primitive operations.  Most categories of
types form <classes> of types.  <Elementary> types are those whose
values are logically indivisible; <composite> types are those whose
values are composed of <component> values.  

3
The elementary types are the <scalar> types (<discrete> and <real>) and
the <access> types (whose values provide access to objects or
subprograms).  Discrete types are either <integer> types or are defined
by enumeration of their values (<enumeration> types).  Real types are
either <floating point> types or <fixed point> types.

4/2
The composite types are the <record> types, <record extensions>, <array>
types, <interface> types, <task> types, and <protected> types.

4.1/2
There can be multiple views of a type with varying sets of operations.
An <incomplete> type represents an incomplete view (see *note 3.10.1::)
of a type with a very restricted usage, providing support for recursive
data structures.  A <private> type or <private extension> represents a
partial view (see *note 7.3::) of a type, providing support for data
abstraction.  The full view (see *note 3.2.1::) of a type represents its
complete definition.  An incomplete or partial view is considered a
composite type, even if the full view is not.

5/2
Certain composite types (and views thereof) have special components
called <discriminants> whose values affect the presence, constraints, or
initialization of other components.  Discriminants can be thought of as
parameters of the type.

6/2
The term <subcomponent> is used in this International Standard in place
of the term component to indicate either a component, or a component of
another subcomponent.  Where other subcomponents are excluded, the term
component is used instead.  Similarly, a <part> of an object or value is
used to mean the whole object or value, or any set of its subcomponents.
The terms component, subcomponent, and part are also applied to a type
meaning the component, subcomponent, or part of objects and values of
the type.

7/2
The set of possible values for an object of a given type can be
subjected to a condition that is called a <constraint> (the case of a
<null constraint> that specifies no restriction is also included); the
rules for which values satisfy a given kind of constraint are given in
*note 3.5:: for range_constraints, *note 3.6.1:: for index_constraints,
and *note 3.7.1:: for discriminant_constraints.  The set of possible
values for an object of an access type can also be subjected to a
condition that excludes the null value (see *note 3.10::).

8/2
A <subtype> of a given type is a combination of the type, a constraint
on values of the type, and certain attributes specific to the subtype.
The given type is called the <type of the subtype>.  Similarly, the
associated constraint is called the <constraint of the subtype>.   The
set of values of a subtype consists of the values of its type that
satisfy its constraint and any exclusion of the null value.  Such values
<belong> to the subtype.  

9
A subtype is called an <unconstrained> subtype if its type has unknown
discriminants, or if its type allows range, index, or discriminant
constraints, but the subtype does not impose such a constraint;
otherwise, the subtype is called a <constrained> subtype (since it has
no unconstrained characteristics).

     NOTES

10/2
     2  Any set of types can be called a "category" of types, and any
     set of types that is closed under derivation (see *note 3.4::) can
     be called a "class" of types.  However, only certain categories and
     classes are used in the description of the rules of the language --
     generally those that have their own particular set of primitive
     operations (see *note 3.2.3::), or that correspond to a set of
     types that are matched by a given kind of generic formal type (see
     *note 12.5::).  The following are examples of "interesting"
     <language-defined classes>: elementary, scalar, discrete,
     enumeration, character, boolean, integer, signed integer, modular,
     real, floating point, fixed point, ordinary fixed point, decimal
     fixed point, numeric, access, access-to-object,
     access-to-subprogram, composite, array, string, (untagged) record,
     tagged, task, protected, nonlimited.  Special syntax is provided to
     define types in each of these classes.  In addition to these
     classes, the following are examples of "interesting"
     <language-defined categories>: abstract, incomplete, interface,
     limited, private, record.

11/2
     These language-defined categories are organized like this:

12/2
          all types
             elementary
                scalar
                   discrete
                      enumeration
                         character
                         boolean
                         other enumeration
                      integer
                         signed integer
                         modular integer
                   real
                      floating point
                      fixed point
                         ordinary fixed point
                         decimal fixed point
                access
                   access-to-object
                   access-to-subprogram
             composite
                untagged
                   array
                      string
                      other array
                   record
                   task
                   protected
                tagged (including interfaces)
                   nonlimited tagged record
                   limited tagged
                      limited tagged record
                      synchronized tagged
                         tagged task
                         tagged protected

13/2
     There are other categories, such as "numeric" and "discriminated",
     which represent other categorization dimensions, but do not fit
     into the above strictly hierarchical picture.

* Menu:

* 3.2.1 ::    Type Declarations
* 3.2.2 ::    Subtype Declarations
* 3.2.3 ::    Classification of Operations
* 3.2.4 ::    Subtype Predicates


File: arm2012.info,  Node: 3.2.1,  Next: 3.2.2,  Up: 3.2

3.2.1 Type Declarations
-----------------------

1
A type_declaration declares a type and its first subtype.

                               _Syntax_

2
     type_declaration ::=  full_type_declaration
        | incomplete_type_declaration
        | private_type_declaration
        | private_extension_declaration

3/3
     full_type_declaration ::=
          type defining_identifier [known_discriminant_part] is 
     type_definition
             [aspect_specification];
        | task_type_declaration
        | protected_type_declaration

4/2
     type_definition ::=
          enumeration_type_definition   | integer_type_definition
        | real_type_definition   | array_type_definition
        | record_type_definition   | access_type_definition
        | derived_type_definition   | interface_type_definition

                           _Legality Rules_

5
A given type shall not have a subcomponent whose type is the given type
itself.

                          _Static Semantics_

6
The defining_identifier (*note 3.1: S0022.) of a type_declaration (*note
3.2.1: S0023.) denotes the <first subtype> of the type.  The
known_discriminant_part (*note 3.7: S0061.), if any, defines the
discriminants of the type (see *note 3.7::, "*note 3.7::
Discriminants").  The remainder of the type_declaration (*note 3.2.1:
S0023.) defines the remaining characteristics of (the view of) the type.

7/2
A type defined by a type_declaration (*note 3.2.1: S0023.) is a <named>
type; such a type has one or more nameable subtypes.  Certain other
forms of declaration also include type definitions as part of the
declaration for an object.  The type defined by such a declaration is
<anonymous> -- it has no nameable subtypes.  For explanatory purposes,
this International Standard sometimes refers to an anonymous type by a
pseudo-name, written in italics, and uses such pseudo-names at places
where the syntax normally requires an identifier.  For a named type
whose first subtype is T, this International Standard sometimes refers
to the type of T as simply "the type T".

8/2
A named type that is declared by a full_type_declaration (*note 3.2.1:
S0024.), or an anonymous type that is defined by an access_definition or
as part of declaring an object of the type, is called a <full type>.
The declaration of a full type also declares the <full view> of the
type.  The type_definition (*note 3.2.1: S0025.), task_definition (*note
9.1: S0207.), protected_definition (*note 9.4: S0212.), or
access_definition (*note 3.10: S0084.) that defines a full type is
called a <full type definition>.  Types declared by other forms of
type_declaration (*note 3.2.1: S0023.) are not separate types; they are
partial or incomplete views of some full type.

9
The definition of a type implicitly declares certain <predefined
operators> that operate on the type, according to what classes the type
belongs, as specified in *note 4.5::, "*note 4.5:: Operators and
Expression Evaluation".

10
The <predefined types> (for example the types Boolean, Wide_Character,
Integer, <root_integer>, and <universal_integer>) are the types that are
defined in a predefined library package called Standard; this package
also includes the (implicit) declarations of their predefined operators.
The package Standard is described in *note A.1::.

                          _Dynamic Semantics_

11
The elaboration of a full_type_declaration consists of the elaboration
of the full type definition.  Each elaboration of a full type definition
creates a distinct type and its first subtype.

                              _Examples_

12
<Examples of type definitions:>

13
     (White, Red, Yellow, Green, Blue, Brown, Black)
     range 1 .. 72
     array(1 .. 10) of Integer

14
<Examples of type declarations:>

15
     type Color  is (White, Red, Yellow, Green, Blue, Brown, Black);
     type Column is range 1 .. 72;
     type Table  is array(1 .. 10) of Integer;

     NOTES

16
     3  Each of the above examples declares a named type.  The
     identifier given denotes the first subtype of the type.  Other
     named subtypes of the type can be declared with
     subtype_declarations (see *note 3.2.2::).  Although names do not
     directly denote types, a phrase like "the type Column" is sometimes
     used in this International Standard to refer to the type of Column,
     where Column denotes the first subtype of the type.  For an example
     of the definition of an anonymous type, see the declaration of the
     array Color_Table in *note 3.3.1::; its type is anonymous -- it has
     no nameable subtypes.


File: arm2012.info,  Node: 3.2.2,  Next: 3.2.3,  Prev: 3.2.1,  Up: 3.2

3.2.2 Subtype Declarations
--------------------------

1
A subtype_declaration declares a subtype of some previously declared
type, as defined by a subtype_indication.

                               _Syntax_

2/3
     subtype_declaration ::=
        subtype defining_identifier is subtype_indication
             [aspect_specification];

3/2
     subtype_indication ::=  [null_exclusion] subtype_mark [constraint]

4
     subtype_mark ::= <subtype_>name

5
     constraint ::= scalar_constraint | composite_constraint

6
     scalar_constraint ::=
          range_constraint | digits_constraint | delta_constraint

7
     composite_constraint ::=
          index_constraint | discriminant_constraint

                        _Name Resolution Rules_

8
A subtype_mark shall resolve to denote a subtype.  The type <determined
by> a subtype_mark is the type of the subtype denoted by the
subtype_mark.

                          _Dynamic Semantics_

9
The elaboration of a subtype_declaration consists of the elaboration of
the subtype_indication.  The elaboration of a subtype_indication creates
a new subtype.  If the subtype_indication does not include a constraint,
the new subtype has the same (possibly null) constraint as that denoted
by the subtype_mark.  The elaboration of a subtype_indication that
includes a constraint proceeds as follows:

10
   * The constraint is first elaborated.

11
   * A check is then made that the constraint is <compatible> with the
     subtype denoted by the subtype_mark.

12
The condition imposed by a constraint is the condition obtained after
elaboration of the constraint.  The rules defining compatibility are
given for each form of constraint in the appropriate subclause.  These
rules are such that if a constraint is <compatible> with a subtype, then
the condition imposed by the constraint cannot contradict any condition
already imposed by the subtype on its values.  The exception
Constraint_Error is raised if any check of compatibility fails.

     NOTES

13
     4  A scalar_constraint may be applied to a subtype of an
     appropriate scalar type (see *note 3.5::, *note 3.5.9::, and *note
     J.3::), even if the subtype is already constrained.  On the other
     hand, a composite_constraint may be applied to a composite subtype
     (or an access-to-composite subtype) only if the composite subtype
     is unconstrained (see *note 3.6.1:: and *note 3.7.1::).

                              _Examples_

14
<Examples of subtype declarations:>

15/2
     subtype Rainbow   is Color range Red .. Blue;        --<  see *note 3.2.1::>
     subtype Red_Blue  is Rainbow;
     subtype Int       is Integer;
     subtype Small_Int is Integer range -10 .. 10;
     subtype Up_To_K   is Column range 1 .. K;            --<  see *note 3.2.1::>
     subtype Square    is Matrix(1 .. 10, 1 .. 10);       --<  see *note 3.6::>
     subtype Male      is Person(Sex => M);               --<  see *note 3.10.1::>
     subtype Binop_Ref is not null Binop_Ptr;             --<  see *note 3.10::>


File: arm2012.info,  Node: 3.2.3,  Next: 3.2.4,  Prev: 3.2.2,  Up: 3.2

3.2.3 Classification of Operations
----------------------------------

                          _Static Semantics_

1/2
An operation <operates on a type> <T> if it yields a value of type <T>,
if it has an operand whose expected type (see *note 8.6::) is <T>, or if
it has an access parameter or access result type (see *note 6.1::)
designating <T>.  A predefined operator, or other language-defined
operation such as assignment or a membership test, that operates on a
type, is called a <predefined operation> of the type.  The <primitive
operations> of a type are the predefined operations of the type, plus
any user-defined primitive subprograms.

2
The <primitive subprograms> of a specific type are defined as follows:

3
   * The predefined operators of the type (see *note 4.5::);

4
   * For a derived type, the inherited (see *note 3.4::) user-defined
     subprograms;

5
   * For an enumeration type, the enumeration literals (which are
     considered parameterless functions -- see *note 3.5.1::);

6
   * For a specific type declared immediately within a
     package_specification, any subprograms (in addition to the
     enumeration literals) that are explicitly declared immediately
     within the same package_specification and that operate on the type;

6.1/3
   * For a specific type with an explicitly declared primitive "="
     operator whose result type is Boolean, the corresponding "/="
     operator (see *note 6.6::);

7/2
   * For a nonformal type, any subprograms not covered above that are
     explicitly declared immediately within the same declarative region
     as the type and that override (see *note 8.3::) other implicitly
     declared primitive subprograms of the type.

8
A primitive subprogram whose designator is an operator_symbol is called
a <primitive operator>.


File: arm2012.info,  Node: 3.2.4,  Prev: 3.2.3,  Up: 3.2

3.2.4 Subtype Predicates
------------------------

1/3
The language-defined <predicate aspects> Static_Predicate and
Dynamic_Predicate may be used to define properties of subtypes.  A
<predicate specification> is an aspect_specification for one of the two
predicate aspects.  General rules for aspects and aspect_specifications
are found in Clause *note 13:: (*note 13.1:: and *note 13.1.1::
respectively).

                        _Name Resolution Rules_

2/3
The expected type for a predicate aspect expression is any boolean type.

                          _Static Semantics_

3/3
A predicate specification may be given on a type_declaration or a
subtype_declaration, and applies to the declared subtype.  In addition,
predicate specifications apply to certain other subtypes:

4/4
   * For a (first) subtype defined by a type declaration, any predicates
     of parent or progenitor subtypes apply.

5/3
   * For a subtype created by a subtype_indication, the predicate of the
     subtype denoted by the subtype_mark applies.

6/4
<This paragraph was deleted.>

7/3
Predicate checks are defined to be <enabled> or <disabled> for a given
subtype as follows:

8/3
   * If a subtype is declared by a type_declaration or
     subtype_declaration that includes a predicate specification, then:

9/3
        * if performing checks is required by the Static_Predicate
          assertion policy (see *note 11.4.2::) and the declaration
          includes a Static_Predicate specification, then predicate
          checks are enabled for the subtype;

10/3
        * if performing checks is required by the Dynamic_Predicate
          assertion policy (see *note 11.4.2::) and the declaration
          includes a Dynamic_Predicate specification, then predicate
          checks are enabled for the subtype;

11/3
        * otherwise, predicate checks are disabled for the subtype,
          regardless of whether predicate checking is enabled for any
          other subtypes mentioned in the declaration;

12/4
   * If a subtype is defined by a type declaration that does not include
     a predicate specification, then predicate checks are enabled for
     the subtype if and only if any predicate checks are enabled for
     parent or progenitor subtypes;

13/3
   * If a subtype is created by a subtype_indication other than in one
     of the previous cases, then predicate checks are enabled for the
     subtype if and only if predicate checks are enabled for the subtype
     denoted by the subtype_mark;

14/3
   * Otherwise, predicate checks are disabled for the given subtype.

14.1/4
For a subtype with a directly-specified predicate aspect, the following
additional language-defined aspect may be specified with an
aspect_specification (see *note 13.1.1::):

14.2/4
Predicate_Failure
               This aspect shall be specified by an expression, which
               determines the action to be performed when a predicate
               check fails because a directly-specified predicate aspect
               of the subtype evaluates to False, as explained below.

                        _Name Resolution Rules_

14.3/4
The expected type for the Predicate_Failure expression is String.

                           _Legality Rules_

15/3
The expression of a Static_Predicate specification shall be
<predicate-static>; that is, one of the following:

16/3
   * a static expression;

17/4
   * a membership test whose <tested_>simple_expression is the current
     instance, and whose membership_choice_list meets the requirements
     for a static membership test (see *note 4.9::);

18/3
   * a case_expression whose <selecting_>expression is the current
     instance, and whose <dependent_>expressions are static expressions;

19/3
   * a call to a predefined equality or ordering operator, where one
     operand is the current instance, and the other is a static
     expression;

20/4
   * a call to a predefined boolean operator and, or, xor, or not, where
     each operand is predicate-static;

21/3
   * a short-circuit control form where both operands are
     predicate-static; or

22/3
   * a parenthesized predicate-static expression.

23/3
A predicate shall not be specified for an incomplete subtype.

24/3
If a predicate applies to a subtype, then that predicate shall not
mention any other subtype to which the same predicate applies.

25/3
An index subtype, discrete_range of an index_constraint or slice, or a
discrete_subtype_definition of a constrained_array_definition,
entry_declaration, or entry_index_specification shall not denote a
subtype to which predicate specifications apply.

26/3
The prefix of an attribute_reference whose attribute_designator is
First, Last, or Range shall not denote a scalar subtype to which
predicate specifications apply.

27/3
The discrete_subtype_definition of a loop_parameter_specification shall
not denote a nonstatic subtype to which predicate specifications apply
or any subtype to which Dynamic_Predicate specifications apply.

28/3
The discrete_choice of a named_array_aggregate shall not denote a
nonstatic subtype to which predicate specifications apply.

29/3
In addition to the places where Legality Rules normally apply (see *note
12.3::), these rules apply also in the private part of an instance of a
generic unit.

                          _Dynamic Semantics_

29.1/4
If any of the above Legality Rules is violated in an instance of a
generic unit, Program_Error is raised at the point of the violation.

29.2/4
To determine whether a value <satisfies the predicates> of a subtype
<S>, the following tests are performed in the following order, until one
of the tests fails, in which case the predicates are not satisfied and
no further tests are performed, or all of the tests succeed, in which
case the predicates are satisfied:

29.3/4
   * the value is first tested to determine whether it satisfies any
     constraints or any null exclusion of <S>;

29.4/4
   * then:

29.5/4
        * if <S> is a first subtype, the value is tested to determine
          whether it satisfies the predicates of the parent and
          progenitor subtypes (if any) of <S> (in an arbitrary order);

29.6/4
        * if <S> is defined by a subtype_indication, the value is tested
          to determine whether it satisfies the predicates of the
          subtype denoted by the subtype_mark of the subtype_indication;

29.7/4
   * finally, if <S> is defined by a declaration to which one or more
     predicate specifications apply, the predicates are evaluated (in an
     arbitrary order) to test that all of them yield True for the given
     value.

30/3
If predicate checks are enabled for a given subtype, then:

31/4
          On every subtype conversion, a check is performed that the
          operand satisfies the predicates of the target subtype.  This
          includes all parameter passing, except for certain parameters
          passed by reference, which are covered by the following rule:
          After normal completion and leaving of a subprogram, for each
          in out or out parameter that is passed by reference, a check
          is performed that the value of the parameter satisfies the
          predicates of the subtype of the actual.  For an object
          created by an object_declaration with no explicit
          initialization expression, or by an uninitialized allocator,
          if any subcomponents have default_expressions, a check is
          performed that the value of the created object satisfies the
          predicates of the nominal subtype.

31.1/4
          If any of the predicate checks fail, Assertion_Error is
          raised, unless the subtype whose directly-specified predicate
          aspect evaluated to False also has a directly-specified
          Predicate_Failure aspect.  In that case, the specified
          Predicate_Failure expression is evaluated; if the evaluation
          of the Predicate_Failure expression propagates an exception
          occurrence, then this occurrence is propagated for the failure
          of the predicate check; otherwise, Assertion_Error is raised,
          with an associated message string defined by the value of the
          Predicate_Failure expression.  In the absence of such a
          Predicate_Failure aspect, an implementation-defined message
          string is associated with the Assertion_Error exception.

32/4
<This paragraph was deleted.>

33/4
<This paragraph was deleted.>

     NOTES

34/3
     5  A predicate specification does not cause a subtype to be
     considered constrained.

35/3
     6  A Static_Predicate, like a constraint, always remains True for
     all objects of the subtype, except in the case of uninitialized
     variables and other invalid values.  A Dynamic_Predicate, on the
     other hand, is checked as specified above, but can become False at
     other times.  For example, the predicate of a record subtype is not
     checked when a subcomponent is modified.

36/4
     7  No predicates apply to the base subtype of a scalar type; every
     value of a scalar type <T> is considered to satisfy the predicates
     of <T>'Base.

37/4
     8  Predicate_Failure expressions are never evaluated during the
     evaluation of a membership test (see *note 4.5.2::) or Valid
     attribute (see *note 13.9.2::).

38/4
     9  A Predicate_Failure expression can be a raise_expression (see
     *note 11.3::).

                              _Examples_

39/4
     subtype Basic_Letter is Character -- <See *note A.3.2:: for "basic letter".>
        with Static_Predicate => Basic_Letter in 'A'..'Z' | 'a'..'z' | 'Æ' | 'æ' | 'Ð' | 'ð' | 'Þ' | 'þ' | 'ß';

40/4
     subtype Even_Integer is Integer
        with Dynamic_Predicate => Even_Integer mod 2 = 0,
            Predicate_Failure => "Even_Integer must be a multiple of 2";

41/4
<Text_IO (see *note A.10.1::) could have used predicates to describe
some common exceptional conditions as follows:>

42/4
     with Ada.IO_Exceptions;
     package Ada.Text_IO is

43/4
        type File_Type is limited private;

44/4
        subtype Open_File_Type is File_Type
           with Dynamic_Predicate => Is_Open (Open_File_Type),
                Predicate_Failure => raise Status_Error with "File not open";
        subtype Input_File_Type is Open_File_Type
           with Dynamic_Predicate => Mode (Input_File_Type) = In_File,
                Predicate_Failure => raise Mode_Error with "Cannot read file: " &
                   Name (Input_File_Type);
        subtype Output_File_Type is Open_File_Type
           with Dynamic_Predicate => Mode (Output_File_Type) /= In_File,
                Predicate_Failure => raise Mode_Error with "Cannot write file: " &
                   Name (Output_File_Type);

45/4
        ...

46/4
        function Mode (File : in Open_File_Type) return File_Mode;
        function Name (File : in Open_File_Type) return String;
        function Form (File : in Open_File_Type) return String;

47/4
        ...

48/4
        procedure Get (File : in Input_File_Type; Item : out Character);

49/4
        procedure Put (File : in Output_File_Type; Item : in Character);

50/4
        ...

51/4
        -- <Similarly for all of the other input and output subprograms.>


File: arm2012.info,  Node: 3.3,  Next: 3.4,  Prev: 3.2,  Up: 3

3.3 Objects and Named Numbers
=============================

1
Objects are created at run time and contain a value of a given type.  An
object can be created and initialized as part of elaborating a
declaration, evaluating an allocator, aggregate, or function_call, or
passing a parameter by copy.  Prior to reclaiming the storage for an
object, it is finalized if necessary (see *note 7.6.1::).

                          _Static Semantics_

2
All of the following are objects:

3
   * the entity declared by an object_declaration;

4
   * a formal parameter of a subprogram, entry, or generic subprogram;

5
   * a generic formal object;

6
   * a loop parameter;

7
   * a choice parameter of an exception_handler;

8
   * an entry index of an entry_body;

9
   * the result of dereferencing an access-to-object value (see *note
     4.1::);

10/3
   * the return object of a function;

11
   * the result of evaluating an aggregate;

11.1/3
   * a qualified_expression whose operand denotes an object;

12
   * a component, slice, or view conversion of another object.

13/3
An object is either a <constant> object or a <variable> object.
Similarly, a view of an object is either a <constant> or a <variable>.
All views of a constant elementary object are constant.  All views of a
constant composite object are constant, except for parts that are of
controlled or immutably limited types; variable views of those parts and
their subcomponents may exist.  In this sense, objects of controlled and
immutably limited types are <inherently mutable>.  A constant view of an
object cannot be used to modify its value.  The terms constant and
variable by themselves refer to constant and variable views of objects.

14
The value of an object is <read> when the value of any part of the
object is evaluated, or when the value of an enclosing object is
evaluated.  The value of a variable is <updated> when an assignment is
performed to any part of the variable, or when an assignment is
performed to an enclosing object.

15
Whether a view of an object is constant or variable is determined by the
definition of the view.  The following (and no others) represent
constants:

16
   * an object declared by an object_declaration with the reserved word
     constant;

17
   * a formal parameter or generic formal object of mode in;

18
   * a discriminant;

18.1/3
   * a loop parameter unless specified to be a variable for a
     generalized loop (see *note 5.5.2::);

19/3
   * a choice parameter or entry index;

20
   * the dereference of an access-to-constant value;

20.1/3
   * the return object declared by an extended_return_statement with the
     reserved word constant;

21/3
   * the object denoted by a function_call or an aggregate;

21.1/3
   * the result of evaluating a qualified_expression;

21.2/3
   * within the body of a protected function (or a function declared
     immediately within a protected_body), the current instance of the
     enclosing protected unit;

22
   * a selected_component, indexed_component, slice, or view conversion
     of a constant.

23/3
At the place where a view of an object is defined, a <nominal subtype>
is associated with the view.  The object's <actual subtype> (that is,
its subtype) can be more restrictive than the nominal subtype of the
view; it always is if the nominal subtype is an <indefinite subtype>.  A
subtype is an indefinite subtype if it is an unconstrained array
subtype, or if it has unknown discriminants or unconstrained
discriminants without defaults (see *note 3.7::); otherwise, the subtype
is a <definite> subtype (all elementary subtypes are definite subtypes).
A class-wide subtype is defined to have unknown discriminants, and is
therefore an indefinite subtype.  An indefinite subtype does not by
itself provide enough information to create an object; an additional
constraint or explicit initialization expression is necessary (see *note
3.3.1::).  A component cannot have an indefinite nominal subtype.

23.1/3
A view of a composite object is <known to be constrained> if:

23.2/3
   * its nominal subtype is constrained, and is not an untagged partial
     view; or

23.3/3
   * its nominal subtype is indefinite; or

23.4/3
   * its type is immutably limited (see *note 7.5::); or

23.5/3
   * it is part of a stand-alone constant (including a generic formal
     object of mode in); or

23.6/3
   * it is part of a formal parameter of mode in; or

23.7/3
   * it is part of the object denoted by a function_call or aggregate;
     or

23.8/3
   * it is part of a constant return object of an
     extended_return_statement; or

23.9/3
   * it is a dereference of a pool-specific access type, and there is no
     ancestor of its type that has a constrained partial view.

23.10/3
For the purposes of determining within a generic body whether an object
is known to be constrained:

23.11/3
   * if a subtype is a descendant of an untagged generic formal private
     or derived type, and the subtype is not an unconstrained array
     subtype, it is not considered indefinite and is considered to have
     a constrained partial view;

23.12/3
   * if a subtype is a descendant of a formal access type, it is not
     considered pool-specific.

24
A <named number> provides a name for a numeric value known at compile
time.  It is declared by a number_declaration.

     NOTES

25
     10  A constant cannot be the target of an assignment operation, nor
     be passed as an in out or out parameter, between its initialization
     and finalization, if any.

25.1/3
     11  The value of a constant object cannot be changed after its
     initialization, except in some cases where the object has a
     controlled or immutably limited part (see *note 7.5::, *note 7.6::,
     and *note 13.9.1::).

26/3
     12  The nominal and actual subtypes of an elementary object are
     always the same.  For a discriminated or array object, if the
     nominal subtype is constrained, then so is the actual subtype.

* Menu:

* 3.3.1 ::    Object Declarations
* 3.3.2 ::    Number Declarations


File: arm2012.info,  Node: 3.3.1,  Next: 3.3.2,  Up: 3.3

3.3.1 Object Declarations
-------------------------

1/3
An object_declaration declares a <stand-alone> object with a given
nominal subtype and, optionally, an explicit initial value given by an
initialization expression.  For an array, access, task, or protected
object, the object_declaration may include the definition of the
(anonymous) type of the object.

                               _Syntax_

2/3
     object_declaration ::=
         defining_identifier_list : [aliased] [constant] 
     subtype_indication [:= expression]
             [aspect_specification];
       | defining_identifier_list : [aliased] [constant] 
     access_definition [:= expression]
             [aspect_specification];
       | defining_identifier_list : [aliased] [constant] 
     array_type_definition [:= expression]
             [aspect_specification];
       | single_task_declaration
       | single_protected_declaration

3
     defining_identifier_list ::=
       defining_identifier {, defining_identifier}

                        _Name Resolution Rules_

4
For an object_declaration with an expression following the compound
delimiter :=, the type expected for the expression is that of the
object.  This expression is called the <initialization expression>.  

                           _Legality Rules_

5/2
An object_declaration without the reserved word constant declares a
variable object.  If it has a subtype_indication or an
array_type_definition that defines an indefinite subtype, then there
shall be an initialization expression.

                          _Static Semantics_

6/3
An object_declaration with the reserved word constant declares a
constant object.  If it has an initialization expression, then it is
called a <full constant declaration>.  Otherwise, it is called a
<deferred constant declaration>.  The rules for deferred constant
declarations are given in subclause *note 7.4::.  The rules for full
constant declarations are given in this subclause.

7
Any declaration that includes a defining_identifier_list with more than
one defining_identifier is equivalent to a series of declarations each
containing one defining_identifier from the list, with the rest of the
text of the declaration copied for each declaration in the series, in
the same order as the list.  The remainder of this International
Standard relies on this equivalence; explanations are given for
declarations with a single defining_identifier.

8/2
The subtype_indication, access_definition, or full type definition of an
object_declaration defines the nominal subtype of the object.  The
object_declaration declares an object of the type of the nominal
subtype.

8.1/2
A component of an object is said to <require late initialization> if it
has an access discriminant value constrained by a per-object expression,
or if it has an initialization expression that includes a name denoting
the current instance of the type or denoting an access discriminant.

                          _Dynamic Semantics_

9/2
If a composite object declared by an object_declaration has an
unconstrained nominal subtype, then if this subtype is indefinite or the
object is constant the actual subtype of this object is constrained.
The constraint is determined by the bounds or discriminants (if any) of
its initial value; the object is said to be <constrained by its initial
value>.  When not constrained by its initial value, the actual and
nominal subtypes of the object are the same.  If its actual subtype is
constrained, the object is called a <constrained object>.

10
For an object_declaration without an initialization expression, any
initial values for the object or its subcomponents are determined by the
<implicit initial values> defined for its nominal subtype, as follows:

11
   * The implicit initial value for an access subtype is the null value
     of the access type.

11.1/3
   * The implicit initial value for a scalar subtype that has the
     Default_Value aspect specified is the value of that aspect
     converted to the nominal subtype (which might raise
     Constraint_Error -- see *note 4.6::, "*note 4.6:: Type
     Conversions");

12
   * The implicit initial (and only) value for each discriminant of a
     constrained discriminated subtype is defined by the subtype.

13/3
   * For a (definite) composite subtype, the implicit initial value of
     each component with a default_expression is obtained by evaluation
     of this expression and conversion to the component's nominal
     subtype (which might raise Constraint_Error), unless the component
     is a discriminant of a constrained subtype (the previous case), or
     is in an excluded variant (see *note 3.8.1::).  For each component
     that does not have a default_expression, if the composite subtype
     has the Default_Component_Value aspect specified, the implicit
     initial value is the value of that aspect converted to the
     component's nominal subtype; otherwise, any implicit initial values
     are those determined by the component's nominal subtype.

14
   * For a protected or task subtype, there is an implicit component (an
     entry queue) corresponding to each entry, with its implicit initial
     value being an empty queue.

15
The elaboration of an object_declaration proceeds in the following
sequence of steps:

16/2
     1.  The subtype_indication (*note 3.2.2: S0027.), access_definition
     (*note 3.10: S0084.), array_type_definition (*note 3.6: S0051.),
     single_task_declaration (*note 9.1: S0206.), or
     single_protected_declaration (*note 9.4: S0211.) is first
     elaborated.  This creates the nominal subtype (and the anonymous
     type in the last four cases).

17
     2.  If the object_declaration includes an initialization
     expression, the (explicit) initial value is obtained by evaluating
     the expression and converting it to the nominal subtype (which
     might raise Constraint_Error -- see *note 4.6::).  

18/2
     3.  The object is created, and, if there is not an initialization
     expression, the object is <initialized by default>.  When an object
     is initialized by default, any per-object constraints (see *note
     3.8::) are elaborated and any implicit initial values for the
     object or for its subcomponents are obtained as determined by the
     nominal subtype.  Any initial values (whether explicit or implicit)
     are assigned to the object or to the corresponding subcomponents.
     As described in *note 5.2:: and *note 7.6::, Initialize and Adjust
     procedures can be called.  

19/2
       <This paragraph was deleted.>

20/2
For the third step above, evaluations and assignments are performed in
an arbitrary order subject to the following restrictions:

20.1/2
   * Assignment to any part of the object is preceded by the evaluation
     of the value that is to be assigned.

20.2/2
   * The evaluation of a default_expression that includes the name of a
     discriminant is preceded by the assignment to that discriminant.

20.3/2
   * The evaluation of the default_expression for any component that
     depends on a discriminant is preceded by the assignment to that
     discriminant.

20.4/3
   * The assignments to any components, including implicit components,
     not requiring late initialization precede the initial value
     evaluations for any components requiring late initialization; if
     two components both require late initialization, then assignments
     to parts of the component occurring earlier in the order of the
     component declarations precede the initial value evaluations of the
     component occurring later.

21/3
There is no implicit initial value defined for a scalar subtype unless
the Default_Value aspect has been specified for the type.  In the
absence of an explicit initialization or the specification of the
Default_Value aspect, a newly created scalar object might have a value
that does not belong to its subtype (see *note 13.9.1:: and *note
H.1::).

     NOTES

22
     13  Implicit initial values are not defined for an indefinite
     subtype, because if an object's nominal subtype is indefinite, an
     explicit initial value is required.

23/3
     14  As indicated above, a stand-alone object is an object declared
     by an object_declaration.  Similar definitions apply to
     "stand-alone constant" and "stand-alone variable."  A subcomponent
     of an object is not a stand-alone object, nor is an object that is
     created by an allocator.  An object declared by a
     loop_parameter_specification, iterator_specification,
     parameter_specification, entry_index_specification,
     choice_parameter_specification, extended_return_statement, or a
     formal_object_declaration of mode in out is not considered a
     stand-alone object.

24
     15  The type of a stand-alone object cannot be abstract (see *note
     3.9.3::).

                              _Examples_

25
<Example of a multiple object declaration:>

26
     --<  the multiple object declaration >

27/2
     John, Paul : not null Person_Name := new Person(Sex => M);  --<  see *note 3.10.1::>

28
     --<  is equivalent to the two single object declarations in the order given>

29/2
     John : not null Person_Name := new Person(Sex => M);
     Paul : not null Person_Name := new Person(Sex => M);

30
<Examples of variable declarations:>

31/2
     Count, Sum  : Integer;
     Size        : Integer range 0 .. 10_000 := 0;
     Sorted      : Boolean := False;
     Color_Table : array(1 .. Max) of Color;
     Option      : Bit_Vector(1 .. 10) := (others => True);
     Hello       : aliased String := "Hi, world.";
     [Unicode 952], [Unicode 966]        : Float range -PI .. +PI;

32
<Examples of constant declarations:>

33/2
     Limit     : constant Integer := 10_000;
     Low_Limit : constant Integer := Limit/10;
     Tolerance : constant Real := Dispersion(1.15);
     Hello_Msg : constant access String := Hello'Access; --< see *note 3.10.2::>


File: arm2012.info,  Node: 3.3.2,  Prev: 3.3.1,  Up: 3.3

3.3.2 Number Declarations
-------------------------

1
A number_declaration declares a named number.

                               _Syntax_

2
     number_declaration ::=
          defining_identifier_list : constant := <static_>expression;

                        _Name Resolution Rules_

3
The <static_>expression given for a number_declaration is expected to be
of any numeric type.

                           _Legality Rules_

4/3
The <static_>expression given for a number declaration shall be a static
expression, as defined by subclause *note 4.9::.

                          _Static Semantics_

5
The named number denotes a value of type <universal_integer> if the type
of the <static_>expression is an integer type.  The named number denotes
a value of type <universal_real> if the type of the <static_>expression
is a real type.

6
The value denoted by the named number is the value of the
<static_>expression, converted to the corresponding universal type.  

                          _Dynamic Semantics_

7
The elaboration of a number_declaration has no effect.

                              _Examples_

8
<Examples of number declarations:>

9
     Two_Pi        : constant := 2.0*Ada.Numerics.Pi;   --< a real number (see *note A.5::)>

10/2
     Max           : constant := 500;                   --< an integer number>
     Max_Line_Size : constant := Max/6;                 --< the integer 83>
     Power_16      : constant := 2**16;                 --< the integer 65_536>
     One, Un, Eins : constant := 1;                     --< three different names for 1>


File: arm2012.info,  Node: 3.4,  Next: 3.5,  Prev: 3.3,  Up: 3

3.4 Derived Types and Classes
=============================

1/2
A derived_type_definition defines a <derived type> (and its first
subtype) whose characteristics are <derived> from those of a parent
type, and possibly from progenitor types.  

1.1/2
A <class of types> is a set of types that is closed under derivation;
that is, if the parent or a progenitor type of a derived type belongs to
a class, then so does the derived type.  By saying that a particular
group of types forms a class, we are saying that all derivatives of a
type in the set inherit the characteristics that define that set.  The
more general term <category of types> is used for a set of types whose
defining characteristics are not necessarily inherited by derivatives;
for example, limited, abstract, and interface are all categories of
types, but not classes of types.

                               _Syntax_

2/2
     derived_type_definition ::=
         [abstract] [limited] new <parent_>subtype_indication [[and 
     interface_list] record_extension_part]

                           _Legality Rules_

3/2
The <parent_>subtype_indication defines the <parent subtype>; its type
is the <parent type>.  The interface_list defines the progenitor types
(see *note 3.9.4::).  A derived type has one parent type and zero or
more progenitor types.

4
A type shall be completely defined (see *note 3.11.1::) prior to being
specified as the parent type in a derived_type_definition -- the
full_type_declarations for the parent type and any of its subcomponents
have to precede the derived_type_definition.

5/2
If there is a record_extension_part, the derived type is called a
<record extension> of the parent type.  A record_extension_part shall be
provided if and only if the parent type is a tagged type.  An
interface_list shall be provided only if the parent type is a tagged
type.

5.1/3
If the reserved word limited appears in a derived_type_definition, the
parent type shall be a limited type.  If the parent type is a tagged
formal type, then in addition to the places where Legality Rules
normally apply (see *note 12.3::), this rule applies also in the private
part of an instance of a generic unit.

                          _Static Semantics_

6
The first subtype of the derived type is unconstrained if a
known_discriminant_part is provided in the declaration of the derived
type, or if the parent subtype is unconstrained.  Otherwise, the
constraint of the first subtype <corresponds> to that of the parent
subtype in the following sense: it is the same as that of the parent
subtype except that for a range constraint (implicit or explicit), the
value of each bound of its range is replaced by the corresponding value
of the derived type.

6.1/2
The first subtype of the derived type excludes null (see *note 3.10::)
if and only if the parent subtype excludes null.

7/3
The <characteristics> and implicitly declared primitive subprograms of
the derived type are defined as follows:

8/2
   * If the parent type or a progenitor type belongs to a class of
     types, then the derived type also belongs to that class.  The
     following sets of types, as well as any higher-level sets composed
     from them, are classes in this sense, and hence the characteristics
     defining these classes are inherited by derived types from their
     parent or progenitor types: signed integer, modular integer,
     ordinary fixed, decimal fixed, floating point, enumeration,
     boolean, character, access-to-constant, general access-to-variable,
     pool-specific access-to-variable, access-to-subprogram, array,
     string, non-array composite, nonlimited, untagged record, tagged,
     task, protected, and synchronized tagged.

9
   * If the parent type is an elementary type or an array type, then the
     set of possible values of the derived type is a copy of the set of
     possible values of the parent type.  For a scalar type, the base
     range of the derived type is the same as that of the parent type.

10
   * If the parent type is a composite type other than an array type,
     then the components, protected subprograms, and entries that are
     declared for the derived type are as follows:

11
             * The discriminants specified by a new
               known_discriminant_part, if there is one; otherwise, each
               discriminant of the parent type (implicitly declared in
               the same order with the same specifications) -- in the
               latter case, the discriminants are said to be
               <inherited>, or if unknown in the parent, are also
               unknown in the derived type;

12
             * Each nondiscriminant component, entry, and protected
               subprogram of the parent type, implicitly declared in the
               same order with the same declarations; these components,
               entries, and protected subprograms are said to be
               <inherited>;

13
             * Each component declared in a record_extension_part, if
               any.

14
     Declarations of components, protected subprograms, and entries,
     whether implicit or explicit, occur immediately within the
     declarative region of the type, in the order indicated above,
     following the parent subtype_indication.

15/2
   * <This paragraph was deleted.>

16
   * For each predefined operator of the parent type, there is a
     corresponding predefined operator of the derived type.

17/2
   * For each user-defined primitive subprogram (other than a
     user-defined equality operator -- see below) of the parent type or
     of a progenitor type that already exists at the place of the
     derived_type_definition, there exists a corresponding <inherited>
     primitive subprogram of the derived type with the same defining
     name.  Primitive user-defined equality operators of the parent type
     and any progenitor types are also inherited by the derived type,
     except when the derived type is a nonlimited record extension, and
     the inherited operator would have a profile that is type conformant
     with the profile of the corresponding predefined equality operator;
     in this case, the user-defined equality operator is not inherited,
     but is rather incorporated into the implementation of the
     predefined equality operator of the record extension (see *note
     4.5.2::).  

18/3
     The profile of an inherited subprogram (including an inherited
     enumeration literal) is obtained from the profile of the
     corresponding (user-defined) primitive subprogram of the parent or
     progenitor type, after systematic replacement of each subtype of
     its profile (see *note 6.1::) that is of the parent or progenitor
     type, other than those subtypes found in the designated profile of
     an access_definition, with a <corresponding subtype> of the derived
     type.  For a given subtype of the parent or progenitor type, the
     corresponding subtype of the derived type is defined as follows:

19
             * If the declaration of the derived type has neither a
               known_discriminant_part nor a record_extension_part, then
               the corresponding subtype has a constraint that
               corresponds (as defined above for the first subtype of
               the derived type) to that of the given subtype.

20
             * If the derived type is a record extension, then the
               corresponding subtype is the first subtype of the derived
               type.

21
             * If the derived type has a new known_discriminant_part but
               is not a record extension, then the corresponding subtype
               is constrained to those values that when converted to the
               parent type belong to the given subtype (see *note
               4.6::).  

22/2
     The same formal parameters have default_expressions in the profile
     of the inherited subprogram.  Any type mismatch due to the
     systematic replacement of the parent or progenitor type by the
     derived type is handled as part of the normal type conversion
     associated with parameter passing -- see *note 6.4.1::.

23/2
If a primitive subprogram of the parent or progenitor type is visible at
the place of the derived_type_definition, then the corresponding
inherited subprogram is implicitly declared immediately after the
derived_type_definition.  Otherwise, the inherited subprogram is
implicitly declared later or not at all, as explained in *note 7.3.1::.

24
A derived type can also be defined by a private_extension_declaration
(*note 7.3: S0194.) (see *note 7.3::) or a
formal_derived_type_definition (*note 12.5.1: S0286.) (see *note
12.5.1::).  Such a derived type is a partial view of the corresponding
full or actual type.

25
All numeric types are derived types, in that they are implicitly derived
from a corresponding root numeric type (see *note 3.5.4:: and *note
3.5.6::).

                          _Dynamic Semantics_

26
The elaboration of a derived_type_definition creates the derived type
and its first subtype, and consists of the elaboration of the
subtype_indication (*note 3.2.2: S0027.) and the record_extension_part
(*note 3.9.1: S0075.), if any.  If the subtype_indication (*note 3.2.2:
S0027.) depends on a discriminant, then only those expressions that do
not depend on a discriminant are evaluated.

27/2
For the execution of a call on an inherited subprogram, a call on the
corresponding primitive subprogram of the parent or progenitor type is
performed; the normal conversion of each actual parameter to the subtype
of the corresponding formal parameter (see *note 6.4.1::) performs any
necessary type conversion as well.  If the result type of the inherited
subprogram is the derived type, the result of calling the subprogram of
the parent or progenitor is converted to the derived type, or in the
case of a null extension, extended to the derived type using the
equivalent of an extension_aggregate with the original result as the
ancestor_part and null record as the record_component_association_list.
     NOTES

28
     16  Classes are closed under derivation -- any class that contains
     a type also contains its derivatives.  Operations available for a
     given class of types are available for the derived types in that
     class.

29
     17  Evaluating an inherited enumeration literal is equivalent to
     evaluating the corresponding enumeration literal of the parent
     type, and then converting the result to the derived type.  This
     follows from their equivalence to parameterless functions.  

30
     18  A generic subprogram is not a subprogram, and hence cannot be a
     primitive subprogram and cannot be inherited by a derived type.  On
     the other hand, an instance of a generic subprogram can be a
     primitive subprogram, and hence can be inherited.

31
     19  If the parent type is an access type, then the parent and the
     derived type share the same storage pool; there is a null access
     value for the derived type and it is the implicit initial value for
     the type.  See *note 3.10::.

32
     20  If the parent type is a boolean type, the predefined relational
     operators of the derived type deliver a result of the predefined
     type Boolean (see *note 4.5.2::).  If the parent type is an integer
     type, the right operand of the predefined exponentiation operator
     is of the predefined type Integer (see *note 4.5.6::).

33
     21  Any discriminants of the parent type are either all inherited,
     or completely replaced with a new set of discriminants.

34
     22  For an inherited subprogram, the subtype of a formal parameter
     of the derived type need not have any value in common with the
     first subtype of the derived type.

35
     23  If the reserved word abstract is given in the declaration of a
     type, the type is abstract (see *note 3.9.3::).

35.1/2
     24  An interface type that has a progenitor type "is derived from"
     that type.  A derived_type_definition, however, never defines an
     interface type.

35.2/2
     25  It is illegal for the parent type of a derived_type_definition
     to be a synchronized tagged type.

                              _Examples_

36
<Examples of derived type declarations:>

37
     type Local_Coordinate is new Coordinate;   --<  two different types>
     type Midweek is new Day range Tue .. Thu;  --<  see *note 3.5.1::>
     type Counter is new Positive;              --<  same range as Positive >

38
     type Special_Key is new Key_Manager.Key;   --<  see *note 7.3.1::>
       --< the inherited subprograms have the following specifications: >
       --<         procedure Get_Key(K : out Special_Key);>
       --<         function "<"(X,Y : Special_Key) return Boolean;>

* Menu:

* 3.4.1 ::    Derivation Classes


File: arm2012.info,  Node: 3.4.1,  Up: 3.4

3.4.1 Derivation Classes
------------------------

1
In addition to the various language-defined classes of types, types can
be grouped into <derivation classes>.

                          _Static Semantics_

2/2
A derived type is <derived from> its parent type <directly>; it is
derived <indirectly> from any type from which its parent type is
derived.  A derived type, interface type, type extension, task type,
protected type, or formal derived type is also derived from every
ancestor of each of its progenitor types, if any.  The derivation class
of types for a type <T> (also called the class <rooted> at <T>) is the
set consisting of <T> (the <root type> of the class) and all types
derived from <T> (directly or indirectly) plus any associated universal
or class-wide types (defined below).

3/2
Every type is either a <specific> type, a <class-wide> type, or a
<universal> type.  A specific type is one defined by a type_declaration,
a formal_type_declaration, or a full type definition embedded in another
construct.  Class-wide and universal types are implicitly defined, to
act as representatives for an entire class of types, as follows:

4
Class-wide types
               Class-wide types are defined for (and belong to) each
               derivation class rooted at a tagged type (see *note
               3.9::).  Given a subtype S of a tagged type <T>, S'Class
               is the subtype_mark for a corresponding subtype of the
               tagged class-wide type <T>'Class.  Such types are called
               "class-wide" because when a formal parameter is defined
               to be of a class-wide type <T>'Class, an actual parameter
               of any type in the derivation class rooted at <T> is
               acceptable (see *note 8.6::).

5
               The set of values for a class-wide type <T>'Class is the
               discriminated union of the set of values of each specific
               type in the derivation class rooted at <T> (the tag acts
               as the implicit discriminant -- see *note 3.9::).
               Class-wide types have no primitive subprograms of their
               own.  However, as explained in *note 3.9.2::, operands of
               a class-wide type <T>'Class can be used as part of a
               dispatching call on a primitive subprogram of the type
               <T>.  The only components (including discriminants) of
               <T>'Class that are visible are those of <T>.  If S is a
               first subtype, then S'Class is a first subtype.

6/2
Universal types
               Universal types are defined for (and belong to) the
               integer, real, fixed point, and access classes, and are
               referred to in this standard as respectively,
               <universal_integer>, <universal_real>, <universal_fixed>,
               and <universal_access>.  These are analogous to
               class-wide types for these language-defined elementary
               classes.  As with class-wide types, if a formal parameter
               is of a universal type, then an actual parameter of any
               type in the corresponding class is acceptable.  In
               addition, a value of a universal type (including an
               integer or real numeric_literal, or the literal null) is
               "universal" in that it is acceptable where some
               particular type in the class is expected (see *note
               8.6::).

7
               The set of values of a universal type is the
               undiscriminated union of the set of values possible for
               any definable type in the associated class.  Like
               class-wide types, universal types have no primitive
               subprograms of their own.  However, their "universality"
               allows them to be used as operands with the primitive
               subprograms of any type in the corresponding class.

8
The integer and real numeric classes each have a specific root type in
addition to their universal type, named respectively <root_integer> and
<root_real>.

9
A class-wide or universal type is said to <cover> all of the types in
its class.  A specific type covers only itself.

10/2
A specific type <T2> is defined to be a <descendant> of a type <T1> if
<T2> is the same as <T1>, or if <T2> is derived (directly or indirectly)
from <T1>.  A class-wide type <T2>'Class is defined to be a descendant
of type <T1> if <T2> is a descendant of <T1>.  Similarly, the numeric
universal types are defined to be descendants of the root types of their
classes.  If a type <T2> is a descendant of a type <T1>, then <T1> is
called an <ancestor> of <T2>.  An <ultimate ancestor> of a type is an
ancestor of that type that is not itself a descendant of any other type.
Every untagged type has a unique ultimate ancestor.

11
An inherited component (including an inherited discriminant) of a
derived type is inherited <from> a given ancestor of the type if the
corresponding component was inherited by each derived type in the chain
of derivations going back to the given ancestor.

     NOTES

12
     26  Because operands of a universal type are acceptable to the
     predefined operators of any type in their class, ambiguity can
     result.  For <universal_integer> and <universal_real>, this
     potential ambiguity is resolved by giving a preference (see *note
     8.6::) to the predefined operators of the corresponding root types
     (<root_integer> and <root_real>, respectively).  Hence, in an
     apparently ambiguous expression like

13
          1 + 4 < 7

14
     where each of the literals is of type <universal_integer>, the
     predefined operators of <root_integer> will be preferred over those
     of other specific integer types, thereby resolving the ambiguity.


File: arm2012.info,  Node: 3.5,  Next: 3.6,  Prev: 3.4,  Up: 3

3.5 Scalar Types
================

1
<Scalar> types comprise enumeration types, integer types, and real
types.  Enumeration types and integer types are called <discrete> types;
each value of a discrete type has a <position number> which is an
integer value.  Integer types and real types are called <numeric> types.
All scalar types are ordered, that is, all relational operators are
predefined for their values.

                               _Syntax_

2
     range_constraint ::=  range range

3
     range ::=  range_attribute_reference
        | simple_expression .. simple_expression

4
A <range> has a <lower bound> and an <upper bound> and specifies a
subset of the values of some scalar type (the <type of the range>).  A
range with lower bound L and upper bound R is described by "L ..  R". If
R is less than L, then the range is a <null range>, and specifies an
empty set of values.  Otherwise, the range specifies the values of the
type from the lower bound to the upper bound, inclusive.  A value
<belongs> to a range if it is of the type of the range, and is in the
subset of values specified by the range.  A value <satisfies> a range
constraint if it belongs to the associated range.  One range is
<included> in another if all values that belong to the first range also
belong to the second.

                        _Name Resolution Rules_

5
For a subtype_indication containing a range_constraint, either directly
or as part of some other scalar_constraint, the type of the range shall
resolve to that of the type determined by the subtype_mark of the
subtype_indication.  For a range of a given type, the simple_expressions
of the range (likewise, the simple_expressions of the equivalent range
for a range_attribute_reference) are expected to be of the type of the
range.

                          _Static Semantics_

6
The <base range> of a scalar type is the range of finite values of the
type that can be represented in every unconstrained object of the type;
it is also the range supported at a minimum for intermediate values
during the evaluation of expressions involving predefined operators of
the type.

7
A constrained scalar subtype is one to which a range constraint applies.
The <range> of a constrained scalar subtype is the range associated with
the range constraint of the subtype.  The <range> of an unconstrained
scalar subtype is the base range of its type.

                          _Dynamic Semantics_

8
A range is <compatible> with a scalar subtype if and only if it is
either a null range or each bound of the range belongs to the range of
the subtype.  A range_constraint is <compatible> with a scalar subtype
if and only if its range is compatible with the subtype.

9
The elaboration of a range_constraint consists of the evaluation of the
range.  The evaluation of a range determines a lower bound and an upper
bound.  If simple_expressions are given to specify bounds, the
evaluation of the range evaluates these simple_expressions in an
arbitrary order, and converts them to the type of the range.  If a
range_attribute_reference is given, the evaluation of the range consists
of the evaluation of the range_attribute_reference.

10
<Attributes>

11
For every scalar subtype S, the following attributes are defined:

12
S'First
               S'First denotes the lower bound of the range of S. The
               value of this attribute is of the type of S.

13
S'Last
               S'Last denotes the upper bound of the range of S. The
               value of this attribute is of the type of S.

14
S'Range
               S'Range is equivalent to the range S'First ..  S'Last.

15
S'Base
               S'Base denotes an unconstrained subtype of the type of S.
               This unconstrained subtype is called the <base subtype>
               of the type.  

16
S'Min
               S'Min denotes a function with the following
               specification:

17
                    function S'Min(<Left>, <Right> : S'Base)
                      return S'Base

18
               The function returns the lesser of the values of the two
               parameters.

19
S'Max
               S'Max denotes a function with the following
               specification:

20
                    function S'Max(<Left>, <Right> : S'Base)
                      return S'Base

21
               The function returns the greater of the values of the two
               parameters.

22
S'Succ
               S'Succ denotes a function with the following
               specification:

23
                    function S'Succ(<Arg> : S'Base)
                      return S'Base

24
               For an enumeration type, the function returns the value
               whose position number is one more than that of the value
               of <Arg>; Constraint_Error is raised if there is no such
               value of the type.  For an integer type, the function
               returns the result of adding one to the value of <Arg>.
               For a fixed point type, the function returns the result
               of adding <small> to the value of <Arg>.  For a floating
               point type, the function returns the machine number (as
               defined in *note 3.5.7::) immediately above the value of
               <Arg>; Constraint_Error is raised if there is no such
               machine number.

25
S'Pred
               S'Pred denotes a function with the following
               specification:

26
                    function S'Pred(<Arg> : S'Base)
                      return S'Base

27
               For an enumeration type, the function returns the value
               whose position number is one less than that of the value
               of <Arg>; Constraint_Error is raised if there is no such
               value of the type.  For an integer type, the function
               returns the result of subtracting one from the value of
               <Arg>.  For a fixed point type, the function returns the
               result of subtracting <small> from the value of <Arg>.
               For a floating point type, the function returns the
               machine number (as defined in *note 3.5.7::) immediately
               below the value of <Arg>; Constraint_Error is raised if
               there is no such machine number.

27.1/2
S'Wide_Wide_Image
               S'Wide_Wide_Image denotes a function with the following
               specification:

27.2/2
                    function S'Wide_Wide_Image(<Arg> : S'Base)
                      return Wide_Wide_String

27.3/2
               The function returns an <image> of the value of <Arg>,
               that is, a sequence of characters representing the value
               in display form.  The lower bound of the result is one.

27.4/2
               The image of an integer value is the corresponding
               decimal literal, without underlines, leading zeros,
               exponent, or trailing spaces, but with a single leading
               character that is either a minus sign or a space.

27.5/2
               The image of an enumeration value is either the
               corresponding identifier in upper case or the
               corresponding character literal (including the two
               apostrophes); neither leading nor trailing spaces are
               included.  For a <nongraphic character> (a value of a
               character type that has no enumeration literal associated
               with it), the result is a corresponding language-defined
               name in upper case (for example, the image of the
               nongraphic character identified as <nul> is "NUL" -- the
               quotes are not part of the image).

27.6/2
               The image of a floating point value is a decimal real
               literal best approximating the value (rounded away from
               zero if halfway between) with a single leading character
               that is either a minus sign or a space, a single digit
               (that is nonzero unless the value is zero), a decimal
               point, S'Digits-1 (see *note 3.5.8::) digits after the
               decimal point (but one if S'Digits is one), an upper case
               E, the sign of the exponent (either + or -), and two or
               more digits (with leading zeros if necessary)
               representing the exponent.  If S'Signed_Zeros is True,
               then the leading character is a minus sign for a
               negatively signed zero.

27.7/2
               The image of a fixed point value is a decimal real
               literal best approximating the value (rounded away from
               zero if halfway between) with a single leading character
               that is either a minus sign or a space, one or more
               digits before the decimal point (with no redundant
               leading zeros), a decimal point, and S'Aft (see *note
               3.5.10::) digits after the decimal point.

28
S'Wide_Image
               S'Wide_Image denotes a function with the following
               specification:

29
                    function S'Wide_Image(<Arg> : S'Base)
                      return Wide_String

30/3
               The function returns an image of the value of <Arg> as a
               Wide_String.  The lower bound of the result is one.  The
               image has the same sequence of graphic characters as
               defined for S'Wide_Wide_Image if all the graphic
               characters are defined in Wide_Character; otherwise, the
               sequence of characters is implementation defined (but no
               shorter than that of S'Wide_Wide_Image for the same value
               of Arg).

               <Paragraphs 31 through 34 were moved to Wide_Wide_Image.>

35
S'Image
               S'Image denotes a function with the following
               specification:

36
                    function S'Image(<Arg> : S'Base)
                      return String

37/3
               The function returns an image of the value of <Arg> as a
               String.  The lower bound of the result is one.  The image
               has the same sequence of graphic characters as that
               defined for S'Wide_Wide_Image if all the graphic
               characters are defined in Character; otherwise, the
               sequence of characters is implementation defined (but no
               shorter than that of S'Wide_Wide_Image for the same value
               of <Arg>).

37.1/2
S'Wide_Wide_Width
               S'Wide_Wide_Width denotes the maximum length of a
               Wide_Wide_String returned by S'Wide_Wide_Image over all
               values of the subtype S. It denotes zero for a subtype
               that has a null range.  Its type is <universal_integer>.

38
S'Wide_Width
               S'Wide_Width denotes the maximum length of a Wide_String
               returned by S'Wide_Image over all values of the subtype
               S. It denotes zero for a subtype that has a null range.
               Its type is <universal_integer>.

39
S'Width
               S'Width denotes the maximum length of a String returned
               by S'Image over all values of the subtype S. It denotes
               zero for a subtype that has a null range.  Its type is
               <universal_integer>.

39.1/2
S'Wide_Wide_Value
               S'Wide_Wide_Value denotes a function with the following
               specification:

39.2/2
                    function S'Wide_Wide_Value(<Arg> : Wide_Wide_String)
                      return S'Base

39.3/2
               This function returns a value given an image of the value
               as a Wide_Wide_String, ignoring any leading or trailing
               spaces.

39.4/3
               For the evaluation of a call on S'Wide_Wide_Value for an
               enumeration subtype S, if the sequence of characters of
               the parameter (ignoring leading and trailing spaces) has
               the syntax of an enumeration literal and if it
               corresponds to a literal of the type of S (or corresponds
               to the result of S'Wide_Wide_Image for a nongraphic
               character of the type), the result is the corresponding
               enumeration value; otherwise, Constraint_Error is raised.

39.5/3
               For the evaluation of a call on S'Wide_Wide_Value for an
               integer subtype S, if the sequence of characters of the
               parameter (ignoring leading and trailing spaces) has the
               syntax of an integer literal, with an optional leading
               sign character (plus or minus for a signed type; only
               plus for a modular type), and the corresponding numeric
               value belongs to the base range of the type of S, then
               that value is the result; otherwise, Constraint_Error is
               raised.

39.6/2
               For the evaluation of a call on S'Wide_Wide_Value for a
               real subtype S, if the sequence of characters of the
               parameter (ignoring leading and trailing spaces) has the
               syntax of one of the following:

39.7/2
                  * numeric_literal

39.8/2
                  * numeral.[exponent]

39.9/2
                  * .numeral[exponent]

39.10/2
                  * base#based_numeral.#[exponent]

39.11/2
                  * base#.based_numeral#[exponent]

39.12/3
               with an optional leading sign character (plus or minus),
               and if the corresponding numeric value belongs to the
               base range of the type of S, then that value is the
               result; otherwise, Constraint_Error is raised.  The sign
               of a zero value is preserved (positive if none has been
               specified) if S'Signed_Zeros is True.

40
S'Wide_Value
               S'Wide_Value denotes a function with the following
               specification:

41
                    function S'Wide_Value(<Arg> : Wide_String)
                      return S'Base

42
               This function returns a value given an image of the value
               as a Wide_String, ignoring any leading or trailing
               spaces.

43/3
               For the evaluation of a call on S'Wide_Value for an
               enumeration subtype S, if the sequence of characters of
               the parameter (ignoring leading and trailing spaces) has
               the syntax of an enumeration literal and if it
               corresponds to a literal of the type of S (or corresponds
               to the result of S'Wide_Image for a value of the type),
               the result is the corresponding enumeration value; 
               otherwise, Constraint_Error is raised.  For a numeric
               subtype S, the evaluation of a call on S'Wide_Value with
               <Arg> of type Wide_String is equivalent to a call on
               S'Wide_Wide_Value for a corresponding <Arg> of type
               Wide_Wide_String.

               <Paragraphs 44 through 51 were moved to Wide_Wide_Value.>

52
S'Value
               S'Value denotes a function with the following
               specification:

53
                    function S'Value(<Arg> : String)
                      return S'Base

54
               This function returns a value given an image of the value
               as a String, ignoring any leading or trailing spaces.

55/3
               For the evaluation of a call on S'Value for an
               enumeration subtype S, if the sequence of characters of
               the parameter (ignoring leading and trailing spaces) has
               the syntax of an enumeration literal and if it
               corresponds to a literal of the type of S (or corresponds
               to the result of S'Image for a value of the type), the
               result is the corresponding enumeration value; otherwise,
               Constraint_Error is raised.  For a numeric subtype S, the
               evaluation of a call on S'Value with <Arg> of type String
               is equivalent to a call on S'Wide_Wide_Value for a
               corresponding <Arg> of type Wide_Wide_String.

55.1/4
For a prefix X that denotes an object of a scalar type (after any
implicit dereference), the following attributes are defined:

55.2/4
X'Wide_Wide_Image
               X'Wide_Wide_Image denotes the result of calling function
               S'Wide_Wide_Image with <Arg> being X, where S is the
               nominal subtype of X.

55.3/4
X'Wide_Image
               X'Wide_Image denotes the result of calling function
               S'Wide_Image with <Arg> being X, where S is the nominal
               subtype of X.

55.4/4
X'Image
               X'Image denotes the result of calling function S'Image
               with <Arg> being X, where S is the nominal subtype of X.

                     _Implementation Permissions_

56/2
An implementation may extend the Wide_Wide_Value, Wide_Value, Value,
Wide_Wide_Image, Wide_Image, and Image attributes of a floating point
type to support special values such as infinities and NaNs.

56.1/3
An implementation may extend the Wide_Wide_Value, Wide_Value, and Value
attributes of a character type to accept strings of the form
"Hex_<hhhhhhhh>" (ignoring case) for any character (not just the ones
for which Wide_Wide_Image would produce that form -- see *note 3.5.2::),
as well as three-character strings of the form "'<X>'", where <X> is any
character, including nongraphic characters.

                          _Static Semantics_

56.2/3
For a scalar type, the following language-defined representation aspect
may be specified with an aspect_specification (see *note 13.1.1::):

56.3/3
Default_Value
               This aspect shall be specified by a static expression,
               and that expression shall be explicit, even if the aspect
               has a boolean type.  Default_Value shall be specified
               only on a full_type_declaration.

56.4/3
If a derived type with no primitive subprograms inherits a boolean
Default_Value aspect, the aspect may be specified to have any value for
the derived type.

                        _Name Resolution Rules_

56.5/3
The expected type for the expression specified for the Default_Value
aspect is the type defined by the full_type_declaration on which it
appears.

     NOTES

57
     27  The evaluation of S'First or S'Last never raises an exception.
     If a scalar subtype S has a nonnull range, S'First and S'Last
     belong to this range.  These values can, for example, always be
     assigned to a variable of subtype S.

58
     28  For a subtype of a scalar type, the result delivered by the
     attributes Succ, Pred, and Value might not belong to the subtype;
     similarly, the actual parameters of the attributes Succ, Pred, and
     Image need not belong to the subtype.

59
     29  For any value V (including any nongraphic character) of an
     enumeration subtype S, S'Value(S'Image(V)) equals V, as do
     S'Wide_Value(S'Wide_Image(V)) and
     S'Wide_Wide_Value(S'Wide_Wide_Image(V)). None of these expressions
     ever raise Constraint_Error.

                              _Examples_

60
<Examples of ranges:>

61
     -10 .. 10
     X .. X + 1
     0.0 .. 2.0*Pi
     Red .. Green     --< see *note 3.5.1::>
     1 .. 0           --< a null range>
     Table'Range      --< a range attribute reference (see *note 3.6::)>

62
<Examples of range constraints:>

63
     range -999.0 .. +999.0
     range S'First+1 .. S'Last-1

* Menu:

* 3.5.1 ::    Enumeration Types
* 3.5.2 ::    Character Types
* 3.5.3 ::    Boolean Types
* 3.5.4 ::    Integer Types
* 3.5.5 ::    Operations of Discrete Types
* 3.5.6 ::    Real Types
* 3.5.7 ::    Floating Point Types
* 3.5.8 ::    Operations of Floating Point Types
* 3.5.9 ::    Fixed Point Types
* 3.5.10 ::   Operations of Fixed Point Types


File: arm2012.info,  Node: 3.5.1,  Next: 3.5.2,  Up: 3.5

3.5.1 Enumeration Types
-----------------------

1
An enumeration_type_definition defines an enumeration type.

                               _Syntax_

2
     enumeration_type_definition ::=
        (enumeration_literal_specification {, 
     enumeration_literal_specification})

3
     enumeration_literal_specification ::=  defining_identifier | 
     defining_character_literal

4
     defining_character_literal ::= character_literal

                           _Legality Rules_

5/3
The defining_identifiers in upper case and the
defining_character_literals listed in an enumeration_type_definition
shall be distinct.

                          _Static Semantics_

6/3
Each enumeration_literal_specification is the explicit declaration of
the corresponding <enumeration literal>: it declares a parameterless
function, whose defining name is the defining_identifier (*note 3.1:
S0022.) or defining_character_literal (*note 3.5.1: S0040.), and whose
result subtype is the base subtype of the enumeration type.

7
Each enumeration literal corresponds to a distinct value of the
enumeration type, and to a distinct position number.  The position
number of the value of the first listed enumeration literal is zero; the
position number of the value of each subsequent enumeration literal is
one more than that of its predecessor in the list.

8
The predefined order relations between values of the enumeration type
follow the order of corresponding position numbers.

9
If the same defining_identifier or defining_character_literal is
specified in more than one enumeration_type_definition (*note 3.5.1:
S0038.), the corresponding enumeration literals are said to be
<overloaded>.  At any place where an overloaded enumeration literal
occurs in the text of a program, the type of the enumeration literal has
to be determinable from the context (see *note 8.6::).

                          _Dynamic Semantics_

10
The elaboration of an enumeration_type_definition creates the
enumeration type and its first subtype, which is constrained to the base
range of the type.

11
When called, the parameterless function associated with an enumeration
literal returns the corresponding value of the enumeration type.

     NOTES

12
     30  If an enumeration literal occurs in a context that does not
     otherwise suffice to determine the type of the literal, then
     qualification by the name of the enumeration type is one way to
     resolve the ambiguity (see *note 4.7::).

                              _Examples_

13
<Examples of enumeration types and subtypes: >

14
     type Day    is (Mon, Tue, Wed, Thu, Fri, Sat, Sun);
     type Suit   is (Clubs, Diamonds, Hearts, Spades);
     type Gender is (M, F);
     type Level  is (Low, Medium, Urgent);
     type Color  is (White, Red, Yellow, Green, Blue, Brown, Black);
     type Light  is (Red, Amber, Green); --< Red and Green are overloaded>

15
     type Hexa   is ('A', 'B', 'C', 'D', 'E', 'F');
     type Mixed  is ('A', 'B', '*', B, None, '?', '%');

16
     subtype Weekday is Day   range Mon .. Fri;
     subtype Major   is Suit  range Hearts .. Spades;
     subtype Rainbow is Color range Red .. Blue;  --<  the Color Red, not the Light>


File: arm2012.info,  Node: 3.5.2,  Next: 3.5.3,  Prev: 3.5.1,  Up: 3.5

3.5.2 Character Types
---------------------

                          _Static Semantics_

1
An enumeration type is said to be a <character type> if at least one of
its enumeration literals is a character_literal.

2/3
The predefined type Character is a character type whose values
correspond to the 256 code points of Row 00 (also known as Latin-1) of
the ISO/IEC 10646:2011 Basic Multilingual Plane (BMP). Each of the
graphic characters of Row 00 of the BMP has a corresponding
character_literal in Character.  Each of the nongraphic characters of
Row 00 has a corresponding language-defined name, which is not usable as
an enumeration literal, but which is usable with the attributes Image,
Wide_Image, Wide_Wide_Image, Value, Wide_Value, and Wide_Wide_Value;
these names are given in the definition of type Character in *note
A.1::, "*note A.1:: The Package Standard", but are set in <italics>.  

3/3
The predefined type Wide_Character is a character type whose values
correspond to the 65536 code points of the ISO/IEC 10646:2011 Basic
Multilingual Plane (BMP). Each of the graphic characters of the BMP has
a corresponding character_literal in Wide_Character.  The first 256
values of Wide_Character have the same character_literal or
language-defined name as defined for Character.  Each of the
graphic_characters has a corresponding character_literal.

4/3
The predefined type Wide_Wide_Character is a character type whose values
correspond to the 2147483648 code points of the ISO/IEC 10646:2011
character set.  Each of the graphic_characters has a corresponding
character_literal in Wide_Wide_Character.  The first 65536 values of
Wide_Wide_Character have the same character_literal or language-defined
name as defined for Wide_Character.

5/3
The characters whose code point is larger than 16#FF# and which are not
graphic_characters have language-defined names which are formed by
appending to the string "Hex_" the representation of their code point in
hexadecimal as eight extended digits.  As with other language-defined
names, these names are usable only with the attributes (Wide_)Wide_Image
and (Wide_)Wide_Value; they are not usable as enumeration literals.

<Paragraphs 6 and 7 were deleted.>

     NOTES

8
     31  The language-defined library package Characters.Latin_1 (see
     *note A.3.3::) includes the declaration of constants denoting
     control characters, lower case characters, and special characters
     of the predefined type Character.

9/3
     32  A conventional character set such as <EBCDIC> can be declared
     as a character type; the internal codes of the characters can be
     specified by an enumeration_representation_clause as explained in
     subclause *note 13.4::.

                              _Examples_

10
<Example of a character type: >

11
     type Roman_Digit is ('I', 'V', 'X', 'L', 'C', 'D', 'M');


File: arm2012.info,  Node: 3.5.3,  Next: 3.5.4,  Prev: 3.5.2,  Up: 3.5

3.5.3 Boolean Types
-------------------

                          _Static Semantics_

1
There is a predefined enumeration type named Boolean, declared in the
visible part of package Standard.  It has the two enumeration literals
False and True ordered with the relation False < True.  Any descendant
of the predefined type Boolean is called a <boolean> type.


File: arm2012.info,  Node: 3.5.4,  Next: 3.5.5,  Prev: 3.5.3,  Up: 3.5

3.5.4 Integer Types
-------------------

1
An integer_type_definition defines an integer type; it defines either a
<signed> integer type, or a <modular> integer type.  The base range of a
signed integer type includes at least the values of the specified range.
A modular type is an integer type with all arithmetic modulo a specified
positive <modulus>; such a type corresponds to an unsigned type with
wrap-around semantics.  

                               _Syntax_

2
     integer_type_definition ::= signed_integer_type_definition | 
     modular_type_definition

3
     signed_integer_type_definition ::= range <static_>
     simple_expression .. <static_>simple_expression

4
     modular_type_definition ::= mod <static_>expression

                        _Name Resolution Rules_

5
Each simple_expression in a signed_integer_type_definition is expected
to be of any integer type; they need not be of the same type.  The
expression in a modular_type_definition is likewise expected to be of
any integer type.

                           _Legality Rules_

6
The simple_expressions of a signed_integer_type_definition shall be
static, and their values shall be in the range System.Min_Int ..
System.Max_Int.

7
The expression of a modular_type_definition shall be static, and its
value (the <modulus>) shall be positive, and shall be no greater than
System.Max_Binary_Modulus if a power of 2, or no greater than
System.Max_Nonbinary_Modulus if not.

                          _Static Semantics_

8
The set of values for a signed integer type is the (infinite) set of
mathematical integers, though only values of the base range of the type
are fully supported for run-time operations.  The set of values for a
modular integer type are the values from 0 to one less than the modulus,
inclusive.

9
A signed_integer_type_definition defines an integer type whose base
range includes at least the values of the simple_expressions and is
symmetric about zero, excepting possibly an extra negative value.  A
signed_integer_type_definition also defines a constrained first subtype
of the type, with a range whose bounds are given by the values of the
simple_expressions, converted to the type being defined.

10
A modular_type_definition defines a modular type whose base range is
from zero to one less than the given modulus.  A modular_type_definition
also defines a constrained first subtype of the type with a range that
is the same as the base range of the type.

11
There is a predefined signed integer subtype named Integer, declared in
the visible part of package Standard.  It is constrained to the base
range of its type.

12
Integer has two predefined subtypes, declared in the visible part of
package Standard:

13
     subtype Natural  is Integer range 0 .. Integer'Last;
     subtype Positive is Integer range 1 .. Integer'Last;

14
A type defined by an integer_type_definition is implicitly derived from
<root_integer>, an anonymous predefined (specific) integer type, whose
base range is System.Min_Int ..  System.Max_Int.  However, the base
range of the new type is not inherited from <root_integer>, but is
instead determined by the range or modulus specified by the
integer_type_definition.  Integer literals are all of the type
<universal_integer>, the universal type (see *note 3.4.1::) for the
class rooted at <root_integer>, allowing their use with the operations
of any integer type.

15
The <position number> of an integer value is equal to the value.

16/2
For every modular subtype S, the following attributes are defined:

16.1/2
S'Mod
               S'Mod denotes a function with the following
               specification:

16.2/2
                    function S'Mod (<Arg> : <universal_integer>)
                      return S'Base

16.3/2
               This function returns <Arg> mod S'Modulus, as a value of
               the type of S.

17
S'Modulus
               S'Modulus yields the modulus of the type of S, as a value
               of the type <universal_integer>.

                          _Dynamic Semantics_

18
The elaboration of an integer_type_definition creates the integer type
and its first subtype.

19
For a modular type, if the result of the execution of a predefined
operator (see *note 4.5::) is outside the base range of the type, the
result is reduced modulo the modulus of the type to a value that is
within the base range of the type.

20
For a signed integer type, the exception Constraint_Error is raised by
the execution of an operation that cannot deliver the correct result
because it is outside the base range of the type.  For any integer type,
Constraint_Error is raised by the operators "/", "rem", and "mod" if the
right operand is zero.

                     _Implementation Requirements_

21
In an implementation, the range of Integer shall include the range
-2**15+1 ..  +2**15-1.

22
If Long_Integer is predefined for an implementation, then its range
shall include the range -2**31+1 ..  +2**31-1.

23
System.Max_Binary_Modulus shall be at least 2**16.

                     _Implementation Permissions_

24
For the execution of a predefined operation of a signed integer type,
the implementation need not raise Constraint_Error if the result is
outside the base range of the type, so long as the correct result is
produced.

25
An implementation may provide additional predefined signed integer
types, declared in the visible part of Standard, whose first subtypes
have names of the form Short_Integer, Long_Integer, Short_Short_Integer,
Long_Long_Integer, etc.  Different predefined integer types are allowed
to have the same base range.  However, the range of Integer should be no
wider than that of Long_Integer.  Similarly, the range of Short_Integer
(if provided) should be no wider than Integer.  Corresponding
recommendations apply to any other predefined integer types.  There need
not be a named integer type corresponding to each distinct base range
supported by an implementation.  The range of each first subtype should
be the base range of its type.

26
An implementation may provide <nonstandard integer types>, descendants
of <root_integer> that are declared outside of the specification of
package Standard, which need not have all the standard characteristics
of a type defined by an integer_type_definition.  For example, a
nonstandard integer type might have an asymmetric base range or it might
not be allowed as an array or loop index (a very long integer).  Any
type descended from a nonstandard integer type is also nonstandard.  An
implementation may place arbitrary restrictions on the use of such
types; it is implementation defined whether operators that are
predefined for "any integer type" are defined for a particular
nonstandard integer type.  In any case, such types are not permitted as
explicit_generic_actual_parameters for formal scalar types -- see *note
12.5.2::.

27
For a one's complement machine, the high bound of the base range of a
modular type whose modulus is one less than a power of 2 may be equal to
the modulus, rather than one less than the modulus.  It is
implementation defined for which powers of 2, if any, this permission is
exercised.

27.1/1
For a one's complement machine, implementations may support nonbinary
modulus values greater than System.Max_Nonbinary_Modulus.  It is
implementation defined which specific values greater than
System.Max_Nonbinary_Modulus, if any, are supported.

                        _Implementation Advice_

28
An implementation should support Long_Integer in addition to Integer if
the target machine supports 32-bit (or longer) arithmetic.  No other
named integer subtypes are recommended for package Standard.  Instead,
appropriate named integer subtypes should be provided in the library
package Interfaces (see *note B.2::).

29
An implementation for a two's complement machine should support modular
types with a binary modulus up to System.Max_Int*2+2.  An implementation
should support a nonbinary modulus up to Integer'Last.

     NOTES

30
     33  Integer literals are of the anonymous predefined integer type
     <universal_integer>.  Other integer types have no literals.
     However, the overload resolution rules (see *note 8.6::, "*note
     8.6:: The Context of Overload Resolution") allow expressions of the
     type <universal_integer> whenever an integer type is expected.

31
     34  The same arithmetic operators are predefined for all signed
     integer types defined by a signed_integer_type_definition (see
     *note 4.5::, "*note 4.5:: Operators and Expression Evaluation").
     For modular types, these same operators are predefined, plus
     bit-wise logical operators (and, or, xor, and not).  In addition,
     for the unsigned types declared in the language-defined package
     Interfaces (see *note B.2::), functions are defined that provide
     bit-wise shifting and rotating.

32
     35  Modular types match a generic_formal_parameter_declaration of
     the form "type T is mod <>;"; signed integer types match "type T is
     range <>;" (see *note 12.5.2::).

                              _Examples_

33
<Examples of integer types and subtypes: >

34
     type Page_Num  is range 1 .. 2_000;
     type Line_Size is range 1 .. Max_Line_Size;

35
     subtype Small_Int   is Integer   range -10 .. 10;
     subtype Column_Ptr  is Line_Size range 1 .. 10;
     subtype Buffer_Size is Integer   range 0 .. Max;

36
     type Byte        is mod 256; --< an unsigned byte>
     type Hash_Index  is mod 97;  --< modulus is prime>


File: arm2012.info,  Node: 3.5.5,  Next: 3.5.6,  Prev: 3.5.4,  Up: 3.5

3.5.5 Operations of Discrete Types
----------------------------------

                          _Static Semantics_

1
For every discrete subtype S, the following attributes are defined:

2
S'Pos
               S'Pos denotes a function with the following
               specification:

3
                    function S'Pos(<Arg> : S'Base)
                      return <universal_integer>

4
               This function returns the position number of the value of
               <Arg>, as a value of type <universal_integer>.

5
S'Val
               S'Val denotes a function with the following
               specification:

6
                    function S'Val(<Arg> : <universal_integer>)
                      return S'Base

7
               This function returns a value of the type of S whose
               position number equals the value of <Arg>.  For the
               evaluation of a call on S'Val, if there is no value in
               the base range of its type with the given position
               number, Constraint_Error is raised.

7.1/4
For every static discrete subtype S for which there exists at least one
value belonging to S that satisfies the predicates of S, the following
attributes are defined:

7.2/4
S'First_Valid
               S'First_Valid denotes the smallest value that belongs to
               S and satisfies the predicates of S. The value of this
               attribute is of the type of S.

7.3/4
S'Last_Valid
               S'Last_Valid denotes the largest value that belongs to S
               and satisfies the predicates of S. The value of this
               attribute is of the type of S.

7.4/3
First_Valid and Last_Valid attribute_references are always static
expressions.  Any explicit predicate of S can only have been specified
by a Static_Predicate aspect.

                        _Implementation Advice_

8
For the evaluation of a call on S'Pos for an enumeration subtype, if the
value of the operand does not correspond to the internal code for any
enumeration literal of its type (perhaps due to an uninitialized
variable), then the implementation should raise Program_Error.  This is
particularly important for enumeration types with noncontiguous internal
codes specified by an enumeration_representation_clause (*note 13.4:
S0311.).

     NOTES

9
     36  Indexing and loop iteration use values of discrete types.

10/3
     37  The predefined operations of a discrete type include the
     assignment operation, qualification, the membership tests, and the
     relational operators; for a boolean type they include the
     short-circuit control forms and the logical operators; for an
     integer type they include type conversion to and from other numeric
     types, as well as the binary and unary adding operators - and +,
     the multiplying operators, the unary operator abs, and the
     exponentiation operator.  The assignment operation is described in
     *note 5.2::.  The other predefined operations are described in
     Clause *note 4::.

11
     38  As for all types, objects of a discrete type have Size and
     Address attributes (see *note 13.3::).

12
     39  For a subtype of a discrete type, the result delivered by the
     attribute Val might not belong to the subtype; similarly, the
     actual parameter of the attribute Pos need not belong to the
     subtype.  The following relations are satisfied (in the absence of
     an exception) by these attributes:

13
             S'Val(S'Pos(X)) = X
             S'Pos(S'Val(N)) = N

                              _Examples_

14
<Examples of attributes of discrete subtypes: >

15
     --<  For the types and subtypes declared in subclause *note 3.5.1:: the following hold: >

16
     --  Color'First   = White,   Color'Last   = Black
     --  Rainbow'First = Red,     Rainbow'Last = Blue

17
     --  Color'Succ(Blue) = Rainbow'Succ(Blue) = Brown
     --  Color'Pos(Blue)  = Rainbow'Pos(Blue)  = 4
     --  Color'Val(0)     = Rainbow'Val(0)     = White


File: arm2012.info,  Node: 3.5.6,  Next: 3.5.7,  Prev: 3.5.5,  Up: 3.5

3.5.6 Real Types
----------------

1
Real types provide approximations to the real numbers, with relative
bounds on errors for floating point types, and with absolute bounds for
fixed point types.

                               _Syntax_

2
     real_type_definition ::=
        floating_point_definition | fixed_point_definition

                          _Static Semantics_

3
A type defined by a real_type_definition is implicitly derived from
<root_real>, an anonymous predefined (specific) real type.  Hence, all
real types, whether floating point or fixed point, are in the derivation
class rooted at <root_real>.

4
Real literals are all of the type <universal_real>, the universal type
(see *note 3.4.1::) for the class rooted at <root_real>, allowing their
use with the operations of any real type.  Certain multiplying operators
have a result type of <universal_fixed> (see *note 4.5.5::), the
universal type for the class of fixed point types, allowing the result
of the multiplication or division to be used where any specific fixed
point type is expected.

                          _Dynamic Semantics_

5
The elaboration of a real_type_definition consists of the elaboration of
the floating_point_definition or the fixed_point_definition.

                     _Implementation Requirements_

6
An implementation shall perform the run-time evaluation of a use of a
predefined operator of <root_real> with an accuracy at least as great as
that of any floating point type definable by a
floating_point_definition.

                     _Implementation Permissions_

7/2
For the execution of a predefined operation of a real type, the
implementation need not raise Constraint_Error if the result is outside
the base range of the type, so long as the correct result is produced,
or the Machine_Overflows attribute of the type is False (see *note
G.2::).

8
An implementation may provide <nonstandard real types>, descendants of
<root_real> that are declared outside of the specification of package
Standard, which need not have all the standard characteristics of a type
defined by a real_type_definition.  For example, a nonstandard real type
might have an asymmetric or unsigned base range, or its predefined
operations might wrap around or "saturate" rather than overflow (modular
or saturating arithmetic), or it might not conform to the accuracy model
(see *note G.2::).  Any type descended from a nonstandard real type is
also nonstandard.  An implementation may place arbitrary restrictions on
the use of such types; it is implementation defined whether operators
that are predefined for "any real type" are defined for a particular
nonstandard real type.  In any case, such types are not permitted as
explicit_generic_actual_parameters for formal scalar types -- see *note
12.5.2::.

     NOTES

9
     40  As stated, real literals are of the anonymous predefined real
     type <universal_real>.  Other real types have no literals.
     However, the overload resolution rules (see *note 8.6::) allow
     expressions of the type <universal_real> whenever a real type is
     expected.


File: arm2012.info,  Node: 3.5.7,  Next: 3.5.8,  Prev: 3.5.6,  Up: 3.5

3.5.7 Floating Point Types
--------------------------

1
For floating point types, the error bound is specified as a relative
precision by giving the required minimum number of significant decimal
digits.

                               _Syntax_

2
     floating_point_definition ::=
       digits <static_>expression [real_range_specification]

3
     real_range_specification ::=
       range <static_>simple_expression .. <static_>simple_expression

                        _Name Resolution Rules_

4
The <requested decimal precision>, which is the minimum number of
significant decimal digits required for the floating point type, is
specified by the value of the expression given after the reserved word
digits.  This expression is expected to be of any integer type.

5
Each simple_expression of a real_range_specification is expected to be
of any real type; the types need not be the same.

                           _Legality Rules_

6
The requested decimal precision shall be specified by a static
expression whose value is positive and no greater than
System.Max_Base_Digits.  Each simple_expression of a
real_range_specification shall also be static.  If the
real_range_specification is omitted, the requested decimal precision
shall be no greater than System.Max_Digits.

7
A floating_point_definition is illegal if the implementation does not
support a floating point type that satisfies the requested decimal
precision and range.

                          _Static Semantics_

8
The set of values for a floating point type is the (infinite) set of
rational numbers.  The <machine numbers> of a floating point type are
the values of the type that can be represented exactly in every
unconstrained variable of the type.  The base range (see *note 3.5::) of
a floating point type is symmetric around zero, except that it can
include some extra negative values in some implementations.

9
The <base decimal precision> of a floating point type is the number of
decimal digits of precision representable in objects of the type.  The
<safe range> of a floating point type is that part of its base range for
which the accuracy corresponding to the base decimal precision is
preserved by all predefined operations.

10
A floating_point_definition defines a floating point type whose base
decimal precision is no less than the requested decimal precision.  If a
real_range_specification is given, the safe range of the floating point
type (and hence, also its base range) includes at least the values of
the simple expressions given in the real_range_specification.  If a
real_range_specification is not given, the safe (and base) range of the
type includes at least the values of the range -10.0**(4*D) ..
+10.0**(4*D) where D is the requested decimal precision.  The safe range
might include other values as well.  The attributes Safe_First and
Safe_Last give the actual bounds of the safe range.

11
A floating_point_definition also defines a first subtype of the type.  
If a real_range_specification is given, then the subtype is constrained
to a range whose bounds are given by a conversion of the values of the
simple_expressions of the real_range_specification to the type being
defined.  Otherwise, the subtype is unconstrained.

12
There is a predefined, unconstrained, floating point subtype named
Float, declared in the visible part of package Standard.

                          _Dynamic Semantics_

13
The elaboration of a floating_point_definition creates the floating
point type and its first subtype.

                     _Implementation Requirements_

14
In an implementation that supports floating point types with 6 or more
digits of precision, the requested decimal precision for Float shall be
at least 6.

15
If Long_Float is predefined for an implementation, then its requested
decimal precision shall be at least 11.

                     _Implementation Permissions_

16
An implementation is allowed to provide additional predefined floating
point types, declared in the visible part of Standard, whose
(unconstrained) first subtypes have names of the form Short_Float,
Long_Float, Short_Short_Float, Long_Long_Float, etc.  Different
predefined floating point types are allowed to have the same base
decimal precision.  However, the precision of Float should be no greater
than that of Long_Float.  Similarly, the precision of Short_Float (if
provided) should be no greater than Float.  Corresponding
recommendations apply to any other predefined floating point types.
There need not be a named floating point type corresponding to each
distinct base decimal precision supported by an implementation.

                        _Implementation Advice_

17
An implementation should support Long_Float in addition to Float if the
target machine supports 11 or more digits of precision.  No other named
floating point subtypes are recommended for package Standard.  Instead,
appropriate named floating point subtypes should be provided in the
library package Interfaces (see *note B.2::).

     NOTES

18
     41  If a floating point subtype is unconstrained, then assignments
     to variables of the subtype involve only Overflow_Checks, never
     Range_Checks.

                              _Examples_

19
<Examples of floating point types and subtypes:>

20
     type Coefficient is digits 10 range -1.0 .. 1.0;

21
     type Real is digits 8;
     type Mass is digits 7 range 0.0 .. 1.0E35;

22
     subtype Probability is Real range 0.0 .. 1.0;   --<   a subtype with a smaller range>


File: arm2012.info,  Node: 3.5.8,  Next: 3.5.9,  Prev: 3.5.7,  Up: 3.5

3.5.8 Operations of Floating Point Types
----------------------------------------

                          _Static Semantics_

1
The following attribute is defined for every floating point subtype S:

2/1
S'Digits
               S'Digits denotes the requested decimal precision for the
               subtype S. The value of this attribute is of the type
               <universal_integer>.  The requested decimal precision of
               the base subtype of a floating point type <T> is defined
               to be the largest value of <d> for which
               ceiling(<d> * log(10) / log(T'Machine_Radix)) + <g> <=
               T'Model_Mantissa
               where g is 0 if Machine_Radix is a positive power of 10
               and 1 otherwise.

     NOTES

3
     42  The predefined operations of a floating point type include the
     assignment operation, qualification, the membership tests, and
     explicit conversion to and from other numeric types.  They also
     include the relational operators and the following predefined
     arithmetic operators: the binary and unary adding operators - and
     +, certain multiplying operators, the unary operator abs, and the
     exponentiation operator.

4
     43  As for all types, objects of a floating point type have Size
     and Address attributes (see *note 13.3::).  Other attributes of
     floating point types are defined in *note A.5.3::.


File: arm2012.info,  Node: 3.5.9,  Next: 3.5.10,  Prev: 3.5.8,  Up: 3.5

3.5.9 Fixed Point Types
-----------------------

1
A fixed point type is either an ordinary fixed point type, or a decimal
fixed point type.  The error bound of a fixed point type is specified as
an absolute value, called the <delta> of the fixed point type.

                               _Syntax_

2
     fixed_point_definition ::= ordinary_fixed_point_definition | 
     decimal_fixed_point_definition

3
     ordinary_fixed_point_definition ::=
        delta <static_>expression  real_range_specification

4
     decimal_fixed_point_definition ::=
        delta <static_>expression digits <static_>expression [
     real_range_specification]

5/4
     digits_constraint ::=
        digits <static_>simple_expression [range_constraint]

                        _Name Resolution Rules_

6
For a type defined by a fixed_point_definition, the <delta> of the type
is specified by the value of the expression given after the reserved
word delta; this expression is expected to be of any real type.  For a
type defined by a decimal_fixed_point_definition (a <decimal> fixed
point type), the number of significant decimal digits for its first
subtype (the <digits> of the first subtype) is specified by the
expression given after the reserved word digits; this expression is
expected to be of any integer type.

6.1/4
The simple_expression of a digits_constraint is expected to be of any
integer type.

                           _Legality Rules_

7
In a fixed_point_definition or digits_constraint, the expressions given
after the reserved words delta and digits shall be static; their values
shall be positive.

8/2
The set of values of a fixed point type comprise the integral multiples
of a number called the <small> of the type.  The <machine numbers> of a
fixed point type are the values of the type that can be represented
exactly in every unconstrained variable of the type.  For a type defined
by an ordinary_fixed_point_definition (an <ordinary> fixed point type),
the <small> may be specified by an attribute_definition_clause (*note
13.3: S0310.) (see *note 13.3::); if so specified, it shall be no
greater than the <delta> of the type.  If not specified, the <small> of
an ordinary fixed point type is an implementation-defined power of two
less than or equal to the <delta>.

9
For a decimal fixed point type, the <small> equals the <delta>; the
<delta> shall be a power of 10.  If a real_range_specification is given,
both bounds of the range shall be in the range -(10**<digits>-1)*<delta>
..  +(10**<digits>-1)*<delta>.

10
A fixed_point_definition is illegal if the implementation does not
support a fixed point type with the given <small> and specified range or
<digits>.

11
For a subtype_indication with a digits_constraint, the subtype_mark
shall denote a decimal fixed point subtype.

                          _Static Semantics_

12
The base range (see *note 3.5::) of a fixed point type is symmetric
around zero, except possibly for an extra negative value in some
implementations.

13
An ordinary_fixed_point_definition defines an ordinary fixed point type
whose base range includes at least all multiples of <small> that are
between the bounds specified in the real_range_specification.  The base
range of the type does not necessarily include the specified bounds
themselves.  An ordinary_fixed_point_definition (*note 3.5.9: S0048.)
also defines a constrained first subtype of the type, with each bound of
its range given by the closer to zero of:

14
   * the value of the conversion to the fixed point type of the
     corresponding expression of the real_range_specification; 

15
   * the corresponding bound of the base range.

16
A decimal_fixed_point_definition defines a decimal fixed point type
whose base range includes at least the range -(10**<digits>-1)*<delta>
..  +(10**<digits>-1)*<delta>.  A decimal_fixed_point_definition also
defines a constrained first subtype of the type.  If a
real_range_specification is given, the bounds of the first subtype are
given by a conversion of the values of the expressions of the
real_range_specification.  Otherwise, the range of the first subtype is
-(10**<digits>-1)*<delta> ..  +(10**<digits>-1)*<delta>.

                          _Dynamic Semantics_

17
The elaboration of a fixed_point_definition creates the fixed point type
and its first subtype.

18/4
For a digits_constraint on a decimal fixed point subtype with a given
<delta>, if it does not have a range_constraint, then it specifies an
implicit range -(10**<D>-1)*<delta> ..  +(10**<D>-1)*<delta>, where <D>
is the value of the simple_expression.  A digits_constraint is
<compatible> with a decimal fixed point subtype if the value of the
simple_expression is no greater than the <digits> of the subtype, and if
it specifies (explicitly or implicitly) a range that is compatible with
the subtype.

19/4
The elaboration of a digits_constraint consists of the elaboration of
the range_constraint, if any.  If a range_constraint is given, a check
is made that the bounds of the range are both in the range
-(10**<D>-1)*<delta> ..  +(10**<D>-1)*<delta>, where <D> is the value of
the (static) simple_expression given after the reserved word digits.  If
this check fails, Constraint_Error is raised.

                     _Implementation Requirements_

20
The implementation shall support at least 24 bits of precision
(including the sign bit) for fixed point types.

                     _Implementation Permissions_

21
Implementations are permitted to support only <small>s that are a power
of two.  In particular, all decimal fixed point type declarations can be
disallowed.  Note however that conformance with the Information Systems
Annex requires support for decimal <small>s, and decimal fixed point
type declarations with <digits> up to at least 18.

     NOTES

22
     44  The base range of an ordinary fixed point type need not include
     the specified bounds themselves so that the range specification can
     be given in a natural way, such as:

23
             type Fraction is delta 2.0**(-15) range -1.0 .. 1.0;
  

24
     With 2's complement hardware, such a type could have a signed
     16-bit representation, using 1 bit for the sign and 15 bits for
     fraction, resulting in a base range of -1.0 ..  1.0-2.0**(-15).

                              _Examples_

25
<Examples of fixed point types and subtypes:>

26
     type Volt is delta 0.125 range 0.0 .. 255.0;

27
       -- <A pure fraction which requires all the available>
       -- <space in a word can be declared as the type Fraction:>
     type Fraction is delta System.Fine_Delta range -1.0 .. 1.0;
       -- <Fraction'Last = 1.0 - System.Fine_Delta>

28
     type Money is delta 0.01 digits 15;  -- <decimal fixed point>
     subtype Salary is Money digits 10;
       -- <Money'Last = 10.0**13 - 0.01, Salary'Last = 10.0**8 - 0.01>


File: arm2012.info,  Node: 3.5.10,  Prev: 3.5.9,  Up: 3.5

3.5.10 Operations of Fixed Point Types
--------------------------------------

                          _Static Semantics_

1
The following attributes are defined for every fixed point subtype S:

2/1
S'Small
               S'Small denotes the <small> of the type of S. The value
               of this attribute is of the type <universal_real>.  Small
               may be specified for nonderived ordinary fixed point
               types via an attribute_definition_clause (*note 13.3:
               S0310.) (see *note 13.3::); the expression of such a
               clause shall be static.

3
S'Delta
               S'Delta denotes the <delta> of the fixed point subtype S.
               The value of this attribute is of the type
               <universal_real>.

4
S'Fore
               S'Fore yields the minimum number of characters needed
               before the decimal point for the decimal representation
               of any value of the subtype S, assuming that the
               representation does not include an exponent, but includes
               a one-character prefix that is either a minus sign or a
               space.  (This minimum number does not include superfluous
               zeros or underlines, and is at least 2.)  The value of
               this attribute is of the type <universal_integer>.

5
S'Aft
               S'Aft yields the number of decimal digits needed after
               the decimal point to accommodate the <delta> of the
               subtype S, unless the <delta> of the subtype S is greater
               than 0.1, in which case the attribute yields the value
               one.  (S'Aft is the smallest positive integer N for which
               (10**N)*S'Delta is greater than or equal to one.)  The
               value of this attribute is of the type
               <universal_integer>.

6
The following additional attributes are defined for every decimal fixed
point subtype S:

7
S'Digits
               S'Digits denotes the <digits> of the decimal fixed point
               subtype S, which corresponds to the number of decimal
               digits that are representable in objects of the subtype.
               The value of this attribute is of the type
               <universal_integer>.  Its value is determined as follows:
               

8
                  * For a first subtype or a subtype defined by a
                    subtype_indication with a digits_constraint, the
                    digits is the value of the expression given after
                    the reserved word digits;

9
                  * For a subtype defined by a subtype_indication
                    without a digits_constraint, the digits of the
                    subtype is the same as that of the subtype denoted
                    by the subtype_mark in the subtype_indication.

10
                  * The digits of a base subtype is the largest integer
                    <D> such that the range -(10**<D>-1)*<delta> ..
                    +(10**<D>-1)*<delta> is included in the base range
                    of the type.

11
S'Scale
               S'Scale denotes the <scale> of the subtype S, defined as
               the value N such that S'Delta = 10.0**(-N). The scale
               indicates the position of the point relative to the
               rightmost significant digits of values of subtype S. The
               value of this attribute is of the type
               <universal_integer>.

12
S'Round
               S'Round denotes a function with the following
               specification:

13
                    function S'Round(<X> : <universal_real>)
                      return S'Base

14
               The function returns the value obtained by rounding X
               (away from 0, if X is midway between two values of the
               type of S).

     NOTES

15
     45  All subtypes of a fixed point type will have the same value for
     the Delta attribute, in the absence of delta_constraints (see *note
     J.3::).

16
     46  S'Scale is not always the same as S'Aft for a decimal subtype;
     for example, if S'Delta = 1.0 then S'Aft is 1 while S'Scale is 0.

17
     47  The predefined operations of a fixed point type include the
     assignment operation, qualification, the membership tests, and
     explicit conversion to and from other numeric types.  They also
     include the relational operators and the following predefined
     arithmetic operators: the binary and unary adding operators - and
     +, multiplying operators, and the unary operator abs.

18
     48  As for all types, objects of a fixed point type have Size and
     Address attributes (see *note 13.3::).  Other attributes of fixed
     point types are defined in *note A.5.4::.


File: arm2012.info,  Node: 3.6,  Next: 3.7,  Prev: 3.5,  Up: 3

3.6 Array Types
===============

1
An <array> object is a composite object consisting of components which
all have the same subtype.  The name for a component of an array uses
one or more index values belonging to specified discrete types.  The
value of an array object is a composite value consisting of the values
of the components.

                               _Syntax_

2
     array_type_definition ::=
        unconstrained_array_definition | constrained_array_definition

3
     unconstrained_array_definition ::=
        array(index_subtype_definition {, index_subtype_definition}) of 
     component_definition

4
     index_subtype_definition ::= subtype_mark range <>

5
     constrained_array_definition ::=
        array (discrete_subtype_definition {, 
     discrete_subtype_definition}) of component_definition

6
     discrete_subtype_definition ::= <discrete_>subtype_indication | 
     range

7/2
     component_definition ::=
        [aliased] subtype_indication
      | [aliased] access_definition

                        _Name Resolution Rules_

8
For a discrete_subtype_definition that is a range, the range shall
resolve to be of some specific discrete type; which discrete type shall
be determined without using any context other than the bounds of the
range itself (plus the preference for <root_integer> -- see *note
8.6::).

                           _Legality Rules_

9
Each index_subtype_definition or discrete_subtype_definition in an
array_type_definition defines an <index subtype>; its type (the <index
type>) shall be discrete.

10
The subtype defined by the subtype_indication of a component_definition
(the <component subtype>) shall be a definite subtype.

11/2
<This paragraph was deleted.>

                          _Static Semantics_

12
An array is characterized by the number of indices (the <dimensionality>
of the array), the type and position of each index, the lower and upper
bounds for each index, and the subtype of the components.  The order of
the indices is significant.

13
A one-dimensional array has a distinct component for each possible index
value.  A multidimensional array has a distinct component for each
possible sequence of index values that can be formed by selecting one
value for each index position (in the given order).  The possible values
for a given index are all the values between the lower and upper bounds,
inclusive; this range of values is called the <index range>.  The
<bounds> of an array are the bounds of its index ranges.  The <length>
of a dimension of an array is the number of values of the index range of
the dimension (zero for a null range).  The <length> of a
one-dimensional array is the length of its only dimension.

14
An array_type_definition defines an array type and its first subtype.
For each object of this array type, the number of indices, the type and
position of each index, and the subtype of the components are as in the
type definition; the values of the lower and upper bounds for each index
belong to the corresponding index subtype of its type, except for null
arrays (see *note 3.6.1::).

15
An unconstrained_array_definition defines an array type with an
unconstrained first subtype.  Each index_subtype_definition (*note 3.6:
S0053.) defines the corresponding index subtype to be the subtype
denoted by the subtype_mark (*note 3.2.2: S0028.).  The compound
delimiter <> (called a <box>) of an index_subtype_definition stands for
an undefined range (different objects of the type need not have the same
bounds).

16
A constrained_array_definition defines an array type with a constrained
first subtype.  Each discrete_subtype_definition (*note 3.6: S0055.)
defines the corresponding index subtype, as well as the corresponding
index range for the constrained first subtype.  The <constraint> of the
first subtype consists of the bounds of the index ranges.

17
The discrete subtype defined by a discrete_subtype_definition (*note
3.6: S0055.) is either that defined by the subtype_indication (*note
3.2.2: S0027.), or a subtype determined by the range as follows:

18
   * If the type of the range resolves to <root_integer>, then the
     discrete_subtype_definition defines a subtype of the predefined
     type Integer with bounds given by a conversion to Integer of the
     bounds of the range; 

19
   * Otherwise, the discrete_subtype_definition defines a subtype of the
     type of the range, with the bounds given by the range.

20
The component_definition of an array_type_definition defines the nominal
subtype of the components.  If the reserved word aliased appears in the
component_definition, then each component of the array is aliased (see
*note 3.10::).

                          _Dynamic Semantics_

21
The elaboration of an array_type_definition creates the array type and
its first subtype, and consists of the elaboration of any
discrete_subtype_definition (*note 3.6: S0055.)s and the
component_definition (*note 3.6: S0056.).

22/2
The elaboration of a discrete_subtype_definition that does not contain
any per-object expressions creates the discrete subtype, and consists of
the elaboration of the subtype_indication (*note 3.2.2: S0027.) or the
evaluation of the range.  The elaboration of a
discrete_subtype_definition that contains one or more per-object
expressions is defined in *note 3.8::.  The elaboration of a
component_definition (*note 3.6: S0056.) in an array_type_definition
(*note 3.6: S0051.) consists of the elaboration of the
subtype_indication (*note 3.2.2: S0027.) or access_definition.  The
elaboration of any discrete_subtype_definition (*note 3.6: S0055.)s and
the elaboration of the component_definition (*note 3.6: S0056.) are
performed in an arbitrary order.

                          _Static Semantics_

22.1/3
For an array type with a scalar component type, the following
language-defined representation aspect may be specified with an
aspect_specification (see *note 13.1.1::):

22.2/3
Default_Component_Value
               This aspect shall be specified by a static expression,
               and that expression shall be explicit, even if the aspect
               has a boolean type.  Default_Component_Value shall be
               specified only on a full_type_declaration.

22.3/3
If a derived type with no primitive subprograms inherits a boolean
Default_Component_Value aspect, the aspect may be specified to have any
value for the derived type.

                        _Name Resolution Rules_

22.4/3
The expected type for the expression specified for the
Default_Component_Value aspect is the component type of the array type
defined by the full_type_declaration on which it appears.

     NOTES

23
     49  All components of an array have the same subtype.  In
     particular, for an array of components that are one-dimensional
     arrays, this means that all components have the same bounds and
     hence the same length.

24
     50  Each elaboration of an array_type_definition creates a distinct
     array type.  A consequence of this is that each object whose
     object_declaration contains an array_type_definition is of its own
     unique type.

                              _Examples_

25
<Examples of type declarations with unconstrained array definitions: >

26
     type Vector     is array(Integer  range <>) of Real;
     type Matrix     is array(Integer  range <>, Integer range <>) of Real;
     type Bit_Vector is array(Integer  range <>) of Boolean;
     type Roman      is array(Positive range <>) of Roman_Digit; --< see *note 3.5.2::>

27
<Examples of type declarations with constrained array definitions: >

28
     type Table    is array(1 .. 10) of Integer;
     type Schedule is array(Day) of Boolean;
     type Line     is array(1 .. Max_Line_Size) of Character;

29
<Examples of object declarations with array type definitions: >

30/2
     Grid      : array(1 .. 80, 1 .. 100) of Boolean;
     Mix       : array(Color range Red .. Green) of Boolean;
     Msg_Table : constant array(Error_Code) of access constant String :=
           (Too_Big => new String'("Result too big"), Too_Small => ...);
     Page      : array(Positive range <>) of Line :=  --<  an array of arrays>
       (1 | 50  => Line'(1 | Line'Last => '+', others => '-'),  --< see *note 4.3.3::>
        2 .. 49 => Line'(1 | Line'Last => '|', others => ' '));
         --< Page is constrained by its initial value to (1..50)>

* Menu:

* 3.6.1 ::    Index Constraints and Discrete Ranges
* 3.6.2 ::    Operations of Array Types
* 3.6.3 ::    String Types


File: arm2012.info,  Node: 3.6.1,  Next: 3.6.2,  Up: 3.6

3.6.1 Index Constraints and Discrete Ranges
-------------------------------------------

1
An index_constraint determines the range of possible values for every
index of an array subtype, and thereby the corresponding array bounds.

                               _Syntax_

2
     index_constraint ::=  (discrete_range {, discrete_range})

3
     discrete_range ::= <discrete_>subtype_indication | range

                        _Name Resolution Rules_

4
The type of a discrete_range is the type of the subtype defined by the
subtype_indication, or the type of the range.  For an index_constraint,
each discrete_range shall resolve to be of the type of the corresponding
index.

                           _Legality Rules_

5
An index_constraint shall appear only in a subtype_indication whose
subtype_mark denotes either an unconstrained array subtype, or an
unconstrained access subtype whose designated subtype is an
unconstrained array subtype; in either case, the index_constraint shall
provide a discrete_range for each index of the array type.

                          _Static Semantics_

6
A discrete_range defines a range whose bounds are given by the range, or
by the range of the subtype defined by the subtype_indication.

                          _Dynamic Semantics_

7
An index_constraint is <compatible> with an unconstrained array subtype
if and only if the index range defined by each discrete_range is
compatible (see *note 3.5::) with the corresponding index subtype.  If
any of the discrete_ranges defines a null range, any array thus
constrained is a <null array>, having no components.  An array value
<satisfies> an index_constraint if at each index position the array
value and the index_constraint have the same index bounds.

8
The elaboration of an index_constraint consists of the evaluation of the
discrete_range(s), in an arbitrary order.  The evaluation of a
discrete_range consists of the elaboration of the subtype_indication or
the evaluation of the range.

     NOTES

9
     51  The elaboration of a subtype_indication consisting of a
     subtype_mark followed by an index_constraint checks the
     compatibility of the index_constraint with the subtype_mark (see
     *note 3.2.2::).

10
     52  Even if an array value does not satisfy the index constraint of
     an array subtype, Constraint_Error is not raised on conversion to
     the array subtype, so long as the length of each dimension of the
     array value and the array subtype match.  See *note 4.6::.

                              _Examples_

11
<Examples of array declarations including an index constraint: >

12
     Board     : Matrix(1 .. 8,  1 .. 8);  --<  see *note 3.6::>
     Rectangle : Matrix(1 .. 20, 1 .. 30);
     Inverse   : Matrix(1 .. N,  1 .. N);  --<  N need not be static >

13
     Filter    : Bit_Vector(0 .. 31);

14
<Example of array declaration with a constrained array subtype: >

15
     My_Schedule : Schedule;  --<  all arrays of type Schedule have the same bounds>

16
<Example of record type with a component that is an array: >

17
     type Var_Line(Length : Natural) is
        record
           Image : String(1 .. Length);
        end record;

18
     Null_Line : Var_Line(0);  --<  Null_Line.Image is a null array>


File: arm2012.info,  Node: 3.6.2,  Next: 3.6.3,  Prev: 3.6.1,  Up: 3.6

3.6.2 Operations of Array Types
-------------------------------

                           _Legality Rules_

1
The argument N used in the attribute_designators for the N-th dimension
of an array shall be a static expression of some integer type.  The
value of N shall be positive (nonzero) and no greater than the
dimensionality of the array.

                          _Static Semantics_

2/1
The following attributes are defined for a prefix A that is of an array
type (after any implicit dereference), or denotes a constrained array
subtype:

3
A'First
               A'First denotes the lower bound of the first index range;
               its type is the corresponding index type.

4
A'First(N)
               A'First(N) denotes the lower bound of the N-th index
               range; its type is the corresponding index type.

5
A'Last
               A'Last denotes the upper bound of the first index range;
               its type is the corresponding index type.

6
A'Last(N)
               A'Last(N) denotes the upper bound of the N-th index
               range; its type is the corresponding index type.

7
A'Range
               A'Range is equivalent to the range A'First ..  A'Last,
               except that the prefix A is only evaluated once.

8
A'Range(N)
               A'Range(N) is equivalent to the range A'First(N) ..
               A'Last(N), except that the prefix A is only evaluated
               once.

9
A'Length
               A'Length denotes the number of values of the first index
               range (zero for a null range); its type is
               <universal_integer>.

10
A'Length(N)
               A'Length(N) denotes the number of values of the N-th
               index range (zero for a null range); its type is
               <universal_integer>.

                        _Implementation Advice_

11/3
An implementation should normally represent multidimensional arrays in
row-major order, consistent with the notation used for multidimensional
array aggregates (see *note 4.3.3::).  However, if convention Fortran is
specified for a multidimensional array type, then column-major order
should be used instead (see *note B.5::, "*note B.5:: Interfacing with
Fortran").

     NOTES

12
     53  The attribute_references A'First and A'First(1) denote the same
     value.  A similar relation exists for the attribute_references
     A'Last, A'Range, and A'Length.  The following relation is satisfied
     (except for a null array) by the above attributes if the index type
     is an integer type:

13
             A'Length(N) = A'Last(N) - A'First(N) + 1

14
     54  An array type is limited if its component type is limited (see
     *note 7.5::).

15
     55  The predefined operations of an array type include the
     membership tests, qualification, and explicit conversion.  If the
     array type is not limited, they also include assignment and the
     predefined equality operators.  For a one-dimensional array type,
     they include the predefined concatenation operators (if nonlimited)
     and, if the component type is discrete, the predefined relational
     operators; if the component type is boolean, the predefined logical
     operators are also included.

16/2
     56  A component of an array can be named with an indexed_component.
     A value of an array type can be specified with an array_aggregate.
     For a one-dimensional array type, a slice of the array can be
     named; also, string literals are defined if the component type is a
     character type.

                              _Examples_

17
<Examples (using arrays declared in the examples of subclause *note
3.6.1::):>

18
     --  Filter'First      =   0   Filter'Last       =  31   Filter'Length =  32
     --  Rectangle'Last(1) =  20   Rectangle'Last(2) =  30


File: arm2012.info,  Node: 3.6.3,  Prev: 3.6.2,  Up: 3.6

3.6.3 String Types
------------------

                          _Static Semantics_

1
A one-dimensional array type whose component type is a character type is
called a <string> type.

2/2
There are three predefined string types, String, Wide_String, and
Wide_Wide_String, each indexed by values of the predefined subtype
Positive; these are declared in the visible part of package Standard:

3
     subtype Positive is Integer range 1 .. Integer'Last;

4/2
     type String is array(Positive range <>) of Character;
     type Wide_String is array(Positive range <>) of Wide_Character;
     type Wide_Wide_String is array(Positive range <>) of Wide_Wide_Character;


     NOTES

5
     57  String literals (see *note 2.6:: and *note 4.2::) are defined
     for all string types.  The concatenation operator & is predefined
     for string types, as for all nonlimited one-dimensional array
     types.  The ordering operators <, <=, >, and >= are predefined for
     string types, as for all one-dimensional discrete array types;
     these ordering operators correspond to lexicographic order (see
     *note 4.5.2::).

                              _Examples_

6
<Examples of string objects:>

7
     Stars      : String(1 .. 120) := (1 .. 120 => '*' );
     Question   : constant String  := "How many characters?";
        --< Question'First = 1, Question'Last = 20>
        --< Question'Length = 20 (the number of characters)>

8
     Ask_Twice  : String  := Question & Question;   --< constrained to (1..40)>
     Ninety_Six : constant Roman   := "XCVI";   --< see *note 3.5.2:: and *note 3.6::>


File: arm2012.info,  Node: 3.7,  Next: 3.8,  Prev: 3.6,  Up: 3

3.7 Discriminants
=================

1/2
A composite type (other than an array or interface type) can have
discriminants, which parameterize the type.  A known_discriminant_part
specifies the discriminants of a composite type.  A discriminant of an
object is a component of the object, and is either of a discrete type or
an access type.  An unknown_discriminant_part in the declaration of a
view of a type specifies that the discriminants of the type are unknown
for the given view; all subtypes of such a view are indefinite subtypes.

                               _Syntax_

2/2
     discriminant_part ::= unknown_discriminant_part | 
     known_discriminant_part

3
     unknown_discriminant_part ::= (<>)

4
     known_discriminant_part ::=
        (discriminant_specification {; discriminant_specification})

5/2
     discriminant_specification ::=
        defining_identifier_list : [null_exclusion] subtype_mark [:= 
     default_expression]
      | defining_identifier_list : access_definition [:= 
     default_expression]

6
     default_expression ::= expression

                        _Name Resolution Rules_

7
The expected type for the default_expression of a
discriminant_specification is that of the corresponding discriminant.

                           _Legality Rules_

8/2
A discriminant_part is only permitted in a declaration for a composite
type that is not an array or interface type (this includes generic
formal types).  A type declared with a known_discriminant_part is called
a <discriminated> type, as is a type that inherits (known)
discriminants.

9/2
The subtype of a discriminant may be defined by an optional
null_exclusion and a subtype_mark, in which case the subtype_mark shall
denote a discrete or access subtype, or it may be defined by an
access_definition.  A discriminant that is defined by an
access_definition is called an <access discriminant> and is of an
anonymous access type.

9.1/3
Default_expressions shall be provided either for all or for none of the
discriminants of a known_discriminant_part (*note 3.7: S0061.).  No
default_expression (*note 3.7: S0063.)s are permitted in a
known_discriminant_part (*note 3.7: S0061.) in a declaration of a
nonlimited tagged type or a generic formal type.

10/3
A discriminant_specification for an access discriminant may have a
default_expression only in the declaration for an immutably limited type
(see *note 7.5::).  In addition to the places where Legality Rules
normally apply (see *note 12.3::), this rule applies also in the private
part of an instance of a generic unit.

11/2
<This paragraph was deleted.>

12
For a type defined by a derived_type_definition, if a
known_discriminant_part is provided in its declaration, then:

13
   * The parent subtype shall be constrained;

14
   * If the parent type is not a tagged type, then each discriminant of
     the derived type shall be used in the constraint defining the
     parent subtype;

15
   * If a discriminant is used in the constraint defining the parent
     subtype, the subtype of the discriminant shall be statically
     compatible (see *note 4.9.1::) with the subtype of the
     corresponding parent discriminant.

16/3
<This paragraph was deleted.>

                          _Static Semantics_

17
A discriminant_specification declares a discriminant; the subtype_mark
denotes its subtype unless it is an access discriminant, in which case
the discriminant's subtype is the anonymous access-to-variable subtype
defined by the access_definition.

18
For a type defined by a derived_type_definition, each discriminant of
the parent type is either inherited, constrained to equal some new
discriminant of the derived type, or constrained to the value of an
expression.  When inherited or constrained to equal some new
discriminant, the parent discriminant and the discriminant of the
derived type are said to <correspond>.  Two discriminants also
correspond if there is some common discriminant to which they both
correspond.  A discriminant corresponds to itself as well.  If a
discriminant of a parent type is constrained to a specific value by a
derived_type_definition, then that discriminant is said to be
<specified> by that derived_type_definition.

19
A constraint that appears within the definition of a discriminated type
<depends on a discriminant> of the type if it names the discriminant as
a bound or discriminant value.  A component_definition depends on a
discriminant if its constraint depends on the discriminant, or on a
discriminant that corresponds to it.

20
A component <depends on a discriminant> if:

21
   * Its component_definition depends on the discriminant; or

22
   * It is declared in a variant_part that is governed by the
     discriminant; or

23
   * It is a component inherited as part of a derived_type_definition,
     and the constraint of the <parent_>subtype_indication depends on
     the discriminant; or

24
   * It is a subcomponent of a component that depends on the
     discriminant.

25
Each value of a discriminated type includes a value for each component
of the type that does not depend on a discriminant; this includes the
discriminants themselves.  The values of discriminants determine which
other component values are present in the value of the discriminated
type.

26
A type declared with a known_discriminant_part is said to have <known
discriminants>; its first subtype is unconstrained.  A type declared
with an unknown_discriminant_part is said to have <unknown
discriminants>.  A type declared without a discriminant_part has no
discriminants, unless it is a derived type; if derived, such a type has
the same sort of discriminants (known, unknown, or none) as its parent
(or ancestor) type.  A tagged class-wide type also has unknown
discriminants.  Any subtype of a type with unknown discriminants is an
unconstrained and indefinite subtype (see *note 3.2:: and *note 3.3::).

                          _Dynamic Semantics_

27/2
For an access discriminant, its access_definition is elaborated when the
value of the access discriminant is defined: by evaluation of its
default_expression, by elaboration of a discriminant_constraint, or by
an assignment that initializes the enclosing object.  

     NOTES

28
     58  If a discriminated type has default_expressions for its
     discriminants, then unconstrained variables of the type are
     permitted, and the values of the discriminants can be changed by an
     assignment to such a variable.  If defaults are not provided for
     the discriminants, then all variables of the type are constrained,
     either by explicit constraint or by their initial value; the values
     of the discriminants of such a variable cannot be changed after
     initialization.

29
     59  The default_expression for a discriminant of a type is
     evaluated when an object of an unconstrained subtype of the type is
     created.

30
     60  Assignment to a discriminant of an object (after its
     initialization) is not allowed, since the name of a discriminant is
     a constant; neither assignment_statements nor assignments inherent
     in passing as an in out or out parameter are allowed.  Note however
     that the value of a discriminant can be changed by assigning to the
     enclosing object, presuming it is an unconstrained variable.

31
     61  A discriminant that is of a named access type is not called an
     access discriminant; that term is used only for discriminants
     defined by an access_definition.

                              _Examples_

32
<Examples of discriminated types:>

33
     type Buffer(Size : Buffer_Size := 100)  is        --< see *note 3.5.4::>
        record
           Pos   : Buffer_Size := 0;
           Value : String(1 .. Size);
        end record;

34
     type Matrix_Rec(Rows, Columns : Integer) is
        record
           Mat : Matrix(1 .. Rows, 1 .. Columns);       --< see *note 3.6::>
        end record;

35
     type Square(Side : Integer) is new
        Matrix_Rec(Rows => Side, Columns => Side);

36
     type Double_Square(Number : Integer) is
        record
           Left  : Square(Number);
           Right : Square(Number);
        end record;

37/3
     task type Worker(Prio : System.Priority; Buf : access Buffer)
        with Priority => Prio is --< see *note D.1::>
        --< discriminants used to parameterize the task type (see *note 9.1::)>
        entry Fill;
        entry Drain;
     end Worker;

* Menu:

* 3.7.1 ::    Discriminant Constraints
* 3.7.2 ::    Operations of Discriminated Types


File: arm2012.info,  Node: 3.7.1,  Next: 3.7.2,  Up: 3.7

3.7.1 Discriminant Constraints
------------------------------

1
A discriminant_constraint specifies the values of the discriminants for
a given discriminated type.

                               _Syntax_

2
     discriminant_constraint ::=
        (discriminant_association {, discriminant_association})

3
     discriminant_association ::=
        [<discriminant_>selector_name {| <discriminant_>
     selector_name} =>] expression

4
     A discriminant_association is said to be <named> if it has one or
     more <discriminant_>selector_names; it is otherwise said to be
     <positional>.  In a discriminant_constraint, any positional
     associations shall precede any named associations.

                        _Name Resolution Rules_

5
Each selector_name of a named discriminant_association (*note 3.7.1:
S0065.) shall resolve to denote a discriminant of the subtype being
constrained; the discriminants so named are the <associated
discriminants> of the named association.  For a positional association,
the <associated discriminant> is the one whose
discriminant_specification (*note 3.7: S0062.) occurred in the
corresponding position in the known_discriminant_part (*note 3.7:
S0061.) that defined the discriminants of the subtype being constrained.

6
The expected type for the expression in a discriminant_association is
that of the associated discriminant(s).

                           _Legality Rules_

7/3
A discriminant_constraint is only allowed in a subtype_indication whose
subtype_mark denotes either an unconstrained discriminated subtype, or
an unconstrained access subtype whose designated subtype is an
unconstrained discriminated subtype.  However, in the case of an access
subtype, a discriminant_constraint (*note 3.7.1: S0064.) is legal only
if any dereference of a value of the access type is known to be
constrained (see *note 3.3::).  In addition to the places where Legality
Rules normally apply (see *note 12.3::), these rules apply also in the
private part of an instance of a generic unit.

8
A named discriminant_association with more than one selector_name is
allowed only if the named discriminants are all of the same type.  A
discriminant_constraint shall provide exactly one value for each
discriminant of the subtype being constrained.

9/3
<This paragraph was deleted.>

                          _Dynamic Semantics_

10
A discriminant_constraint is <compatible> with an unconstrained
discriminated subtype if each discriminant value belongs to the subtype
of the corresponding discriminant.

11
A composite value <satisfies> a discriminant constraint if and only if
each discriminant of the composite value has the value imposed by the
discriminant constraint.

12
For the elaboration of a discriminant_constraint, the expressions in the
discriminant_associations are evaluated in an arbitrary order and
converted to the type of the associated discriminant (which might raise
Constraint_Error -- see *note 4.6::); the expression of a named
association is evaluated (and converted) once for each associated
discriminant.  The result of each evaluation and conversion is the value
imposed by the constraint for the associated discriminant.

     NOTES

13
     62  The rules of the language ensure that a discriminant of an
     object always has a value, either from explicit or implicit
     initialization.

                              _Examples_

14/3
<Examples (using types declared above in subclause *note 3.7::):>

15
     Large   : Buffer(200);  --<  constrained, always 200 characters>
                             --<   (explicit discriminant value)>
     Message : Buffer;       --<  unconstrained, initially 100 characters>
                             --<   (default discriminant value)>
     Basis   : Square(5);    --<  constrained, always 5 by 5>
     Illegal : Square;       --<  illegal, a Square has to be constrained>


File: arm2012.info,  Node: 3.7.2,  Prev: 3.7.1,  Up: 3.7

3.7.2 Operations of Discriminated Types
---------------------------------------

1
If a discriminated type has default_expressions for its discriminants,
then unconstrained variables of the type are permitted, and the
discriminants of such a variable can be changed by assignment to the
variable.  For a formal parameter of such a type, an attribute is
provided to determine whether the corresponding actual parameter is
constrained or unconstrained.

                          _Static Semantics_

2
For a prefix A that is of a discriminated type (after any implicit
dereference), the following attribute is defined:

3/3
A'Constrained
               Yields the value True if A denotes a constant, a value, a
               tagged object, or a constrained variable, and False
               otherwise.

                         _Erroneous Execution_

4
The execution of a construct is erroneous if the construct has a
constituent that is a name denoting a subcomponent that depends on
discriminants, and the value of any of these discriminants is changed by
this execution between evaluating the name and the last use (within this
execution) of the subcomponent denoted by the name.


File: arm2012.info,  Node: 3.8,  Next: 3.9,  Prev: 3.7,  Up: 3

3.8 Record Types
================

1
A record object is a composite object consisting of named components.
The value of a record object is a composite value consisting of the
values of the components.  

                               _Syntax_

2
     record_type_definition ::= [[abstract] tagged] [limited] 
     record_definition

3
     record_definition ::=
         record
            component_list
         end record
       | null record

4
     component_list ::=
           component_item {component_item}
        | {component_item} variant_part
        |  null;

5/1
     component_item ::= component_declaration | aspect_clause

6/3
     component_declaration ::=
        defining_identifier_list : component_definition [:= 
     default_expression]
             [aspect_specification];

                        _Name Resolution Rules_

7
The expected type for the default_expression, if any, in a
component_declaration is the type of the component.

                           _Legality Rules_

8/2
<This paragraph was deleted.>

9/2
Each component_declaration declares a component of the record type.
Besides components declared by component_declarations, the components of
a record type include any components declared by
discriminant_specifications of the record type declaration.  The
identifiers of all components of a record type shall be distinct.

10
Within a type_declaration, a name that denotes a component, protected
subprogram, or entry of the type is allowed only in the following cases:

11/3
   * A name that denotes any component, protected subprogram, or entry
     is allowed within an aspect_specification, an operational item, or
     a representation item that occurs within the declaration of the
     composite type.

12/3
   * A name that denotes a noninherited discriminant is allowed within
     the declaration of the type, but not within the discriminant_part.
     If the discriminant is used to define the constraint of a
     component, the bounds of an entry family, or the constraint of the
     parent subtype in a derived_type_definition, then its name shall
     appear alone as a direct_name (not as part of a larger expression
     or expanded name).  A discriminant shall not be used to define the
     constraint of a scalar component.

13
If the name of the current instance of a type (see *note 8.6::) is used
to define the constraint of a component, then it shall appear as a
direct_name that is the prefix of an attribute_reference whose result is
of an access type, and the attribute_reference shall appear alone.

                          _Static Semantics_

13.1/3
If a record_type_definition includes the reserved word limited, the type
is called an <explicitly limited record> type.

14
The component_definition of a component_declaration defines the
(nominal) subtype of the component.  If the reserved word aliased
appears in the component_definition, then the component is aliased (see
*note 3.10::).

15
If the component_list of a record type is defined by the reserved word
null and there are no discriminants, then the record type has no
components and all records of the type are <null records>.  A
record_definition of null record is equivalent to record null; end
record.

                          _Dynamic Semantics_

16
The elaboration of a record_type_definition creates the record type and
its first subtype, and consists of the elaboration of the
record_definition.  The elaboration of a record_definition consists of
the elaboration of its component_list, if any.

17
The elaboration of a component_list consists of the elaboration of the
component_items and variant_part, if any, in the order in which they
appear.  The elaboration of a component_declaration consists of the
elaboration of the component_definition.

18/2
Within the definition of a composite type, if a component_definition or
discrete_subtype_definition (see *note 9.5.2::) includes a name that
denotes a discriminant of the type, or that is an attribute_reference
whose prefix denotes the current instance of the type, the expression
containing the name is called a <per-object expression>, and the
constraint or range being defined is called a <per-object constraint>.
For the elaboration of a component_definition of a component_declaration
or the discrete_subtype_definition (*note 3.6: S0055.) of an
entry_declaration (*note 9.5.2: S0218.) for an entry family (see *note
9.5.2::), if the component subtype is defined by an access_definition or
if the constraint or range of the subtype_indication or
discrete_subtype_definition (*note 3.6: S0055.) is not a per-object
constraint, then the access_definition, subtype_indication, or
discrete_subtype_definition (*note 3.6: S0055.) is elaborated.  On the
other hand, if the constraint or range is a per-object constraint, then
the elaboration consists of the evaluation of any included expression
that is not part of a per-object expression.  Each such expression is
evaluated once unless it is part of a named association in a
discriminant constraint, in which case it is evaluated once for each
associated discriminant.

18.1/1
When a per-object constraint is elaborated (as part of creating an
object), each per-object expression of the constraint is evaluated.  For
other expressions, the values determined during the elaboration of the
component_definition (*note 3.6: S0056.) or entry_declaration (*note
9.5.2: S0218.) are used.  Any checks associated with the enclosing
subtype_indication or discrete_subtype_definition are performed,
including the subtype compatibility check (see *note 3.2.2::), and the
associated subtype is created.

     NOTES

19
     63  A component_declaration with several identifiers is equivalent
     to a sequence of single component_declarations, as explained in
     *note 3.3.1::.

20
     64  The default_expression of a record component is only evaluated
     upon the creation of a default-initialized object of the record
     type (presuming the object has the component, if it is in a
     variant_part -- see *note 3.3.1::).

21
     65  The subtype defined by a component_definition (see *note 3.6::)
     has to be a definite subtype.

22
     66  If a record type does not have a variant_part, then the same
     components are present in all values of the type.

23
     67  A record type is limited if it has the reserved word limited in
     its definition, or if any of its components are limited (see *note
     7.5::).

24
     68  The predefined operations of a record type include membership
     tests, qualification, and explicit conversion.  If the record type
     is nonlimited, they also include assignment and the predefined
     equality operators.

25/2
     69  A component of a record can be named with a selected_component.
     A value of a record can be specified with a record_aggregate.

                              _Examples_

26
<Examples of record type declarations: >

27
     type Date is
        record
           Day   : Integer range 1 .. 31;
           Month : Month_Name;
           Year  : Integer range 0 .. 4000;
        end record;

28
     type Complex is
        record
           Re : Real := 0.0;
           Im : Real := 0.0;
        end record;

29
<Examples of record variables: >

30
     Tomorrow, Yesterday : Date;
     A, B, C : Complex;

31
     --< both components of A, B, and C are implicitly initialized to zero >

* Menu:

* 3.8.1 ::    Variant Parts and Discrete Choices


File: arm2012.info,  Node: 3.8.1,  Up: 3.8

3.8.1 Variant Parts and Discrete Choices
----------------------------------------

1
A record type with a variant_part specifies alternative lists of
components.  Each variant defines the components for the value or values
of the discriminant covered by its discrete_choice_list.

                               _Syntax_

2
     variant_part ::=
        case <discriminant_>direct_name is
            variant
           {variant}
        end case;

3
     variant ::=
        when discrete_choice_list =>
           component_list

4
     discrete_choice_list ::= discrete_choice {| discrete_choice}

5/3
     discrete_choice ::= choice_expression | <discrete_>
     subtype_indication | range | others

                        _Name Resolution Rules_

6
The <discriminant_>direct_name shall resolve to denote a discriminant
(called the <discriminant of the variant_part>) specified in the
known_discriminant_part of the full_type_declaration that contains the
variant_part.  The expected type for each discrete_choice in a variant
is the type of the discriminant of the variant_part.

                           _Legality Rules_

7
The discriminant of the variant_part shall be of a discrete type.

8/3
The choice_expressions, subtype_indications, and ranges given as
discrete_choices in a variant_part shall be static.  The discrete_choice
others shall appear alone in a discrete_choice_list, and such a
discrete_choice_list, if it appears, shall be the last one in the
enclosing construct.

9
A discrete_choice is defined to <cover a value> in the following cases:

10/3
   * A discrete_choice that is a choice_expression covers a value if the
     value equals the value of the choice_expression converted to the
     expected type.

10.1/4
   * A discrete_choice that is a subtype_indication covers all values
     (possibly none) that belong to the subtype and that satisfy the
     static predicates of the subtype (see *note 3.2.4::).

11/3
   * A discrete_choice that is a range covers all values (possibly none)
     that belong to the range.

12
   * The discrete_choice others covers all values of its expected type
     that are not covered by previous discrete_choice_lists of the same
     construct.

13
A discrete_choice_list covers a value if one of its discrete_choices
covers the value.

14
The possible values of the discriminant of a variant_part shall be
covered as follows:

15/4
   * If the discriminant is of a static constrained scalar subtype then,
     except within an instance of a generic unit, each non-others
     discrete_choice (*note 3.8.1: S0074.) shall cover only values in
     that subtype that satisfy its predicates, and each value of that
     subtype that satisfies its predicates shall be covered by some
     discrete_choice (*note 3.8.1: S0074.) (either explicitly or by
     others);

16/3
   * If the type of the discriminant is a descendant of a generic formal
     scalar type, then the variant_part shall have an others
     discrete_choice;

17
   * Otherwise, each value of the base range of the type of the
     discriminant shall be covered (either explicitly or by others).

18
Two distinct discrete_choices of a variant_part shall not cover the same
value.

                          _Static Semantics_

19
If the component_list of a variant is specified by null, the variant has
no components.

20
The discriminant of a variant_part is said to <govern> the variant_part
and its variants.  In addition, the discriminant of a derived type
governs a variant_part and its variants if it corresponds (see *note
3.7::) to the discriminant of the variant_part.

                          _Dynamic Semantics_

21
A record value contains the values of the components of a particular
variant only if the value of the discriminant governing the variant is
covered by the discrete_choice_list of the variant.  This rule applies
in turn to any further variant that is, itself, included in the
component_list of the given variant.

21.1/3
When an object of a discriminated type <T> is initialized by default,
Constraint_Error is raised if no discrete_choice_list of any variant of
a variant_part of <T> covers the value of the discriminant that governs
the variant_part.  When a variant_part appears in the component_list of
another variant <V>, this test is only applied if the value of the
discriminant governing <V> is covered by the discrete_choice_list of
<V>.

22
The elaboration of a variant_part consists of the elaboration of the
component_list of each variant in the order in which they appear.

                              _Examples_

23
<Example of record type with a variant part: >

24
     type Device is (Printer, Disk, Drum);
     type State  is (Open, Closed);

25
     type Peripheral(Unit : Device := Disk) is
        record
           Status : State;
           case Unit is
              when Printer =>
                 Line_Count : Integer range 1 .. Page_Size;
              when others =>
                 Cylinder   : Cylinder_Index;
                 Track      : Track_Number;
              end case;
           end record;

26
<Examples of record subtypes:>

27
     subtype Drum_Unit is Peripheral(Drum);
     subtype Disk_Unit is Peripheral(Disk);

28
<Examples of constrained record variables:>

29
     Writer   : Peripheral(Unit  => Printer);
     Archive  : Disk_Unit;


File: arm2012.info,  Node: 3.9,  Next: 3.10,  Prev: 3.8,  Up: 3

3.9 Tagged Types and Type Extensions
====================================

1
Tagged types and type extensions support object-oriented programming,
based on inheritance with extension and run-time polymorphism via
<dispatching operations>.  

                          _Static Semantics_

2/2
A record type or private type that has the reserved word tagged in its
declaration is called a <tagged> type.  In addition, an interface type
is a tagged type, as is a task or protected type derived from an
interface (see *note 3.9.4::).  When deriving from a tagged type, as for
any derived type, additional primitive subprograms may be defined, and
inherited primitive subprograms may be overridden.  The derived type is
called an <extension> of its ancestor types, or simply a <type
extension>.

2.1/2
Every type extension is also a tagged type, and is a <record extension>
or a <private extension> of some other tagged type, or a noninterface
synchronized tagged type (see *note 3.9.4::).  A record extension is
defined by a derived_type_definition with a record_extension_part (see
*note 3.9.1::), which may include the definition of additional
components.  A private extension, which is a partial view of a record
extension or of a synchronized tagged type, can be declared in the
visible part of a package (see *note 7.3::) or in a generic formal part
(see *note 12.5.1::).

3
An object of a tagged type has an associated (run-time) <tag> that
identifies the specific tagged type used to create the object
originally.  The tag of an operand of a class-wide tagged type <T>'Class
controls which subprogram body is to be executed when a primitive
subprogram of type <T> is applied to the operand (see *note 3.9.2::);
using a tag to control which body to execute is called <dispatching>.  

4/2
The tag of a specific tagged type identifies the full_type_declaration
of the type, and for a type extension, is sufficient to uniquely
identify the type among all descendants of the same ancestor.  If a
declaration for a tagged type occurs within a
generic_package_declaration, then the corresponding type declarations in
distinct instances of the generic package are associated with distinct
tags.  For a tagged type that is local to a generic package body and
with all of its ancestors (if any) also local to the generic body, the
language does not specify whether repeated instantiations of the generic
body result in distinct tags.

5
The following language-defined library package exists:

6/2
     package Ada.Tags is
         pragma Preelaborate(Tags);
         type Tag is private;
         pragma Preelaborable_Initialization(Tag);

6.1/2
         No_Tag : constant Tag;

7/2
         function Expanded_Name(T : Tag) return String;
         function Wide_Expanded_Name(T : Tag) return Wide_String;
         function Wide_Wide_Expanded_Name(T : Tag) return Wide_Wide_String;
         function External_Tag(T : Tag) return String;
         function Internal_Tag(External : String) return Tag;

7.1/2
         function Descendant_Tag(External : String; Ancestor : Tag) return Tag;
         function Is_Descendant_At_Same_Level(Descendant, Ancestor : Tag)
             return Boolean;

7.2/2
         function Parent_Tag (T : Tag) return Tag;

7.3/2
         type Tag_Array is array (Positive range <>) of Tag;

7.4/2
         function Interface_Ancestor_Tags (T : Tag) return Tag_Array;

7.5/3
         function Is_Abstract (T : Tag) return Boolean;

8
         Tag_Error : exception;

9
     private
        ... -- <not specified by the language>
     end Ada.Tags;

9.1/2
No_Tag is the default initial value of type Tag.

10/2
The function Wide_Wide_Expanded_Name returns the full expanded name of
the first subtype of the specific type identified by the tag, in upper
case, starting with a root library unit.  The result is implementation
defined if the type is declared within an unnamed block_statement.

10.1/2
The function Expanded_Name (respectively, Wide_Expanded_Name) returns
the same sequence of graphic characters as that defined for
Wide_Wide_Expanded_Name, if all the graphic characters are defined in
Character (respectively, Wide_Character); otherwise, the sequence of
characters is implementation defined, but no shorter than that returned
by Wide_Wide_Expanded_Name for the same value of the argument.

11
The function External_Tag returns a string to be used in an external
representation for the given tag.  The call External_Tag(S'Tag) is
equivalent to the attribute_reference S'External_Tag (see *note 13.3::).

11.1/2
The string returned by the functions Expanded_Name, Wide_Expanded_Name,
Wide_Wide_Expanded_Name, and External_Tag has lower bound 1.

12/2
The function Internal_Tag returns a tag that corresponds to the given
external tag, or raises Tag_Error if the given string is not the
external tag for any specific type of the partition.  Tag_Error is also
raised if the specific type identified is a library-level type whose tag
has not yet been created (see *note 13.14::).

12.1/3
The function Descendant_Tag returns the (internal) tag for the type that
corresponds to the given external tag and is both a descendant of the
type identified by the Ancestor tag and has the same accessibility level
as the identified ancestor.  Tag_Error is raised if External is not the
external tag for such a type.  Tag_Error is also raised if the specific
type identified is a library-level type whose tag has not yet been
created, or if the given external tag identifies more than one type that
has the appropriate Ancestor and accessibility level.

12.2/2
The function Is_Descendant_At_Same_Level returns True if the Descendant
tag identifies a type that is both a descendant of the type identified
by Ancestor and at the same accessibility level.  If not, it returns
False.

12.3/3
For the purposes of the dynamic semantics of functions Descendant_Tag
and Is_Descendant_At_Same_Level, a tagged type T2 is a <descendant> of a
type T1 if it is the same as T1, or if its parent type or one of its
progenitor types is a descendant of type T1 by this rule, even if at the
point of the declaration of T2, one of the derivations in the chain is
not visible.

12.4/4
The function Parent_Tag returns the tag of the parent type of the type
whose tag is T. If the type does not have a parent type (that is, it was
not defined by a derived_type_definition), then No_Tag is returned.

12.5/3
The function Interface_Ancestor_Tags returns an array containing the tag
of each interface ancestor type of the type whose tag is T, other than T
itself.  The lower bound of the returned array is 1, and the order of
the returned tags is unspecified.  Each tag appears in the result
exactly once.  If the type whose tag is T has no interface ancestors, a
null array is returned.

12.6/3
The function Is_Abstract returns True if the type whose tag is T is
abstract, and False otherwise.

13
For every subtype S of a tagged type <T> (specific or class-wide), the
following attributes are defined:

14
S'Class
               S'Class denotes a subtype of the class-wide type (called
               <T>'Class in this International Standard) for the class
               rooted at <T> (or if S already denotes a class-wide
               subtype, then S'Class is the same as S).

15
               S'Class is unconstrained.  However, if S is constrained,
               then the values of S'Class are only those that when
               converted to the type <T> belong to S.

16
S'Tag
               S'Tag denotes the tag of the type <T> (or if <T> is
               class-wide, the tag of the root type of the corresponding
               class).  The value of this attribute is of type Tag.

17
Given a prefix X that is of a class-wide tagged type (after any implicit
dereference), the following attribute is defined:

18
X'Tag
               X'Tag denotes the tag of X. The value of this attribute
               is of type Tag.

18.1/2
The following language-defined generic function exists:

18.2/3
     generic
         type T (<>) is abstract tagged limited private;
         type Parameters (<>) is limited private;
         with function Constructor (Params : not null access Parameters)
             return T is abstract;
     function Ada.Tags.Generic_Dispatching_Constructor
        (The_Tag : Tag;
         Params  : not null access Parameters) return T'Class
        with Convention => Intrinsic;
     pragma Preelaborate(Generic_Dispatching_Constructor);

18.3/2
Tags.Generic_Dispatching_Constructor provides a mechanism to create an
object of an appropriate type from just a tag value.  The function
Constructor is expected to create the object given a reference to an
object of type Parameters.

                          _Dynamic Semantics_

19
The tag associated with an object of a tagged type is determined as
follows:

20
   * The tag of a stand-alone object, a component, or an aggregate of a
     specific tagged type <T> identifies <T>.

21
   * The tag of an object created by an allocator for an access type
     with a specific designated tagged type <T>, identifies <T>.

22
   * The tag of an object of a class-wide tagged type is that of its
     initialization expression.

23
   * The tag of the result returned by a function whose result type is a
     specific tagged type <T> identifies <T>.

24/2
   * The tag of the result returned by a function with a class-wide
     result type is that of the return object.

25
The tag is preserved by type conversion and by parameter passing.  The
tag of a value is the tag of the associated object (see *note 6.2::).

25.1/3
Tag_Error is raised by a call of Descendant_Tag, Expanded_Name,
External_Tag, Interface_Ancestor_Tags, Is_Abstract,
Is_Descendant_At_Same_Level, Parent_Tag, Wide_Expanded_Name, or
Wide_Wide_Expanded_Name if any tag passed is No_Tag.

25.2/2
An instance of Tags.Generic_Dispatching_Constructor raises Tag_Error if
The_Tag does not represent a concrete descendant of T or if the
innermost master (see *note 7.6.1::) of this descendant is not also a
master of the instance.  Otherwise, it dispatches to the primitive
function denoted by the formal Constructor for the type identified by
The_Tag, passing Params, and returns the result.  Any exception raised
by the function is propagated.

                         _Erroneous Execution_

25.3/2
If an internal tag provided to an instance of
Tags.Generic_Dispatching_Constructor or to any subprogram declared in
package Tags identifies either a type that is not library-level and
whose tag has not been created (see *note 13.14::), or a type that does
not exist in the partition at the time of the call, then execution is
erroneous.

                     _Implementation Permissions_

26/2
The implementation of Internal_Tag and Descendant_Tag may raise
Tag_Error if no specific type corresponding to the string External
passed as a parameter exists in the partition at the time the function
is called, or if there is no such type whose innermost master is a
master of the point of the function call.

                        _Implementation Advice_

26.1/3
Internal_Tag should return the tag of a type, if one exists, whose
innermost master is a master of the point of the function call.

     NOTES

27
     70  A type declared with the reserved word tagged should normally
     be declared in a package_specification, so that new primitive
     subprograms can be declared for it.

28
     71  Once an object has been created, its tag never changes.

29
     72  Class-wide types are defined to have unknown discriminants (see
     *note 3.7::).  This means that objects of a class-wide type have to
     be explicitly initialized (whether created by an object_declaration
     or an allocator), and that aggregates have to be explicitly
     qualified with a specific type when their expected type is
     class-wide.

30/2
     73  The capability provided by Tags.Generic_Dispatching_Constructor
     is sometimes known as a <factory>.

                              _Examples_

31
<Examples of tagged record types:>

32
     type Point is tagged
       record
         X, Y : Real := 0.0;
       end record;

33
     type Expression is tagged null record;
       --< Components will be added by each extension>

* Menu:

* 3.9.1 ::    Type Extensions
* 3.9.2 ::    Dispatching Operations of Tagged Types
* 3.9.3 ::    Abstract Types and Subprograms
* 3.9.4 ::    Interface Types


File: arm2012.info,  Node: 3.9.1,  Next: 3.9.2,  Up: 3.9

3.9.1 Type Extensions
---------------------

1/2
Every type extension is a tagged type, and is a <record extension> or a
<private extension> of some other tagged type, or a noninterface
synchronized tagged type.

                               _Syntax_

2
     record_extension_part ::= with record_definition

                           _Legality Rules_

3/2
The parent type of a record extension shall not be a class-wide type nor
shall it be a synchronized tagged type (see *note 3.9.4::).  If the
parent type or any progenitor is nonlimited, then each of the components
of the record_extension_part shall be nonlimited.  In addition to the
places where Legality Rules normally apply (see *note 12.3::), these
rules apply also in the private part of an instance of a generic unit.

4/2
Within the body of a generic unit, or the body of any of its descendant
library units, a tagged type shall not be declared as a descendant of a
formal type declared within the formal part of the generic unit.

                          _Static Semantics_

4.1/2
A record extension is a <null extension> if its declaration has no
known_discriminant_part and its record_extension_part includes no
component_declarations.

                          _Dynamic Semantics_

5
The elaboration of a record_extension_part consists of the elaboration
of the record_definition.

     NOTES

6
     74  The term "type extension" refers to a type as a whole.  The
     term "extension part" refers to the piece of text that defines the
     additional components (if any) the type extension has relative to
     its specified ancestor type.

7/2
     75  When an extension is declared immediately within a body,
     primitive subprograms are inherited and are overridable, but new
     primitive subprograms cannot be added.

8
     76  A name that denotes a component (including a discriminant) of
     the parent type is not allowed within the record_extension_part.
     Similarly, a name that denotes a component defined within the
     record_extension_part is not allowed within the
     record_extension_part.  It is permissible to use a name that
     denotes a discriminant of the record extension, providing there is
     a new known_discriminant_part in the enclosing type declaration.
     (The full rule is given in *note 3.8::.)

9
     77  Each visible component of a record extension has to have a
     unique name, whether the component is (visibly) inherited from the
     parent type or declared in the record_extension_part (see *note
     8.3::).

                              _Examples_

10
<Examples of record extensions (of types defined above in *note 3.9::):>

11
     type Painted_Point is new Point with
       record
         Paint : Color := White;
       end record;
         --< Components X and Y are inherited>

12
     Origin : constant Painted_Point := (X | Y => 0.0, Paint => Black);

13
     type Literal is new Expression with
       record                 --< a leaf in an Expression tree>
         Value : Real;
       end record;

14
     type Expr_Ptr is access all Expression'Class;
                                    --< see *note 3.10::>

15
     type Binary_Operation is new Expression with
       record                 --< an internal node in an Expression tree>
         Left, Right : Expr_Ptr;
       end record;

16
     type Addition is new Binary_Operation with null record;
     type Subtraction is new Binary_Operation with null record;
       --< No additional components needed for these extensions>

17
     Tree : Expr_Ptr :=         --< A tree representation of "5.0 + (13.0-7.0)">
        new Addition'(
           Left  => new Literal'(Value => 5.0),
           Right => new Subtraction'(
              Left  => new Literal'(Value => 13.0),
              Right => new Literal'(Value => 7.0)));


File: arm2012.info,  Node: 3.9.2,  Next: 3.9.3,  Prev: 3.9.1,  Up: 3.9

3.9.2 Dispatching Operations of Tagged Types
--------------------------------------------

1/2
The primitive subprograms of a tagged type, the subprograms declared by
formal_abstract_subprogram_declaration (*note 12.6: S0298.)s, and the
stream attributes of a specific tagged type that are available (see
*note 13.13.2::) at the end of the declaration list where the type is
declared are called <dispatching operations>.  A dispatching operation
can be called using a statically determined <controlling> tag, in which
case the body to be executed is determined at compile time.
Alternatively, the controlling tag can be dynamically determined, in
which case the call <dispatches> to a body that is determined at run
time; such a call is termed a <dispatching call>.  As explained below,
the properties of the operands and the context of a particular call on a
dispatching operation determine how the controlling tag is determined,
and hence whether or not the call is a dispatching call.  Run-time
polymorphism is achieved when a dispatching operation is called by a
dispatching call.  

                          _Static Semantics_

2/3
A <call on a dispatching operation> is a call whose name or prefix
denotes the declaration of a dispatching operation.  A <controlling
operand> in a call on a dispatching operation of a tagged type <T> is
one whose corresponding formal parameter is of type <T> or is of an
anonymous access type with designated type <T>; the corresponding formal
parameter is called a <controlling formal parameter>.  If the
controlling formal parameter is an access parameter, the controlling
operand is the object designated by the actual parameter, rather than
the actual parameter itself.  If the call is to a (primitive) function
with result type <T> (a <function with a controlling result>), then the
call has a <controlling result> -- the context of the call can control
the dispatching.  Similarly, if the call is to a function with an access
result type designating <T> (a <function with a controlling access
result>), then the call has a <controlling access result>, and the
context can similarly control dispatching.

3
A name or expression of a tagged type is either <statically> tagged,
<dynamically> tagged, or <tag indeterminate>, according to whether, when
used as a controlling operand, the tag that controls dispatching is
determined statically by the operand's (specific) type, dynamically by
its tag at run time, or from context.  A qualified_expression or
parenthesized expression is statically, dynamically, or indeterminately
tagged according to its operand.  For other kinds of names and
expressions, this is determined as follows:

4/2
   * The name or expression is <statically tagged> if it is of a
     specific tagged type and, if it is a call with a controlling result
     or controlling access result, it has at least one statically tagged
     controlling operand;

5/2
   * The name or expression is <dynamically tagged> if it is of a
     class-wide type, or it is a call with a controlling result or
     controlling access result and at least one dynamically tagged
     controlling operand;

6/2
   * The name or expression is <tag indeterminate> if it is a call with
     a controlling result or controlling access result, all of whose
     controlling operands (if any) are tag indeterminate.

7/1
A type_conversion is statically or dynamically tagged according to
whether the type determined by the subtype_mark is specific or
class-wide, respectively.  For an object that is designated by an
expression whose expected type is an anonymous access-to-specific tagged
type, the object is dynamically tagged if the expression, ignoring
enclosing parentheses, is of the form X'Access, where X is of a
class-wide type, or is of the form new T'(...), where T denotes a
class-wide subtype.  Otherwise, the object is statically or dynamically
tagged according to whether the designated type of the type of the
expression is specific or class-wide, respectively.

                           _Legality Rules_

8
A call on a dispatching operation shall not have both dynamically tagged
and statically tagged controlling operands.

9/1
If the expected type for an expression or name is some specific tagged
type, then the expression or name shall not be dynamically tagged unless
it is a controlling operand in a call on a dispatching operation.
Similarly, if the expected type for an expression is an anonymous
access-to-specific tagged type, then the object designated by the
expression shall not be dynamically tagged unless it is a controlling
operand in a call on a dispatching operation.

10/2
In the declaration of a dispatching operation of a tagged type,
everywhere a subtype of the tagged type appears as a subtype of the
profile (see *note 6.1::), it shall statically match the first subtype
of the tagged type.  If the dispatching operation overrides an inherited
subprogram, it shall be subtype conformant with the inherited
subprogram.  The convention of an inherited dispatching operation is the
convention of the corresponding primitive operation of the parent or
progenitor type.  The default convention of a dispatching operation that
overrides an inherited primitive operation is the convention of the
inherited operation; if the operation overrides multiple inherited
operations, then they shall all have the same convention.  An explicitly
declared dispatching operation shall not be of convention Intrinsic.

11/2
The default_expression for a controlling formal parameter of a
dispatching operation shall be tag indeterminate.

11.1/2
If a dispatching operation is defined by a
subprogram_renaming_declaration or the instantiation of a generic
subprogram, any access parameter of the renamed subprogram or the
generic subprogram that corresponds to a controlling access parameter of
the dispatching operation, shall have a subtype that excludes null.

12
A given subprogram shall not be a dispatching operation of two or more
distinct tagged types.

13
The explicit declaration of a primitive subprogram of a tagged type
shall occur before the type is frozen (see *note 13.14::).  For example,
new dispatching operations cannot be added after objects or values of
the type exist, nor after deriving a record extension from it, nor after
a body.

                          _Dynamic Semantics_

14
For the execution of a call on a dispatching operation of a type <T>,
the <controlling tag value> determines which subprogram body is
executed.  The controlling tag value is defined as follows:

15
   * If one or more controlling operands are statically tagged, then the
     controlling tag value is <statically determined> to be the tag of
     <T>.

16
   * If one or more controlling operands are dynamically tagged, then
     the controlling tag value is not statically determined, but is
     rather determined by the tags of the controlling operands.  If
     there is more than one dynamically tagged controlling operand, a
     check is made that they all have the same tag.  If this check
     fails, Constraint_Error is raised unless the call is a
     function_call whose name denotes the declaration of an equality
     operator (predefined or user defined) that returns Boolean, in
     which case the result of the call is defined to indicate
     inequality, and no subprogram_body is executed.  This check is
     performed prior to evaluating any tag-indeterminate controlling
     operands.

17/2
   * If all of the controlling operands (if any) are tag-indeterminate,
     then:

18/2
             * If the call has a controlling result or controlling
               access result and is itself, or designates, a (possibly
               parenthesized or qualified) controlling operand of an
               enclosing call on a dispatching operation of a descendant
               of type <T>, then its controlling tag value is determined
               by the controlling tag value of this enclosing call;

18.1/2
             * If the call has a controlling result or controlling
               access result and (possibly parenthesized, qualified, or
               dereferenced) is the expression of an
               assignment_statement whose target is of a class-wide
               type, then its controlling tag value is determined by the
               target;

19
             * Otherwise, the controlling tag value is statically
               determined to be the tag of type <T>.

20/3
For the execution of a call on a dispatching operation, the action
performed is determined by the properties of the corresponding
dispatching operation of the specific type identified by the controlling
tag value:

20.1/3
   * if the corresponding operation is explicitly declared for this
     type, even if the declaration occurs in a private part, then the
     action comprises an invocation of the explicit body for the
     operation;

20.2/3
   * if the corresponding operation is implicitly declared for this type
     and is implemented by an entry or protected subprogram (see *note
     9.1:: and *note 9.4::), then the action comprises a call on this
     entry or protected subprogram, with the target object being given
     by the first actual parameter of the call, and the actual
     parameters of the entry or protected subprogram being given by the
     remaining actual parameters of the call, if any;

20.3/3
   * if the corresponding operation is a predefined operator then the
     action comprises an invocation of that operator;

20.4/3
   * otherwise, the action is the same as the action for the
     corresponding operation of the parent type or progenitor type from
     which the operation was inherited except that additional invariant
     checks (see *note 7.3.2::) and class-wide postcondition checks (see
     *note 6.1.1::) may apply.  If there is more than one such
     corresponding operation, the action is that for the operation that
     is not a null procedure, if any; otherwise, the action is that of
     an arbitrary one of the operations.

     NOTES

21
     78  The body to be executed for a call on a dispatching operation
     is determined by the tag; it does not matter whether that tag is
     determined statically or dynamically, and it does not matter
     whether the subprogram's declaration is visible at the place of the
     call.

22/2
     79  This subclause covers calls on dispatching subprograms of a
     tagged type.  Rules for tagged type membership tests are described
     in *note 4.5.2::.  Controlling tag determination for an
     assignment_statement is described in *note 5.2::.

23
     80  A dispatching call can dispatch to a body whose declaration is
     not visible at the place of the call.

24
     81  A call through an access-to-subprogram value is never a
     dispatching call, even if the access value designates a dispatching
     operation.  Similarly a call whose prefix denotes a
     subprogram_renaming_declaration cannot be a dispatching call unless
     the renaming itself is the declaration of a primitive subprogram.


File: arm2012.info,  Node: 3.9.3,  Next: 3.9.4,  Prev: 3.9.2,  Up: 3.9

3.9.3 Abstract Types and Subprograms
------------------------------------

1/2
An <abstract type> is a tagged type intended for use as an ancestor of
other types, but which is not allowed to have objects of its own.  An
<abstract subprogram> is a subprogram that has no body, but is intended
to be overridden at some point when inherited.  Because objects of an
abstract type cannot be created, a dispatching call to an abstract
subprogram always dispatches to some overriding body.

                               _Syntax_

1.1/3
     abstract_subprogram_declaration ::=
         [overriding_indicator]
         subprogram_specification is abstract
             [aspect_specification];

                          _Static Semantics_

1.2/2
Interface types (see *note 3.9.4::) are abstract types.  In addition, a
tagged type that has the reserved word abstract in its declaration is an
abstract type.  The class-wide type (see *note 3.4.1::) rooted at an
abstract type is not itself an abstract type.

                           _Legality Rules_

2/2
Only a tagged type shall have the reserved word abstract in its
declaration.

3/2
A subprogram declared by an abstract_subprogram_declaration (*note
3.9.3: S0076.) or a formal_abstract_subprogram_declaration (*note 12.6:
S0298.) (see *note 12.6::) is an <abstract subprogram>.  If it is a
primitive subprogram of a tagged type, then the tagged type shall be
abstract.

4/3
If a type has an implicitly declared primitive subprogram that is
inherited or is a predefined operator, and the corresponding primitive
subprogram of the parent or ancestor type is abstract or is a function
with a controlling access result, or if a type other than a nonabstract
null extension inherits a function with a controlling result, then:

5/2
   * If the type is abstract or untagged, the implicitly declared
     subprogram is <abstract>.

6/4
   * Otherwise, the subprogram shall be overridden with a nonabstract
     subprogram or, in the case of a private extension inheriting a
     nonabstract function with a controlling result, have a full type
     that is a null extension; for a type declared in the visible part
     of a package, the overriding may be either in the visible or the
     private part.  Such a subprogram is said to <require overriding>.
     However, if the type is a generic formal type, the subprogram need
     not be overridden for the formal type itself; a nonabstract version
     will necessarily be provided by the actual type.

7
A call on an abstract subprogram shall be a dispatching call;
nondispatching calls to an abstract subprogram are not allowed.

8/3
The type of an aggregate, or of an object created by an
object_declaration or an allocator, or a generic formal object of mode
in, shall not be abstract.  The type of the target of an assignment
operation (see *note 5.2::) shall not be abstract.  The type of a
component shall not be abstract.  If the result type of a function is
abstract, then the function shall be abstract.  If a function has an
access result type designating an abstract type, then the function shall
be abstract.  The type denoted by a return_subtype_indication (see *note
6.5::) shall not be abstract.  A generic function shall not have an
abstract result type or an access result type designating an abstract
type.

9
If a partial view is not abstract, the corresponding full view shall not
be abstract.  If a generic formal type is abstract, then for each
primitive subprogram of the formal that is not abstract, the
corresponding primitive subprogram of the actual shall not be abstract.

10/3
For an abstract type declared in a visible part, an abstract primitive
subprogram shall not be declared in the private part, unless it is
overriding an abstract subprogram implicitly declared in the visible
part.  For a tagged type declared in a visible part, a primitive
function with a controlling result or a controlling access result shall
not be declared in the private part, unless it is overriding a function
implicitly declared in the visible part.

11/2
A generic actual subprogram shall not be an abstract subprogram unless
the generic formal subprogram is declared by a
formal_abstract_subprogram_declaration.  The prefix of an
attribute_reference for the Access, Unchecked_Access, or Address
attributes shall not denote an abstract subprogram.

                          _Dynamic Semantics_

11.1/2
The elaboration of an abstract_subprogram_declaration has no effect.

     NOTES

12
     82  Abstractness is not inherited; to declare an abstract type, the
     reserved word abstract has to be used in the declaration of the
     type extension.

13
     83  A class-wide type is never abstract.  Even if a class is rooted
     at an abstract type, the class-wide type for the class is not
     abstract, and an object of the class-wide type can be created; the
     tag of such an object will identify some nonabstract type in the
     class.

                              _Examples_

14
<Example of an abstract type representing a set of natural numbers:>

15
     package Sets is
         subtype Element_Type is Natural;
         type Set is abstract tagged null record;
         function Empty return Set is abstract;
         function Union(Left, Right : Set) return Set is abstract;
         function Intersection(Left, Right : Set) return Set is abstract;
         function Unit_Set(Element : Element_Type) return Set is abstract;
         procedure Take(Element : out Element_Type;
                        From : in out Set) is abstract;
     end Sets;

     NOTES

16
     84  <Notes on the example:> Given the above abstract type, one
     could then derive various (nonabstract) extensions of the type,
     representing alternative implementations of a set.  One might use a
     bit vector, but impose an upper bound on the largest element
     representable, while another might use a hash table, trading off
     space for flexibility.


File: arm2012.info,  Node: 3.9.4,  Prev: 3.9.3,  Up: 3.9

3.9.4 Interface Types
---------------------

1/2
An interface type is an abstract tagged type that provides a restricted
form of multiple inheritance.  A tagged type, task type, or protected
type may have one or more interface types as ancestors.

                               _Syntax_

2/2
     interface_type_definition ::=
         [limited | task | protected | synchronized] interface [and 
     interface_list]

3/2
     interface_list ::= <interface_>subtype_mark {and <interface_>
     subtype_mark}

                          _Static Semantics_

4/2
An interface type (also called an <interface>) is a specific abstract
tagged type that is defined by an interface_type_definition.

5/2
An interface with the reserved word limited, task, protected, or
synchronized in its definition is termed, respectively, a <limited
interface>, a <task interface>, a <protected interface>, or a
<synchronized interface>.  In addition, all task and protected
interfaces are synchronized interfaces, and all synchronized interfaces
are limited interfaces.

6/2
A task or protected type derived from an interface is a tagged type.
Such a tagged type is called a <synchronized> tagged type, as are
synchronized interfaces and private extensions whose declaration
includes the reserved word synchronized.

7/2
A task interface is an abstract task type.  A protected interface is an
abstract protected type.

8/2
An interface type has no components.

9/2
An <interface_>subtype_mark in an interface_list names a <progenitor
subtype>; its type is the <progenitor type>.  An interface type inherits
user-defined primitive subprograms from each progenitor type in the same
way that a derived type inherits user-defined primitive subprograms from
its progenitor types (see *note 3.4::).

                           _Legality Rules_

10/2
All user-defined primitive subprograms of an interface type shall be
abstract subprograms or null procedures.

11/2
The type of a subtype named in an interface_list shall be an interface
type.

12/2
A type derived from a nonlimited interface shall be nonlimited.

13/2
An interface derived from a task interface shall include the reserved
word task in its definition; any other type derived from a task
interface shall be a private extension or a task type declared by a task
declaration (see *note 9.1::).

14/2
An interface derived from a protected interface shall include the
reserved word protected in its definition; any other type derived from a
protected interface shall be a private extension or a protected type
declared by a protected declaration (see *note 9.4::).

15/2
An interface derived from a synchronized interface shall include one of
the reserved words task, protected, or synchronized in its definition;
any other type derived from a synchronized interface shall be a private
extension, a task type declared by a task declaration, or a protected
type declared by a protected declaration.

16/2
No type shall be derived from both a task interface and a protected
interface.

17/2
In addition to the places where Legality Rules normally apply (see *note
12.3::), these rules apply also in the private part of an instance of a
generic unit.

                          _Dynamic Semantics_

18/3
The elaboration of an interface_type_definition creates the interface
type and its first subtype.

     NOTES

19/2
     85  Nonlimited interface types have predefined nonabstract equality
     operators.  These may be overridden with user-defined abstract
     equality operators.  Such operators will then require an explicit
     overriding for any nonabstract descendant of the interface.

                              _Examples_

20/2
<Example of a limited interface and a synchronized interface extending
it:>

21/2
     type Queue is limited interface;
     procedure Append(Q : in out Queue; Person : in Person_Name) is abstract;
     procedure Remove_First(Q      : in out Queue;
                            Person : out Person_Name) is abstract;
     function Cur_Count(Q : in Queue) return Natural is abstract;
     function Max_Count(Q : in Queue) return Natural is abstract;
     -- <See *note 3.10.1:: for Person_Name.>

22/3
     Queue_Error : exception;
     --< Append raises Queue_Error if Cur_Count(Q) = Max_Count(Q)>
     --< Remove_First raises Queue_Error if Cur_Count(Q) = 0>

23/2
     type Synchronized_Queue is synchronized interface and Queue; --< see *note 9.11::>
     procedure Append_Wait(Q      : in out Synchronized_Queue;
                           Person : in Person_Name) is abstract;
     procedure Remove_First_Wait(Q      : in out Synchronized_Queue;
                                 Person : out Person_Name) is abstract;

24/2
     ...

25/2
     procedure Transfer(From   : in out Queue'Class;
                        To     : in out Queue'Class;
                        Number : in     Natural := 1) is
        Person : Person_Name;
     begin
        for I in 1..Number loop
           Remove_First(From, Person);
           Append(To, Person);
        end loop;
     end Transfer;

26/2
This defines a Queue interface defining a queue of people.  (A similar
design could be created to define any kind of queue simply by replacing
Person_Name by an appropriate type.)  The Queue interface has four
dispatching operations, Append, Remove_First, Cur_Count, and Max_Count.
The body of a class-wide operation, Transfer is also shown.  Every
nonabstract extension of Queue must provide implementations for at least
its four dispatching operations, as they are abstract.  Any object of a
type derived from Queue may be passed to Transfer as either the From or
the To operand.  The two operands need not be of the same type in any
given call.

27/2
The Synchronized_Queue interface inherits the four dispatching
operations from Queue and adds two additional dispatching operations,
which wait if necessary rather than raising the Queue_Error exception.
This synchronized interface may only be implemented by a task or
protected type, and as such ensures safe concurrent access.

28/2
<Example use of the interface:>

29/3
     type Fast_Food_Queue is new Queue with record ...;
     procedure Append(Q : in out Fast_Food_Queue; Person : in Person_Name);
     procedure Remove_First(Q : in out Fast_Food_Queue; Person : out Person_Name);
     function Cur_Count(Q : in Fast_Food_Queue) return Natural;
     function Max_Count(Q : in Fast_Food_Queue) return Natural;

30/2
     ...

31/2
     Cashier, Counter : Fast_Food_Queue;

32/2
     ...
     -- <Add George (see *note 3.10.1::) to the cashier's queue:>
     Append (Cashier, George);
     -- <After payment, move George to the sandwich counter queue:>
     Transfer (Cashier, Counter);
     ...

33/2
An interface such as Queue can be used directly as the parent of a new
type (as shown here), or can be used as a progenitor when a type is
derived.  In either case, the primitive operations of the interface are
inherited.  For Queue, the implementation of the four inherited routines
must be provided.  Inside the call of Transfer, calls will dispatch to
the implementations of Append and Remove_First for type Fast_Food_Queue.

34/2
<Example of a task interface:>

35/2
     type Serial_Device is task interface;  --< see *note 9.1::>
     procedure Read (Dev : in Serial_Device; C : out Character) is abstract;
     procedure Write(Dev : in Serial_Device; C : in  Character) is abstract;

36/2
The Serial_Device interface has two dispatching operations which are
intended to be implemented by task entries (see 9.1).


File: arm2012.info,  Node: 3.10,  Next: 3.11,  Prev: 3.9,  Up: 3

3.10 Access Types
=================

1
A value of an access type (an <access value>) provides indirect access
to the object or subprogram it <designates>.  Depending on its type, an
access value can designate either subprograms, objects created by
allocators (see *note 4.8::), or more generally <aliased> objects of an
appropriate type.  

                               _Syntax_

2/2
     access_type_definition ::=
         [null_exclusion] access_to_object_definition
       | [null_exclusion] access_to_subprogram_definition

3
     access_to_object_definition ::=
         access [general_access_modifier] subtype_indication

4
     general_access_modifier ::= all | constant

5
     access_to_subprogram_definition ::=
         access [protected] procedure parameter_profile
       | access [protected] function  parameter_and_result_profile

5.1/2
     null_exclusion ::= not null

6/2
     access_definition ::=
         [null_exclusion] access [constant] subtype_mark
       | [null_exclusion] access [protected] procedure parameter_profile
       | [null_exclusion] access [protected] function 
     parameter_and_result_profile

                          _Static Semantics_

7/1
There are two kinds of access types, <access-to-object> types, whose
values designate objects, and <access-to-subprogram> types, whose values
designate subprograms.  Associated with an access-to-object type is a
<storage pool>; several access types may share the same storage pool.
All descendants of an access type share the same storage pool.  A
storage pool is an area of storage used to hold dynamically allocated
objects (called <pool elements>) created by allocators; storage pools
are described further in *note 13.11::, "*note 13.11:: Storage
Management".

8
Access-to-object types are further subdivided into <pool-specific>
access types, whose values can designate only the elements of their
associated storage pool, and <general> access types, whose values can
designate the elements of any storage pool, as well as aliased objects
created by declarations rather than allocators, and aliased
subcomponents of other objects.

9/3
A view of an object is defined to be <aliased> if it is defined by an
object_declaration (*note 3.3.1: S0032.), component_definition (*note
3.6: S0056.), parameter_specification (*note 6.1: S0175.), or
extended_return_object_declaration with the reserved word aliased, or by
a renaming of an aliased view.  In addition, the dereference of an
access-to-object value denotes an aliased view, as does a view
conversion (see *note 4.6::) of an aliased view.  The current instance
of an immutably limited type (see *note 7.5::) is defined to be aliased.
Finally, a formal parameter or generic formal object of a tagged type is
defined to be aliased.  Aliased views are the ones that can be
designated by an access value.

10
An access_to_object_definition defines an access-to-object type and its
first subtype; the subtype_indication (*note 3.2.2: S0027.) defines the
<designated subtype> of the access type.  If a general_access_modifier
(*note 3.10: S0081.) appears, then the access type is a general access
type.  If the modifier is the reserved word constant, then the type is
an <access-to-constant type>; a designated object cannot be updated
through a value of such a type.  If the modifier is the reserved word
all, then the type is an <access-to-variable type>; a designated object
can be both read and updated through a value of such a type.  If no
general_access_modifier (*note 3.10: S0081.) appears in the
access_to_object_definition (*note 3.10: S0080.), the access type is a
pool-specific access-to-variable type.

11
An access_to_subprogram_definition defines an access-to-subprogram type
and its first subtype; the parameter_profile or
parameter_and_result_profile defines the <designated profile> of the
access type.  There is a <calling convention> associated with the
designated profile; only subprograms with this calling convention can be
designated by values of the access type.  By default, the calling
convention is "<protected>" if the reserved word protected appears, and
"Ada" otherwise.  See *note Annex B:: for how to override this default.

12/3
An access_definition defines an anonymous general access type or an
anonymous access-to-subprogram type.  For a general access type, the
subtype_mark denotes its <designated subtype>; if the
general_access_modifier (*note 3.10: S0081.) constant appears, the type
is an access-to-constant type; otherwise, it is an access-to-variable
type.  For an access-to-subprogram type, the parameter_profile (*note
6.1: S0172.) or parameter_and_result_profile (*note 6.1: S0173.) denotes
its <designated profile>.

13/2
For each access type, there is a null access value designating no entity
at all, which can be obtained by (implicitly) converting the literal
null to the access type.  The null value of an access type is the
default initial value of the type.  Nonnull values of an
access-to-object type are obtained by evaluating an allocator, which
returns an access value designating a newly created object (see *note
3.10.2::), or in the case of a general access-to-object type, evaluating
an attribute_reference for the Access or Unchecked_Access attribute of
an aliased view of an object.  Nonnull values of an access-to-subprogram
type are obtained by evaluating an attribute_reference for the Access
attribute of a nonintrinsic subprogram.

13.1/2
A null_exclusion in a construct specifies that the null value does not
belong to the access subtype defined by the construct, that is, the
access subtype <excludes null>.  In addition, the anonymous access
subtype defined by the access_definition for a controlling access
parameter (see *note 3.9.2::) excludes null.  Finally, for a
subtype_indication without a null_exclusion, the subtype denoted by the
subtype_indication excludes null if and only if the subtype denoted by
the subtype_mark in the subtype_indication excludes null.

14/3
All subtypes of an access-to-subprogram type are constrained.  The first
subtype of a type defined by an access_definition or an
access_to_object_definition is unconstrained if the designated subtype
is an unconstrained array or discriminated subtype; otherwise, it is
constrained.

                           _Legality Rules_

14.1/2
If a subtype_indication (*note 3.2.2: S0027.),
discriminant_specification (*note 3.7: S0062.), parameter_specification
(*note 6.1: S0175.), parameter_and_result_profile (*note 6.1: S0173.),
object_renaming_declaration (*note 8.5.1: S0200.), or
formal_object_declaration (*note 12.4: S0280.) has a null_exclusion
(*note 3.10: S0083.), the subtype_mark (*note 3.2.2: S0028.) in that
construct shall denote an access subtype that does not exclude null.

                          _Dynamic Semantics_

15/2
A composite_constraint is <compatible> with an unconstrained access
subtype if it is compatible with the designated subtype.  A
null_exclusion is compatible with any access subtype that does not
exclude null.  An access value <satisfies> a composite_constraint of an
access subtype if it equals the null value of its type or if it
designates an object whose value satisfies the constraint.  An access
value satisfies an exclusion of the null value if it does not equal the
null value of its type.

16
The elaboration of an access_type_definition creates the access type and
its first subtype.  For an access-to-object type, this elaboration
includes the elaboration of the subtype_indication, which creates the
designated subtype.

17/2
The elaboration of an access_definition creates an anonymous access
type.

     NOTES

18
     86  Access values are called "pointers" or "references" in some
     other languages.

19
     87  Each access-to-object type has an associated storage pool;
     several access types can share the same pool.  An object can be
     created in the storage pool of an access type by an allocator (see
     *note 4.8::) for the access type.  A storage pool (roughly)
     corresponds to what some other languages call a "heap."  See *note
     13.11:: for a discussion of pools.

20
     88  Only index_constraints and discriminant_constraints can be
     applied to access types (see *note 3.6.1:: and *note 3.7.1::).

                              _Examples_

21
<Examples of access-to-object types:>

22/4
     type Frame is access Matrix;    --<  see *note 3.6::>
     type Peripheral_Ref is not null access Peripheral;  --<  see *note 3.8.1::>
     type Binop_Ptr is access all Binary_Operation'Class;
                                                --< general access-to-class-wide, see *note 3.9.1::>

23
<Example of an access subtype:>

24
     subtype Drum_Ref is Peripheral_Ref(Drum);  --<  see *note 3.8.1::>

25
<Example of an access-to-subprogram type:>

26
     type Message_Procedure is access procedure (M : in String := "Error!");
     procedure Default_Message_Procedure(M : in String);
     Give_Message : Message_Procedure := Default_Message_Procedure'Access;
     ...
     procedure Other_Procedure(M : in String);
     ...
     Give_Message := Other_Procedure'Access;
     ...
     Give_Message("File not found.");  --< call with parameter (.all is optional)>
     Give_Message.all;                 --< call with no parameters>

* Menu:

* 3.10.1 ::   Incomplete Type Declarations
* 3.10.2 ::   Operations of Access Types


File: arm2012.info,  Node: 3.10.1,  Next: 3.10.2,  Up: 3.10

3.10.1 Incomplete Type Declarations
-----------------------------------

1
There are no particular limitations on the designated type of an access
type.  In particular, the type of a component of the designated type can
be another access type, or even the same access type.  This permits
mutually dependent and recursive access types.  An
incomplete_type_declaration can be used to introduce a type to be used
as a designated type, while deferring its full definition to a
subsequent full_type_declaration.

                               _Syntax_

2/2
     incomplete_type_declaration ::= type defining_identifier [
     discriminant_part] [is tagged];

                          _Static Semantics_

2.1/4
An incomplete_type_declaration declares an <incomplete view> of a type
and its first subtype; the first subtype is unconstrained if a
discriminant_part appears.  If the incomplete_type_declaration (*note
3.10.1: S0085.) includes the reserved word tagged, it declares a <tagged
incomplete view>.  If <T> denotes a tagged incomplete view, then
<T>'Class denotes a tagged incomplete view.  An incomplete view of a
type is a limited view of the type (see *note 7.5::).

2.2/2
Given an access type <A> whose designated type <T> is an incomplete
view, a dereference of a value of type <A> also has this incomplete view
except when:

2.3/2
   * it occurs within the immediate scope of the completion of <T>, or

2.4/3
   * it occurs within the scope of a nonlimited_with_clause that
     mentions a library package in whose visible part the completion of
     <T> is declared, or

2.5/3
   * it occurs within the scope of the completion of <T> and <T> is an
     incomplete view declared by an incomplete_type_declaration.

2.6/3
In these cases, the dereference has the view of <T> visible at the point
of the dereference.

2.7/3
Similarly, if a subtype_mark denotes a subtype_declaration defining a
subtype of an incomplete view <T>, the subtype_mark denotes an
incomplete view except under the same three circumstances given above,
in which case it denotes the view of <T> visible at the point of the
subtype_mark.

                           _Legality Rules_

3/3
An incomplete_type_declaration (*note 3.10.1: S0085.) requires a
completion, which shall be a type_declaration (*note 3.2.1: S0023.)
other than an incomplete_type_declaration (*note 3.10.1: S0085.).  If
the incomplete_type_declaration (*note 3.10.1: S0085.) occurs
immediately within either the visible part of a package_specification
(*note 7.1: S0191.) or a declarative_part (*note 3.11: S0086.), then the
type_declaration (*note 3.2.1: S0023.) shall occur later and immediately
within this visible part or declarative_part (*note 3.11: S0086.).  If
the incomplete_type_declaration (*note 3.10.1: S0085.) occurs
immediately within the private part of a given package_specification
(*note 7.1: S0191.), then the type_declaration (*note 3.2.1: S0023.)
shall occur later and immediately within either the private part itself,
or the declarative_part (*note 3.11: S0086.) of the corresponding
package_body (*note 7.2: S0192.).

4/3
If an incomplete_type_declaration (*note 3.10.1: S0085.) includes the
reserved word tagged, then a type_declaration (*note 3.2.1: S0023.) that
completes it shall declare a tagged type.  If an
incomplete_type_declaration (*note 3.10.1: S0085.) has a
known_discriminant_part (*note 3.7: S0061.), then a type_declaration
(*note 3.2.1: S0023.) that completes it shall have a fully conforming
(explicit) known_discriminant_part (*note 3.7: S0061.) (see *note
6.3.1::).  If an incomplete_type_declaration (*note 3.10.1: S0085.) has
no discriminant_part (or an unknown_discriminant_part (*note 3.7:
S0060.)), then a corresponding type_declaration (*note 3.2.1: S0023.) is
nevertheless allowed to have discriminants, either explicitly, or
inherited via derivation.

5/2
A name that denotes an incomplete view of a type may be used as follows:

6/3
   * as the subtype_mark in the subtype_indication of an
     access_to_object_definition (*note 3.10: S0080.); the only form of
     constraint allowed in this subtype_indication is a
     discriminant_constraint (a null_exclusion is not allowed);

7/2
   * as the subtype_mark in the subtype_indication of a
     subtype_declaration; the subtype_indication (*note 3.2.2: S0027.)
     shall not have a null_exclusion (*note 3.10: S0083.) or a
     constraint;

8/3
   * as the subtype_mark in an access_definition for an access-to-object
     type;

8.1/3
   * as the subtype_mark defining the subtype of a parameter or result
     in a profile occurring within a basic_declaration;

8.2/3
   * as a generic actual parameter whose corresponding generic formal
     parameter is a formal incomplete type (see *note 12.5.1::).

8.3/2
If such a name denotes a tagged incomplete view, it may also be used:

8.4/3
   * as the subtype_mark defining the subtype of a parameter in the
     profile for a subprogram_body, entry_body, or accept_statement;

9/2
   * as the prefix of an attribute_reference whose attribute_designator
     (*note 4.1.4: S0101.) is Class; such an attribute_reference (*note
     4.1.4: S0100.) is restricted to the uses allowed here; it denotes a
     tagged incomplete view.

9.1/3
<This paragraph was deleted.>

9.2/3
   * <This paragraph was deleted.>

9.3/2
If any of the above uses occurs as part of the declaration of a
primitive subprogram of the incomplete view, and the declaration occurs
immediately within the private part of a package, then the completion of
the incomplete view shall also occur immediately within the private
part; it shall not be deferred to the package body.

9.4/2
No other uses of a name that denotes an incomplete view of a type are
allowed.

10/3
A prefix that denotes an object shall not be of an incomplete view.  An
actual parameter in a call shall not be of an untagged incomplete view.
The result object of a function call shall not be of an incomplete view.
A prefix shall not denote a subprogram having a formal parameter of an
untagged incomplete view, nor a return type that is an incomplete view.

<Paragraph 11 was deleted.>

                          _Dynamic Semantics_

12
The elaboration of an incomplete_type_declaration has no effect.

     NOTES

13
     89  Within a declarative_part, an incomplete_type_declaration and a
     corresponding full_type_declaration cannot be separated by an
     intervening body.  This is because a type has to be completely
     defined before it is frozen, and a body freezes all types declared
     prior to it in the same declarative_part (see *note 13.14::).

13.1/3
     90  A name that denotes an object of an incomplete view is defined
     to be of a limited type.  Hence, the target of an assignment
     statement cannot be of an incomplete view.

                              _Examples_

14
<Example of a recursive type:>

15
     type Cell;  --<  incomplete type declaration>
     type Link is access Cell;

16
     type Cell is
        record
           Value  : Integer;
           Succ   : Link;
           Pred   : Link;
        end record;

17
     Head   : Link  := new Cell'(0, null, null);
     Next   : Link  := Head.Succ;

18
<Examples of mutually dependent access types:>

19/2
     type Person(<>);    --< incomplete type declaration>
     type Car is tagged; --< incomplete type declaration>

20/2
     type Person_Name is access Person;
     type Car_Name    is access all Car'Class;

21/2
     type Car is tagged
        record
           Number  : Integer;
           Owner   : Person_Name;
        end record;

22
     type Person(Sex : Gender) is
        record
           Name     : String(1 .. 20);
           Birth    : Date;
           Age      : Integer range 0 .. 130;
           Vehicle  : Car_Name;
           case Sex is
              when M => Wife           : Person_Name(Sex => F);
              when F => Husband        : Person_Name(Sex => M);
           end case;
        end record;

23
     My_Car, Your_Car, Next_Car : Car_Name := new Car;  --< see *note 4.8::>
     George : Person_Name := new Person(M);
        ...
     George.Vehicle := Your_Car;


File: arm2012.info,  Node: 3.10.2,  Prev: 3.10.1,  Up: 3.10

3.10.2 Operations of Access Types
---------------------------------

1/3
The attribute Access is used to create access values designating aliased
objects and nonintrinsic subprograms.  The "accessibility" rules prevent
dangling references (in the absence of uses of certain unchecked
features -- see Clause *note 13::).

                        _Name Resolution Rules_

2/2
For an attribute_reference with attribute_designator Access (or
Unchecked_Access -- see *note 13.10::), the expected type shall be a
single access type <A> such that:

2.1/2
   * <A> is an access-to-object type with designated type <D> and the
     type of the prefix is <D>'Class or is covered by <D>, or

2.2/2
   * <A> is an access-to-subprogram type whose designated profile is
     type conformant with that of the prefix.

2.3/2
The prefix of such an attribute_reference is never interpreted as an
implicit_dereference or a parameterless function_call (see *note
4.1.4::).  The designated type or profile of the expected type of the
attribute_reference is the expected type or profile for the prefix.

                          _Static Semantics_

3/2
The accessibility rules, which prevent dangling references, are written
in terms of <accessibility levels>, which reflect the run-time nesting
of <masters>.  As explained in *note 7.6.1::, a master is the execution
of a certain construct, such as a subprogram_body.  An accessibility
level is <deeper than> another if it is more deeply nested at run time.
For example, an object declared local to a called subprogram has a
deeper accessibility level than an object declared local to the calling
subprogram.  The accessibility rules for access types require that the
accessibility level of an object designated by an access value be no
deeper than that of the access type.  This ensures that the object will
live at least as long as the access type, which in turn ensures that the
access value cannot later designate an object that no longer exists.
The Unchecked_Access attribute may be used to circumvent the
accessibility rules.

4
A given accessibility level is said to be <statically deeper> than
another if the given level is known at compile time (as defined below)
to be deeper than the other for all possible executions.  In most cases,
accessibility is enforced at compile time by Legality Rules.  Run-time
accessibility checks are also used, since the Legality Rules do not
cover certain cases involving access parameters and generic packages.

5
Each master, and each entity and view created by it, has an
accessibility level:

6
   * The accessibility level of a given master is deeper than that of
     each dynamically enclosing master, and deeper than that of each
     master upon which the task executing the given master directly
     depends (see *note 9.3::).

7/4
   * An entity or view defined by a declaration and created as part of
     its elaboration has the same accessibility level as the innermost
     master of the declaration except in the cases of renaming and
     derived access types described below.  Other than for an explicitly
     aliased parameter of a function or generic function, a formal
     parameter of a callable entity has the same accessibility level as
     the master representing the invocation of the entity.

8
   * The accessibility level of a view of an object or subprogram
     defined by a renaming_declaration is the same as that of the
     renamed view.

9/2
   * The accessibility level of a view conversion, qualified_expression,
     or parenthesized expression, is the same as that of the operand.

9.1/3
   * The accessibility level of a conditional_expression is the
     accessibility level of the evaluated <dependent_>expression.

10/4
   * The accessibility level of an aggregate that is used (in its
     entirety) to directly initialize part of an object is that of the
     object being initialized.  In other contexts, the accessibility
     level of an aggregate is that of the innermost master that
     evaluates the aggregate.  Corresponding rules apply to a value
     conversion (see *note 4.6::).

10.1/3
   * The accessibility level of the result of a function call is that of
     the <master of the function call>, which is determined by the point
     of call as follows:

10.2/3
             * If the result is used (in its entirety) to directly
               initialize part of an object, the master is that of the
               object being initialized.  In the case where the
               initialized object is a coextension (see below) that
               becomes a coextension of another object, the master is
               that of the eventual object to which the coextension will
               be transferred.

10.3/3
             * If the result is of an anonymous access type and is the
               operand of an explicit conversion, the master is that of
               the target type of the conversion;

10.4/3
             * If the result is of an anonymous access type and defines
               an access discriminant, the master is the same as that
               for an object created by an anonymous allocator that
               defines an access discriminant (even if the access result
               is of an access-to-subprogram type).

10.5/3
             * If the call itself defines the result of a function to
               which one of the above rules applies, these rules are
               applied recursively;

10.6/3
             * In other cases, the master of the call is that of the
               innermost master that evaluates the function call.

10.7/3
     In the case of a call to a function whose result type is an
     anonymous access type, the accessibility level of the type of the
     result of the function call is also determined by the point of call
     as described above.

10.8/3
   * Within a return statement, the accessibility level of the return
     object is that of the execution of the return statement.  If the
     return statement completes normally by returning from the function,
     then prior to leaving the function, the accessibility level of the
     return object changes to be a level determined by the point of
     call, as does the level of any coextensions (see below) of the
     return object.

11
   * The accessibility level of a derived access type is the same as
     that of its ultimate ancestor.

11.1/2
   * The accessibility level of the anonymous access type defined by an
     access_definition of an object_renaming_declaration is the same as
     that of the renamed view.

12/2
   * The accessibility level of the anonymous access type of an access
     discriminant in the subtype_indication or qualified_expression of
     an allocator, or in the expression or return_subtype_indication
     (*note 6.5: S0187.) of a return statement is determined as follows:

12.1/2
             * If the value of the access discriminant is determined by
               a discriminant_association in a subtype_indication, the
               accessibility level of the object or subprogram
               designated by the associated value (or library level if
               the value is null);

12.2/3
             * If the value of the access discriminant is determined by
               a default_expression in the declaration of the
               discriminant, the level of the object or subprogram
               designated by the associated value (or library level if
               null);

12.3/3
             * If the value of the access discriminant is determined by
               a record_component_association in an aggregate, the
               accessibility level of the object or subprogram
               designated by the associated value (or library level if
               the value is null);

12.4/3
             * In other cases, where the value of the access
               discriminant is determined by an object with an
               unconstrained nominal subtype, the accessibility level of
               the object.

12.5/3
   * The accessibility level of the anonymous access type of an access
     discriminant in any other context is that of the enclosing object.

13/3
   * The accessibility level of the anonymous access type of an access
     parameter specifying an access-to-object type is the same as that
     of the view designated by the actual (or library-level if the
     actual is null).

13.1/2
   * The accessibility level of the anonymous access type of an access
     parameter specifying an access-to-subprogram type is deeper than
     that of any master; all such anonymous access types have this same
     level.

13.2/4
   * The accessibility level of the anonymous access subtype defined by
     a return_subtype_indication that is an access_definition (see *note
     6.5::) is that of the result subtype of the enclosing function.

13.3/4
   * The accessibility level of the type of a stand-alone object of an
     anonymous access-to-object type is the same as the accessibility
     level of the type of the access value most recently assigned to the
     object; accessibility checks ensure that this is never deeper than
     that of the declaration of the stand-alone object.

13.4/4
   * The accessibility level of an explicitly aliased (see *note 6.1::)
     formal parameter in a function body is determined by the point of
     call; it is the same level that the return object ultimately will
     have.

14/3
   * The accessibility level of an object created by an allocator is the
     same as that of the access type, except for an allocator of an
     anonymous access type (an <anonymous allocator>) in certain
     contexts, as follows: For an anonymous allocator that defines the
     result of a function with an access result, the accessibility level
     is determined as though the allocator were in place of the call of
     the function; in the special case of a call that is the operand of
     a type conversion, the level is that of the target access type of
     the conversion.  For an anonymous allocator defining the value of
     an access parameter, the accessibility level is that of the
     innermost master of the call.  For an anonymous allocator whose
     type is that of a stand-alone object of an anonymous
     access-to-object type, the accessibility level is that of the
     declaration of the stand-alone object.  For one defining an access
     discriminant, the accessibility level is determined as follows:

14.1/3
             * for an allocator used to define the discriminant of an
               object, the level of the object;

14.2/3
             * for an allocator used to define the constraint in a
               subtype_indication in any other context, the level of the
               master that elaborates the subtype_indication.

14.3/3
             * <This paragraph was deleted.>

14.4/3
     In the first case, the allocated object is said to be a
     <coextension> of the object whose discriminant designates it, as
     well as of any object of which the discriminated object is itself a
     coextension or subcomponent.  If the allocated object is a
     coextension of an anonymous object representing the result of an
     aggregate or function call that is used (in its entirety) to
     directly initialize a part of an object, after the result is
     assigned, the coextension becomes a coextension of the object being
     initialized and is no longer considered a coextension of the
     anonymous object.  All coextensions of an object (which have not
     thus been transfered by such an initialization) are finalized when
     the object is finalized (see *note 7.6.1::).

14.5/3
   * Within a return statement, the accessibility level of the anonymous
     access type of an access result is that of the master of the call.

15/3
   * The accessibility level of a view of an object or subprogram
     designated by an access value is the same as that of the access
     type.

16
   * The accessibility level of a component, protected subprogram, or
     entry of (a view of) a composite object is the same as that of (the
     view of) the composite object.

16.1/3
In the above rules, the operand of a view conversion, parenthesized
expression or qualified_expression is considered to be used in a context
if the view conversion, parenthesized expression or qualified_expression
itself is used in that context.  Similarly, a <dependent_>expression of
a conditional_expression is considered to be used in a context if the
conditional_expression itself is used in that context.

17
One accessibility level is defined to be <statically deeper> than
another in the following cases:

18
   * For a master that is statically nested within another master, the
     accessibility level of the inner master is statically deeper than
     that of the outer master.

18.1/2
   * The accessibility level of the anonymous access type of an access
     parameter specifying an access-to-subprogram type is statically
     deeper than that of any master; all such anonymous access types
     have this same level.

19/3
   * The statically deeper relationship does not apply to the
     accessibility level of the anonymous type of an access parameter
     specifying an access-to-object type nor does it apply to a
     descendant of a generic formal type; that is, such an accessibility
     level is not considered to be statically deeper, nor statically
     shallower, than any other.

19.1/3
   * The statically deeper relationship does not apply to the
     accessibility level of the type of a stand-alone object of an
     anonymous access-to-object type; that is, such an accessibility
     level is not considered to be statically deeper, nor statically
     shallower, than any other.

19.2/4
   * Inside a return statement that applies to a function or generic
     function <F>, or the return expression of an expression function
     <F>, when determining whether the accessibility level of an
     explicitly aliased parameter of <F> is statically deeper than the
     level of the return object of <F>, the level of the return object
     is considered to be the same as that of the level of the explicitly
     aliased parameter; for statically comparing with the level of other
     entities, an explicitly aliased parameter of <F> is considered to
     have the accessibility level of the body of <F>.

19.3/4
   * For determining whether a level is statically deeper than the level
     of the anonymous access type of an access result of a function or
     generic function <F>, when within a return statement that applies
     to <F> or the return expression of expression function <F>, the
     level of the master of the call is presumed to be the same as that
     of the level of the master that elaborated the body of <F>.

20
   * or generic function <F>

21
   * For determining whether one level is statically deeper than another
     when within a generic package body, the generic package is presumed
     to be instantiated at the same level as where it was declared;
     run-time checks are needed in the case of more deeply nested
     instantiations.

22
   * For determining whether one level is statically deeper than another
     when within the declarative region of a type_declaration, the
     current instance of the type is presumed to be an object created at
     a deeper level than that of the type.

23
The accessibility level of all library units is called the <library
level>; a library-level declaration or entity is one whose accessibility
level is the library level.

24
The following attribute is defined for a prefix X that denotes an
aliased view of an object:

25/1
X'Access
               X'Access yields an access value that designates the
               object denoted by X. The type of X'Access is an
               access-to-object type, as determined by the expected
               type.  The expected type shall be a general access type.               X shall denote an aliased view of an object, including
               possibly the current instance (see *note 8.6::) of a
               limited type within its definition, or a formal parameter
               or generic formal object of a tagged type.  The view
               denoted by the prefix X shall satisfy the following
               additional requirements, presuming the expected type for
               X'Access is the general access type <A> with designated
               type <D>:

26
                  * If <A> is an access-to-variable type, then the view
                    shall be a variable; on the other hand, if <A> is an
                    access-to-constant type, the view may be either a
                    constant or a variable.

27/3
                  * The view shall not be a subcomponent that depends on
                    discriminants of an object unless the object is
                    known to be constrained.

28/2
                  * If <A> is a named access type and <D> is a tagged
                    type, then the type of the view shall be covered by
                    <D>; if <A> is anonymous and <D> is tagged, then the
                    type of the view shall be either <D>'Class or a type
                    covered by <D>; if <D> is untagged, then the type of
                    the view shall be <D>, and either:

28.1/2
                            * the designated subtype of <A> shall
                              statically match the nominal subtype of
                              the view; or

28.2/4
                            * <D> shall be discriminated in its full
                              view and unconstrained in any partial
                              view, and the designated subtype of <A>
                              shall be unconstrained.

29/3
                  * The accessibility level of the view shall not be
                    statically deeper than that of the access type <A>.                    

29.1/3
               In addition to the places where Legality Rules normally
               apply (see *note 12.3::), these requirements apply also
               in the private part of an instance of a generic unit.

30
               A check is made that the accessibility level of X is not
               deeper than that of the access type <A>.  If this check
               fails, Program_Error is raised.

31
               If the nominal subtype of X does not statically match the
               designated subtype of <A>, a view conversion of X to the
               designated subtype is evaluated (which might raise
               Constraint_Error -- see *note 4.6::) and the value of
               X'Access designates that view.

32
The following attribute is defined for a prefix P that denotes a
subprogram:

33/3
P'Access
               P'Access yields an access value that designates the
               subprogram denoted by P. The type of P'Access is an
               access-to-subprogram type (<S>), as determined by the
               expected type.  The accessibility level of P shall not be
               statically deeper than that of <S>.  In addition to the
               places where Legality Rules normally apply (see *note
               12.3::), this rule applies also in the private part of an
               instance of a generic unit.  The profile of P shall be
               subtype conformant with the designated profile of <S>,
               and shall not be Intrinsic.  If the subprogram denoted by
               P is declared within a generic unit, and the expression
               P'Access occurs within the body of that generic unit or
               within the body of a generic unit declared within the
               declarative region of the generic unit, then the ultimate
               ancestor of <S> shall be either a nonformal type declared
               within the generic unit or an anonymous access type of an
               access parameter.

                           _Legality Rules_

33.1/3
An expression is said to have <distributed accessibility> if it is

33.2/3
   * a conditional_expression (see *note 4.5.7::); or

33.3/3
   * a view conversion, qualified_expression, or parenthesized
     expression whose operand has distributed accessibility.

33.4/3
The statically deeper relationship does not apply to the accessibility
level of an expression having distributed accessibility; that is, such
an accessibility level is not considered to be statically deeper, nor
statically shallower, than any other.

33.5/3
Any static accessibility requirement that is imposed on an expression
that has distributed accessibility (or on its type) is instead imposed
on the <dependent_>expressions of the underlying conditional_expression.
This rule is applied recursively if a <dependent_>expression also has
distributed accessibility.

     NOTES

34
     91  The Unchecked_Access attribute yields the same result as the
     Access attribute for objects, but has fewer restrictions (see *note
     13.10::).  There are other predefined operations that yield access
     values: an allocator can be used to create an object, and return an
     access value that designates it (see *note 4.8::); evaluating the
     literal null yields a null access value that designates no entity
     at all (see *note 4.2::).

35/2
     92  The predefined operations of an access type also include the
     assignment operation, qualification, and membership tests.
     Explicit conversion is allowed between general access types with
     matching designated subtypes; explicit conversion is allowed
     between access-to-subprogram types with subtype conformant profiles
     (see *note 4.6::).  Named access types have predefined equality
     operators; anonymous access types do not, but they can use the
     predefined equality operators for <universal_access> (see *note
     4.5.2::).

36
     93  The object or subprogram designated by an access value can be
     named with a dereference, either an explicit_dereference (*note
     4.1: S0094.) or an implicit_dereference.  See *note 4.1::.

37
     94  A call through the dereference of an access-to-subprogram value
     is never a dispatching call.

38/2
     95  The Access attribute for subprograms and parameters of an
     anonymous access-to-subprogram type may together be used to
     implement "downward closures" -- that is, to pass a more-nested
     subprogram as a parameter to a less-nested subprogram, as might be
     appropriate for an iterator abstraction or numerical integration.
     Downward closures can also be implemented using generic formal
     subprograms (see *note 12.6::).  Note that Unchecked_Access is not
     allowed for subprograms.

39
     96  Note that using an access-to-class-wide tagged type with a
     dispatching operation is a potentially more structured alternative
     to using an access-to-subprogram type.

40
     97  An implementation may consider two access-to-subprogram values
     to be unequal, even though they designate the same subprogram.
     This might be because one points directly to the subprogram, while
     the other points to a special prologue that performs an
     Elaboration_Check and then jumps to the subprogram.  See *note
     4.5.2::.

                              _Examples_

41
<Example of use of the Access attribute:>

42
     Martha : Person_Name := new Person(F);       --< see *note 3.10.1::>
     Cars   : array (1..2) of aliased Car;
        ...
     Martha.Vehicle := Cars(1)'Access;
     George.Vehicle := Cars(2)'Access;


File: arm2012.info,  Node: 3.11,  Prev: 3.10,  Up: 3

3.11 Declarative Parts
======================

1
A declarative_part contains declarative_items (possibly none).

                               _Syntax_

2
     declarative_part ::= {declarative_item}

3
     declarative_item ::=
         basic_declarative_item | body

4/1
     basic_declarative_item ::=
         basic_declaration | aspect_clause | use_clause

5
     body ::= proper_body | body_stub

6
     proper_body ::=
         subprogram_body | package_body | task_body | protected_body

                          _Static Semantics_

6.1/2
The list of declarative_items of a declarative_part is called the
<declaration list> of the declarative_part.

                          _Dynamic Semantics_

7
The elaboration of a declarative_part consists of the elaboration of the
declarative_items, if any, in the order in which they are given in the
declarative_part.

8
An elaborable construct is in the <elaborated> state after the normal
completion of its elaboration.  Prior to that, it is <not yet
elaborated>.

9
For a construct that attempts to use a body, a check (Elaboration_Check)
is performed, as follows:

10/1
   * For a call to a (non-protected) subprogram that has an explicit
     body, a check is made that the body is already elaborated.  This
     check and the evaluations of any actual parameters of the call are
     done in an arbitrary order.

11/3
   * For a call to a protected operation of a protected type (that has a
     body -- no check is performed if the protected type is imported --
     see *note B.1::), a check is made that the protected_body is
     already elaborated.  This check and the evaluations of any actual
     parameters of the call are done in an arbitrary order.

12
   * For the activation of a task, a check is made by the activator that
     the task_body is already elaborated.  If two or more tasks are
     being activated together (see *note 9.2::), as the result of the
     elaboration of a declarative_part or the initialization for the
     object created by an allocator, this check is done for all of them
     before activating any of them.

13
   * For the instantiation of a generic unit that has a body, a check is
     made that this body is already elaborated.  This check and the
     evaluation of any explicit_generic_actual_parameters of the
     instantiation are done in an arbitrary order.

14
The exception Program_Error is raised if any of these checks fails.

* Menu:

* 3.11.1 ::   Completions of Declarations


File: arm2012.info,  Node: 3.11.1,  Up: 3.11

3.11.1 Completions of Declarations
----------------------------------

1/3
Declarations sometimes come in two parts.  A declaration that requires a
second part is said to <require completion>.  The second part is called
the <completion> of the declaration (and of the entity declared), and is
either another declaration, a body, or a pragma.  A <body> is a body, an
entry_body, a null_procedure_declaration or an
expression_function_declaration that completes another declaration, or a
renaming-as-body (see *note 8.5.4::).

                        _Name Resolution Rules_

2
A construct that can be a completion is interpreted as the completion of
a prior declaration only if:

3
   * The declaration and the completion occur immediately within the
     same declarative region;

4
   * The defining name or defining_program_unit_name in the completion
     is the same as in the declaration, or in the case of a pragma, the
     pragma applies to the declaration;

5
   * If the declaration is overloadable, then the completion either has
     a type-conformant profile, or is a pragma.  

                           _Legality Rules_

6/3
An implicit declaration shall not have a completion.  For any explicit
declaration that is specified to <require completion>, there shall be a
corresponding explicit completion, unless the declared entity is
imported (see *note B.1::).

7
At most one completion is allowed for a given declaration.  Additional
requirements on completions appear where each kind of completion is
defined.

8
A type is <completely defined> at a place that is after its full type
definition (if it has one) and after all of its subcomponent types are
completely defined.  A type shall be completely defined before it is
frozen (see *note 13.14:: and *note 7.3::).

     NOTES

9/3
     98  Completions are in principle allowed for any kind of explicit
     declaration.  However, for some kinds of declaration, the only
     allowed completion is an implementation-defined pragma, and
     implementations are not required to have any such pragmas.

10
     99  There are rules that prevent premature uses of declarations
     that have a corresponding completion.  The Elaboration_Checks of
     *note 3.11:: prevent such uses at run time for subprograms,
     protected operations, tasks, and generic units.  The rules of *note
     13.14::, "*note 13.14:: Freezing Rules" prevent, at compile time,
     premature uses of other entities such as private types and deferred
     constants.


File: arm2012.info,  Node: 4,  Next: 5,  Prev: 3,  Up: Top

4 Names and Expressions
***********************

1/3
The rules applicable to the different forms of name and expression, and
to their evaluation, are given in this clause.

* Menu:

* 4.1 ::      Names
* 4.2 ::      Literals
* 4.3 ::      Aggregates
* 4.4 ::      Expressions
* 4.5 ::      Operators and Expression Evaluation
* 4.6 ::      Type Conversions
* 4.7 ::      Qualified Expressions
* 4.8 ::      Allocators
* 4.9 ::      Static Expressions and Static Subtypes


File: arm2012.info,  Node: 4.1,  Next: 4.2,  Up: 4

4.1 Names
=========

1
Names can denote declared entities, whether declared explicitly or
implicitly (see *note 3.1::).  Names can also denote objects or
subprograms designated by access values; the results of type_conversions
or function_calls; subcomponents and slices of objects and values;
protected subprograms, single entries, entry families, and entries in
families of entries.  Finally, names can denote attributes of any of the
foregoing.

                               _Syntax_

2/3
     name ::=
          direct_name   | explicit_dereference
        | indexed_component   | slice
        | selected_component   | attribute_reference
        | type_conversion   | function_call
        | character_literal   | qualified_expression
        | generalized_reference   | generalized_indexing

3
     direct_name ::= identifier | operator_symbol

4
     prefix ::= name | implicit_dereference

5
     explicit_dereference ::= name.all

6
     implicit_dereference ::= name

7/3
Certain forms of name (indexed_components, selected_components, slices,
and attribute_references) include a prefix that is either itself a name
that denotes some related entity, or an implicit_dereference of an
access value that designates some related entity.

                        _Name Resolution Rules_

8
The name in a <dereference> (either an implicit_dereference or an
explicit_dereference) is expected to be of any access type.

                          _Static Semantics_

9/3
If the type of the name in a dereference is some access-to-object type
<T>, then the dereference denotes a view of an object, the <nominal
subtype> of the view being the designated subtype of <T>.  If the
designated subtype has unconstrained discriminants, the (actual) subtype
of the view is constrained by the values of the discriminants of the
designated object, except when there is a partial view of the type of
the designated subtype that does not have discriminants, in which case
the dereference is not constrained by its discriminant values.

10
If the type of the name in a dereference is some access-to-subprogram
type <S>, then the dereference denotes a view of a subprogram, the
<profile> of the view being the designated profile of <S>.

                          _Dynamic Semantics_

11/2
The evaluation of a name determines the entity denoted by the name.
This evaluation has no other effect for a name that is a direct_name or
a character_literal.

12
The evaluation of a name that has a prefix includes the evaluation of
the prefix.  The evaluation of a prefix consists of the evaluation of
the name or the implicit_dereference.  The prefix denotes the entity
denoted by the name or the implicit_dereference.

13
The evaluation of a dereference consists of the evaluation of the name
and the determination of the object or subprogram that is designated by
the value of the name.  A check is made that the value of the name is
not the null access value.  Constraint_Error is raised if this check
fails.  The dereference denotes the object or subprogram designated by
the value of the name.

                              _Examples_

14
<Examples of direct names:>

15
     Pi    <-- the direct name of a number>    (see *note 3.3.2::)
     Limit    <-- the direct name of a constant>    (see *note 3.3.1::)
     Count    <-- the direct name of a scalar variable>    (see *note 3.3.1::)
     Board    <-- the direct name of an array variable>    (see *note 3.6.1::)
     Matrix    <-- the direct name of a type>    (see *note 3.6::)
     Random    <-- the direct name of a function>    (see *note 6.1::)
     Error    <-- the direct name of an exception>    (see *note 11.1::)

16
<Examples of dereferences:>

17
     Next_Car.all   --<  explicit dereference denoting the object designated by>
                       --<  the access variable Next_Car (see *note 3.10.1::)>
     Next_Car.Owner    --<  selected component with implicit dereference;>
                       --<  same as Next_Car.all.Owner>

* Menu:

* 4.1.1 ::    Indexed Components
* 4.1.2 ::    Slices
* 4.1.3 ::    Selected Components
* 4.1.4 ::    Attributes
* 4.1.5 ::    User-Defined References
* 4.1.6 ::    User-Defined Indexing


File: arm2012.info,  Node: 4.1.1,  Next: 4.1.2,  Up: 4.1

4.1.1 Indexed Components
------------------------

1
An indexed_component denotes either a component of an array or an entry
in a family of entries.  

                               _Syntax_

2
     indexed_component ::= prefix(expression {, expression})

                        _Name Resolution Rules_

3
The prefix of an indexed_component with a given number of expressions
shall resolve to denote an array (after any implicit dereference) with
the corresponding number of index positions, or shall resolve to denote
an entry family of a task or protected object (in which case there shall
be only one expression).

4
The expected type for each expression is the corresponding index type.

                          _Static Semantics_

5
When the prefix denotes an array, the indexed_component denotes the
component of the array with the specified index value(s).  The nominal
subtype of the indexed_component is the component subtype of the array
type.

6
When the prefix denotes an entry family, the indexed_component denotes
the individual entry of the entry family with the specified index value.

                          _Dynamic Semantics_

7
For the evaluation of an indexed_component, the prefix and the
expressions are evaluated in an arbitrary order.  The value of each
expression is converted to the corresponding index type.  A check is
made that each index value belongs to the corresponding index range of
the array or entry family denoted by the prefix.  Constraint_Error is
raised if this check fails.

                              _Examples_

8
<Examples of indexed components:>

9
      My_Schedule(Sat)     --<  a component of a one-dimensional array    (see *note 3.6.1::)>
      Page(10)             --<  a component of a one-dimensional array    (see *note 3.6::)>
      Board(M, J + 1)      --<  a component of a two-dimensional array    (see *note 3.6.1::)>
      Page(10)(20)         --<  a component of a component    (see *note 3.6::)>
      Request(Medium)      --<  an entry in a family of entries    (see *note 9.1::)>
      Next_Frame(L)(M, N)  --<  a component of a function call    (see *note 6.1::)>

     NOTES

10
     1  <Notes on the examples:> Distinct notations are used for
     components of multidimensional arrays (such as Board) and arrays of
     arrays (such as Page).  The components of an array of arrays are
     arrays and can therefore be indexed.  Thus Page(10)(20) denotes the
     20th component of Page(10).  In the last example Next_Frame(L) is a
     function call returning an access value that designates a
     two-dimensional array.


File: arm2012.info,  Node: 4.1.2,  Next: 4.1.3,  Prev: 4.1.1,  Up: 4.1

4.1.2 Slices
------------

1
A slice denotes a one-dimensional array formed by a sequence of
consecutive components of a one-dimensional array.  A slice of a
variable is a variable; a slice of a constant is a constant; a slice of
a value is a value.

                               _Syntax_

2
     slice ::= prefix(discrete_range)

                        _Name Resolution Rules_

3
The prefix of a slice shall resolve to denote a one-dimensional array
(after any implicit dereference).

4
The expected type for the discrete_range of a slice is the index type of
the array type.

                          _Static Semantics_

5
A slice denotes a one-dimensional array formed by the sequence of
consecutive components of the array denoted by the prefix, corresponding
to the range of values of the index given by the discrete_range.

6
The type of the slice is that of the prefix.  Its bounds are those
defined by the discrete_range.

                          _Dynamic Semantics_

7
For the evaluation of a slice, the prefix and the discrete_range are
evaluated in an arbitrary order.  If the slice is not a <null slice> (a
slice where the discrete_range is a null range), then a check is made
that the bounds of the discrete_range belong to the index range of the
array denoted by the prefix.  Constraint_Error is raised if this check
fails.

     NOTES

8
     2  A slice is not permitted as the prefix of an Access
     attribute_reference, even if the components or the array as a whole
     are aliased.  See *note 3.10.2::.

9
     3  For a one-dimensional array A, the slice A(N ..  N) denotes an
     array that has only one component; its type is the type of A. On
     the other hand, A(N) denotes a component of the array A and has the
     corresponding component type.

                              _Examples_

10
<Examples of slices:>

11
       Stars(1 .. 15)        --<  a slice of 15 characters    (see *note 3.6.3::)>
       Page(10 .. 10 + Size) --<  a slice of 1 + Size components    (see *note 3.6::)>
       Page(L)(A .. B)       --<  a slice of the array Page(L)    (see *note 3.6::)>
       Stars(1 .. 0)         --<  a null slice    (see *note 3.6.3::)>
       My_Schedule(Weekday)  --<  bounds given by subtype    (see *note 3.6.1:: and *note 3.5.1::)>
       Stars(5 .. 15)(K)     --<  same as Stars(K)    (see *note 3.6.3::)>
                             --<  provided that K is in 5 .. 15>


File: arm2012.info,  Node: 4.1.3,  Next: 4.1.4,  Prev: 4.1.2,  Up: 4.1

4.1.3 Selected Components
-------------------------

1
Selected_components are used to denote components (including
discriminants), entries, entry families, and protected subprograms; they
are also used as expanded names as described below.  

                               _Syntax_

2
     selected_component ::= prefix . selector_name

3
     selector_name ::= identifier | character_literal | operator_symbol

                        _Name Resolution Rules_

4
A selected_component is called an <expanded name> if, according to the
visibility rules, at least one possible interpretation of its prefix
denotes a package or an enclosing named construct (directly, not through
a subprogram_renaming_declaration or generic_renaming_declaration).

5
A selected_component that is not an expanded name shall resolve to
denote one of the following:

6
   * A component (including a discriminant):

7
     The prefix shall resolve to denote an object or value of some
     non-array composite type (after any implicit dereference).  The
     selector_name shall resolve to denote a discriminant_specification
     of the type, or, unless the type is a protected type, a
     component_declaration of the type.  The selected_component denotes
     the corresponding component of the object or value.

8
   * A single entry, an entry family, or a protected subprogram:

9
     The prefix shall resolve to denote an object or value of some task
     or protected type (after any implicit dereference).  The
     selector_name shall resolve to denote an entry_declaration or
     subprogram_declaration occurring (implicitly or explicitly) within
     the visible part of that type.  The selected_component denotes the
     corresponding entry, entry family, or protected subprogram.

9.1/2
   * A view of a subprogram whose first formal parameter is of a tagged
     type or is an access parameter whose designated type is tagged:

9.2/3
     The prefix (after any implicit dereference) shall resolve to denote
     an object or value of a specific tagged type <T> or class-wide type
     <T>'Class.  The selector_name shall resolve to denote a view of a
     subprogram declared immediately within the declarative region in
     which an ancestor of the type <T> is declared.  The first formal
     parameter of the subprogram shall be of type <T>, or a class-wide
     type that covers <T>, or an access parameter designating one of
     these types.  The designator of the subprogram shall not be the
     same as that of a component of the tagged type visible at the point
     of the selected_component.  The subprogram shall not be an
     implicitly declared primitive operation of type <T> that overrides
     an inherited subprogram implemented by an entry or protected
     subprogram visible at the point of the selected_component.  The
     selected_component denotes a view of this subprogram that omits the
     first formal parameter.  This view is called a <prefixed view> of
     the subprogram, and the prefix of the selected_component (after any
     implicit dereference) is called the <prefix> of the prefixed view.     

10
An expanded name shall resolve to denote a declaration that occurs
immediately within a named declarative region, as follows:

11
   * The prefix shall resolve to denote either a package (including the
     current instance of a generic package, or a rename of a package),
     or an enclosing named construct.

12
   * The selector_name shall resolve to denote a declaration that occurs
     immediately within the declarative region of the package or
     enclosing construct (the declaration shall be visible at the place
     of the expanded name -- see *note 8.3::).  The expanded name
     denotes that declaration.

13
   * If the prefix does not denote a package, then it shall be a
     direct_name or an expanded name, and it shall resolve to denote a
     program unit (other than a package), the current instance of a
     type, a block_statement, a loop_statement, or an accept_statement
     (*note 9.5.2: S0219.) (in the case of an accept_statement (*note
     9.5.2: S0219.) or entry_body (*note 9.5.2: S0221.), no family index
     is allowed); the expanded name shall occur within the declarative
     region of this construct.  Further, if this construct is a callable
     construct and the prefix denotes more than one such enclosing
     callable construct, then the expanded name is ambiguous,
     independently of the selector_name.

                           _Legality Rules_

13.1/2
For a subprogram whose first parameter is an access parameter, the
prefix of any prefixed view shall denote an aliased view of an object.

13.2/2
For a subprogram whose first parameter is of mode in out or out, or of
an anonymous access-to-variable type, the prefix of any prefixed view
shall denote a variable.

                          _Dynamic Semantics_

14
The evaluation of a selected_component includes the evaluation of the
prefix.

15
For a selected_component that denotes a component of a variant, a check
is made that the values of the discriminants are such that the value or
object denoted by the prefix has this component.  The exception
Constraint_Error is raised if this check fails.

                              _Examples_

16
<Examples of selected components:>

17/2
       Tomorrow.Month     --<  a record component    (see *note 3.8::)>
       Next_Car.Owner     --<  a record component    (see *note 3.10.1::)>
       Next_Car.Owner.Age --<  a record component    (see *note 3.10.1::)>
                          --<  the previous two lines involve implicit dereferences>
       Writer.Unit        --<  a record component (a discriminant)    (see *note 3.8.1::)>
       Min_Cell(H).Value  --<  a record component of the result    (see *note 6.1::)>
                          --<  of the function call Min_Cell(H)>
       Cashier.Append     --<  a prefixed view of a procedure    (see *note 3.9.4::)>
       Control.Seize      --<  an entry of a protected object    (see *note 9.4::)>
       Pool(K).Write      --<  an entry of the task Pool(K)    (see *note 9.4::)>

18
<Examples of expanded names:>

19
       Key_Manager."<"      --<  an operator of the visible part of a package    (see *note 7.3.1::)>
       Dot_Product.Sum      --<  a variable declared in a function body    (see *note 6.1::)>
       Buffer.Pool          --<  a variable declared in a protected unit    (see *note 9.11::)>
       Buffer.Read          --<  an entry of a protected unit    (see *note 9.11::)>
       Swap.Temp            --<  a variable declared in a block statement    (see *note 5.6::)>
       Standard.Boolean     --<  the name of a predefined type    (see *note A.1::)>


File: arm2012.info,  Node: 4.1.4,  Next: 4.1.5,  Prev: 4.1.3,  Up: 4.1

4.1.4 Attributes
----------------

1
An <attribute> is a characteristic of an entity that can be queried via
an attribute_reference (*note 4.1.4: S0100.) or a
range_attribute_reference (*note 4.1.4: S0102.).

                               _Syntax_

2
     attribute_reference ::= prefix'attribute_designator

3/2
     attribute_designator ::=
         identifier[(<static_>expression)]
       | Access | Delta | Digits | Mod

4
     range_attribute_reference ::= prefix'range_attribute_designator

5
     range_attribute_designator ::= Range[(<static_>expression)]

                        _Name Resolution Rules_

6
In an attribute_reference, if the attribute_designator is for an
attribute defined for (at least some) objects of an access type, then
the prefix is never interpreted as an implicit_dereference; otherwise
(and for all range_attribute_references), if the type of the name within
the prefix is of an access type, the prefix is interpreted as an
implicit_dereference.  Similarly, if the attribute_designator is for an
attribute defined for (at least some) functions, then the prefix is
never interpreted as a parameterless function_call; otherwise (and for
all range_attribute_references), if the prefix consists of a name that
denotes a function, it is interpreted as a parameterless function_call.

7
The expression, if any, in an attribute_designator or
range_attribute_designator is expected to be of any integer type.

                           _Legality Rules_

8
The expression, if any, in an attribute_designator or
range_attribute_designator shall be static.

                          _Static Semantics_

9/4
An attribute_reference denotes a value, an object, a subprogram, or some
other kind of program entity.  Unless explicitly specified otherwise,
for an attribute_reference that denotes a value or an object, if its
type is scalar, then its nominal subtype is the base subtype of the
type; if its type is tagged, its nominal subtype is the first subtype of
the type; otherwise, its nominal subtype is a subtype of the type
without any constraint, null_exclusion, or predicate.  Similarly, unless
explicitly specified otherwise, for an attribute_reference that denotes
a function, when its result type is scalar, its result subtype is the
base subtype of the type, when its result type is tagged, the result
subtype is the first subtype of the type, and when the result type is
some other type, the result subtype is a subtype of the type without any
constraint, null_exclusion, or predicate.

10
A range_attribute_reference X'Range(N) is equivalent to the range
X'First(N) ..  X'Last(N), except that the prefix is only evaluated once.
Similarly, X'Range is equivalent to X'First ..  X'Last, except that the
prefix is only evaluated once.

                          _Dynamic Semantics_

11
The evaluation of an attribute_reference (or range_attribute_reference)
consists of the evaluation of the prefix.

                     _Implementation Permissions_

12/1
An implementation may provide implementation-defined attributes; the
identifier for an implementation-defined attribute shall differ from
those of the language-defined attributes unless supplied for
compatibility with a previous edition of this International Standard.

     NOTES

13
     4  Attributes are defined throughout this International Standard,
     and are summarized in *note K.2::.

14/2
     5  In general, the name in a prefix of an attribute_reference (or a
     range_attribute_reference) has to be resolved without using any
     context.  However, in the case of the Access attribute, the
     expected type for the attribute_reference has to be a single access
     type, and the resolution of the name can use the fact that the type
     of the object or the profile of the callable entity denoted by the
     prefix has to match the designated type or be type conformant with
     the designated profile of the access type.  

                              _Examples_

15
<Examples of attributes:>

16
     Color'First        --< minimum value of the enumeration type Color    (see *note 3.5.1::)>
     Rainbow'Base'First --< same as Color'First    (see *note 3.5.1::)>
     Real'Digits        --< precision of the type Real    (see *note 3.5.7::)>
     Board'Last(2)      --< upper bound of the second dimension of Board    (see *note 3.6.1::)>
     Board'Range(1)     --< index range of the first dimension of Board    (see *note 3.6.1::)>
     Pool(K)'Terminated --< True if task Pool(K) is terminated    (see *note 9.1::)>
     Date'Size          --< number of bits for records of type Date    (see *note 3.8::)>
     Message'Address    --< address of the record variable Message    (see *note 3.7.1::)>


File: arm2012.info,  Node: 4.1.5,  Next: 4.1.6,  Prev: 4.1.4,  Up: 4.1

4.1.5 User-Defined References
-----------------------------

                          _Static Semantics_

1/3
Given a discriminated type <T>, the following type-related operational
aspect may be specified:

2/3
Implicit_Dereference
               This aspect is specified by a name that denotes an access
               discriminant declared for the type <T>.

3/3
A (view of a) type with a specified Implicit_Dereference aspect is a
<reference type>.  A <reference object> is an object of a reference
type.  The discriminant named by the Implicit_Dereference aspect is the
<reference discriminant> of the reference type or reference object.  A
generalized_reference is a name that identifies a reference object, and
denotes the object or subprogram designated by the reference
discriminant of the reference object.

                               _Syntax_

4/3
     generalized_reference ::= <reference_object_>name

                        _Name Resolution Rules_

5/3
The expected type for the <reference_object_>name in a
generalized_reference is any reference type.

                          _Static Semantics_

5.1/4
The Implicit_Dereference aspect is nonoverridable (see *note 13.1.1::).

6/3
A generalized_reference denotes a view equivalent to that of a
dereference of the reference discriminant of the reference object.

7/3
Given a reference type <T>, the Implicit_Dereference aspect is inherited
by descendants of type <T> if not overridden.  If a descendant type
constrains the value of the reference discriminant of <T> by a new
discriminant, that new discriminant is the reference discriminant of the
descendant.  If the descendant type constrains the value of the
reference discriminant of <T> by an expression other than the name of a
new discriminant, a generalized_reference that identifies an object of
the descendant type denotes the object or subprogram designated by the
value of this constraining expression.

                          _Dynamic Semantics_

8/3
The evaluation of a generalized_reference consists of the evaluation of
the <reference_object_>name and a determination of the object or
subprogram designated by the reference discriminant of the named
reference object.  A check is made that the value of the reference
discriminant is not the null access value.  Constraint_Error is raised
if this check fails.  The generalized_reference denotes the object or
subprogram designated by the value of the reference discriminant of the
named reference object.

                              _Examples_

9/3
     type Barrel is tagged ...  -- <holds objects of type Element>

10/3
     type Ref_Element(Data : access Element) is limited private
        with Implicit_Dereference => Data;
           -- <This Ref_Element type is a "reference" type.>
           -- <"Data" is its reference discriminant.>

11/3
     function Find (B : aliased in out Barrel; Key : String) return Ref_Element;
        -- <Return a reference to an element of a barrel.>

12/3
     B: aliased Barrel;

13/3
     ...

14/3
     Find (B, "grape") := Element'(...);  -- <Assign through a reference.>

15/3
     -- <This is equivalent to:>
     Find (B, "grape").Data.all := Element'(...);


File: arm2012.info,  Node: 4.1.6,  Prev: 4.1.5,  Up: 4.1

4.1.6 User-Defined Indexing
---------------------------

                          _Static Semantics_

1/3
Given a tagged type <T>, the following type-related, operational aspects
may be specified:

2/3
Constant_Indexing
               This aspect shall be specified by a name that denotes one
               or more functions declared immediately within the same
               declaration list in which <T> is declared.  All such
               functions shall have at least two parameters, the first
               of which is of type <T> or <T>'Class, or is an
               access-to-constant parameter with designated type <T> or
               <T>'Class.

3/3
Variable_Indexing
               This aspect shall be specified by a name that denotes one
               or more functions declared immediately within the same
               declaration list in which <T> is declared.  All such
               functions shall have at least two parameters, the first
               of which is of type <T> or <T>'Class, or is an access
               parameter with designated type <T> or <T>'Class.  All
               such functions shall have a return type that is a
               reference type (see *note 4.1.5::), whose reference
               discriminant is of an access-to-variable type.

4/4
These aspects are inherited by descendants of <T> (including the
class-wide type <T>'Class).

5/3
An <indexable container type> is (a view of) a tagged type with at least
one of the aspects Constant_Indexing or Variable_Indexing specified.  An
<indexable container object> is an object of an indexable container
type.  A generalized_indexing is a name that denotes the result of
calling a function named by a Constant_Indexing or Variable_Indexing
aspect.

5.1/4
The Constant_Indexing and Variable_Indexing aspects are nonoverridable
(see *note 13.1.1::).

<Paragraphs 6 through 9 were deleted.>

                               _Syntax_

10/3
     generalized_indexing ::= <indexable_container_object_>prefix 
     actual_parameter_part

                        _Name Resolution Rules_

11/3
The expected type for the <indexable_container_object_>prefix of a
generalized_indexing is any indexable container type.

12/3
If the Constant_Indexing aspect is specified for the type of the
<indexable_container_object_>prefix of a generalized_indexing, then the
generalized_indexing is interpreted as a <constant indexing> under the
following circumstances:

13/3
   * when the Variable_Indexing aspect is not specified for the type of
     the <indexable_container_object_>prefix;

14/3
   * when the <indexable_container_object_>prefix denotes a constant;

15/3
   * when the generalized_indexing is used within a primary where a name
     denoting a constant is permitted.

16/3
Otherwise, the generalized_indexing is interpreted as a <variable
indexing>.

17/3
When a generalized_indexing is interpreted as a constant (or variable)
indexing, it is equivalent to a call on a prefixed view of one of the
functions named by the Constant_Indexing (or Variable_Indexing) aspect
of the type of the <indexable_container_object_>prefix with the given
actual_parameter_part, and with the <indexable_container_object_>prefix
as the prefix of the prefixed view.

     NOTES

18/4
     6  The Constant_Indexing and Variable_Indexing aspects cannot be
     redefined when inherited for a derived type, but the functions that
     they denote can be modified by overriding or overloading.

                              _Examples_

19/3
     type Indexed_Barrel is tagged ...
       with Variable_Indexing => Find;
       -- <Indexed_Barrel is an indexable container type,>
       -- <Find is the generalized indexing operation.>

20/3
     function Find (B : aliased in out Indexed_Barrel; Key : String) return Ref_Element;
        -- <Return a reference to an element of a barrel (see *note 4.1.5::).>

21/3
     IB: aliased Indexed_Barrel;

22/3
     -- <All of the following calls are then equivalent:>
     Find (IB,"pear").Data.all := Element'(...); -- <Traditional call>
     IB.Find ("pear").Data.all := Element'(...); -- <Call of prefixed view>
     IB.Find ("pear")          := Element'(...); -- <Implicit dereference (see *note 4.1.5::)>
     IB      ("pear")          := Element'(...); -- <Implicit indexing and dereference>
     IB      ("pear").Data.all := Element'(...); -- <Implicit indexing only>


File: arm2012.info,  Node: 4.2,  Next: 4.3,  Prev: 4.1,  Up: 4

4.2 Literals
============

1
A <literal> represents a value literally, that is, by means of notation
suited to its kind.  A literal is either a numeric_literal, a
character_literal, the literal null, or a string_literal.  

                        _Name Resolution Rules_

2/2
<This paragraph was deleted.>

3
For a name that consists of a character_literal, either its expected
type shall be a single character type, in which case it is interpreted
as a parameterless function_call that yields the corresponding value of
the character type, or its expected profile shall correspond to a
parameterless function with a character result type, in which case it is
interpreted as the name of the corresponding parameterless function
declared as part of the character type's definition (see *note 3.5.1::).
In either case, the character_literal denotes the
enumeration_literal_specification.

4
The expected type for a primary that is a string_literal shall be a
single string type.

                           _Legality Rules_

5
A character_literal that is a name shall correspond to a
defining_character_literal of the expected type, or of the result type
of the expected profile.

6
For each character of a string_literal with a given expected string
type, there shall be a corresponding defining_character_literal of the
component type of the expected string type.

7/2
<This paragraph was deleted.>

                          _Static Semantics_

8/2
An integer literal is of type <universal_integer>.  A real literal is of
type <universal_real>.  The literal null is of type <universal_access>.

                          _Dynamic Semantics_

9
The evaluation of a numeric literal, or the literal null, yields the
represented value.

10
The evaluation of a string_literal that is a primary yields an array
value containing the value of each character of the sequence of
characters of the string_literal, as defined in *note 2.6::.  The bounds
of this array value are determined according to the rules for
positional_array_aggregates (see *note 4.3.3::), except that for a null
string literal, the upper bound is the predecessor of the lower bound.

11
For the evaluation of a string_literal of type <T>, a check is made that
the value of each character of the string_literal belongs to the
component subtype of <T>.  For the evaluation of a null string literal,
a check is made that its lower bound is greater than the lower bound of
the base range of the index type.  The exception Constraint_Error is
raised if either of these checks fails.

     NOTES

12
     7  Enumeration literals that are identifiers rather than
     character_literals follow the normal rules for identifiers when
     used in a name (see *note 4.1:: and *note 4.1.3::).
     Character_literals used as selector_names follow the normal rules
     for expanded names (see *note 4.1.3::).

                              _Examples_

13
<Examples of literals:>

14
     3.14159_26536    --<  a real literal>
     1_345    --<  an integer literal>
     'A'    --<  a character literal>
     "Some Text"    --<  a string literal >


File: arm2012.info,  Node: 4.3,  Next: 4.4,  Prev: 4.2,  Up: 4

4.3 Aggregates
==============

1
An <aggregate> combines component values into a composite value of an
array type, record type, or record extension.  

                               _Syntax_

2
     aggregate ::= record_aggregate | extension_aggregate | 
     array_aggregate

                        _Name Resolution Rules_

3/2
The expected type for an aggregate shall be a single array type, record
type, or record extension.

                           _Legality Rules_

4
An aggregate shall not be of a class-wide type.

                          _Dynamic Semantics_

5
For the evaluation of an aggregate, an anonymous object is created and
values for the components or ancestor part are obtained (as described in
the subsequent subclause for each kind of the aggregate) and assigned
into the corresponding components or ancestor part of the anonymous
object.  Obtaining the values and the assignments occur in an arbitrary
order.  The value of the aggregate is the value of this object.

6
If an aggregate is of a tagged type, a check is made that its value
belongs to the first subtype of the type.  Constraint_Error is raised if
this check fails.

* Menu:

* 4.3.1 ::    Record Aggregates
* 4.3.2 ::    Extension Aggregates
* 4.3.3 ::    Array Aggregates


File: arm2012.info,  Node: 4.3.1,  Next: 4.3.2,  Up: 4.3

4.3.1 Record Aggregates
-----------------------

1
In a record_aggregate, a value is specified for each component of the
record or record extension value, using either a named or a positional
association.

                               _Syntax_

2
     record_aggregate ::= (record_component_association_list)

3
     record_component_association_list ::=
         record_component_association {, record_component_association}
       | null record

4/2
     record_component_association ::=
         [component_choice_list =>] expression
        | component_choice_list => <>

5
     component_choice_list ::=
          <component_>selector_name {| <component_>selector_name}
        | others

6
     A record_component_association (*note 4.3.1: S0109.) is a <named
     component association> if it has a component_choice_list;
     otherwise, it is a <positional component association>.  Any
     positional component associations shall precede any named component
     associations.  If there is a named association with a
     component_choice_list of others, it shall come last.

7
     In the record_component_association_list (*note 4.3.1: S0108.) for
     a record_aggregate (*note 4.3.1: S0107.), if there is only one
     association, it shall be a named association.

                        _Name Resolution Rules_

8/2
The expected type for a record_aggregate shall be a single record type
or record extension.

9
For the record_component_association_list (*note 4.3.1: S0108.) of a
record_aggregate (*note 4.3.1: S0107.), all components of the composite
value defined by the aggregate are <needed>; for the association list of
an extension_aggregate, only those components not determined by the
ancestor expression or subtype are needed (see *note 4.3.2::).  Each
selector_name (*note 4.1.3: S0099.) in a record_component_association
(*note 4.3.1: S0109.) shall denote a needed component (including
possibly a discriminant).

10
The expected type for the expression of a record_component_association
(*note 4.3.1: S0109.) is the type of the <associated> component(s); the
associated component(s) are as follows:

11
   * For a positional association, the component (including possibly a
     discriminant) in the corresponding relative position (in the
     declarative region of the type), counting only the needed
     components;

12
   * For a named association with one or more
     <component_>selector_names, the named component(s);

13
   * For a named association with the reserved word others, all needed
     components that are not associated with some previous association.

                           _Legality Rules_

14
If the type of a record_aggregate is a record extension, then it shall
be a descendant of a record type, through one or more record extensions
(and no private extensions).

15/3
The reserved words null record may appear only if there are no
components needed in a given record_component_association_list (*note
4.3.1: S0108.).

16/4
Each record_component_association other than an others choice with a <>
shall have at least one associated component, and each needed component
shall be associated with exactly one record_component_association (*note
4.3.1: S0109.).  If a record_component_association (*note 4.3.1: S0109.)
with an expression has two or more associated components, all of them
shall be of the same type, or all of them shall be of anonymous access
types whose subtypes statically match.  In addition, Legality Rules are
enforced separately for each associated component.

17/3
The value of a discriminant that governs a variant_part <P> shall be
given by a static expression, unless <P> is nested within a variant <V>
that is not selected by the discriminant value governing the
variant_part enclosing <V>.

17.1/2
A record_component_association for a discriminant without a
default_expression shall have an expression rather than <>.

                          _Dynamic Semantics_

18
The evaluation of a record_aggregate consists of the evaluation of the
record_component_association_list (*note 4.3.1: S0108.).

19
For the evaluation of a record_component_association_list (*note 4.3.1:
S0108.), any per-object constraints (see *note 3.8::) for components
specified in the association list are elaborated and any expressions are
evaluated and converted to the subtype of the associated component.  Any
constraint elaborations and expression evaluations (and conversions)
occur in an arbitrary order, except that the expression for a
discriminant is evaluated (and converted) prior to the elaboration of
any per-object constraint that depends on it, which in turn occurs prior
to the evaluation and conversion of the expression for the component
with the per-object constraint.

19.1/2
For a record_component_association with an expression, the expression
defines the value for the associated component(s).  For a
record_component_association with <>, if the component_declaration has a
default_expression, that default_expression defines the value for the
associated component(s); otherwise, the associated component(s) are
initialized by default as for a stand-alone object of the component
subtype (see *note 3.3.1::).

20
The expression of a record_component_association is evaluated (and
converted) once for each associated component.

     NOTES

21
     8  For a record_aggregate with positional associations, expressions
     specifying discriminant values appear first since the
     known_discriminant_part is given first in the declaration of the
     type; they have to be in the same order as in the
     known_discriminant_part.

                              _Examples_

22
<Example of a record aggregate with positional associations:>

23
     (4, July, 1776)                                       --<  see *note 3.8:: >

24
<Examples of record aggregates with named associations:>

25
     (Day => 4, Month => July, Year => 1776)
     (Month => July, Day => 4, Year => 1776)

26
     (Disk, Closed, Track => 5, Cylinder => 12)            --<  see *note 3.8.1::>
     (Unit => Disk, Status => Closed, Cylinder => 9, Track => 1)

27/2
<Examples of component associations with several choices:>

28
     (Value => 0, Succ|Pred => new Cell'(0, null, null))    --<  see *note 3.10.1::>

29
      --<  The allocator is evaluated twice: Succ and Pred designate different cells>

29.1/2
     (Value => 0, Succ|Pred => <>)    --<  see *note 3.10.1::>

29.2/2
      --<  Succ and Pred will be set to null>

30
<Examples of record aggregates for tagged types (see *note 3.9:: and
*note 3.9.1::):>

31
     Expression'(null record)
     Literal'(Value => 0.0)
     Painted_Point'(0.0, Pi/2.0, Paint => Red)


File: arm2012.info,  Node: 4.3.2,  Next: 4.3.3,  Prev: 4.3.1,  Up: 4.3

4.3.2 Extension Aggregates
--------------------------

1
An extension_aggregate specifies a value for a type that is a record
extension by specifying a value or subtype for an ancestor of the type,
followed by associations for any components not determined by the
ancestor_part.

                               _Syntax_

2
     extension_aggregate ::=
         (ancestor_part with record_component_association_list)

3
     ancestor_part ::= expression | subtype_mark

                        _Name Resolution Rules_

4/2
The expected type for an extension_aggregate shall be a single type that
is a record extension.  If the ancestor_part is an expression, it is
expected to be of any tagged type.

                           _Legality Rules_

5/3
If the ancestor_part is a subtype_mark, it shall denote a specific
tagged subtype.  If the ancestor_part is an expression, it shall not be
dynamically tagged.  The type of the extension_aggregate shall be a
descendant of the type of the ancestor_part (the <ancestor> type),
through one or more record extensions (and no private extensions).  If
the ancestor_part is a subtype_mark, the view of the ancestor type from
which the type is descended (see *note 7.3.1::) shall not have unknown
discriminants.

5.1/3
If the type of the ancestor_part is limited and at least one component
is needed in the record_component_association_list, then the
ancestor_part shall not be:

5.2/3
   * a call to a function with an unconstrained result subtype; nor

5.3/3
   * a parenthesized or qualified expression whose operand would violate
     this rule; nor

5.4/3
   * a conditional_expression having at least one <dependent_>expression
     that would violate this rule.

                          _Static Semantics_

6
For the record_component_association_list (*note 4.3.1: S0108.) of an
extension_aggregate (*note 4.3.2: S0111.), the only components <needed>
are those of the composite value defined by the aggregate that are not
inherited from the type of the ancestor_part (*note 4.3.2: S0112.), plus
any inherited discriminants if the ancestor_part (*note 4.3.2: S0112.)
is a subtype_mark (*note 3.2.2: S0028.) that denotes an unconstrained
subtype.

                          _Dynamic Semantics_

7
For the evaluation of an extension_aggregate, the
record_component_association_list (*note 4.3.1: S0108.) is evaluated.
If the ancestor_part is an expression, it is also evaluated; if the
ancestor_part is a subtype_mark, the components of the value of the
aggregate not given by the record_component_association_list (*note
4.3.1: S0108.) are initialized by default as for an object of the
ancestor type.  Any implicit initializations or evaluations are
performed in an arbitrary order, except that the expression for a
discriminant is evaluated prior to any other evaluation or
initialization that depends on it.

8/3
If the type of the ancestor_part has discriminants and the ancestor_part
is not a subtype_mark that denotes an unconstrained subtype, then a
check is made that each discriminant determined by the ancestor_part has
the value specified for a corresponding discriminant, if any, either in
the record_component_association_list (*note 4.3.1: S0108.), or in the
derived_type_definition for some ancestor of the type of the
extension_aggregate.  Constraint_Error is raised if this check fails.

     NOTES

9
     9  If all components of the value of the extension_aggregate are
     determined by the ancestor_part, then the
     record_component_association_list (*note 4.3.1: S0108.) is required
     to be simply null record.

10
     10  If the ancestor_part is a subtype_mark, then its type can be
     abstract.  If its type is controlled, then as the last step of
     evaluating the aggregate, the Initialize procedure of the ancestor
     type is called, unless the Initialize procedure is abstract (see
     *note 7.6::).

                              _Examples_

11
<Examples of extension aggregates (for types defined in *note 3.9.1::):>

12
     Painted_Point'(Point with Red)
     (Point'(P) with Paint => Black)

13
     (Expression with Left => 1.2, Right => 3.4)
     Addition'(Binop with null record)
                  --< presuming Binop is of type Binary_Operation>


File: arm2012.info,  Node: 4.3.3,  Prev: 4.3.2,  Up: 4.3

4.3.3 Array Aggregates
----------------------

1
In an array_aggregate, a value is specified for each component of an
array, either positionally or by its index.  For a
positional_array_aggregate, the components are given in increasing-index
order, with a final others, if any, representing any remaining
components.  For a named_array_aggregate, the components are identified
by the values covered by the discrete_choices.

                               _Syntax_

2
     array_aggregate ::=
       positional_array_aggregate | named_array_aggregate

3/2
     positional_array_aggregate ::=
         (expression, expression {, expression})
       | (expression {, expression}, others => expression)
       | (expression {, expression}, others => <>)

4
     named_array_aggregate ::=
         (array_component_association {, array_component_association})

5/2
     array_component_association ::=
         discrete_choice_list => expression
       | discrete_choice_list => <>

6
An <n-dimensional> array_aggregate is one that is written as n levels of
nested array_aggregates (or at the bottom level, equivalent
string_literals).  For the multidimensional case (n >= 2) the
array_aggregates (or equivalent string_literals) at the n-1 lower levels
are called <subaggregate>s of the enclosing n-dimensional
array_aggregate.  The expressions of the bottom level subaggregates (or
of the array_aggregate itself if one-dimensional) are called the <array
component expressions> of the enclosing n-dimensional array_aggregate.

                        _Name Resolution Rules_

7/2
The expected type for an array_aggregate (that is not a subaggregate)
shall be a single array type.  The component type of this array type is
the expected type for each array component expression of the
array_aggregate.

8
The expected type for each discrete_choice in any discrete_choice_list
of a named_array_aggregate is the type of the <corresponding index>; the
corresponding index for an array_aggregate that is not a subaggregate is
the first index of its type; for an (n-m)-dimensional subaggregate
within an array_aggregate of an n-dimensional type, the corresponding
index is the index in position m+1.

                           _Legality Rules_

9
An array_aggregate of an n-dimensional array type shall be written as an
n-dimensional array_aggregate.

10
An others choice is allowed for an array_aggregate only if an
<applicable index constraint> applies to the array_aggregate.  An
applicable index constraint is a constraint provided by certain contexts
where an array_aggregate is permitted that can be used to determine the
bounds of the array value specified by the aggregate.  Each of the
following contexts (and none other) defines an applicable index
constraint:

11/4
   * For an explicit_actual_parameter, an
     explicit_generic_actual_parameter, the expression of a return
     statement, the return expression of an expression function, the
     initialization expression in an object_declaration (*note 3.3.1:
     S0032.), or a default_expression (*note 3.7: S0063.) (for a
     parameter or a component), when the nominal subtype of the
     corresponding formal parameter, generic formal parameter, function
     return object, expression function return object, object, or
     component is a constrained array subtype, the applicable index
     constraint is the constraint of the subtype;

12
   * For the expression of an assignment_statement where the name
     denotes an array variable, the applicable index constraint is the
     constraint of the array variable;

13
   * For the operand of a qualified_expression whose subtype_mark
     denotes a constrained array subtype, the applicable index
     constraint is the constraint of the subtype;

14
   * For a component expression in an aggregate, if the component's
     nominal subtype is a constrained array subtype, the applicable
     index constraint is the constraint of the subtype;

15/3
   * For a parenthesized expression, the applicable index constraint is
     that, if any, defined for the expression;

15.1/3
   * For a conditional_expression, the applicable index constraint for
     each <dependent_>expression is that, if any, defined for the
     conditional_expression.

16
The applicable index constraint <applies> to an array_aggregate that
appears in such a context, as well as to any subaggregates thereof.  In
the case of an explicit_actual_parameter (or default_expression) for a
call on a generic formal subprogram, no applicable index constraint is
defined.

17/3
The discrete_choice_list of an array_component_association is allowed to
have a discrete_choice that is a nonstatic choice_expression or that is
a subtype_indication or range that defines a nonstatic or null range,
only if it is the single discrete_choice of its discrete_choice_list,
and there is only one array_component_association in the
array_aggregate.

18/3
In a named_array_aggregate where all discrete_choices are static, no two
discrete_choices are allowed to cover the same value (see *note
3.8.1::); if there is no others choice, the discrete_choices taken
together shall exactly cover a contiguous sequence of values of the
corresponding index type.

19
A bottom level subaggregate of a multidimensional array_aggregate of a
given array type is allowed to be a string_literal only if the component
type of the array type is a character type; each character of such a
string_literal shall correspond to a defining_character_literal of the
component type.

                          _Static Semantics_

20
A subaggregate that is a string_literal is equivalent to one that is a
positional_array_aggregate of the same length, with each expression
being the character_literal for the corresponding character of the
string_literal.

                          _Dynamic Semantics_

21
The evaluation of an array_aggregate of a given array type proceeds in
two steps:

22
     1.  Any discrete_choices of this aggregate and of its subaggregates
     are evaluated in an arbitrary order, and converted to the
     corresponding index type; 

23
     2.  The array component expressions of the aggregate are evaluated
     in an arbitrary order and their values are converted to the
     component subtype of the array type; an array component expression
     is evaluated once for each associated component.  

23.1/4
Each expression in an array_component_association defines the value for
the associated component(s).  For an array_component_association with
<>, the associated component(s) are initialized to the
Default_Component_Value of the array type if this aspect has been
specified for the array type; otherwise, they are initialized by default
as for a stand-alone object of the component subtype (see *note
3.3.1::).

24
The bounds of the index range of an array_aggregate (including a
subaggregate) are determined as follows:

25
   * For an array_aggregate with an others choice, the bounds are those
     of the corresponding index range from the applicable index
     constraint;

26
   * For a positional_array_aggregate (or equivalent string_literal)
     without an others choice, the lower bound is that of the
     corresponding index range in the applicable index constraint, if
     defined, or that of the corresponding index subtype, if not; in
     either case, the upper bound is determined from the lower bound and
     the number of expressions (or the length of the string_literal);

27
   * For a named_array_aggregate without an others choice, the bounds
     are determined by the smallest and largest index values covered by
     any discrete_choice_list.

28
For an array_aggregate, a check is made that the index range defined by
its bounds is compatible with the corresponding index subtype.

29/3
For an array_aggregate with an others choice, a check is made that no
expression or <> is specified for an index value outside the bounds
determined by the applicable index constraint.

30
For a multidimensional array_aggregate, a check is made that all
subaggregates that correspond to the same index have the same bounds.

31
The exception Constraint_Error is raised if any of the above checks
fail.

     NOTES

32/3
     11  In an array_aggregate, positional notation may only be used
     with two or more expressions; a single expression in parentheses is
     interpreted as a parenthesized expression.  A
     named_array_aggregate, such as (1 => X), may be used to specify an
     array with a single component.

                              _Examples_

33
<Examples of array aggregates with positional associations:>

34
     (7, 9, 5, 1, 3, 2, 4, 8, 6, 0)
     Table'(5, 8, 4, 1, others => 0)  --<  see *note 3.6:: >

35
<Examples of array aggregates with named associations:>

36
     (1 .. 5 => (1 .. 8 => 0.0))      --<  two-dimensional>
     (1 .. N => new Cell)             --<  N new cells, in particular for N = 0>

37
     Table'(2 | 4 | 10 => 1, others => 0)
     Schedule'(Mon .. Fri => True,  others => False)  --<  see *note 3.6::>
     Schedule'(Wed | Sun  => False, others => True)
     Vector'(1 => 2.5)                                --<  single-component vector>

38
<Examples of two-dimensional array aggregates:>

39
     --< Three aggregates for the same value of subtype Matrix(1..2,1..3) (see *note 3.6::):>

40
     ((1.1, 1.2, 1.3), (2.1, 2.2, 2.3))
     (1 => (1.1, 1.2, 1.3), 2 => (2.1, 2.2, 2.3))
     (1 => (1 => 1.1, 2 => 1.2, 3 => 1.3), 2 => (1 => 2.1, 2 => 2.2, 3 => 2.3))

41
<Examples of aggregates as initial values:>

42
     A : Table := (7, 9, 5, 1, 3, 2, 4, 8, 6, 0);        --< A(1)=7, A(10)=0>
     B : Table := (2 | 4 | 10 => 1, others => 0);        --< B(1)=0, B(10)=1>
     C : constant Matrix := (1 .. 5 => (1 .. 8 => 0.0)); --< C'Last(1)=5, C'Last(2)=8>

43
     D : Bit_Vector(M .. N) := (M .. N => True);         --< see *note 3.6::>
     E : Bit_Vector(M .. N) := (others => True);
     F : String(1 .. 1) := (1 => 'F');  --< a one component aggregate: same as "F">

44/2
<Example of an array aggregate with defaulted others choice and with an
applicable index constraint provided by an enclosing record aggregate:>

45/2
     Buffer'(Size => 50, Pos => 1, Value => String'('x', others => <>))  --< see *note 3.7::>


File: arm2012.info,  Node: 4.4,  Next: 4.5,  Prev: 4.3,  Up: 4

4.4 Expressions
===============

1/3
An <expression> is a formula that defines the computation or retrieval
of a value.  In this International Standard, the term "expression"
refers to a construct of the syntactic category expression or of any of
the following categories: choice_expression, choice_relation, relation,
simple_expression, term, factor, primary, conditional_expression,
quantified_expression.  

                               _Syntax_

2
     expression ::=
          relation {and relation}    | relation {and then relation}
        | relation {or relation}    | relation {or else relation}
        | relation {xor relation}

2.1/3
     choice_expression ::=
          choice_relation {and choice_relation}
        | choice_relation {or choice_relation}
        | choice_relation {xor choice_relation}
        | choice_relation {and then choice_relation}
        | choice_relation {or else choice_relation}

2.2/3
     choice_relation ::=
          simple_expression [relational_operator simple_expression]

3/4
     relation ::=
          simple_expression [relational_operator simple_expression]
        | <tested_>simple_expression [not] in membership_choice_list
        | raise_expression

3.1/3
     membership_choice_list ::= membership_choice {| membership_choice}

3.2/4
     membership_choice ::= <choice_>simple_expression | range | 
     subtype_mark

4
     simple_expression ::= [unary_adding_operator] term {
     binary_adding_operator term}

5
     term ::= factor {multiplying_operator factor}

6
     factor ::= primary [** primary] | abs primary | not primary

7/3
     primary ::=
        numeric_literal | null | string_literal | aggregate
      | name | allocator | (expression)
      | (conditional_expression) | (quantified_expression)

                        _Name Resolution Rules_

8
A name used as a primary shall resolve to denote an object or a value.

                          _Static Semantics_

9
Each expression has a type; it specifies the computation or retrieval of
a value of that type.

                          _Dynamic Semantics_

10
The value of a primary that is a name denoting an object is the value of
the object.

                     _Implementation Permissions_

11
For the evaluation of a primary that is a name denoting an object of an
unconstrained numeric subtype, if the value of the object is outside the
base range of its type, the implementation may either raise
Constraint_Error or return the value of the object.

                              _Examples_

12
<Examples of primaries:>

13
     4.0                --<  real literal>
     Pi                 --<  named number>
     (1 .. 10 => 0)     --<  array aggregate>
     Sum                --<  variable>
     Integer'Last       --<  attribute>
     Sine(X)            --<  function call>
     Color'(Blue)       --<  qualified expression>
     Real(M*N)          --<  conversion>
     (Line_Count + 10)  --<  parenthesized expression >

14
<Examples of expressions:>

15/2
     Volume                      --< primary>
     not Destroyed               --< factor>
     2*Line_Count                --< term>
     -4.0                        --< simple expression>
     -4.0 + A                    --< simple expression>
     B**2 - 4.0*A*C              --< simple expression>
     R*Sin([Unicode 952])*Cos([Unicode 966])             --< simple expression>
     Password(1 .. 3) = "Bwv"    --< relation>
     Count in Small_Int          --< relation>
     Count not in Small_Int      --< relation>
     Index = 0 or Item_Hit       --< expression>
     (Cold and Sunny) or Warm    --< expression (parentheses are required)>
     A**(B**C)                   --< expression (parentheses are required)>


File: arm2012.info,  Node: 4.5,  Next: 4.6,  Prev: 4.4,  Up: 4

4.5 Operators and Expression Evaluation
=======================================

1
The language defines the following six categories of operators (given in
order of increasing precedence).  The corresponding operator_symbols,
and only those, can be used as designators in declarations of functions
for user-defined operators.  See *note 6.6::, "*note 6.6:: Overloading
of Operators".

                               _Syntax_

2
     logical_operator ::=     and | or  | xor

3
     relational_operator ::=     =   | /=  | <   | <= | > | >=

4
     binary_adding_operator ::=     +   | -   | &

5
     unary_adding_operator ::=     +   | -

6
     multiplying_operator ::=     *   | /   | mod | rem

7
     highest_precedence_operator ::=     **  | abs | not

                          _Static Semantics_

8
For a sequence of operators of the same precedence level, the operators
are associated with their operands in textual order from left to right.
Parentheses can be used to impose specific associations.

9
For each form of type definition, certain of the above operators are
<predefined>; that is, they are implicitly declared immediately after
the type definition.  For each such implicit operator declaration, the
parameters are called Left and Right for <binary> operators; the single
parameter is called Right for <unary> operators.  An expression of the
form X op Y, where op is a binary operator, is equivalent to a
function_call of the form "op"(X, Y). An expression of the form op Y,
where op is a unary operator, is equivalent to a function_call of the
form "op"(Y). The predefined operators and their effects are described
in subclauses *note 4.5.1:: through *note 4.5.6::.

                          _Dynamic Semantics_

10
The predefined operations on integer types either yield the
mathematically correct result or raise the exception Constraint_Error.
For implementations that support the Numerics Annex, the predefined
operations on real types yield results whose accuracy is defined in
*note Annex G::, or raise the exception Constraint_Error.

                     _Implementation Requirements_

11
The implementation of a predefined operator that delivers a result of an
integer or fixed point type may raise Constraint_Error only if the
result is outside the base range of the result type.

12
The implementation of a predefined operator that delivers a result of a
floating point type may raise Constraint_Error only if the result is
outside the safe range of the result type.

                     _Implementation Permissions_

13
For a sequence of predefined operators of the same precedence level (and
in the absence of parentheses imposing a specific association), an
implementation may impose any association of the operators with operands
so long as the result produced is an allowed result for the
left-to-right association, but ignoring the potential for failure of
language-defined checks in either the left-to-right or chosen order of
association.

     NOTES

14
     12  The two operands of an expression of the form X op Y, where op
     is a binary operator, are evaluated in an arbitrary order, as for
     any function_call (see *note 6.4::).

                              _Examples_

15
<Examples of precedence:>

16
     not Sunny or Warm    --<  same as (not Sunny) or Warm>
     X > 4.0 and Y > 0.0  --<  same as (X > 4.0) and (Y > 0.0)>

17
     -4.0*A**2            --<  same as -(4.0 * (A**2))>
     abs(1 + A) + B       --<  same as (abs (1 + A)) + B>
     Y**(-3)              --<  parentheses are necessary>
     A / B * C            --<  same as (A/B)*C>
     A + (B + C)          --<  evaluate B + C before adding it to A >

* Menu:

* 4.5.1 ::    Logical Operators and Short-circuit Control Forms
* 4.5.2 ::    Relational Operators and Membership Tests
* 4.5.3 ::    Binary Adding Operators
* 4.5.4 ::    Unary Adding Operators
* 4.5.5 ::    Multiplying Operators
* 4.5.6 ::    Highest Precedence Operators
* 4.5.7 ::    Conditional Expressions
* 4.5.8 ::    Quantified Expressions


File: arm2012.info,  Node: 4.5.1,  Next: 4.5.2,  Up: 4.5

4.5.1 Logical Operators and Short-circuit Control Forms
-------------------------------------------------------

                        _Name Resolution Rules_

1
An expression consisting of two relations connected by and then or or
else (a <short-circuit control form>) shall resolve to be of some
boolean type; the expected type for both relations is that same boolean
type.

                          _Static Semantics_

2
The following logical operators are predefined for every boolean type
<T>, for every modular type <T>, and for every one-dimensional array
type <T> whose component type is a boolean type: 

3
     function "and"(Left, Right : <T>) return <T>
     function "or" (Left, Right : <T>) return <T>
     function "xor"(Left, Right : <T>) return <T>

4
For boolean types, the predefined logical operators and, or, and xor
perform the conventional operations of conjunction, inclusive
disjunction, and exclusive disjunction, respectively.

5
For modular types, the predefined logical operators are defined on a
bit-by-bit basis, using the binary representation of the value of the
operands to yield a binary representation for the result, where zero
represents False and one represents True.  If this result is outside the
base range of the type, a final subtraction by the modulus is performed
to bring the result into the base range of the type.

6
The logical operators on arrays are performed on a
component-by-component basis on matching components (as for equality --
see *note 4.5.2::), using the predefined logical operator for the
component type.  The bounds of the resulting array are those of the left
operand.

                          _Dynamic Semantics_

7
The short-circuit control forms and then and or else deliver the same
result as the corresponding predefined and and or operators for boolean
types, except that the left operand is always evaluated first, and the
right operand is not evaluated if the value of the left operand
determines the result.

8
For the logical operators on arrays, a check is made that for each
component of the left operand there is a matching component of the right
operand, and vice versa.  Also, a check is made that each component of
the result belongs to the component subtype.  The exception
Constraint_Error is raised if either of the above checks fails.

     NOTES

9
     13  The conventional meaning of the logical operators is given by
     the following truth table:

10
               A     B   (A and B)   (A or B)   (A xor B)

             True     True     True     True     False
             True     False    False    True     True
             False    True     False    True     True
             False    False    False    False    False

                              _Examples_

11
<Examples of logical operators:>

12
     Sunny or Warm
     Filter(1 .. 10) and Filter(15 .. 24)   --<   see *note 3.6.1:: >

13
<Examples of short-circuit control forms:>

14
     Next_Car.Owner /= null and then Next_Car.Owner.Age > 25   --<   see *note 3.10.1::>
     N = 0 or else A(N) = Hit_Value


File: arm2012.info,  Node: 4.5.2,  Next: 4.5.3,  Prev: 4.5.1,  Up: 4.5

4.5.2 Relational Operators and Membership Tests
-----------------------------------------------

1
The <equality operators> = (equals) and /= (not equals) are predefined
for nonlimited types.  The other relational_operators are the <ordering
operators> < (less than), <= (less than or equal), > (greater than), and
>= (greater than or equal).  The ordering operators are predefined for
scalar types, and for <discrete array types>, that is, one-dimensional
array types whose components are of a discrete type.

2/3
A <membership test>, using in or not in, determines whether or not a
value belongs to any given subtype or range, is equal to any given
value, has a tag that identifies a type that is covered by a given type,
or is convertible to and has an accessibility level appropriate for a
given access type.  Membership tests are allowed for all types.

                        _Name Resolution Rules_

3/3
The <tested type> of a membership test is determined by the
membership_choices of the membership_choice_list.  Either all
membership_choices of the membership_choice_list shall resolve to the
same type, which is the tested type; or each membership_choice shall be
of an elementary type, and the tested type shall be covered by each of
these elementary types.

3.1/4
If the tested type is tagged, then the <tested_>simple_expression shall
resolve to be of a type that is convertible (see *note 4.6::) to the
tested type; if untagged, the expected type for the
<tested_>simple_expression is the tested type.  The expected type of a
<choice_>simple_expression in a membership_choice, and of a
simple_expression of a range in a membership_choice, is the tested type
of the membership operation.

                           _Legality Rules_

4/4
For a membership test, if the <tested_>simple_expression is of a tagged
class-wide type, then the tested type shall be (visibly) tagged.

4.1/4
If a membership test includes one or more <choice_>simple_expressions
and the tested type of the membership test is limited, then the tested
type of the membership test shall have a visible primitive equality
operator.

                          _Static Semantics_

5
The result type of a membership test is the predefined type Boolean.

6
The equality operators are predefined for every specific type <T> that
is not limited, and not an anonymous access type, with the following
specifications:

7
     function "=" (Left, Right : <T>) return Boolean
     function "/="(Left, Right : <T>) return Boolean

7.1/2
The following additional equality operators for the <universal_access>
type are declared in package Standard for use with anonymous access
types:

7.2/2
     function "=" (Left, Right : <universal_access>) return Boolean
     function "/="(Left, Right : <universal_access>) return Boolean

8
The ordering operators are predefined for every specific scalar type
<T>, and for every discrete array type <T>, with the following
specifications:

9
     function "<" (Left, Right : <T>) return Boolean
     function "<="(Left, Right : <T>) return Boolean
     function ">" (Left, Right : <T>) return Boolean
     function ">="(Left, Right : <T>) return Boolean

                        _Name Resolution Rules_

9.1/2
At least one of the operands of an equality operator for
<universal_access> shall be of a specific anonymous access type.  Unless
the predefined equality operator is identified using an expanded name
with prefix denoting the package Standard, neither operand shall be of
an access-to-object type whose designated type is <D> or <D>'Class,
where <D> has a user-defined primitive equality operator such that:

9.2/2
   * its result type is Boolean;

9.3/3
   * it is declared immediately within the same declaration list as <D>
     or any partial or incomplete view of <D>; and

9.4/2
   * at least one of its operands is an access parameter with designated
     type <D>.

                           _Legality Rules_

9.5/2
At least one of the operands of the equality operators for
<universal_access> shall be of type <universal_access>, or both shall be
of access-to-object types, or both shall be of access-to-subprogram
types.  Further:

9.6/2
   * When both are of access-to-object types, the designated types shall
     be the same or one shall cover the other, and if the designated
     types are elementary or array types, then the designated subtypes
     shall statically match;

9.7/2
   * When both are of access-to-subprogram types, the designated
     profiles shall be subtype conformant.

9.8/4
If the profile of an explicitly declared primitive equality operator of
an untagged record type is type conformant with that of the
corresponding predefined equality operator, the declaration shall occur
before the type is frozen.  In addition to the places where Legality
Rules normally apply (see *note 12.3::), this rule applies also in the
private part of an instance of a generic unit.

                          _Dynamic Semantics_

10
For discrete types, the predefined relational operators are defined in
terms of corresponding mathematical operations on the position numbers
of the values of the operands.

11
For real types, the predefined relational operators are defined in terms
of the corresponding mathematical operations on the values of the
operands, subject to the accuracy of the type.

12
Two access-to-object values are equal if they designate the same object,
or if both are equal to the null value of the access type.

13
Two access-to-subprogram values are equal if they are the result of the
same evaluation of an Access attribute_reference, or if both are equal
to the null value of the access type.  Two access-to-subprogram values
are unequal if they designate different subprograms.  It is unspecified
whether two access values that designate the same subprogram but are the
result of distinct evaluations of Access attribute_references are equal
or unequal.

14/3
For a type extension, predefined equality is defined in terms of the
primitive (possibly user-defined) equals operator for the parent type
and for any components that have a record type in the extension part,
and predefined equality for any other components not inherited from the
parent type.

14.1/3
For a derived type whose parent is an untagged record type, predefined
equality is defined in terms of the primitive (possibly user-defined)
equals operator of the parent type.

15/3
For a private type, if its full type is a record type, predefined
equality is defined in terms of the primitive equals operator of the
full type; otherwise, predefined equality for the private type is that
of its full type.

16
For other composite types, the predefined equality operators (and
certain other predefined operations on composite types -- see *note
4.5.1:: and *note 4.6::) are defined in terms of the corresponding
operation on <matching components>, defined as follows:

17
   * For two composite objects or values of the same non-array type,
     matching components are those that correspond to the same
     component_declaration or discriminant_specification;

18
   * For two one-dimensional arrays of the same type, matching
     components are those (if any) whose index values match in the
     following sense: the lower bounds of the index ranges are defined
     to match, and the successors of matching indices are defined to
     match;

19
   * For two multidimensional arrays of the same type, matching
     components are those whose index values match in successive index
     positions.

20
The analogous definitions apply if the types of the two objects or
values are convertible, rather than being the same.

21
Given the above definition of matching components, the result of the
predefined equals operator for composite types (other than for those
composite types covered earlier) is defined as follows:

22
   * If there are no components, the result is defined to be True;

23
   * If there are unmatched components, the result is defined to be
     False;

24/3
   * Otherwise, the result is defined in terms of the primitive equals
     operator for any matching components that are records, and the
     predefined equals for any other matching components.

24.1/3
If the primitive equals operator for an untagged record type is
abstract, then Program_Error is raised at the point of any (implicit)
call to that abstract subprogram.

24.2/1
For any composite type, the order in which "=" is called for components
is unspecified.  Furthermore, if the result can be determined before
calling "=" on some components, it is unspecified whether "=" is called
on those components.

25
The predefined "/=" operator gives the complementary result to the
predefined "=" operator.

26/3
For a discrete array type, the predefined ordering operators correspond
to <lexicographic order> using the predefined order relation of the
component type: A null array is lexicographically less than any array
having at least one component.  In the case of nonnull arrays, the left
operand is lexicographically less than the right operand if the first
component of the left operand is less than that of the right; otherwise,
the left operand is lexicographically less than the right operand only
if their first components are equal and the tail of the left operand is
lexicographically less than that of the right (the <tail> consists of
the remaining components beyond the first and can be null).

26.1/3
An <individual membership test> is the membership test of a single
membership_choice.

27/4
For the evaluation of a membership test using in whose
membership_choice_list has a single membership_choice, the
<tested_>simple_expression and the membership_choice are evaluated in an
arbitrary order; the result is the result of the individual membership
test for the membership_choice.

27.1/4
For the evaluation of a membership test using in whose
membership_choice_list has more than one membership_choice, the
<tested_>simple_expression of the membership test is evaluated first and
the result of the operation is equivalent to that of a sequence
consisting of an individual membership test on each membership_choice
combined with the short-circuit control form or else.

28/3
An individual membership test yields the result True if:

28.1/4
   * The membership_choice is a <choice_>simple_expression, and the
     <tested_>simple_expression is equal to the value of the
     membership_choice.  If the tested type is a record type or a
     limited type, the test uses the primitive equality for the type;
     otherwise, the test uses predefined equality.

28.2/4
   * The membership_choice is a range and the value of the
     <tested_>simple_expression belongs to the given range.

29/4
   * The membership_choice is a subtype_mark, the tested type is scalar,
     the value of the <tested_>simple_expression belongs to the range of
     the named subtype, and the value satisfies the predicates of the
     named subtype.

30/4
   * The membership_choice is a subtype_mark, the tested type is not
     scalar, the value of the <tested_>simple_expression satisfies any
     constraints of the named subtype, the value satisfies the
     predicates of the named subtype, and:

30.1/4
             * if the type of the <tested_>simple_expression is
               class-wide, the value has a tag that identifies a type
               covered by the tested type;

30.2/4
             * if the tested type is an access type and the named
               subtype excludes null, the value of the
               <tested_>simple_expression is not null;

30.3/4
             * if the tested type is a general access-to-object type,
               the type of the <tested_>simple_expression is convertible
               to the tested type and its accessibility level is no
               deeper than that of the tested type; further, if the
               designated type of the tested type is tagged and the
               <tested_>simple_expression is nonnull, the tag of the
               object designated by the value of the
               <tested_>simple_expression is covered by the designated
               type of the tested type.

31/3
Otherwise, the test yields the result False.

32
A membership test using not in gives the complementary result to the
corresponding membership test using in.

                     _Implementation Requirements_

32.1/1
For all nonlimited types declared in language-defined packages, the "="
and "/=" operators of the type shall behave as if they were the
predefined equality operators for the purposes of the equality of
composite types and generic formal types.

     NOTES

33/2
     <This paragraph was deleted.>

34
     14  If a composite type has components that depend on
     discriminants, two values of this type have matching components if
     and only if their discriminants are equal.  Two nonnull arrays have
     matching components if and only if the length of each dimension is
     the same for both.

                              _Examples_

35
<Examples of expressions involving relational operators and membership
tests:>

36
     X /= Y

37
     "" < "A" and "A" < "Aa"     --<  True>
     "Aa" < "B" and "A" < "A  "  --<  True>

38/3
     My_Car = null               --< True if My_Car has been set to null (see *note 3.10.1::)>
     My_Car = Your_Car           --< True if we both share the same car>
     My_Car.all = Your_Car.all   --< True if the two cars are identical>

39/3
     N not in 1 .. 10            --< range membership test>
     Today in Mon .. Fri         --< range membership test>
     Today in Weekday            --< subtype membership test (see *note 3.5.1::)>
     Card in Clubs | Spades      --< list membership test (see *note 3.5.1::)>
     Archive in Disk_Unit        --< subtype membership test (see *note 3.8.1::)>
     Tree.all in Addition'Class  --< class membership test (see *note 3.9.1::)>


File: arm2012.info,  Node: 4.5.3,  Next: 4.5.4,  Prev: 4.5.2,  Up: 4.5

4.5.3 Binary Adding Operators
-----------------------------

                          _Static Semantics_

1
The binary adding operators + (addition) and - (subtraction) are
predefined for every specific numeric type <T> with their conventional
meaning.  They have the following specifications:

2
     function "+"(Left, Right : <T>) return <T>
     function "-"(Left, Right : <T>) return <T>

3
The concatenation operators & are predefined for every nonlimited,
one-dimensional array type <T> with component type <C>.  They have the
following specifications:

4
     function "&"(Left : <T>; Right : <T>) return <T>
     function "&"(Left : <T>; Right : <C>) return <T>
     function "&"(Left : <C>; Right : <T>) return <T>
     function "&"(Left : <C>; Right : <C>) return <T>

                          _Dynamic Semantics_

5
For the evaluation of a concatenation with result type <T>, if both
operands are of type <T>, the result of the concatenation is a
one-dimensional array whose length is the sum of the lengths of its
operands, and whose components comprise the components of the left
operand followed by the components of the right operand.  If the left
operand is a null array, the result of the concatenation is the right
operand.  Otherwise, the lower bound of the result is determined as
follows:

6
   * If the ultimate ancestor of the array type was defined by a
     constrained_array_definition, then the lower bound of the result is
     that of the index subtype;

7
   * If the ultimate ancestor of the array type was defined by an
     unconstrained_array_definition, then the lower bound of the result
     is that of the left operand.

8
The upper bound is determined by the lower bound and the length.  A
check is made that the upper bound of the result of the concatenation
belongs to the range of the index subtype, unless the result is a null
array.  Constraint_Error is raised if this check fails.

9
If either operand is of the component type <C>, the result of the
concatenation is given by the above rules, using in place of such an
operand an array having this operand as its only component (converted to
the component subtype) and having the lower bound of the index subtype
of the array type as its lower bound.  

10
The result of a concatenation is defined in terms of an assignment to an
anonymous object, as for any function call (see *note 6.5::).

     NOTES

11
     15  As for all predefined operators on modular types, the binary
     adding operators + and - on modular types include a final reduction
     modulo the modulus if the result is outside the base range of the
     type.

                              _Examples_

12
<Examples of expressions involving binary adding operators:>

13
     Z + 0.1      --<  Z has to be of a real type >

14
     "A" & "BCD"  --<  concatenation of two string literals>
     'A' & "BCD"  --<  concatenation of a character literal and a string literal>
     'A' & 'A'    --<  concatenation of two character literals >


File: arm2012.info,  Node: 4.5.4,  Next: 4.5.5,  Prev: 4.5.3,  Up: 4.5

4.5.4 Unary Adding Operators
----------------------------

                          _Static Semantics_

1
The unary adding operators + (identity) and - (negation) are predefined
for every specific numeric type <T> with their conventional meaning.
They have the following specifications:

2
     function "+"(Right : <T>) return <T>
     function "-"(Right : <T>) return <T>

     NOTES

3
     16  For modular integer types, the unary adding operator -, when
     given a nonzero operand, returns the result of subtracting the
     value of the operand from the modulus; for a zero operand, the
     result is zero.


File: arm2012.info,  Node: 4.5.5,  Next: 4.5.6,  Prev: 4.5.4,  Up: 4.5

4.5.5 Multiplying Operators
---------------------------

                          _Static Semantics_

1
The multiplying operators * (multiplication), / (division), mod
(modulus), and rem (remainder) are predefined for every specific integer
type <T>:

2
     function "*"  (Left, Right : <T>) return <T>
     function "/"  (Left, Right : <T>) return <T>
     function "mod"(Left, Right : <T>) return <T>
     function "rem"(Left, Right : <T>) return <T>

3
Signed integer multiplication has its conventional meaning.

4
Signed integer division and remainder are defined by the relation:

5
     A = (A/B)*B + (A rem B)

6
where (A rem B) has the sign of A and an absolute value less than the
absolute value of B. Signed integer division satisfies the identity:

7
     (-A)/B = -(A/B) = A/(-B)

8/3
The signed integer modulus operator is defined such that the result of A
mod B is either zero, or has the sign of B and an absolute value less
than the absolute value of B; in addition, for some signed integer value
N, this result satisfies the relation:

9
     A = B*N + (A mod B)

10
The multiplying operators on modular types are defined in terms of the
corresponding signed integer operators, followed by a reduction modulo
the modulus if the result is outside the base range of the type (which
is only possible for the "*" operator).

11
Multiplication and division operators are predefined for every specific
floating point type <T>:

12
     function "*"(Left, Right : <T>) return <T>
     function "/"(Left, Right : <T>) return <T>

13
The following multiplication and division operators, with an operand of
the predefined type Integer, are predefined for every specific fixed
point type <T>:

14
     function "*"(Left : <T>; Right : Integer) return <T>
     function "*"(Left : Integer; Right : <T>) return <T>
     function "/"(Left : <T>; Right : Integer) return <T>

15
All of the above multiplying operators are usable with an operand of an
appropriate universal numeric type.  The following additional
multiplying operators for <root_real> are predefined, and are usable
when both operands are of an appropriate universal or root numeric type,
and the result is allowed to be of type <root_real>, as in a
number_declaration:

16
     function "*"(Left, Right : <root_real>) return <root_real>
     function "/"(Left, Right : <root_real>) return <root_real>

17
     function "*"(Left : <root_real>; Right : <root_integer>) return <root_real>
     function "*"(Left : <root_integer>; Right : <root_real>) return <root_real>
     function "/"(Left : <root_real>; Right : <root_integer>) return <root_real>

18
Multiplication and division between any two fixed point types are
provided by the following two predefined operators:

19
     function "*"(Left, Right : <universal_fixed>) return <universal_fixed>
     function "/"(Left, Right : <universal_fixed>) return <universal_fixed>

                        _Name Resolution Rules_

19.1/2
The above two fixed-fixed multiplying operators shall not be used in a
context where the expected type for the result is itself
<universal_fixed> -- the context has to identify some other numeric type
to which the result is to be converted, either explicitly or implicitly.
Unless the predefined universal operator is identified using an expanded
name with prefix denoting the package Standard, an explicit conversion
is required on the result when using the above fixed-fixed
multiplication operator if either operand is of a type having a
user-defined primitive multiplication operator such that:

19.2/3
   * it is declared immediately within the same declaration list as the
     type or any partial or incomplete view thereof; and

19.3/2
   * both of its formal parameters are of a fixed-point type.

19.4/2
A corresponding requirement applies to the universal fixed-fixed
division operator.

<Paragraph 20 was deleted.>

                          _Dynamic Semantics_

21
The multiplication and division operators for real types have their
conventional meaning.  For floating point types, the accuracy of the
result is determined by the precision of the result type.  For decimal
fixed point types, the result is truncated toward zero if the
mathematical result is between two multiples of the <small> of the
specific result type (possibly determined by context); for ordinary
fixed point types, if the mathematical result is between two multiples
of the <small>, it is unspecified which of the two is the result.  

22
The exception Constraint_Error is raised by integer division, rem, and
mod if the right operand is zero.  Similarly, for a real type <T> with
<T'>Machine_Overflows True, division by zero raises Constraint_Error.

     NOTES

23
     17  For positive A and B, A/B is the quotient and A rem B is the
     remainder when A is divided by B. The following relations are
     satisfied by the rem operator:

24
               A  rem (-B) =   A rem B
             (-A) rem   B  = -(A rem B)

25
     18  For any signed integer K, the following identity holds:

26
             A mod B   =   (A + K*B) mod B

27
     The relations between signed integer division, remainder, and
     modulus are illustrated by the following table:

28
             A      B   A/B   A rem B  A mod B     A     B    A/B   A rem B   A mod B

29
             10     5    2       0        0       -10    5    -2       0         0
             11     5    2       1        1       -11    5    -2      -1         4
             12     5    2       2        2       -12    5    -2      -2         3
             13     5    2       3        3       -13    5    -2      -3         2
             14     5    2       4        4       -14    5    -2      -4         1

30
             A      B   A/B   A rem B  A mod B     A     B    A/B   A rem B   A mod B

             10    -5   -2       0        0       -10   -5     2       0         0
             11    -5   -2       1       -4       -11   -5     2      -1        -1
             12    -5   -2       2       -3       -12   -5     2      -2        -2
             13    -5   -2       3       -2       -13   -5     2      -3        -3
             14    -5   -2       4       -1       -14   -5     2      -4        -4

                              _Examples_

31
<Examples of expressions involving multiplying operators:>

32
     I : Integer := 1;
     J : Integer := 2;
     K : Integer := 3;

33
     X : Real := 1.0;                      --<     see *note 3.5.7::>
     Y : Real := 2.0;

34
     F : Fraction := 0.25;                 --<     see *note 3.5.9::>
     G : Fraction := 0.5;

35
     <Expression>     <Value>     <Result Type>

     I*J               2         <same as I and J, that is, Integer>
     K/J               1         <same as K and J, that is, Integer>
     K mod J     1         <same as K and J, that is, Integer>

     X/Y               0.5       <same as X and Y, that is, Real>
     F/2               0.125     <same as F, that is, Fraction>

     3*F               0.75      <same as F, that is, Fraction>
     0.75*G            0.375     <universal_fixed, implicitly convertible>
                                 <to any fixed point type>
     Fraction(F*G)     0.125     <Fraction, as stated by the conversion>
     Real(J)*Y         4.0       <Real, the type of both operands after>
                                 <conversion of J>


File: arm2012.info,  Node: 4.5.6,  Next: 4.5.7,  Prev: 4.5.5,  Up: 4.5

4.5.6 Highest Precedence Operators
----------------------------------

                          _Static Semantics_

1
The highest precedence unary operator abs (absolute value) is predefined
for every specific numeric type <T>, with the following specification:

2
     function "abs"(Right : <T>) return <T>

3
The highest precedence unary operator not (logical negation) is
predefined for every boolean type <T>, every modular type <T>, and for
every one-dimensional array type <T> whose components are of a boolean
type, with the following specification:

4
     function "not"(Right : <T>) return <T>

5
The result of the operator not for a modular type is defined as the
difference between the high bound of the base range of the type and the
value of the operand.  For a binary modulus, this corresponds to a
bit-wise complement of the binary representation of the value of the
operand.

6
The operator not that applies to a one-dimensional array of boolean
components yields a one-dimensional boolean array with the same bounds;
each component of the result is obtained by logical negation of the
corresponding component of the operand (that is, the component that has
the same index value).  A check is made that each component of the
result belongs to the component subtype; the exception Constraint_Error
is raised if this check fails.

7
The highest precedence <exponentiation> operator ** is predefined for
every specific integer type <T> with the following specification:

8
     function "**"(Left : <T>; Right : Natural) return <T>

9
Exponentiation is also predefined for every specific floating point type
as well as <root_real>, with the following specification (where <T> is
<root_real> or the floating point type):

10
     function "**"(Left : <T>; Right : Integer'Base) return <T>

11/3
The right operand of an exponentiation is the <exponent>.  The value of
X**N with the value of the exponent N positive is the same as the value
of X*X*...X (with N-1 multiplications) except that the multiplications
are associated in an arbitrary order.  With N equal to zero, the result
is one.  With the value of N negative (only defined for a floating point
operand), the result is the reciprocal of the result using the absolute
value of N as the exponent.

                     _Implementation Permissions_

12
The implementation of exponentiation for the case of a negative exponent
is allowed to raise Constraint_Error if the intermediate result of the
repeated multiplications is outside the safe range of the type, even
though the final result (after taking the reciprocal) would not be.
(The best machine approximation to the final result in this case would
generally be 0.0.)

     NOTES

13
     19  As implied by the specification given above for exponentiation
     of an integer type, a check is made that the exponent is not
     negative.  Constraint_Error is raised if this check fails.


File: arm2012.info,  Node: 4.5.7,  Next: 4.5.8,  Prev: 4.5.6,  Up: 4.5

4.5.7 Conditional Expressions
-----------------------------

1/3
A conditional_expression selects for evaluation at most one of the
enclosed <dependent_>expressions, depending on a decision among the
alternatives.  One kind of conditional_expression is the if_expression,
which selects for evaluation a <dependent_>expression depending on the
value of one or more corresponding conditions.  The other kind of
conditional_expression is the case_expression, which selects for
evaluation one of a number of alternative <dependent_>expressions; the
chosen alternative is determined by the value of a
<selecting_>expression.

                               _Syntax_

2/3
     conditional_expression ::= if_expression | case_expression

3/3
     if_expression ::=
        if condition then <dependent_>expression
        {elsif condition then <dependent_>expression}
        [else <dependent_>expression]

4/3
     condition ::= <boolean_>expression

5/3
     case_expression ::=
         case <selecting_>expression is
         case_expression_alternative {,
         case_expression_alternative}

6/3
     case_expression_alternative ::=
         when discrete_choice_list =>
             <dependent_>expression

7/3
     Wherever the Syntax Rules allow an expression, a
     conditional_expression may be used in place of the expression, so
     long as it is immediately surrounded by parentheses.

                        _Name Resolution Rules_

8/3
If a conditional_expression is expected to be of a type <T>, then each
<dependent_>expression of the conditional_expression is expected to be
of type <T>.  Similarly, if a conditional_expression is expected to be
of some class of types, then each <dependent_>expression of the
conditional_expression is subject to the same expectation.  If a
conditional_expression shall resolve to be of a type <T>, then each
<dependent_>expression shall resolve to be of type <T>.

9/3
The possible types of a conditional_expression are further determined as
follows:

10/3
   * If the conditional_expression is the operand of a type conversion,
     the type of the conditional_expression is the target type of the
     conversion; otherwise,

11/3
   * If all of the <dependent_>expressions are of the same type, the
     type of the conditional_expression is that type; otherwise,

12/3
   * If a <dependent_>expression is of an elementary type, the type of
     the conditional_expression shall be covered by that type;
     otherwise,

13/3
   * If the conditional_expression is expected to be of type <T> or
     shall resolve to type <T>, then the conditional_expression is of
     type <T>.

14/3
A condition is expected to be of any boolean type.

15/3
The expected type for the <selecting_>expression and the
discrete_choices are as for case statements (see *note 5.4::).  

                           _Legality Rules_

16/3
All of the <dependent_>expressions shall be convertible (see *note
4.6::) to the type of the conditional_expression.

17/3
If the expected type of a conditional_expression is a specific tagged
type, all of the <dependent_>expressions of the conditional_expression
shall be dynamically tagged, or none shall be dynamically tagged.  In
this case, the conditional_expression is dynamically tagged if all of
the <dependent_>expressions are dynamically tagged, is tag-indeterminate
if all of the <dependent_>expressions are tag-indeterminate, and is
statically tagged otherwise.

18/3
If there is no else <dependent_>expression, the if_expression shall be
of a boolean type.

19/3
All Legality Rules that apply to the discrete_choices of a
case_statement (see *note 5.4::) also apply to the discrete_choices of a
case_expression except within an instance of a generic unit.

                          _Dynamic Semantics_

20/3
For the evaluation of an if_expression, the condition specified after
if, and any conditions specified after elsif, are evaluated in
succession (treating a final else as elsif True then), until one
evaluates to True or all conditions are evaluated and yield False.  If a
condition evaluates to True, the associated <dependent_>expression is
evaluated, converted to the type of the if_expression, and the resulting
value is the value of the if_expression.  Otherwise (when there is no
else clause), the value of the if_expression is True.

21/3
For the evaluation of a case_expression, the <selecting_>expression is
first evaluated.  If the value of the <selecting_>expression is covered
by the discrete_choice_list of some case_expression_alternative, then
the <dependent_>expression of the case_expression_alternative is
evaluated, converted to the type of the case_expression, and the
resulting value is the value of the case_expression.  Otherwise (the
value is not covered by any discrete_choice_list, perhaps due to being
outside the base range), Constraint_Error is raised.


File: arm2012.info,  Node: 4.5.8,  Prev: 4.5.7,  Up: 4.5

4.5.8 Quantified Expressions
----------------------------

0.1/4
Quantified expressions provide a way to write universally and
existentially quantified predicates over containers and arrays.

                               _Syntax_

1/3
     quantified_expression ::= for quantifier 
     loop_parameter_specification => predicate
       | for quantifier iterator_specification => predicate

2/3
     quantifier ::= all | some

3/3
     predicate ::= <boolean_>expression

4/3
     Wherever the Syntax Rules allow an expression, a
     quantified_expression may be used in place of the expression, so
     long as it is immediately surrounded by parentheses.

                        _Name Resolution Rules_

5/3
The expected type of a quantified_expression is any Boolean type.  The
predicate in a quantified_expression is expected to be of the same type.

                          _Dynamic Semantics_

6/4
For the evaluation of a quantified_expression, the
loop_parameter_specification or iterator_specification is first
elaborated.  The evaluation of a quantified_expression then evaluates
the predicate for the values of the loop parameter in the order
specified by the loop_parameter_specification (see *note 5.5::) or
iterator_specification (see *note 5.5.2::).

7/3
The value of the quantified_expression is determined as follows:

8/4
   * If the quantifier is all, the expression is False if the evaluation
     of any predicate yields False; evaluation of the
     quantified_expression stops at that point.  Otherwise (every
     predicate has been evaluated and yielded True), the expression is
     True.  Any exception raised by evaluation of the predicate is
     propagated.

9/4
   * If the quantifier is some, the expression is True if the evaluation
     of any predicate yields True; evaluation of the
     quantified_expression stops at that point.  Otherwise (every
     predicate has been evaluated and yielded False), the expression is
     False.  Any exception raised by evaluation of the predicate is
     propagated.

                              _Examples_

10/3
The postcondition for a sorting routine on an array A with an index
subtype T can be written:

11/3
     Post => (A'Length < 2 or else
        (for all I in A'First .. T'Pred(A'Last) => A (I) <= A (T'Succ (I))))

12/3
The assertion that a positive number is composite (as opposed to prime)
can be written:

13/3
     pragma Assert (for some X in 2 .. N / 2 => N mod X = 0);


File: arm2012.info,  Node: 4.6,  Next: 4.7,  Prev: 4.5,  Up: 4

4.6 Type Conversions
====================

1/3
Explicit type conversions, both value conversions and view conversions,
are allowed between closely related types as defined below.  This
subclause also defines rules for value and view conversions to a
particular subtype of a type, both explicit ones and those implicit in
other constructs.  

                               _Syntax_

2
     type_conversion ::=
         subtype_mark(expression)
       | subtype_mark(name)

3
The <target subtype> of a type_conversion is the subtype denoted by the
subtype_mark.  The <operand> of a type_conversion is the expression or
name within the parentheses; its type is the <operand type>.

4/3
One type is <convertible> to a second type if a type_conversion with the
first type as operand type and the second type as target type is legal
according to the rules of this subclause.  Two types are convertible if
each is convertible to the other.

5/2
A type_conversion whose operand is the name of an object is called a
<view conversion> if both its target type and operand type are tagged,
or if it appears in a call as an actual parameter of mode out or in out;
other type_conversions are called <value conversions>.  

                        _Name Resolution Rules_

6
The operand of a type_conversion is expected to be of any type.

7
The operand of a view conversion is interpreted only as a name; the
operand of a value conversion is interpreted as an expression.

                           _Legality Rules_

8/2
In a view conversion for an untagged type, the target type shall be
convertible (back) to the operand type.

<Paragraphs 9 through 20 were reorganized and moved below.>

21/3
If there is a type (other than a root numeric type) that is an ancestor
of both the target type and the operand type, or both types are
class-wide types, then at least one of the following rules shall apply:

21.1/2
   * The target type shall be untagged; or

22
   * The operand type shall be covered by or descended from the target
     type; or

23/2
   * The operand type shall be a class-wide type that covers the target
     type; or

23.1/2
   * The operand and target types shall both be class-wide types and the
     specific type associated with at least one of them shall be an
     interface type.

24/3
If there is no type (other than a root numeric type) that is the
ancestor of both the target type and the operand type, and they are not
both class-wide types, one of the following rules shall apply:

24.1/2
   * If the target type is a numeric type, then the operand type shall
     be a numeric type.

24.2/2
   * If the target type is an array type, then the operand type shall be
     an array type.  Further:

24.3/2
             * The types shall have the same dimensionality;

24.4/2
             * Corresponding index types shall be convertible; 

24.5/2
             * The component subtypes shall statically match; 

24.6/2
             * If the component types are anonymous access types, then
               the accessibility level of the operand type shall not be
               statically deeper than that of the target type; 

24.7/2
             * Neither the target type nor the operand type shall be
               limited;

24.8/2
             * If the target type of a view conversion has aliased
               components, then so shall the operand type; and

24.9/2
             * The operand type of a view conversion shall not have a
               tagged, private, or volatile subcomponent.

24.10/2
   * If the target type is <universal_access>, then the operand type
     shall be an access type.

24.11/2
   * If the target type is a general access-to-object type, then the
     operand type shall be <universal_access> or an access-to-object
     type.  Further, if the operand type is not <universal_access>:

24.12/2
             * If the target type is an access-to-variable type, then
               the operand type shall be an access-to-variable type;

24.13/2
             * If the target designated type is tagged, then the operand
               designated type shall be convertible to the target
               designated type; 

24.14/2
             * If the target designated type is not tagged, then the
               designated types shall be the same, and either:

24.15/2
                  * the designated subtypes shall statically match; or

24.16/2
                  * the designated type shall be discriminated in its
                    full view and unconstrained in any partial view, and
                    one of the designated subtypes shall be
                    unconstrained;

24.17/4
             * The accessibility level of the operand type shall not be
               statically deeper than that of the target type, unless
               the target type is an anonymous access type of a
               stand-alone object.  If the target type is that of such a
               stand-alone object, the accessibility level of the
               operand type shall not be statically deeper than that of
               the declaration of the stand-alone object.

24.18/2
   * If the target type is a pool-specific access-to-object type, then
     the operand type shall be <universal_access>.

24.19/2
   * If the target type is an access-to-subprogram type, then the
     operand type shall be <universal_access> or an access-to-subprogram
     type.  Further, if the operand type is not <universal_access>:

24.20/3
             * The designated profiles shall be subtype conformant.  

24.21/4
             * The accessibility level of the operand type shall not be
               statically deeper than that of the target type.  If the
               operand type is declared within a generic body, the
               target type shall be declared within the generic body.

24.22/4
In addition to the places where Legality Rules normally apply (see *note
12.3::), these rules apply also in the private part of an instance of a
generic unit.

                          _Static Semantics_

25
A type_conversion that is a value conversion denotes the value that is
the result of converting the value of the operand to the target subtype.

26/3
A type_conversion that is a view conversion denotes a view of the object
denoted by the operand.  This view is a variable of the target type if
the operand denotes a variable; otherwise, it is a constant of the
target type.

27
The nominal subtype of a type_conversion is its target subtype.

                          _Dynamic Semantics_

28
For the evaluation of a type_conversion that is a value conversion, the
operand is evaluated, and then the value of the operand is <converted>
to a <corresponding> value of the target type, if any.  If there is no
value of the target type that corresponds to the operand value,
Constraint_Error is raised; this can only happen on conversion to a
modular type, and only when the operand value is outside the base range
of the modular type.  Additional rules follow:

29
   * Numeric Type Conversion

30
             * If the target and the operand types are both integer
               types, then the result is the value of the target type
               that corresponds to the same mathematical integer as the
               operand.

31
             * If the target type is a decimal fixed point type, then
               the result is truncated (toward 0) if the value of the
               operand is not a multiple of the <small> of the target
               type.

32
             * If the target type is some other real type, then the
               result is within the accuracy of the target type (see
               *note G.2::, "*note G.2:: Numeric Performance
               Requirements", for implementations that support the
               Numerics Annex).

33
             * If the target type is an integer type and the operand
               type is real, the result is rounded to the nearest
               integer (away from zero if exactly halfway between two
               integers).

34
   * Enumeration Type Conversion

35
             * The result is the value of the target type with the same
               position number as that of the operand value.

36
   * Array Type Conversion

37
             * If the target subtype is a constrained array subtype,
               then a check is made that the length of each dimension of
               the value of the operand equals the length of the
               corresponding dimension of the target subtype.  The
               bounds of the result are those of the target subtype.

38
             * If the target subtype is an unconstrained array subtype,
               then the bounds of the result are obtained by converting
               each bound of the value of the operand to the
               corresponding index type of the target type.  For each
               nonnull index range, a check is made that the bounds of
               the range belong to the corresponding index subtype.

39
             * In either array case, the value of each component of the
               result is that of the matching component of the operand
               value (see *note 4.5.2::).

39.1/2
             * If the component types of the array types are anonymous
               access types, then a check is made that the accessibility
               level of the operand type is not deeper than that of the
               target type.  

40
   * Composite (Non-Array) Type Conversion

41
             * The value of each nondiscriminant component of the result
               is that of the matching component of the operand value.

42
             * The tag of the result is that of the operand.  If the
               operand type is class-wide, a check is made that the tag
               of the operand identifies a (specific) type that is
               covered by or descended from the target type.

43
             * For each discriminant of the target type that corresponds
               to a discriminant of the operand type, its value is that
               of the corresponding discriminant of the operand value; 
               if it corresponds to more than one discriminant of the
               operand type, a check is made that all these
               discriminants are equal in the operand value.

44
             * For each discriminant of the target type that corresponds
               to a discriminant that is specified by the
               derived_type_definition for some ancestor of the operand
               type (or if class-wide, some ancestor of the specific
               type identified by the tag of the operand), its value in
               the result is that specified by the
               derived_type_definition.

45
             * For each discriminant of the operand type that
               corresponds to a discriminant that is specified by the
               derived_type_definition for some ancestor of the target
               type, a check is made that in the operand value it equals
               the value specified for it.

46
             * For each discriminant of the result, a check is made that
               its value belongs to its subtype.

47
   * Access Type Conversion

48/3
             * For an access-to-object type, a check is made that the
               accessibility level of the operand type is not deeper
               than that of the target type, unless the target type is
               an anonymous access type of a stand-alone object.  If the
               target type is that of such a stand-alone object, a check
               is made that the accessibility level of the operand type
               is not deeper than that of the declaration of the
               stand-alone object; then if the check succeeds, the
               accessibility level of the target type becomes that of
               the operand type.  

49/2
             * If the operand value is null, the result of the
               conversion is the null value of the target type.

50
             * If the operand value is not null, then the result
               designates the same object (or subprogram) as is
               designated by the operand value, but viewed as being of
               the target designated subtype (or profile); any checks
               associated with evaluating a conversion to the target
               designated subtype are performed.

51/4
After conversion of the value to the target type, if the target subtype
is constrained, a check is performed that the value satisfies this
constraint.  If the target subtype excludes null, then a check is made
that the value is not null.  If predicate checks are enabled for the
target subtype (see *note 3.2.4::), a check is performed that the value
satisfies the predicates of the target subtype.

52
For the evaluation of a view conversion, the operand name is evaluated,
and a new view of the object denoted by the operand is created, whose
type is the target type; if the target type is composite, checks are
performed as above for a value conversion.

53
The properties of this new view are as follows:

54/1
   * If the target type is composite, the bounds or discriminants (if
     any) of the view are as defined above for a value conversion; each
     nondiscriminant component of the view denotes the matching
     component of the operand object; the subtype of the view is
     constrained if either the target subtype or the operand object is
     constrained, or if the target subtype is indefinite, or if the
     operand type is a descendant of the target type and has
     discriminants that were not inherited from the target type;

55
   * If the target type is tagged, then an assignment to the view
     assigns to the corresponding part of the object denoted by the
     operand; otherwise, an assignment to the view assigns to the
     object, after converting the assigned value to the subtype of the
     object (which might raise Constraint_Error); 

56/4
   * Reading the value of the view yields the result of converting the
     value of the operand object to the target subtype (which might
     raise Constraint_Error), except if the object is of an elementary
     type and the view conversion is passed as an out parameter; in this
     latter case, the value of the operand object may be used to
     initialize the formal parameter without checking against any
     constraint of the target subtype (as described more precisely in
     *note 6.4.1::).  

57/4
If an Accessibility_Check fails, Program_Error is raised.  If a
predicate check fails, the effect is as defined in subclause *note
3.2.4::, "*note 3.2.4:: Subtype Predicates".  Any other check associated
with a conversion raises Constraint_Error if it fails.

58
Conversion to a type is the same as conversion to an unconstrained
subtype of the type.

58.1/4
Evaluation of a value conversion of a composite type either creates a
new anonymous object (similar to the object created by the evaluation of
an aggregate or a function call) or yields a new view of the operand
object without creating a new object:

58.2/4
   * If the target type is a by-reference type and there is a type that
     is an ancestor of both the target type and the operand type then no
     new object is created;

58.3/4
   * If the target type is an array type having aliased components and
     the operand type is an array type having unaliased components, then
     a new object is created;

58.4/4
   * Otherwise, it is unspecified whether a new object is created.

58.5/4
If a new object is created, then the initialization of that object is an
assignment operation.

     NOTES

59
     20  In addition to explicit type_conversions, type conversions are
     performed implicitly in situations where the expected type and the
     actual type of a construct differ, as is permitted by the type
     resolution rules (see *note 8.6::).  For example, an integer
     literal is of the type <universal_integer>, and is implicitly
     converted when assigned to a target of some specific integer type.
     Similarly, an actual parameter of a specific tagged type is
     implicitly converted when the corresponding formal parameter is of
     a class-wide type.

60
     Even when the expected and actual types are the same, implicit
     subtype conversions are performed to adjust the array bounds (if
     any) of an operand to match the desired target subtype, or to raise
     Constraint_Error if the (possibly adjusted) value does not satisfy
     the constraints of the target subtype.

61/2
     21  A ramification of the overload resolution rules is that the
     operand of an (explicit) type_conversion cannot be an allocator, an
     aggregate, a string_literal, a character_literal, or an
     attribute_reference for an Access or Unchecked_Access attribute.
     Similarly, such an expression enclosed by parentheses is not
     allowed.  A qualified_expression (see *note 4.7::) can be used
     instead of such a type_conversion.

62
     22  The constraint of the target subtype has no effect for a
     type_conversion of an elementary type passed as an out parameter.
     Hence, it is recommended that the first subtype be specified as the
     target to minimize confusion (a similar recommendation applies to
     renaming and generic formal in out objects).

                              _Examples_

63
<Examples of numeric type conversion:>

64
     Real(2*J)      <--  value is converted to floating point>
     Integer(1.6)   <--  value is 2>
     Integer(-0.4)  <--  value is 0>

65
<Example of conversion between derived types:>

66
     type A_Form is new B_Form;

67
     X : A_Form;
     Y : B_Form;

68
     X := A_Form(Y);
     Y := B_Form(X);  <--  the reverse conversion >

69
<Examples of conversions between array types:>

70
     type Sequence is array (Integer range <>) of Integer;
     subtype Dozen is Sequence(1 .. 12);
     Ledger : array(1 .. 100) of Integer;

71
     Sequence(Ledger)            <--  bounds are those of Ledger>
     Sequence(Ledger(31 .. 42))  <--  bounds are 31 and 42>
     Dozen(Ledger(31 .. 42))     <--  bounds are those of Dozen >


File: arm2012.info,  Node: 4.7,  Next: 4.8,  Prev: 4.6,  Up: 4

4.7 Qualified Expressions
=========================

1
A qualified_expression is used to state explicitly the type, and to
verify the subtype, of an operand that is either an expression or an
aggregate.  

                               _Syntax_

2
     qualified_expression ::=
        subtype_mark'(expression) | subtype_mark'aggregate

                        _Name Resolution Rules_

3
The <operand> (the expression or aggregate) shall resolve to be of the
type determined by the subtype_mark (*note 3.2.2: S0028.), or a
universal type that covers it.

                          _Static Semantics_

3.1/3
If the operand of a qualified_expression denotes an object, the
qualified_expression denotes a constant view of that object.  The
nominal subtype of a qualified_expression is the subtype denoted by the
subtype_mark.

                          _Dynamic Semantics_

4/4
The evaluation of a qualified_expression evaluates the operand (and if
of a universal type, converts it to the type determined by the
subtype_mark) and checks that its value belongs to the subtype denoted
by the subtype_mark.  The exception Constraint_Error is raised if this
check fails.  Furthermore, if predicate checks are enabled for the
subtype denoted by the subtype_mark, a check is performed as defined in
subclause *note 3.2.4::, "*note 3.2.4:: Subtype Predicates" that the
value satifies the predicates of the subtype.

     NOTES

5
     23  When a given context does not uniquely identify an expected
     type, a qualified_expression can be used to do so.  In particular,
     if an overloaded name or aggregate is passed to an overloaded
     subprogram, it might be necessary to qualify the operand to resolve
     its type.

                              _Examples_

6
<Examples of disambiguating expressions using qualification:>

7
     type Mask is (Fix, Dec, Exp, Signif);
     type Code is (Fix, Cla, Dec, Tnz, Sub);

8
     Print (Mask'(Dec));  <--  Dec is of type Mask>
     Print (Code'(Dec));  <--  Dec is of type Code >

9
     for J in Code'(Fix) .. Code'(Dec) loop ... <-- qualification needed for either Fix or Dec>
     for J in Code range Fix .. Dec loop ...    <-- qualification unnecessary>
     for J in Code'(Fix) .. Dec loop ...        <-- qualification unnecessary for Dec>

10
     Dozen'(1 | 3 | 5 | 7 => 2, others => 0) <-- see *note 4.6:: >


File: arm2012.info,  Node: 4.8,  Next: 4.9,  Prev: 4.7,  Up: 4

4.8 Allocators
==============

1
The evaluation of an allocator creates an object and yields an access
value that designates the object.  

                               _Syntax_

2/3
     allocator ::=
        new [subpool_specification] subtype_indication
      | new [subpool_specification] qualified_expression

2.1/3
     subpool_specification ::= (<subpool_handle_>name)

2.2/3
     For an allocator with a subtype_indication, the subtype_indication
     shall not specify a null_exclusion.

                        _Name Resolution Rules_

3/3
The expected type for an allocator shall be a single access-to-object
type with designated type <D> such that either <D> covers the type
determined by the subtype_mark of the subtype_indication (*note 3.2.2:
S0027.) or qualified_expression (*note 4.7: S0142.), or the expected
type is anonymous and the determined type is <D>'Class.  A
<subpool_handle_>name is expected to be of any type descended from
Subpool_Handle, which is the type used to identify a subpool, declared
in package System.Storage_Pools.Subpools (see *note 13.11.4::).

                           _Legality Rules_

4
An <initialized> allocator is an allocator with a qualified_expression.An <uninitialized> allocator is one with a subtype_indication.  In the
subtype_indication of an uninitialized allocator, a constraint is
permitted only if the subtype_mark denotes an unconstrained composite
subtype; if there is no constraint, then the subtype_mark shall denote a
definite subtype.  

5/2
If the type of the allocator is an access-to-constant type, the
allocator shall be an initialized allocator.

5.1/3
If a subpool_specification is given, the type of the storage pool of the
access type shall be a descendant of Root_Storage_Pool_With_Subpools.

5.2/3
If the designated type of the type of the allocator is class-wide, the
accessibility level of the type determined by the subtype_indication or
qualified_expression shall not be statically deeper than that of the
type of the allocator.

5.3/3
If the subtype determined by the subtype_indication or
qualified_expression of the allocator has one or more access
discriminants, then the accessibility level of the anonymous access type
of each access discriminant shall not be statically deeper than that of
the type of the allocator (see *note 3.10.2::).

5.4/3
An allocator shall not be of an access type for which the Storage_Size
has been specified by a static expression with value zero or is defined
by the language to be zero.

5.5/3
If the designated type of the type of the allocator is limited, then the
allocator shall not be used to define the value of an access
discriminant, unless the discriminated type is immutably limited (see
*note 7.5::).

5.6/3
In addition to the places where Legality Rules normally apply (see *note
12.3::), these rules apply also in the private part of an instance of a
generic unit.

                          _Static Semantics_

6/3
If the designated type of the type of the allocator is elementary, then
the subtype of the created object is the designated subtype.  If the
designated type is composite, then the subtype of the created object is
the designated subtype when the designated subtype is constrained or
there is an ancestor of the designated type that has a constrained
partial view; otherwise, the created object is constrained by its
initial value (even if the designated subtype is unconstrained with
defaults).  

                          _Dynamic Semantics_

7/2
For the evaluation of an initialized allocator, the evaluation of the
qualified_expression is performed first.  An object of the designated
type is created and the value of the qualified_expression is converted
to the designated subtype and assigned to the object.  

8
For the evaluation of an uninitialized allocator, the elaboration of the
subtype_indication is performed first.  Then:

9/2
   * If the designated type is elementary, an object of the designated
     subtype is created and any implicit initial value is assigned;

10/2
   * If the designated type is composite, an object of the designated
     type is created with tag, if any, determined by the subtype_mark of
     the subtype_indication.  This object is then initialized by default
     (see *note 3.3.1::) using the subtype_indication to determine its
     nominal subtype.  A check is made that the value of the object
     belongs to the designated subtype.  Constraint_Error is raised if
     this check fails.  This check and the initialization of the object
     are performed in an arbitrary order.

10.1/3
For any allocator, if the designated type of the type of the allocator
is class-wide, then a check is made that the master of the type
determined by the subtype_indication, or by the tag of the value of the
qualified_expression, includes the elaboration of the type of the
allocator.  If any part of the subtype determined by the
subtype_indication or qualified_expression of the allocator (or by the
tag of the value if the type of the qualified_expression is class-wide)
has one or more access discriminants, then a check is made that the
accessibility level of the anonymous access type of each access
discriminant is not deeper than that of the type of the allocator.
Program_Error is raised if either such check fails.  

10.2/2
If the object to be created by an allocator has a controlled or
protected part, and the finalization of the collection of the type of
the allocator (see *note 7.6.1::) has started, Program_Error is raised.
10.3/2
If the object to be created by an allocator contains any tasks, and the
master of the type of the allocator is completed, and all of the
dependent tasks of the master are terminated (see *note 9.3::), then
Program_Error is raised.  

10.4/3
If the allocator includes a <subpool_handle_>name, Constraint_Error is
raised if the subpool handle is null.  Program_Error is raised if the
subpool does not <belong> (see *note 13.11.4::) to the storage pool of
the access type of the allocator.  

11
If the created object contains any tasks, they are activated (see *note
9.2::).  Finally, an access value that designates the created object is
returned.

                      _Bounded (Run-Time) Errors_

11.1/2
It is a bounded error if the finalization of the collection of the type
(see *note 7.6.1::) of the allocator has started.  If the error is
detected, Program_Error is raised.  Otherwise, the allocation proceeds
normally.

     NOTES

12
     24  Allocators cannot create objects of an abstract type.  See
     *note 3.9.3::.

13
     25  If any part of the created object is controlled, the
     initialization includes calls on corresponding Initialize or Adjust
     procedures.  See *note 7.6::.

14
     26  As explained in *note 13.11::, "*note 13.11:: Storage
     Management", the storage for an object allocated by an allocator
     comes from a storage pool (possibly user defined).  The exception
     Storage_Error is raised by an allocator if there is not enough
     storage.  Instances of Unchecked_Deallocation may be used to
     explicitly reclaim storage.

15/3
     27  Implementations are permitted, but not required, to provide
     garbage collection.

                              _Examples_

16
<Examples of allocators:>

17
     new Cell'(0, null, null)                          <-- initialized explicitly, see *note 3.10.1::>
     new Cell'(Value => 0, Succ => null, Pred => null) <-- initialized explicitly>
     new Cell                                          <-- not initialized>

18
     new Matrix(1 .. 10, 1 .. 20)                      <-- the bounds only are given>
     new Matrix'(1 .. 10 => (1 .. 20 => 0.0))          <-- initialized explicitly>

19
     new Buffer(100)                                   <-- the discriminant only is given>
     new Buffer'(Size => 80, Pos => 0, Value => (1 .. 80 => 'A')) <-- initialized explicitly>

20
     Expr_Ptr'(new Literal)                  <-- allocator for access-to-class-wide type, see *note 3.9.1::>
     Expr_Ptr'(new Literal'(Expression with 3.5))      <-- initialized explicitly>


File: arm2012.info,  Node: 4.9,  Prev: 4.8,  Up: 4

4.9 Static Expressions and Static Subtypes
==========================================

1
Certain expressions of a scalar or string type are defined to be static.
Similarly, certain discrete ranges are defined to be static, and certain
scalar and string subtypes are defined to be static subtypes.  <Static>
means determinable at compile time, using the declared properties or
values of the program entities.  

2
A static expression is a scalar or string expression that is one of the
following:

3
   * a numeric_literal;

4
   * a string_literal of a static string subtype;

5
   * a name that denotes the declaration of a named number or a static
     constant;

6
   * a function_call whose <function_>name or <function_>prefix
     statically denotes a static function, and whose actual parameters,
     if any (whether given explicitly or by default), are all static
     expressions;

7
   * an attribute_reference that denotes a scalar value, and whose
     prefix denotes a static scalar subtype;

8
   * an attribute_reference whose prefix statically denotes a statically
     constrained array object or array subtype, and whose
     attribute_designator is First, Last, or Length, with an optional
     dimension;

9
   * a type_conversion whose subtype_mark denotes a static scalar
     subtype, and whose operand is a static expression;

10
   * a qualified_expression whose subtype_mark denotes a static (scalar
     or string) subtype, and whose operand is a static expression;

11/4
   * a membership test whose <tested_>simple_expression is a static
     expression, and whose membership_choice_list consists only of
     membership_choices that are either static
     <choice_>simple_expressions, static ranges, or subtype_marks that
     denote a static (scalar or string) subtype;

12
   * a short-circuit control form both of whose relations are static
     expressions;

12.1/3
   * a conditional_expression all of whose conditions,
     <selecting_>expressions, and <dependent_>expressions are static
     expressions;

13
   * a static expression enclosed in parentheses.

14
A name <statically denotes> an entity if it denotes the entity and:

15
   * It is a direct_name, expanded name, or character_literal, and it
     denotes a declaration other than a renaming_declaration; or

16
   * It is an attribute_reference whose prefix statically denotes some
     entity; or

17
   * It denotes a renaming_declaration with a name that statically
     denotes the renamed entity.

18
A <static function> is one of the following:

19
   * a predefined operator whose parameter and result types are all
     scalar types none of which are descendants of formal scalar types;

20
   * a predefined concatenation operator whose result type is a string
     type;

21
   * an enumeration literal;

22
   * a language-defined attribute that is a function, if the prefix
     denotes a static scalar subtype, and if the parameter and result
     types are scalar.

23
In any case, a generic formal subprogram is not a static function.

24
A <static constant> is a constant view declared by a full constant
declaration or an object_renaming_declaration (*note 8.5.1: S0200.) with
a static nominal subtype, having a value defined by a static scalar
expression or by a static string expression whose value has a length not
exceeding the maximum length of a string_literal (*note 2.6: S0016.) in
the implementation.

25
A <static range> is a range whose bounds are static expressions, or a
range_attribute_reference (*note 4.1.4: S0102.) that is equivalent to
such a range.  A <static discrete_range (*note 3.6.1: S0058.)> is one
that is a static range or is a subtype_indication (*note 3.2.2: S0027.)
that defines a static scalar subtype.  The base range of a scalar type
is a static range, unless the type is a descendant of a formal scalar
type.

26/3
A <static subtype> is either a <static scalar subtype> or a <static
string subtype>.  A static scalar subtype is an unconstrained scalar
subtype whose type is not a descendant of a formal type, or a
constrained scalar subtype formed by imposing a compatible static
constraint on a static scalar subtype.  A static string subtype is an
unconstrained string subtype whose index subtype and component subtype
are static, or a constrained string subtype formed by imposing a
compatible static constraint on a static string subtype.  In any case,
the subtype of a generic formal object of mode in out, and the result
subtype of a generic formal function, are not static.  Also, a subtype
is not static if any Dynamic_Predicate specifications apply to it.

27
The different kinds of <static constraint> are defined as follows:

28
   * A null constraint is always static;

29
   * A scalar constraint is static if it has no range_constraint, or one
     with a static range;

30
   * An index constraint is static if each discrete_range is static, and
     each index subtype of the corresponding array type is static;

31
   * A discriminant constraint is static if each expression of the
     constraint is static, and the subtype of each discriminant is
     static.

31.1/2
In any case, the constraint of the first subtype of a scalar formal type
is neither static nor null.

32
A subtype is <statically constrained> if it is constrained, and its
constraint is static.  An object is <statically constrained> if its
nominal subtype is statically constrained, or if it is a static string
constant.

                           _Legality Rules_

32.1/3
An expression is <statically unevaluated> if it is part of:

32.2/3
   * the right operand of a static short-circuit control form whose
     value is determined by its left operand; or

32.3/3
   * a <dependent_>expression of an if_expression whose associated
     condition is static and equals False; or

32.4/3
   * a condition or <dependent_>expression of an if_expression where the
     condition corresponding to at least one preceding
     <dependent_>expression of the if_expression is static and equals
     True; or

32.5/3
   * a <dependent_>expression of a case_expression whose
     <selecting_>expression is static and whose value is not covered by
     the corresponding discrete_choice_list; or

32.6/4
   * a <choice_>simple_expression (or a simple_expression of a range
     that occurs as a membership_choice of a membership_choice_list) of
     a static membership test that is preceded in the enclosing
     membership_choice_list by another item whose individual membership
     test (see *note 4.5.2::) statically yields True.

33/3
A static expression is evaluated at compile time except when it is
statically unevaluated.  The compile-time evaluation of a static
expression is performed exactly, without performing Overflow_Checks.
For a static expression that is evaluated:

34/3
   * The expression is illegal if its evaluation fails a
     language-defined check other than Overflow_Check.  For the purposes
     of this evaluation, the assertion policy is assumed to be Check.

35/2
   * If the expression is not part of a larger static expression and the
     expression is expected to be of a single specific type, then its
     value shall be within the base range of its expected type.
     Otherwise, the value may be arbitrarily large or small.

36/2
   * If the expression is of type <universal_real> and its expected type
     is a decimal fixed point type, then its value shall be a multiple
     of the <small> of the decimal type.  This restriction does not
     apply if the expected type is a descendant of a formal scalar type
     (or a corresponding actual type in an instance).

37/2
In addition to the places where Legality Rules normally apply (see *note
12.3::), the above restrictions also apply in the private part of an
instance of a generic unit.

                     _Implementation Requirements_

38/2
For a real static expression that is not part of a larger static
expression, and whose expected type is not a descendant of a formal
type, the implementation shall round or truncate the value (according to
the Machine_Rounds attribute of the expected type) to the nearest
machine number of the expected type; if the value is exactly half-way
between two machine numbers, the rounding performed is
implementation-defined.  If the expected type is a descendant of a
formal type, or if the static expression appears in the body of an
instance of a generic unit and the corresponding expression is nonstatic
in the corresponding generic body, then no special rounding or
truncating is required -- normal accuracy rules apply (see *note Annex
G::).

                        _Implementation Advice_

38.1/2
For a real static expression that is not part of a larger static
expression, and whose expected type is not a descendant of a formal
type, the rounding should be the same as the default rounding for the
target system.

     NOTES

39
     28  An expression can be static even if it occurs in a context
     where staticness is not required.

40
     29  A static (or run-time) type_conversion from a real type to an
     integer type performs rounding.  If the operand value is exactly
     half-way between two integers, the rounding is performed away from
     zero.

                              _Examples_

41
<Examples of static expressions:>

42
     1 + 1       <-- 2>
     abs(-10)*3  <-- 30>

43
     Kilo : constant := 1000;
     Mega : constant := Kilo*Kilo;   <-- 1_000_000>
     Long : constant := Float'Digits*2;

44
     Half_Pi    : constant := Pi/2;           <-- see *note 3.3.2::>
     Deg_To_Rad : constant := Half_Pi/90;
     Rad_To_Deg : constant := 1.0/Deg_To_Rad; <-- equivalent to 1.0/((3.14159_26536/2)/90)>

* Menu:

* 4.9.1 ::    Statically Matching Constraints and Subtypes


File: arm2012.info,  Node: 4.9.1,  Up: 4.9

4.9.1 Statically Matching Constraints and Subtypes
--------------------------------------------------

                          _Static Semantics_

1/2
A constraint <statically matches> another constraint if:

1.1/2
   * both are null constraints;

1.2/2
   * both are static and have equal corresponding bounds or discriminant
     values;

1.3/2
   * both are nonstatic and result from the same elaboration of a
     constraint of a subtype_indication (*note 3.2.2: S0027.) or the
     same evaluation of a range of a discrete_subtype_definition (*note
     3.6: S0055.); or

1.4/2
   * both are nonstatic and come from the same formal_type_declaration.

2/3
A subtype <statically matches> another subtype of the same type if they
have statically matching constraints, all predicate specifications that
apply to them come from the same declarations, and, for access subtypes,
either both or neither exclude null.  Two anonymous access-to-object
subtypes statically match if their designated subtypes statically match,
and either both or neither exclude null, and either both or neither are
access-to-constant.  Two anonymous access-to-subprogram subtypes
statically match if their designated profiles are subtype conformant,
and either both or neither exclude null.

3
Two ranges of the same type <statically match> if both result from the
same evaluation of a range, or if both are static and have equal
corresponding bounds.

4/3
A constraint is <statically compatible> with a scalar subtype if it
statically matches the constraint of the subtype, or if both are static
and the constraint is compatible with the subtype.  A constraint is
<statically compatible> with an access or composite subtype if it
statically matches the constraint of the subtype, or if the subtype is
unconstrained.

5/3
Two statically matching subtypes are statically compatible with each
other.  In addition, a subtype <S1> is statically compatible with a
subtype <S2> if:

6/3
   * the constraint of <S1> is statically compatible with <S2>, and

7/3
   * if <S2> excludes null, so does <S1>, and

8/3
   * either:

9/3
             * all predicate specifications that apply to <S2> apply
               also to <S1>, or

10/4
             * both subtypes are static, every value that satisfies the
               predicates of <S1> also satisfies the predicates of <S2>,
               and it is not the case that both types each have at least
               one applicable predicate specification, predicate checks
               are enabled (see *note 11.4.2::) for <S2>, and predicate
               checks are not enabled for <S1>.


File: arm2012.info,  Node: 5,  Next: 6,  Prev: 4,  Up: Top

5 Statements
************

1
A statement defines an action to be performed upon its execution.

2/3
This clause describes the general rules applicable to all statements.
Some statements are discussed in later clauses: Procedure_call_statement
(*note 6.4: S0178.)s and return statements are described in *note 6::,
"*note 6:: Subprograms".  Entry_call_statement (*note 9.5.3: S0225.)s,
requeue_statement (*note 9.5.4: S0226.)s, delay_statement (*note 9.6:
S0227.)s, accept_statement (*note 9.5.2: S0219.)s, select_statement
(*note 9.7: S0230.)s, and abort_statement (*note 9.8: S0245.)s are
described in *note 9::, "*note 9:: Tasks and Synchronization".
Raise_statement (*note 11.3: S0269.)s are described in *note 11::,
"*note 11:: Exceptions", and code_statement (*note 13.8: S0318.)s in
*note 13::.  The remaining forms of statements are presented in this
clause.

* Menu:

* 5.1 ::      Simple and Compound Statements - Sequences of Statements
* 5.2 ::      Assignment Statements
* 5.3 ::      If Statements
* 5.4 ::      Case Statements
* 5.5 ::      Loop Statements
* 5.6 ::      Block Statements
* 5.7 ::      Exit Statements
* 5.8 ::      Goto Statements


File: arm2012.info,  Node: 5.1,  Next: 5.2,  Up: 5

5.1 Simple and Compound Statements - Sequences of Statements
============================================================

1
A statement is either simple or compound.  A simple_statement encloses
no other statement.  A compound_statement can enclose simple_statements
and other compound_statements.

                               _Syntax_

2/3
     sequence_of_statements ::= statement {statement} {label}

3
     statement ::=
        {label} simple_statement | {label} compound_statement

4/2
     simple_statement ::= null_statement
        | assignment_statement   | exit_statement
        | goto_statement   | procedure_call_statement
        | simple_return_statement   | entry_call_statement
        | requeue_statement   | delay_statement
        | abort_statement   | raise_statement
        | code_statement

5/2
     compound_statement ::=
          if_statement   | case_statement
        | loop_statement   | block_statement
        | extended_return_statement
        | accept_statement   | select_statement

6
     null_statement ::= null;

7
     label ::= <<<label_>statement_identifier>>

8
     statement_identifier ::= direct_name

9
     The direct_name of a statement_identifier shall be an identifier
     (not an operator_symbol).

                        _Name Resolution Rules_

10
The direct_name of a statement_identifier shall resolve to denote its
corresponding implicit declaration (see below).

                           _Legality Rules_

11
Distinct identifiers shall be used for all statement_identifiers that
appear in the same body, including inner block_statements but excluding
inner program units.

                          _Static Semantics_

12
For each statement_identifier, there is an implicit declaration (with
the specified identifier) at the end of the declarative_part of the
innermost block_statement or body that encloses the
statement_identifier.  The implicit declarations occur in the same order
as the statement_identifiers occur in the source text.  If a usage name
denotes such an implicit declaration, the entity it denotes is the
label, loop_statement, or block_statement with the given
statement_identifier.

12.1/3
If one or more labels end a sequence_of_statements, an implicit
null_statement follows the labels before any following constructs.

                          _Dynamic Semantics_

13
The execution of a null_statement has no effect.

14/2
A <transfer of control> is the run-time action of an exit_statement,
return statement, goto_statement, or requeue_statement, selection of a
terminate_alternative, raising of an exception, or an abort, which
causes the next action performed to be one other than what would
normally be expected from the other rules of the language.  As explained
in *note 7.6.1::, a transfer of control can cause the execution of
constructs to be completed and then left, which may trigger
finalization.

15
The execution of a sequence_of_statements consists of the execution of
the individual statements in succession until the sequence_ is
completed.

     NOTES

16
     1  A statement_identifier that appears immediately within the
     declarative region of a named loop_statement or an accept_statement
     is nevertheless implicitly declared immediately within the
     declarative region of the innermost enclosing body or
     block_statement; in other words, the expanded name for a named
     statement is not affected by whether the statement occurs inside or
     outside a named loop or an accept_statement -- only nesting within
     block_statements is relevant to the form of its expanded name.

                              _Examples_

17
<Examples of labeled statements:>

18
     <<Here>> <<Ici>> <<Aqui>> <<Hier>> null;

19
     <<After>> X := 1;


File: arm2012.info,  Node: 5.2,  Next: 5.3,  Prev: 5.1,  Up: 5

5.2 Assignment Statements
=========================

1
An assignment_statement replaces the current value of a variable with
the result of evaluating an expression.

                               _Syntax_

2
     assignment_statement ::=
        <variable_>name := expression;

3
The execution of an assignment_statement includes the evaluation of the
expression and the <assignment> of the value of the expression into the
<target>.  An assignment operation (as opposed to an
assignment_statement (*note 5.2: S0152.)) is performed in other contexts
as well, including object initialization and by-copy parameter passing.The <target> of an assignment operation is the view of the object to
which a value is being assigned; the target of an assignment_statement
(*note 5.2: S0152.) is the variable denoted by the <variable_>name.

                        _Name Resolution Rules_

4/2
The <variable_>name of an assignment_statement is expected to be of any
type.  The expected type for the expression is the type of the target.

                           _Legality Rules_

5/2
The target denoted by the <variable_>name shall be a variable of a
nonlimited type.

6
If the target is of a tagged class-wide type <T>'Class, then the
expression shall either be dynamically tagged, or of type <T> and
tag-indeterminate (see *note 3.9.2::).

                          _Dynamic Semantics_

7
For the execution of an assignment_statement, the <variable_>name and
the expression are first evaluated in an arbitrary order.

8
When the type of the target is class-wide:

9
   * If the expression is tag-indeterminate (see *note 3.9.2::), then
     the controlling tag value for the expression is the tag of the
     target;

10
   * Otherwise (the expression is dynamically tagged), a check is made
     that the tag of the value of the expression is the same as that of
     the target; if this check fails, Constraint_Error is raised.

11
The value of the expression is converted to the subtype of the target.
The conversion might raise an exception (see *note 4.6::).  

12
In cases involving controlled types, the target is finalized, and an
anonymous object might be used as an intermediate in the assignment, as
described in *note 7.6.1::, "*note 7.6.1:: Completion and Finalization".
In any case, the converted value of the expression is then <assigned> to
the target, which consists of the following two steps:

13
   * The value of the target becomes the converted value.

14/3
   * If any part of the target is controlled, its value is adjusted as
     explained in subclause *note 7.6::.  

     NOTES

15
     2  The tag of an object never changes; in particular, an
     assignment_statement does not change the tag of the target.

16/2
     <This paragraph was deleted.>

                              _Examples_

17
<Examples of assignment statements:>

18
     Value := Max_Value - 1;
     Shade := Blue;

19
     Next_Frame(F)(M, N) := 2.5;        --<  see *note 4.1.1::>
     U := Dot_Product(V, W);            --<  see *note 6.3::>

20/4
     Writer := (Status => Open, Unit => Printer, Line_Count => 60);  --< see *note 3.8.1::>
     Next.all := (72074, null, Head);   --<  see *note 3.10.1::>

21
<Examples involving scalar subtype conversions:>

22
     I, J : Integer range 1 .. 10 := 5;
     K    : Integer range 1 .. 20 := 15;
      ...

23
     I := J;  --<  identical ranges>
     K := J;  --<  compatible ranges>
     J := K;  --<  will raise Constraint_Error if K > 10>

24
<Examples involving array subtype conversions:>

25
     A : String(1 .. 31);
     B : String(3 .. 33);
      ...

26
     A := B;  --<  same number of components>

27
     A(1 .. 9)  := "tar sauce";
     A(4 .. 12) := A(1 .. 9);  --<  A(1 .. 12) = "tartar sauce">

     NOTES

28
     3  <Notes on the examples:> Assignment_statements are allowed even
     in the case of overlapping slices of the same array, because the
     <variable_>name and expression are both evaluated before copying
     the value into the variable.  In the above example, an
     implementation yielding A(1 ..  12) = "tartartartar" would be
     incorrect.


File: arm2012.info,  Node: 5.3,  Next: 5.4,  Prev: 5.2,  Up: 5

5.3 If Statements
=================

1
An if_statement selects for execution at most one of the enclosed
sequences_of_statements, depending on the (truth) value of one or more
corresponding conditions.

                               _Syntax_

2
     if_statement ::=
         if condition then
           sequence_of_statements
        {elsif condition then
           sequence_of_statements}
        [else
           sequence_of_statements]
         end if;

<Paragraphs 3 and 4 were deleted.>

                          _Dynamic Semantics_

5/3
For the execution of an if_statement, the condition specified after if,
and any conditions specified after elsif, are evaluated in succession
(treating a final else as elsif True then), until one evaluates to True
or all conditions are evaluated and yield False.  If a condition
evaluates to True, then the corresponding sequence_of_statements is
executed; otherwise, none of them is executed.

                              _Examples_

6
<Examples of if statements:>

7
     if Month = December and Day = 31 then
        Month := January;
        Day   := 1;
        Year  := Year + 1;
     end if;

8
     if Line_Too_Short then
        raise Layout_Error;
     elsif Line_Full then
        New_Line;
        Put(Item);
     else
        Put(Item);
     end if;

9
     if My_Car.Owner.Vehicle /= My_Car then            --<  see *note 3.10.1::>
        Report ("Incorrect data");
     end if;


File: arm2012.info,  Node: 5.4,  Next: 5.5,  Prev: 5.3,  Up: 5

5.4 Case Statements
===================

1
A case_statement selects for execution one of a number of alternative
sequences_of_statements; the chosen alternative is defined by the value
of an expression.

                               _Syntax_

2/3
     case_statement ::=
        case <selecting_>expression is
            case_statement_alternative
           {case_statement_alternative}
        end case;

3
     case_statement_alternative ::=
        when discrete_choice_list =>
           sequence_of_statements

                        _Name Resolution Rules_

4/3
The <selecting_>expression is expected to be of any discrete type.  The
expected type for each discrete_choice is the type of the
<selecting_>expression.

                           _Legality Rules_

5/3
The choice_expressions, subtype_indications, and ranges given as
discrete_choices of a case_statement shall be static.  A discrete_choice
others, if present, shall appear alone and in the last
discrete_choice_list.

6/3
The possible values of the <selecting_>expression shall be covered (see
*note 3.8.1::) as follows:

7/4
   * If the <selecting_>expression is a name (including a
     type_conversion, qualified_expression, or function_call) having a
     static and constrained nominal subtype, then each non-others
     discrete_choice shall cover only values in that subtype that
     satisfy its predicates (see *note 3.2.4::), and each value of that
     subtype that satisfies its predicates shall be covered by some
     discrete_choice (either explicitly or by others).

8/3
   * If the type of the <selecting_>expression is <root_integer>,
     <universal_integer>, or a descendant of a formal scalar type, then
     the case_statement shall have an others discrete_choice.

9/3
   * Otherwise, each value of the base range of the type of the
     <selecting_>expression shall be covered (either explicitly or by
     others).

10
Two distinct discrete_choices of a case_statement shall not cover the
same value.

                          _Dynamic Semantics_

11/3
For the execution of a case_statement the <selecting_>expression is
first evaluated.

12/3
If the value of the <selecting_>expression is covered by the
discrete_choice_list (*note 3.8.1: S0073.) of some
case_statement_alternative (*note 5.4: S0155.), then the
sequence_of_statements (*note 5.1: S0145.) of the _alternative is
executed.

13
Otherwise (the value is not covered by any discrete_choice_list, perhaps
due to being outside the base range), Constraint_Error is raised.

     NOTES

14
     4  The execution of a case_statement chooses one and only one
     alternative.  Qualification of the expression of a case_statement
     by a static subtype can often be used to limit the number of
     choices that need be given explicitly.

                              _Examples_

15
<Examples of case statements:>

16
     case Sensor is
        when Elevation   => Record_Elevation(Sensor_Value);
        when Azimuth   => Record_Azimuth  (Sensor_Value);
        when Distance   => Record_Distance (Sensor_Value);
        when others   => null;
     end case;

17
     case Today is
        when Mon   => Compute_Initial_Balance;
        when Fri   => Compute_Closing_Balance;
        when Tue .. Thu   => Generate_Report(Today);
        when Sat .. Sun   => null;
     end case;

18
     case Bin_Number(Count) is
        when 1   => Update_Bin(1);
        when 2   => Update_Bin(2);
        when 3 | 4   =>
           Empty_Bin(1);
           Empty_Bin(2);
        when others   => raise Error;
     end case;


File: arm2012.info,  Node: 5.5,  Next: 5.6,  Prev: 5.4,  Up: 5

5.5 Loop Statements
===================

1
A loop_statement includes a sequence_of_statements that is to be
executed repeatedly, zero or more times.

                               _Syntax_

2
     loop_statement ::=
        [<loop_>statement_identifier:]
           [iteration_scheme] loop
              sequence_of_statements
            end loop [<loop_>identifier];

3/3
     iteration_scheme ::= while condition
        | for loop_parameter_specification
        | for iterator_specification

4
     loop_parameter_specification ::=
        defining_identifier in [reverse] discrete_subtype_definition

5
     If a loop_statement has a <loop_>statement_identifier, then the
     identifier shall be repeated after the end loop; otherwise, there
     shall not be an identifier after the end loop.

                          _Static Semantics_

6
A loop_parameter_specification declares a <loop parameter>, which is an
object whose subtype is that defined by the discrete_subtype_definition.

                          _Dynamic Semantics_

7
For the execution of a loop_statement, the sequence_of_statements is
executed repeatedly, zero or more times, until the loop_statement is
complete.  The loop_statement is complete when a transfer of control
occurs that transfers control out of the loop, or, in the case of an
iteration_scheme, as specified below.

8
For the execution of a loop_statement with a while iteration_scheme, the
condition is evaluated before each execution of the
sequence_of_statements (*note 5.1: S0145.); if the value of the
condition is True, the sequence_of_statements (*note 5.1: S0145.) is
executed; if False, the execution of the loop_statement (*note 5.5:
S0156.) is complete.

9/4
For the execution of a loop_statement with the iteration_scheme being
for loop_parameter_specification (*note 5.5: S0158.), the
loop_parameter_specification (*note 5.5: S0158.) is first elaborated.
This elaboration creates the loop parameter and elaborates the
discrete_subtype_definition (*note 3.6: S0055.).  If the
discrete_subtype_definition (*note 3.6: S0055.) defines a subtype with a
null range, the execution of the loop_statement is complete.  Otherwise,
the sequence_of_statements (*note 5.1: S0145.) is executed once for each
value of the discrete subtype defined by the discrete_subtype_definition
(*note 3.6: S0055.) that satisfies the predicates of the subtype (or
until the loop is left as a consequence of a transfer of control).
Prior to each such iteration, the corresponding value of the discrete
subtype is assigned to the loop parameter.  These values are assigned in
increasing order unless the reserved word reverse is present, in which
case the values are assigned in decreasing order.

9.1/3
For details about the execution of a loop_statement with the
iteration_scheme being for iterator_specification, see *note 5.5.2::.

     NOTES

10
     5  A loop parameter is a constant; it cannot be updated within the
     sequence_of_statements of the loop (see *note 3.3::).

11
     6  An object_declaration should not be given for a loop parameter,
     since the loop parameter is automatically declared by the
     loop_parameter_specification.  The scope of a loop parameter
     extends from the loop_parameter_specification to the end of the
     loop_statement, and the visibility rules are such that a loop
     parameter is only visible within the sequence_of_statements of the
     loop.

12
     7  The discrete_subtype_definition of a for loop is elaborated just
     once.  Use of the reserved word reverse does not alter the discrete
     subtype defined, so that the following iteration_schemes are not
     equivalent; the first has a null range.

13
          for J in reverse 1 .. 0
          for J in 0 .. 1

                              _Examples_

14
<Example of a loop statement without an iteration scheme:>

15
     loop
        Get(Current_Character);
        exit when Current_Character = '*';
     end loop;

16
<Example of a loop statement with a while iteration scheme:>

17
     while Bid(N).Price < Cut_Off.Price loop
        Record_Bid(Bid(N).Price);
        N := N + 1;
     end loop;

18
<Example of a loop statement with a for iteration scheme:>

19
     for J in Buffer'Range loop     --<  works even with a null range>
        if Buffer(J) /= Space then
           Put(Buffer(J));
        end if;
     end loop;

20
<Example of a loop statement with a name:>

21
     Summation:
        while Next /= Head loop       --< see *note 3.10.1::>
           Sum  := Sum + Next.Value;
           Next := Next.Succ;
        end loop Summation;

* Menu:

* 5.5.1 ::    User-Defined Iterator Types
* 5.5.2 ::    Generalized Loop Iteration


File: arm2012.info,  Node: 5.5.1,  Next: 5.5.2,  Up: 5.5

5.5.1 User-Defined Iterator Types
---------------------------------

                          _Static Semantics_

1/3
The following language-defined generic library package exists:

2/3
     generic
        type Cursor;
        with function Has_Element (Position : Cursor) return Boolean;
     package Ada.Iterator_Interfaces is
        pragma Pure (Iterator_Interfaces);

3/3
        type Forward_Iterator is limited interface;
        function First (Object : Forward_Iterator) return Cursor is abstract;
        function Next (Object : Forward_Iterator; Position : Cursor)
           return Cursor is abstract;

4/3
        type Reversible_Iterator is limited interface and Forward_Iterator;
        function Last (Object : Reversible_Iterator) return Cursor is abstract;
        function Previous (Object : Reversible_Iterator; Position : Cursor)
           return Cursor is abstract;

5/3
     end Ada.Iterator_Interfaces;

6/3
An <iterator type> is a type descended from the Forward_Iterator
interface from some instance of Ada.Iterator_Interfaces.  A <reversible
iterator type> is a type descended from the Reversible_Iterator
interface from some instance of Ada.Iterator_Interfaces.  An <iterator
object> is an object of an iterator type.  A <reversible iterator
object> is an object of a reversible iterator type.  The formal subtype
Cursor from the associated instance of Ada.Iterator_Interfaces is the
<iteration cursor subtype> for the iterator type.

7/3
The following type-related operational aspects may be specified for an
indexable container type <T> (see *note 4.1.6::):

8/3
Default_Iterator
               This aspect is specified by a name that denotes exactly
               one function declared immediately within the same
               declaration list in which <T> is declared, whose first
               parameter is of type <T> or <T>'Class or an access
               parameter whose designated type is type <T> or <T>'Class,
               whose other parameters, if any, have default expressions,
               and whose result type is an iterator type.  This function
               is the <default iterator function> for <T>.  Its result
               subtype is the <default iterator subtype> for <T>.  The
               iteration cursor subtype for the default iterator subtype
               is the <default cursor subtype> for <T>.

9/3
Iterator_Element
               This aspect is specified by a name that denotes a
               subtype.  This is the <default element subtype> for <T>.

10/3
These aspects are inherited by descendants of type <T> (including
<T>'Class).

11/3
An <iterable container type> is an indexable container type with
specified Default_Iterator and Iterator_Element aspects.  A <reversible
iterable container type> is an iterable container type with the default
iterator type being a reversible iterator type.  An <iterable container
object> is an object of an iterable container type.  A <reversible
iterable container object> is an object of a reversible iterable
container type.

11.1/4
The Default_Iterator and Iterator_Element aspects are nonoverridable
(see *note 13.1.1::).

                           _Legality Rules_

12/3
The Constant_Indexing aspect (if any) of an iterable container type <T>
shall denote exactly one function with the following properties:

13/3
   * the result type of the function is covered by the default element
     type of <T> or is a reference type (see *note 4.1.5::) with an
     access discriminant designating a type covered by the default
     element type of <T>;

14/3
   * the type of the second parameter of the function covers the default
     cursor type for <T>;

15/3
   * if there are more than two parameters, the additional parameters
     all have default expressions.

16/3
This function (if any) is the <default constant indexing function> for
<T>.

17/3
The Variable_Indexing aspect (if any) of an iterable container type <T>
shall denote exactly one function with the following properties:

18/3
   * the result type of the function is a reference type (see *note
     4.1.5::) with an access discriminant designating a type covered by
     the default element type of <T>;

19/3
   * the type of the second parameter of the function covers the default
     cursor type for <T>;

20/3
   * if there are more than two parameters, the additional parameters
     all have default expressions.

21/3
This function (if any) is the <default variable indexing function> for
<T>.


File: arm2012.info,  Node: 5.5.2,  Prev: 5.5.1,  Up: 5.5

5.5.2 Generalized Loop Iteration
--------------------------------

1/3
Generalized forms of loop iteration are provided by an
iterator_specification.

                               _Syntax_

2/3
     iterator_specification ::=
         defining_identifier in [reverse] <iterator_>name
       | defining_identifier [: 
     subtype_indication] of [reverse] <iterable_>name

                        _Name Resolution Rules_

3/3
For the first form of iterator_specification, called a <generalized
iterator>, the expected type for the <iterator_>name is any iterator
type.  For the second form of iterator_specification, the expected type
for the <iterable_>name is any array or iterable container type.  If the
<iterable_>name denotes an array object, the iterator_specification is
called an <array component iterator>; otherwise it is called a
<container element iterator>.

                           _Legality Rules_

4/3
If the reserved word reverse appears, the iterator_specification is a
<reverse iterator>; otherwise it is a <forward iterator>.  In a reverse
generalized iterator, the <iterator_>name shall be of a reversible
iterator type.  In a reverse container element iterator, the default
iterator type for the type of the <iterable_>name shall be a reversible
iterator type.

5/4
The subtype defined by the subtype_indication, if any, of an array
component iterator shall statically match the component subtype of the
type of the <iterable_>name.  The subtype defined by the
subtype_indication, if any, of a container element iterator shall
statically match the default element subtype for the type of the
<iterable_>name.

6/3
In a container element iterator whose <iterable_>name has type <T>, if
the <iterable_>name denotes a constant or the Variable_Indexing aspect
is not specified for <T>, then the Constant_Indexing aspect shall be
specified for <T>.

6.1/4
The <iterator_>name or <iterable_>name of an iterator_specification
shall not denote a subcomponent that depends on discriminants of an
object whose nominal subtype is unconstrained, unless the object is
known to be constrained.

6.2/4
A container element iterator is illegal if the call of the default
iterator function that creates the loop iterator (see below) is illegal.

6.3/4
A generalized iterator is illegal if the iteration cursor subtype of the
<iterator_>name is a limited type at the point of the generalized
iterator.  A container element iterator is illegal if the default cursor
subtype of the type of the <iterable_>name is a limited type at the
point of the container element iterator.

                          _Static Semantics_

7/3
An iterator_specification declares a <loop parameter>.  In a generalized
iterator, the nominal subtype of the loop parameter is the iteration
cursor subtype.  In an array component iterator or a container element
iterator, if a subtype_indication is present, it determines the nominal
subtype of the loop parameter.  In an array component iterator, if a
subtype_indication is not present, the nominal subtype of the loop
parameter is the component subtype of the type of the <iterable_>name.
In a container element iterator, if a subtype_indication is not present,
the nominal subtype of the loop parameter is the default element subtype
for the type of the <iterable_>name.

8/3
In a generalized iterator, the loop parameter is a constant.  In an
array component iterator, the loop parameter is a constant if the
<iterable_>name denotes a constant; otherwise it denotes a variable.  In
a container element iterator, the loop parameter is a constant if the
<iterable_>name denotes a constant, or if the Variable_Indexing aspect
is not specified for the type of the <iterable_>name; otherwise it is a
variable.

                          _Dynamic Semantics_

9/3
For the execution of a loop_statement with an iterator_specification,
the iterator_specification is first elaborated.  This elaboration
elaborates the subtype_indication, if any.

10/3
For a generalized iterator, the loop parameter is created, the
<iterator_>name is evaluated, and the denoted iterator object becomes
the <loop iterator>.  In a forward generalized iterator, the operation
First of the iterator type is called on the loop iterator, to produce
the initial value for the loop parameter.  If the result of calling
Has_Element on the initial value is False, then the execution of the
loop_statement is complete.  Otherwise, the sequence_of_statements is
executed and then the Next operation of the iterator type is called with
the loop iterator and the current value of the loop parameter to produce
the next value to be assigned to the loop parameter.  This repeats until
the result of calling Has_Element on the loop parameter is False, or the
loop is left as a consequence of a transfer of control.  For a reverse
generalized iterator, the operations Last and Previous are called rather
than First and Next.

11/3
For an array component iterator, the <iterable_>name is evaluated and
the denoted array object becomes the <array for the loop>.  If the array
for the loop is a null array, then the execution of the loop_statement
is complete.  Otherwise, the sequence_of_statements is executed with the
loop parameter denoting each component of the array for the loop, using
a <canonical> order of components, which is last dimension varying
fastest (unless the array has convention Fortran, in which case it is
first dimension varying fastest).  For a forward array component
iterator, the iteration starts with the component whose index values are
each the first in their index range, and continues in the canonical
order.  For a reverse array component iterator, the iteration starts
with the component whose index values are each the last in their index
range, and continues in the reverse of the canonical order.  The loop
iteration proceeds until the sequence_of_statements has been executed
for each component of the array for the loop, or until the loop is left
as a consequence of a transfer of control.

12/3
For a container element iterator, the <iterable_>name is evaluated and
the denoted iterable container object becomes the <iterable container
object for the loop>.  The default iterator function for the type of the
iterable container object for the loop is called on the iterable
container object and the result is the <loop iterator>.  An object of
the default cursor subtype is created (the <loop cursor>).

13/3
For a forward container element iterator, the operation First of the
iterator type is called on the loop iterator, to produce the initial
value for the loop cursor.  If the result of calling Has_Element on the
initial value is False, then the execution of the loop_statement is
complete.  Otherwise, the sequence_of_statements is executed with the
loop parameter denoting an indexing (see *note 4.1.6::) into the
iterable container object for the loop, with the only parameter to the
indexing being the current value of the loop cursor; then the Next
operation of the iterator type is called with the loop iterator and the
loop cursor to produce the next value to be assigned to the loop cursor.
This repeats until the result of calling Has_Element on the loop cursor
is False, or until the loop is left as a consequence of a transfer of
control.  For a reverse container element iterator, the operations Last
and Previous are called rather than First and Next.  If the loop
parameter is a constant (see above), then the indexing uses the default
constant indexing function for the type of the iterable container object
for the loop; otherwise it uses the default variable indexing function.

14/4
Any exception propagated by the execution of a generalized iterator or
container element iterator is propagated by the immediately enclosing
loop statement.

                              _Examples_

15/3
     -- <Array component iterator example:>
     for Element of Board loop  -- <See *note 3.6.1::.>
        Element := Element * 2.0; -- <Double each element of Board, a two-dimensional array.>
     end loop;

16/3
For examples of use of generalized iterators, see *note A.18.32:: and
the corresponding container packages in *note A.18.2:: and *note
A.18.3::.


File: arm2012.info,  Node: 5.6,  Next: 5.7,  Prev: 5.5,  Up: 5

5.6 Block Statements
====================

1
A block_statement encloses a handled_sequence_of_statements optionally
preceded by a declarative_part.

                               _Syntax_

2
     block_statement ::=
        [<block_>statement_identifier:]
            [declare
                 declarative_part]
             begin
                 handled_sequence_of_statements
             end [<block_>identifier];

3
     If a block_statement has a <block_>statement_identifier, then the
     identifier shall be repeated after the end; otherwise, there shall
     not be an identifier after the end.

                          _Static Semantics_

4
A block_statement that has no explicit declarative_part has an implicit
empty declarative_part.

                          _Dynamic Semantics_

5
The execution of a block_statement consists of the elaboration of its
declarative_part followed by the execution of its
handled_sequence_of_statements.

                              _Examples_

6
<Example of a block statement with a local variable:>

7
     Swap:
        declare
           Temp : Integer;
        begin
           Temp := V; V := U; U := Temp;
        end Swap;


File: arm2012.info,  Node: 5.7,  Next: 5.8,  Prev: 5.6,  Up: 5

5.7 Exit Statements
===================

1
An exit_statement is used to complete the execution of an enclosing
loop_statement; the completion is conditional if the exit_statement
includes a condition.

                               _Syntax_

2
     exit_statement ::=
        exit [<loop_>name] [when condition];

                        _Name Resolution Rules_

3
The <loop_>name, if any, in an exit_statement shall resolve to denote a
loop_statement.

                           _Legality Rules_

4
Each exit_statement (*note 5.7: S0161.) <applies to> a loop_statement
(*note 5.5: S0156.); this is the loop_statement (*note 5.5: S0156.)
being exited.  An exit_statement (*note 5.7: S0161.) with a name is only
allowed within the loop_statement (*note 5.5: S0156.) denoted by the
name, and applies to that loop_statement (*note 5.5: S0156.).  An
exit_statement (*note 5.7: S0161.) without a name is only allowed within
a loop_statement (*note 5.5: S0156.), and applies to the innermost
enclosing one.  An exit_statement (*note 5.7: S0161.) that applies to a
given loop_statement (*note 5.5: S0156.) shall not appear within a body
or accept_statement (*note 9.5.2: S0219.), if this construct is itself
enclosed by the given loop_statement.

                          _Dynamic Semantics_

5
For the execution of an exit_statement, the condition, if present, is
first evaluated.  If the value of the condition is True, or if there is
no condition, a transfer of control is done to complete the
loop_statement (*note 5.5: S0156.).  If the value of the condition is
False, no transfer of control takes place.

     NOTES

6
     8  Several nested loops can be exited by an exit_statement that
     names the outer loop.

                              _Examples_

7
<Examples of loops with exit statements:>

8
     for N in 1 .. Max_Num_Items loop
        Get_New_Item(New_Item);
        Merge_Item(New_Item, Storage_File);
        exit when New_Item = Terminal_Item;
     end loop;

9
     Main_Cycle:
        loop
           --<  initial statements>
           exit Main_Cycle when Found;
           --<  final statements>
        end loop Main_Cycle;


File: arm2012.info,  Node: 5.8,  Prev: 5.7,  Up: 5

5.8 Goto Statements
===================

1
A goto_statement specifies an explicit transfer of control from this
statement to a target statement with a given label.

                               _Syntax_

2
     goto_statement ::= goto <label_>name;

                        _Name Resolution Rules_

3
The <label_>name shall resolve to denote a label; the statement with
that label is the <target statement>.

                           _Legality Rules_

4
The innermost sequence_of_statements that encloses the target statement
shall also enclose the goto_statement.  Furthermore, if a goto_statement
is enclosed by an accept_statement or a body, then the target statement
shall not be outside this enclosing construct.

                          _Dynamic Semantics_

5
The execution of a goto_statement transfers control to the target
statement, completing the execution of any compound_statement that
encloses the goto_statement but does not enclose the target.

     NOTES

6
     9  The above rules allow transfer of control to a statement of an
     enclosing sequence_of_statements but not the reverse.  Similarly,
     they prohibit transfers of control such as between alternatives of
     a case_statement, if_statement, or select_statement; between
     exception_handlers; or from an exception_handler of a
     handled_sequence_of_statements back to its sequence_of_statements.

                              _Examples_

7
<Example of a loop containing a goto statement:>

8
     <<Sort>>
     for I in 1 .. N-1 loop
        if A(I) > A(I+1) then
           Exchange(A(I), A(I+1));
           goto Sort;
        end if;
     end loop;


File: arm2012.info,  Node: 6,  Next: 7,  Prev: 5,  Up: Top

6 Subprograms
*************

1
A subprogram is a program unit or intrinsic operation whose execution is
invoked by a subprogram call.  There are two forms of subprogram:
procedures and functions.  A procedure call is a statement; a function
call is an expression and returns a value.  The definition of a
subprogram can be given in two parts: a subprogram declaration defining
its interface, and a subprogram_body defining its execution.  Operators
and enumeration literals are functions.

2/3
A <callable entity> is a subprogram or entry (see Section 9).  A
callable entity is invoked by a <call>; that is, a subprogram call or
entry call.  A <callable construct> is a construct that defines the
action of a call upon a callable entity: a subprogram_body, entry_body,
or accept_statement.

* Menu:

* 6.1 ::      Subprogram Declarations
* 6.2 ::      Formal Parameter Modes
* 6.3 ::      Subprogram Bodies
* 6.4 ::      Subprogram Calls
* 6.5 ::      Return Statements
* 6.6 ::      Overloading of Operators
* 6.7 ::      Null Procedures
* 6.8 ::      Expression Functions


File: arm2012.info,  Node: 6.1,  Next: 6.2,  Up: 6

6.1 Subprogram Declarations
===========================

1
A subprogram_declaration declares a procedure or function.

                               _Syntax_

2/3
     subprogram_declaration ::=
         [overriding_indicator]
         subprogram_specification
             [aspect_specification];

3/2
     <This paragraph was deleted.>

4/2
     subprogram_specification ::=
         procedure_specification
       | function_specification

4.1/2
     procedure_specification ::= procedure defining_program_unit_name 
     parameter_profile

4.2/2
     function_specification ::= function defining_designator 
     parameter_and_result_profile

5
     designator ::= [parent_unit_name . ]identifier | operator_symbol

6
     defining_designator ::= defining_program_unit_name | 
     defining_operator_symbol

7
     defining_program_unit_name ::= [parent_unit_name . ]
     defining_identifier

8
     The optional parent_unit_name is only allowed for library units
     (see *note 10.1.1::).

9
     operator_symbol ::= string_literal

10/3
     The sequence of characters in an operator_symbol shall form a
     reserved word, a delimiter, or compound delimiter that corresponds
     to an operator belonging to one of the six categories of operators
     defined in subclause *note 4.5::.

11
     defining_operator_symbol ::= operator_symbol

12
     parameter_profile ::= [formal_part]

13/2
     parameter_and_result_profile ::=
         [formal_part] return [null_exclusion] subtype_mark
       | [formal_part] return access_definition

14
     formal_part ::=
        (parameter_specification {; parameter_specification})

15/3
     parameter_specification ::=
         defining_identifier_list : [aliased] mode [null_exclusion] 
     subtype_mark [:= default_expression]
       | defining_identifier_list : access_definition [:= 
     default_expression]

16
     mode ::= [in] | in out | out

                        _Name Resolution Rules_

17
A <formal parameter> is an object directly visible within a
subprogram_body that represents the actual parameter passed to the
subprogram in a call; it is declared by a parameter_specification.  For
a formal parameter, the expected type for its default_expression, if
any, is that of the formal parameter.  

                           _Legality Rules_

18/3
The <parameter mode> of a formal parameter conveys the direction of
information transfer with the actual parameter: in, in out, or out.
Mode in is the default, and is the mode of a parameter defined by an
access_definition.

19
A default_expression is only allowed in a parameter_specification for a
formal parameter of mode in.

20/3
A subprogram_declaration or a generic_subprogram_declaration requires a
completion unless the Import aspect (see *note B.1::) is True for the
declaration; the completion shall be a body or a renaming_declaration
(see *note 8.5::).  A completion is not allowed for an
abstract_subprogram_declaration (see *note 3.9.3::), a
null_procedure_declaration (see *note 6.7::), or an
expression_function_declaration (see *note 6.8::).

21
A name that denotes a formal parameter is not allowed within the
formal_part in which it is declared, nor within the formal_part of a
corresponding body or accept_statement.

                          _Static Semantics_

22
The <profile> of (a view of) a callable entity is either a
parameter_profile or parameter_and_result_profile; it embodies
information about the interface to that entity -- for example, the
profile includes information about parameters passed to the callable
entity.  All callable entities have a profile -- enumeration literals,
other subprograms, and entries.  An access-to-subprogram type has a
designated profile.  Associated with a profile is a calling convention.
A subprogram_declaration declares a procedure or a function, as
indicated by the initial reserved word, with name and profile as given
by its specification.

23/2
The nominal subtype of a formal parameter is the subtype determined by
the optional null_exclusion and the subtype_mark, or defined by the
access_definition, in the parameter_specification.  The nominal subtype
of a function result is the subtype determined by the optional
null_exclusion and the subtype_mark, or defined by the
access_definition, in the parameter_and_result_profile.  

23.1/3
An <explicitly aliased parameter> is a formal parameter whose
parameter_specification includes the reserved word aliased.

24/2
An <access parameter> is a formal in parameter specified by an
access_definition.  An <access result type> is a function result type
specified by an access_definition.  An access parameter or result type
is of an anonymous access type (see *note 3.10::).  Access parameters of
an access-to-object type allow dispatching calls to be controlled by
access values.  Access parameters of an access-to-subprogram type permit
calls to subprograms passed as parameters irrespective of their
accessibility level.

25
The <subtypes of a profile> are:

26
   * For any non-access parameters, the nominal subtype of the
     parameter.

27/2
   * For any access parameters of an access-to-object type, the
     designated subtype of the parameter type.

27.1/3
   * For any access parameters of an access-to-subprogram type, the
     subtypes of the designated profile of the parameter type.

28/2
   * For any non-access result, the nominal subtype of the function
     result.

28.1/2
   * For any access result type of an access-to-object type, the
     designated subtype of the result type.

28.2/3
   * For any access result type of an access-to-subprogram type, the
     subtypes of the designated profile of the result type.

29
The <types of a profile> are the types of those subtypes.

30/3
A subprogram declared by an abstract_subprogram_declaration is abstract;
a subprogram declared by a subprogram_declaration is not.  See *note
3.9.3::, "*note 3.9.3:: Abstract Types and Subprograms".  Similarly, a
procedure declared by a null_procedure_declaration is a null procedure;
a procedure declared by a subprogram_declaration is not.  See *note
6.7::, "*note 6.7:: Null Procedures".  Finally, a function declared by
an expression_function_declaration is an expression function; a function
declared by a subprogram_declaration is not.  See *note 6.8::, "*note
6.8:: Expression Functions".

30.1/2
An overriding_indicator is used to indicate whether overriding is
intended.  See *note 8.3.1::, "*note 8.3.1:: Overriding Indicators".

                          _Dynamic Semantics_

31/2
The elaboration of a subprogram_declaration has no effect.

     NOTES

32
     1  A parameter_specification with several identifiers is equivalent
     to a sequence of single parameter_specifications, as explained in
     *note 3.3::.

33
     2  Abstract subprograms do not have bodies, and cannot be used in a
     nondispatching call (see *note 3.9.3::, "*note 3.9.3:: Abstract
     Types and Subprograms").

34
     3  The evaluation of default_expressions is caused by certain
     calls, as described in *note 6.4.1::.  They are not evaluated
     during the elaboration of the subprogram declaration.

35
     4  Subprograms can be called recursively and can be called
     concurrently from multiple tasks.

                              _Examples_

36
<Examples of subprogram declarations:>

37
     procedure Traverse_Tree;
     procedure Increment(X : in out Integer);
     procedure Right_Indent(Margin : out Line_Size);          --<  see *note 3.5.4::>
     procedure Switch(From, To : in out Link);                --<  see *note 3.10.1::>

38
     function Random return Probability;                      --<  see *note 3.5.7::>

39/4
     function Min_Cell(X : Link) return Cell;                 --<  see *note 3.10.1::>
     function Next_Frame(K : Positive) return Frame;          --<  see *note 3.10::>
     function Dot_Product(Left, Right : Vector) return Real;  --<  see *note 3.6::>
     function Find(B : aliased in out Barrel; Key : String) return Real;
                                                              --<  see *note 4.1.5::>

40
     function "*"(Left, Right : Matrix) return Matrix;        --<  see *note 3.6::>

41
<Examples of in parameters with default expressions:>

42
     procedure Print_Header(Pages  : in Natural;
                 Header : in Line    :=  (1 .. Line'Last => ' ');  --<  see *note 3.6::>
                 Center : in Boolean := True);

* Menu:

* 6.1.1 ::    Preconditions and Postconditions


File: arm2012.info,  Node: 6.1.1,  Up: 6.1

6.1.1 Preconditions and Postconditions
--------------------------------------

1/4
For a noninstance subprogram, a generic subprogram, or an entry, the
following language-defined aspects may be specified with an
aspect_specification (see *note 13.1.1::):

2/3
Pre
               This aspect specifies a specific precondition for a
               callable entity; it shall be specified by an expression,
               called a <specific precondition expression>.  If not
               specified for an entity, the specific precondition
               expression for the entity is the enumeration literal
               True.

3/3
Pre'Class
               This aspect specifies a class-wide precondition for an
               operation of a tagged type and its descendants; it shall
               be specified by an expression, called a <class-wide
               precondition expression>.  If not specified for an
               entity, then if no other class-wide precondition applies
               to the entity, the class-wide precondition expression for
               the entity is the enumeration literal True.

4/3
Post
               This aspect specifies a specific postcondition for a
               callable entity; it shall be specified by an expression,
               called a <specific postcondition expression>.  If not
               specified for an entity, the specific postcondition
               expression for the entity is the enumeration literal
               True.

5/3
Post'Class
               This aspect specifies a class-wide postcondition for an
               operation of a tagged type and its descendants; it shall
               be specified by an expression, called a <class-wide
               postcondition expression>.  If not specified for an
               entity, the class-wide postcondition expression for the
               entity is the enumeration literal True.

                        _Name Resolution Rules_

6/3
The expected type for a precondition or postcondition expression is any
boolean type.

7/4
Within the expression for a Pre'Class or Post'Class aspect for a
primitive subprogram <S> of a tagged type <T>, a name that denotes a
formal parameter (or <S>'Result) of type <T> is interpreted as though it
had a (notional) type <NT> that is a formal derived type whose ancestor
type is <T>, with directly visible primitive operations.  Similarly, a
name that denotes a formal access parameter (or <S>'Result) of type
access-to-<T> is interpreted as having type access-to-<NT>.  The result
of this interpretation is that the only operations that can be applied
to such names are those defined for such a formal derived type.

8/3
For an attribute_reference with attribute_designator Old, if the
attribute reference has an expected type or shall resolve to a given
type, the same applies to the prefix; otherwise, the prefix shall be
resolved independently of context.

                           _Legality Rules_

9/3
The Pre or Post aspect shall not be specified for an abstract subprogram
or a null procedure.  Only the Pre'Class and Post'Class aspects may be
specified for such a subprogram.

10/3
If a type <T> has an implicitly declared subprogram <P> inherited from a
parent type <T1> and a homograph (see *note 8.3::) of <P> from a
progenitor type <T2>, and

11/3
   * the corresponding primitive subprogram <P1> of type <T1> is neither
     null nor abstract; and

12/3
   * the class-wide precondition expression True does not apply to <P1>
     (implicitly or explicitly); and

13/3
   * there is a class-wide precondition expression that applies to the
     corresponding primitive subprogram <P2> of <T2> that does not fully
     conform to any class-wide precondition expression that applies to
     <P1>,

14/3
then:

15/3
   * If the type <T> is abstract, the implicitly declared subprogram <P>
     is <abstract>.

16/3
   * Otherwise, the subprogram <P> <requires overriding> and shall be
     overridden with a nonabstract subprogram.

17/3
If a renaming of a subprogram or entry <S1> overrides an inherited
subprogram <S2>, then the overriding is illegal unless each class-wide
precondition expression that applies to <S1> fully conforms to some
class-wide precondition expression that applies to <S2> and each
class-wide precondition expression that applies to <S2> fully conforms
to some class-wide precondition expression that applies to <S1>.

17.1/4
Pre'Class shall not be specified for an overriding primitive subprogram
of a tagged type <T> unless the Pre'Class aspect is specified for the
corresponding primitive subprogram of some ancestor of <T>.

17.2/4
In addition to the places where Legality Rules normally apply (see *note
12.3::), these rules also apply in the private part of an instance of a
generic unit.

                          _Static Semantics_

18/4
If a Pre'Class or Post'Class aspect is specified for a primitive
subprogram <S> of a tagged type <T>, or such an aspect defaults to True,
then a corresponding expression also applies to the corresponding
primitive subprogram <S> of each descendant of <T>.  The <corresponding
expression> is constructed from the associated expression as follows: 

18.1/4
   * References to formal parameters of <S> (or to <S> itself) are
     replaced with references to the corresponding formal parameters of
     the corresponding inherited or overriding subprogram <S> (or to the
     corresponding subprogram <S> itself).

18.2/4
The primitive subprogram <S> is illegal if it is not abstract and the
corresponding expression for a Pre'Class or Post'Class aspect would be
illegal.

19/3
If performing checks is required by the Pre, Pre'Class, Post, or
Post'Class assertion policies (see *note 11.4.2::) in effect at the
point of a corresponding aspect specification applicable to a given
subprogram or entry, then the respective precondition or postcondition
expressions are considered <enabled>.

20/3
An expression is <potentially unevaluated> if it occurs within:

21/3
   * any part of an if_expression other than the first condition;

22/3
   * a <dependent_>expression of a case_expression;

22.1/4
   * a predicate of a quantified_expression;

23/3
   * the right operand of a short-circuit control form; or

24/3
   * a membership_choice other than the first of a membership operation.

25/3
For a prefix X that denotes an object of a nonlimited type, the
following attribute is defined:

26/4
X'Old
               Each X'Old in a postcondition expression that is enabled
               denotes a constant that is implicitly declared at the
               beginning of the subprogram body, entry body, or accept
               statement.

26.1/4
               The implicitly declared entity denoted by each occurrence
               of X'Old is declared as follows:

26.2/4
                  * If X is of an anonymous access type defined by an
                    access_definition <A> then

26.3/4
                         <X'Old> : constant <A> := X;

26.4/4
                  * If X is of a specific tagged type <T> then

26.5/4
                         <anonymous> : constant <T>'Class := <T>'Class(X);
                         <X'Old> : <T> renames <T>(<anonymous>);

26.6/4
                    where the name X'Old denotes the object renaming.

26.7/4
                  * Otherwise

26.8/4
                         <X'Old> : constant <S> := X;

26.9/4
                    where <S> is the nominal subtype of X. This includes
                    the case where the type of <S> is an anonymous array
                    type or a universal type.

26.10/4
               The nominal subtype of X'Old is as implied by the above
               definitions.  The expected type of the prefix of an Old
               attribute is that of the attribute.  Similarly, if an Old
               attribute shall resolve to be of some type, then the
               prefix of the attribute shall resolve to be of that type.

27/3
               Reference to this attribute is only allowed within a
               postcondition expression.  The prefix of an Old
               attribute_reference shall not contain a Result
               attribute_reference, nor an Old attribute_reference, nor
               a use of an entity declared within the postcondition
               expression but not within prefix itself (for example, the
               loop parameter of an enclosing quantified_expression).
               The prefix of an Old attribute_reference that is
               potentially unevaluated shall statically denote an
               entity.

28/3
For a prefix F that denotes a function declaration, the following
attribute is defined:

29/3
F'Result
               Within a postcondition expression for function F, denotes
               the result object of the function.  The type of this
               attribute is that of the function result except within a
               Post'Class postcondition expression for a function with a
               controlling result or with a controlling access result.
               For a controlling result, the type of the attribute is
               <T>'Class, where <T> is the function result type.  For a
               controlling access result, the type of the attribute is
               an anonymous access type whose designated type is
               <T>'Class, where <T> is the designated type of the
               function result type.

30/3
               Use of this attribute is allowed only within a
               postcondition expression for F.

                          _Dynamic Semantics_

31/3
Upon a call of the subprogram or entry, after evaluating any actual
parameters, precondition checks are performed as follows:

32/3
   * The specific precondition check begins with the evaluation of the
     specific precondition expression that applies to the subprogram or
     entry, if it is enabled; if the expression evaluates to False,
     Assertions.Assertion_Error is raised; if the expression is not
     enabled, the check succeeds.

33/3
   * The class-wide precondition check begins with the evaluation of any
     enabled class-wide precondition expressions that apply to the
     subprogram or entry.  If and only if all the class-wide
     precondition expressions evaluate to False,
     Assertions.Assertion_Error is raised.

34/3
The precondition checks are performed in an arbitrary order, and if any
of the class-wide precondition expressions evaluate to True, it is not
specified whether the other class-wide precondition expressions are
evaluated.  The precondition checks and any check for elaboration of the
subprogram body are performed in an arbitrary order.  It is not
specified whether in a call on a protected operation, the checks are
performed before or after starting the protected action.  For an entry
call, the checks are performed prior to checking whether the entry is
open.

35/3
Upon successful return from a call of the subprogram or entry, prior to
copying back any by-copy in out or out parameters, the postcondition
check is performed.  This consists of the evaluation of any enabled
specific and class-wide postcondition expressions that apply to the
subprogram or entry.  If any of the postcondition expressions evaluate
to False, then Assertions.Assertion_Error is raised.  The postcondition
expressions are evaluated in an arbitrary order, and if any
postcondition expression evaluates to False, it is not specified whether
any other postcondition expressions are evaluated.  The postcondition
check, and any constraint or predicate checks associated with in out or
out parameters are performed in an arbitrary order.

35.1/4
For a call to a task entry, the postcondition check is performed before
the end of the rendezvous; for a call to a protected operation, the
postcondition check is performed before the end of the protected action
of the call.  The postcondition check for any call is performed before
the finalization of any implicitly-declared constants associated (as
described above) with Old attribute_references but after the
finalization of any other entities whose accessibility level is that of
the execution of the callable construct.

36/3
If a precondition or postcondition check fails, the exception is raised
at the point of the call; the exception cannot be handled inside the
called subprogram or entry.  Similarly, any exception raised by the
evaluation of a precondition or postcondition expression is raised at
the point of call.

37/4
For any call to a subprogram or entry <S> (including dispatching calls),
the checks that are performed to verify specific precondition
expressions and specific and class-wide postcondition expressions are
determined by those for the subprogram or entry actually invoked.  Note
that the class-wide postcondition expressions verified by the
postcondition check that is part of a call on a primitive subprogram of
type <T> includes all class-wide postcondition expressions originating
in any progenitor of <T>, even if the primitive subprogram called is
inherited from a type <T1> and some of the postcondition expressions do
not apply to the corresponding primitive subprogram of <T1>.  Any
operations within a class-wide postcondition expression that were
resolved as primitive operations of the (notional) formal derived type
<NT>, are in the evaluation of the postcondition bound to the
corresponding operations of the type identified by the controlling tag
of the call on <S>.  This applies to both dispatching and
non-dispatching calls on <S>.

38/4
The class-wide precondition check for a call to a subprogram or entry
<S> consists solely of checking the class-wide precondition expressions
that apply to the denoted callable entity (not necessarily to the one
that is invoked).  Any operations within such an expression that were
resolved as primitive operations of the (notional) formal derived type
<NT> are in the evaluation of the precondition bound to the
corresponding operations of the type identified by the controlling tag
of the call on <S>.  This applies to both dispatching and
non-dispatching calls on <S>.

39/3
For a call via an access-to-subprogram value, all precondition and
postcondition checks performed are determined by the subprogram or entry
denoted by the prefix of the Access attribute reference that produced
the value.

     NOTES

40/3
     5  A precondition is checked just before the call.  If another task
     can change any value that the precondition expression depends on,
     the precondition need not hold within the subprogram or entry body.


File: arm2012.info,  Node: 6.2,  Next: 6.3,  Prev: 6.1,  Up: 6

6.2 Formal Parameter Modes
==========================

1
A parameter_specification declares a formal parameter of mode in, in
out, or out.

                          _Static Semantics_

2
A parameter is passed either <by copy> or <by reference>.  When a
parameter is passed by copy, the formal parameter denotes a separate
object from the actual parameter, and any information transfer between
the two occurs only before and after executing the subprogram.  When a
parameter is passed by reference, the formal parameter denotes (a view
of) the object denoted by the actual parameter; reads and updates of the
formal parameter directly reference the actual parameter object.

3/3
A type is a <by-copy type> if it is an elementary type, or if it is a
descendant of a private type whose full type is a by-copy type.  A
parameter of a by-copy type is passed by copy, unless the formal
parameter is explicitly aliased.

4
A type is a <by-reference type> if it is a descendant of one of the
following:

5
   * a tagged type;

6
   * a task or protected type;

7/3
   * an explicitly limited record type;

8
   * a composite type with a subcomponent of a by-reference type;

9
   * a private type whose full type is a by-reference type.

10/4
A parameter of a by-reference type is passed by reference, as is an
explicitly aliased parameter of any type.  Each value of a by-reference
type has an associated object.  For a parenthesized expression,
qualified_expression, or view conversion, this object is the one
associated with the operand.  For a value conversion, the associated
object is the anonymous result object if such an object is created (see
*note 4.6::); otherwise it is the associated object of the operand.  For
a conditional_expression, this object is the one associated with the
evaluated <dependent_>expression.

11/3
For other parameters, it is unspecified whether the parameter is passed
by copy or by reference.

                      _Bounded (Run-Time) Errors_

12/3
If one name denotes a part of a formal parameter, and a second name
denotes a part of a distinct formal parameter or an object that is not
part of a formal parameter, then the two names are considered <distinct
access paths>.  If an object is of a type for which the parameter
passing mechanism is not specified and is not an explicitly aliased
parameter, then it is a bounded error to assign to the object via one
access path, and then read the value of the object via a distinct access
path, unless the first access path denotes a part of a formal parameter
that no longer exists at the point of the second access (due to leaving
the corresponding callable construct).  The possible consequences are
that Program_Error is raised, or the newly assigned value is read, or
some old value of the object is read.

     NOTES

13/4
     6  The mode of a formal parameter describes the direction of
     information transfer to or from the subprogram_body (see *note
     6.1::).

14
     7  A formal parameter of mode in is a constant view (see *note
     3.3::); it cannot be updated within the subprogram_body.

15/4
     8  A formal parameter of mode out might be uninitialized at the
     start of the subprogram_body (see *note 6.4.1::).


File: arm2012.info,  Node: 6.3,  Next: 6.4,  Prev: 6.2,  Up: 6

6.3 Subprogram Bodies
=====================

1
A subprogram_body specifies the execution of a subprogram.

                               _Syntax_

2/3
     subprogram_body ::=
         [overriding_indicator]
         subprogram_specification
            [aspect_specification] is
            declarative_part
         begin
             handled_sequence_of_statements
         end [designator];

3
     If a designator appears at the end of a subprogram_body, it shall
     repeat the defining_designator of the subprogram_specification.

                           _Legality Rules_

4
In contrast to other bodies, a subprogram_body need not be the
completion of a previous declaration, in which case the body declares
the subprogram.  If the body is a completion, it shall be the completion
of a subprogram_declaration or generic_subprogram_declaration.  The
profile of a subprogram_body that completes a declaration shall conform
fully to that of the declaration.  

                          _Static Semantics_

5
A subprogram_body is considered a declaration.  It can either complete a
previous declaration, or itself be the initial declaration of the
subprogram.

                          _Dynamic Semantics_

6
The elaboration of a nongeneric subprogram_body has no other effect than
to establish that the subprogram can from then on be called without
failing the Elaboration_Check.

7
The execution of a subprogram_body is invoked by a subprogram call.  For
this execution the declarative_part is elaborated, and the
handled_sequence_of_statements is then executed.

                              _Examples_

8
<Example of procedure body:>

9
     procedure Push(E : in Element_Type; S : in out Stack) is
     begin
        if S.Index = S.Size then
           raise Stack_Overflow;
        else
           S.Index := S.Index + 1;
           S.Space(S.Index) := E;
        end if;
     end Push;

10
<Example of a function body:>

11
     function Dot_Product(Left, Right : Vector) return Real is
        Sum : Real := 0.0;
     begin
        Check(Left'First = Right'First and Left'Last = Right'Last);
        for J in Left'Range loop
           Sum := Sum + Left(J)*Right(J);
        end loop;
        return Sum;
     end Dot_Product;

* Menu:

* 6.3.1 ::    Conformance Rules
* 6.3.2 ::    Inline Expansion of Subprograms


File: arm2012.info,  Node: 6.3.1,  Next: 6.3.2,  Up: 6.3

6.3.1 Conformance Rules
-----------------------

1
When subprogram profiles are given in more than one place, they are
required to conform in one of four ways: type conformance, mode
conformance, subtype conformance, or full conformance.

                          _Static Semantics_

2/1
As explained in *note B.1::, "*note B.1:: Interfacing Aspects", a
<convention> can be specified for an entity.  Unless this International
Standard states otherwise, the default convention of an entity is Ada.
For a callable entity or access-to-subprogram type, the convention is
called the <calling convention>.  The following conventions are defined
by the language:

3/3
   * The default calling convention for any subprogram not listed below
     is <Ada>.  The Convention aspect may be specified to override the
     default calling convention (see *note B.1::).

4
   * The <Intrinsic> calling convention represents subprograms that are
     "built in" to the compiler.  The default calling convention is
     Intrinsic for the following:

5
             * an enumeration literal;

6
             * a "/=" operator declared implicitly due to the
               declaration of "=" (see *note 6.6::);

7
             * any other implicitly declared subprogram unless it is a
               dispatching operation of a tagged type;

8
             * an inherited subprogram of a generic formal tagged type
               with unknown discriminants;

9
             * an attribute that is a subprogram;

10/2
             * a subprogram declared immediately within a
               protected_body;

10.1/4
             * any prefixed view of a subprogram (see *note 4.1.3::)
               without synchronization kind (see *note 9.5::) By_Entry
               or By_Protected_Procedure.

11
     The Access attribute is not allowed for Intrinsic subprograms.

12/4
   * The default calling convention is <protected> for a protected
     subprogram, for a prefixed view of a subprogram with a
     synchronization kind of By_Protected_Procedure, and for an
     access-to-subprogram type with the reserved word protected in its
     definition.

13/4
   * The default calling convention is <entry> for an entry and for a
     prefixed view of a subprogram with a synchronization kind of
     By_Entry.

13.1/3
   * The calling convention for an anonymous access-to-subprogram
     parameter or anonymous access-to-subprogram result is <protected>
     if the reserved word protected appears in its definition;
     otherwise, it is the convention of the subprogram that contains the
     parameter.

13.2/1
   * If not specified above as Intrinsic, the calling convention for any
     inherited or overriding dispatching operation of a tagged type is
     that of the corresponding subprogram of the parent type.  The
     default calling convention for a new dispatching operation of a
     tagged type is the convention of the type.

14/3
Of these four conventions, only Ada and Intrinsic are allowed as a
<convention_>identifier in the specification of a Convention aspect.

15/2
Two profiles are <type conformant> if they have the same number of
parameters, and both have a result if either does, and corresponding
parameter and result types are the same, or, for access parameters or
access results, corresponding designated types are the same, or
corresponding designated profiles are type conformant.  

16/3
Two profiles are <mode conformant> if:

16.1/3
   * they are type conformant; and

16.2/3
   * corresponding parameters have identical modes and both or neither
     are explicitly aliased parameters; and

16.3/3
   * for corresponding access parameters and any access result type, the
     designated subtypes statically match and either both or neither are
     access-to-constant, or the designated profiles are subtype
     conformant.  

17/3
Two profiles are <subtype conformant> if they are mode conformant,
corresponding subtypes of the profile statically match, and the
associated calling conventions are the same.  The profile of a generic
formal subprogram is not subtype conformant with any other profile.  

18/3
Two profiles are <fully conformant> if they are subtype conformant, if
they have access-to-subprogram results whose designated profiles are
fully conformant, and for corresponding parameters:

18.1/3
   * they have the same names; and

18.2/3
   * both or neither have null_exclusions; and

18.3/3
   * neither have default_expressions, or they both have
     default_expressions that are fully conformant with one another; and

18.4/3
   * for access-to-subprogram parameters, the designated profiles are
     fully conformant.

19
Two expressions are <fully conformant> if, after replacing each use of
an operator with the equivalent function_call:

20
   * each constituent construct of one corresponds to an instance of the
     same syntactic category in the other, except that an expanded name
     may correspond to a direct_name (or character_literal) or to a
     different expanded name in the other; and

20.1/4
   * corresponding defining_identifiers occurring within the two
     expressions are the same; and

21/4
   * each direct_name, character_literal, and selector_name that is not
     part of the prefix of an expanded name in one denotes the same
     declaration as the corresponding direct_name, character_literal, or
     selector_name in the other, or they denote corresponding
     declarations occurring within the two expressions; and

21.1/3
   * each attribute_designator in one is the same as the corresponding
     attribute_designator in the other; and

22
   * each primary that is a literal in one has the same value as the
     corresponding literal in the other.

23
Two known_discriminant_parts are <fully conformant> if they have the
same number of discriminants, and discriminants in the same positions
have the same names, statically matching subtypes, and
default_expressions that are fully conformant with one another.  

24
Two discrete_subtype_definitions are <fully conformant> if they are both
subtype_indications or are both ranges, the subtype_marks (if any)
denote the same subtype, and the corresponding simple_expressions of the
ranges (if any) fully conform.

24.1/2
The <prefixed view profile> of a subprogram is the profile obtained by
omitting the first parameter of that subprogram.  There is no prefixed
view profile for a parameterless subprogram.  For the purposes of
defining subtype and mode conformance, the convention of a prefixed view
profile is considered to match that of either an entry or a protected
operation.

                     _Implementation Permissions_

25
An implementation may declare an operator declared in a language-defined
library unit to be intrinsic.


File: arm2012.info,  Node: 6.3.2,  Prev: 6.3.1,  Up: 6.3

6.3.2 Inline Expansion of Subprograms
-------------------------------------

1
Subprograms may be expanded in line at the call site.

<Paragraphs 2 through 4 were moved to *note Annex J::, "*note Annex J::
Obsolescent Features".>

                          _Static Semantics_

5/3
For a callable entity or a generic subprogram, the following
language-defined representation aspect may be specified:

5.1/3
Inline
               The type of aspect Inline is Boolean.  When aspect Inline
               is True for a callable entity, inline expansion is
               desired for all calls to that entity.  When aspect Inline
               is True for a generic subprogram, inline expansion is
               desired for all calls to all instances of that generic
               subprogram.

5.2/3
               If directly specified, the aspect_definition shall be a
               static expression.  This aspect is never inherited; if
               not directly specified, the aspect is False.

                     _Implementation Permissions_

6/3
For each call, an implementation is free to follow or to ignore the
recommendation determined by the Inline aspect.


File: arm2012.info,  Node: 6.4,  Next: 6.5,  Prev: 6.3,  Up: 6

6.4 Subprogram Calls
====================

1
A <subprogram call> is either a procedure_call_statement or a
function_call; it invokes the execution of the subprogram_body.  The
call specifies the association of the actual parameters, if any, with
formal parameters of the subprogram.

                               _Syntax_

2
     procedure_call_statement ::=
         <procedure_>name;
       | <procedure_>prefix actual_parameter_part;

3
     function_call ::=
         <function_>name
       | <function_>prefix actual_parameter_part

4
     actual_parameter_part ::=
         (parameter_association {, parameter_association})

5
     parameter_association ::=
        [<formal_parameter_>selector_name =>] explicit_actual_parameter

6
     explicit_actual_parameter ::= expression | <variable_>name

7
     A parameter_association is <named> or <positional> according to
     whether or not the <formal_parameter_>selector_name (*note 4.1.3:
     S0099.) is specified.  Any positional associations shall precede
     any named associations.  Named associations are not allowed if the
     prefix in a subprogram call is an attribute_reference (*note 4.1.4:
     S0100.).

                        _Name Resolution Rules_

8/2
The name or prefix given in a procedure_call_statement shall resolve to
denote a callable entity that is a procedure, or an entry renamed as
(viewed as) a procedure.  The name or prefix given in a function_call
shall resolve to denote a callable entity that is a function.  The name
or prefix shall not resolve to denote an abstract subprogram unless it
is also a dispatching subprogram.  When there is an
actual_parameter_part (*note 6.4: S0180.), the prefix can be an
implicit_dereference (*note 4.1: S0095.) of an access-to-subprogram
value.

9
A subprogram call shall contain at most one association for each formal
parameter.  Each formal parameter without an association shall have a
default_expression (in the profile of the view denoted by the name or
prefix).  This rule is an overloading rule (see *note 8.6::).

                          _Dynamic Semantics_

10/2
For the execution of a subprogram call, the name or prefix of the call
is evaluated, and each parameter_association (*note 6.4: S0181.) is
evaluated (see *note 6.4.1::).  If a default_expression (*note 3.7:
S0063.) is used, an implicit parameter_association (*note 6.4: S0181.)
is assumed for this rule.  These evaluations are done in an arbitrary
order.  The subprogram_body (*note 6.3: S0177.) is then executed, or a
call on an entry or protected subprogram is performed (see *note
3.9.2::).  Finally, if the subprogram completes normally, then after it
is left, any necessary assigning back of formal to actual parameters
occurs (see *note 6.4.1::).

10.1/2
If the name or prefix of a subprogram call denotes a prefixed view (see
*note 4.1.3::), the subprogram call is equivalent to a call on the
underlying subprogram, with the first actual parameter being provided by
the prefix of the prefixed view (or the Access attribute of this prefix
if the first formal parameter is an access parameter), and the remaining
actual parameters given by the actual_parameter_part, if any.

11/2
The exception Program_Error is raised at the point of a function_call if
the function completes normally without executing a return statement.

12/2
A function_call denotes a constant, as defined in *note 6.5::; the
nominal subtype of the constant is given by the nominal subtype of the
function result.  

                              _Examples_

13
<Examples of procedure calls:>

14
     Traverse_Tree;                                               --<  see *note 6.1::>
     Print_Header(128, Title, True);                              --<  see *note 6.1::>

15
     Switch(From => X, To => Next);                               --<  see *note 6.1::>
     Print_Header(128, Header => Title, Center => True);          --<  see *note 6.1::>
     Print_Header(Header => Title, Center => True, Pages => 128); --<  see *note 6.1::>

16
<Examples of function calls:>

17
     Dot_Product(U, V)   --<  see *note 6.1:: and *note 6.3::>
     Clock               --<  see *note 9.6::>
     F.all               --<  presuming F is of an access-to-subprogram type -- see *note 3.10::>

18
<Examples of procedures with default expressions:>

19
     procedure Activate(Process : in Process_Name;
                        After   : in Process_Name := No_Process;
                        Wait    : in Duration := 0.0;
                        Prior   : in Boolean := False);

20/3
     procedure Pair(Left, Right : in Person_Name := new Person(M));   --<  see *note 3.10.1::>

21
<Examples of their calls:>

22
     Activate(X);
     Activate(X, After => Y);
     Activate(X, Wait => 60.0, Prior => True);
     Activate(X, Y, 10.0, False);

23/3
     Pair;
     Pair(Left => new Person(F), Right => new Person(M));

     NOTES

24
     9  If a default_expression is used for two or more parameters in a
     multiple parameter_specification (*note 6.1: S0175.), the
     default_expression (*note 3.7: S0063.) is evaluated once for each
     omitted parameter.  Hence in the above examples, the two calls of
     Pair are equivalent.

                              _Examples_

25
<Examples of overloaded subprograms:>

26
     procedure Put(X : in Integer);
     procedure Put(X : in String);

27
     procedure Set(Tint   : in Color);
     procedure Set(Signal : in Light);

28
<Examples of their calls:>

29
     Put(28);
     Put("no possible ambiguity here");

30
     Set(Tint   => Red);
     Set(Signal => Red);
     Set(Color'(Red));

31
     --<  Set(Red) would be ambiguous since Red may>
     --<  denote a value either of type Color or of type Light>

* Menu:

* 6.4.1 ::    Parameter Associations


File: arm2012.info,  Node: 6.4.1,  Up: 6.4

6.4.1 Parameter Associations
----------------------------

1
A parameter association defines the association between an actual
parameter and a formal parameter.

                        _Name Resolution Rules_

2/3
The <formal_parameter_>selector_name of a named parameter_association
(*note 6.4: S0181.) shall resolve to denote a parameter_specification
(*note 6.1: S0175.) of the view being called; this is the formal
parameter of the association.  The formal parameter for a positional
parameter_association (*note 6.4: S0181.) is the parameter with the
corresponding position in the formal part of the view being called.

3
The <actual parameter> is either the explicit_actual_parameter given in
a parameter_association for a given formal parameter, or the
corresponding default_expression if no parameter_association is given
for the formal parameter.  The expected type for an actual parameter is
the type of the corresponding formal parameter.

4
If the mode is in, the actual is interpreted as an expression;
otherwise, the actual is interpreted only as a name, if possible.

                           _Legality Rules_

5
If the mode is in out or out, the actual shall be a name that denotes a
variable.

5.1/4
If the mode is out, the actual parameter is a view conversion, and the
type of the formal parameter is an access type or a scalar type that has
the Default_Value aspect specified, then

5.2/4
   * there shall exist a type (other than a root numeric type) that is
     an ancestor of both the target type and the operand type; and

5.3/4
   * in the case of a scalar type, the type of the operand of the
     conversion shall have the Default_Value aspect specified.

5.4/4
In addition to the places where Legality Rules normally apply (see *note
12.3::), these rules also apply in the private part of an instance of a
generic unit.

6/3
If the formal parameter is an explicitly aliased parameter, the type of
the actual parameter shall be tagged or the actual parameter shall be an
aliased view of an object.  Further, if the formal parameter subtype <F>
is untagged:

6.1/3
   * the subtype <F> shall statically match the nominal subtype of the
     actual object; or

6.2/3
   * the subtype <F> shall be unconstrained, discriminated in its full
     view, and unconstrained in any partial view.

6.3/4
In addition to the places where Legality Rules normally apply (see *note
12.3::), these rules also apply in the private part of an instance of a
generic unit.

6.4/3
In a function call, the accessibility level of the actual object for
each explicitly aliased parameter shall not be statically deeper than
the accessibility level of the master of the call (see *note 3.10.2::).

6.5/3
Two names are <known to denote the same object> if:

6.6/3
   * both names statically denote the same stand-alone object or
     parameter; or

6.7/3
   * both names are selected_components, their prefixes are known to
     denote the same object, and their selector_names denote the same
     component; or

6.8/3
   * both names are dereferences (implicit or explicit) and the
     dereferenced names are known to denote the same object; or

6.9/3
   * both names are indexed_components, their prefixes are known to
     denote the same object, and each of the pairs of corresponding
     index values are either both static expressions with the same
     static value or both names that are known to denote the same
     object; or

6.10/3
   * both names are slices, their prefixes are known to denote the same
     object, and the two slices have statically matching index
     constraints; or

6.11/3
   * one of the two names statically denotes a renaming declaration
     whose renamed <object_>name is known to denote the same object as
     the other, the prefix of any dereference within the renamed
     <object_>name is not a variable, and any expression within the
     renamed <object_>name contains no references to variables nor calls
     on nonstatic functions.

6.12/3
Two names are <known to refer to the same object> if 

6.13/3
   * The two names are known to denote the same object; or

6.14/3
   * One of the names is a selected_component, indexed_component, or
     slice and its prefix is known to refer to the same object as the
     other name; or

6.15/3
   * One of the two names statically denotes a renaming declaration
     whose renamed <object_>name is known to refer to the same object as
     the other name.

6.16/3
If a call <C> has two or more parameters of mode in out or out that are
of an elementary type, then the call is legal only if:

6.17/3
   * For each name <N> that is passed as a parameter of mode in out or
     out to the call <C>, there is no other name among the other
     parameters of mode in out or out to <C> that is known to denote the
     same object.

6.18/3
If a construct <C> has two or more direct constituents that are names or
expressions whose evaluation may occur in an arbitrary order, at least
one of which contains a function call with an in out or out parameter,
then the construct is legal only if:

6.19/3
   * For each name <N> that is passed as a parameter of mode in out or
     out to some inner function call <C2> (not including the construct
     <C> itself), there is no other name anywhere within a direct
     constituent of the construct <C> other than the one containing
     <C2>, that is known to refer to the same object.

6.20/3
For the purposes of checking this rule:

6.21/3
   * For an array aggregate, an expression associated with a
     discrete_choice_list that has two or more discrete choices, or that
     has a nonstatic range, is considered as two or more separate
     occurrences of the expression;

6.22/3
   * For a record aggregate:

6.23/3
             * The expression of a record_component_association is
               considered to occur once for each associated component;
               and

6.24/3
             * The default_expression for each
               record_component_association with <> for which the
               associated component has a default_expression is
               considered part of the aggregate;

6.25/3
   * For a call, any default_expression evaluated as part of the call is
     considered part of the call.

                          _Dynamic Semantics_

7
For the evaluation of a parameter_association:

8
   * The actual parameter is first evaluated.

9
   * For an access parameter, the access_definition is elaborated, which
     creates the anonymous access type.

10
   * For a parameter (of any mode) that is passed by reference (see
     *note 6.2::), a view conversion of the actual parameter to the
     nominal subtype of the formal parameter is evaluated, and the
     formal parameter denotes that conversion.  

11
   * For an in or in out parameter that is passed by copy (see *note
     6.2::), the formal parameter object is created, and the value of
     the actual parameter is converted to the nominal subtype of the
     formal parameter and assigned to the formal.  

12
   * For an out parameter that is passed by copy, the formal parameter
     object is created, and:

13/3
        * For an access type, the formal parameter is initialized from
          the value of the actual, without checking that the value
          satisfies any constraint, any predicate, or any exclusion of
          the null value;

13.1/4
        * For a scalar type that has the Default_Value aspect specified,
          the formal parameter is initialized from the value of the
          actual, without checking that the value satisfies any
          constraint or any predicate.  Furthermore, if the actual
          parameter is a view conversion and either

13.2/4
             * there exists no type (other than a root numeric type)
               that is an ancestor of both the target type and the type
               of the operand of the conversion; or

13.3/4
             * the Default_Value aspect is unspecified for the type of
               the operand of the conversion

13.4/4
          then Program_Error is raised;

14
        * For a composite type with discriminants or that has implicit
          initial values for any subcomponents (see *note 3.3.1::), the
          behavior is as for an in out parameter passed by copy.

15
        * For any other type, the formal parameter is uninitialized.  If
          composite, a view conversion of the actual parameter to the
          nominal subtype of the formal is evaluated (which might raise
          Constraint_Error), and the actual subtype of the formal is
          that of the view conversion.  If elementary, the actual
          subtype of the formal is given by its nominal subtype.

15.1/3
   * In a function call, for each explicitly aliased parameter, a check
     is made that the accessibility level of the master of the actual
     object is not deeper than that of the master of the call (see *note
     3.10.2::).

16
A formal parameter of mode in out or out with discriminants is
constrained if either its nominal subtype or the actual parameter is
constrained.

17
After normal completion and leaving of a subprogram, for each in out or
out parameter that is passed by copy, the value of the formal parameter
is converted to the subtype of the variable given as the actual
parameter and assigned to it.  These conversions and assignments occur
in an arbitrary order.

                         _Erroneous Execution_

18/3
If the nominal subtype of a formal parameter with discriminants is
constrained or indefinite, and the parameter is passed by reference,
then the execution of the call is erroneous if the value of any
discriminant of the actual is changed while the formal parameter exists
(that is, before leaving the corresponding callable construct).


File: arm2012.info,  Node: 6.5,  Next: 6.6,  Prev: 6.4,  Up: 6

6.5 Return Statements
=====================

1/2
A simple_return_statement (*note 6.5: S0183.) or
extended_return_statement (*note 6.5: S0186.) (collectively called a
<return statement>)  is used to complete the execution of the innermost
enclosing subprogram_body (*note 6.3: S0177.), entry_body (*note 9.5.2:
S0221.), or accept_statement (*note 9.5.2: S0219.).

                               _Syntax_

2/2
     simple_return_statement ::= return [expression];

2.1/3
     extended_return_object_declaration ::=
         defining_identifier : [aliased][constant] 
     return_subtype_indication [:= expression]

2.2/3
     extended_return_statement ::=
         return extended_return_object_declaration [do
             handled_sequence_of_statements
         end return];

2.3/2
     return_subtype_indication ::= subtype_indication | 
     access_definition

                        _Name Resolution Rules_

3/2
The <result subtype> of a function is the subtype denoted by the
subtype_mark, or defined by the access_definition, after the reserved
word return in the profile of the function.  The expected type for the
expression, if any, of a simple_return_statement (*note 6.5: S0183.) is
the result type of the corresponding function.  The expected type for
the expression of an extended_return_statement is that of the
return_subtype_indication (*note 6.5: S0187.).

                           _Legality Rules_

4/2
A return statement shall be within a callable construct, and it <applies
to> the innermost callable construct or extended_return_statement that
contains it.  A return statement shall not be within a body that is
within the construct to which the return statement applies.

5/3
A function body shall contain at least one return statement that applies
to the function body, unless the function contains code_statements.  A
simple_return_statement (*note 6.5: S0183.) shall include an expression
if and only if it applies to a function body.  An
extended_return_statement shall apply to a function body.  An
extended_return_statement with the reserved word constant shall include
an expression.

5.1/2
For an extended_return_statement (*note 6.5: S0186.) that applies to a
function body:

5.2/3
   * If the result subtype of the function is defined by a subtype_mark,
     the return_subtype_indication (*note 6.5: S0187.) shall be a
     subtype_indication.  The type of the subtype_indication shall be
     covered by the result type of the function.  The subtype defined by
     the subtype_indication shall be statically compatible with the
     result subtype of the function; if the result type of the function
     is elementary, the two subtypes shall statically match.  If the
     result subtype of the function is indefinite, then the subtype
     defined by the subtype_indication shall be a definite subtype, or
     there shall be an expression.

5.3/2
   * If the result subtype of the function is defined by an
     access_definition, the return_subtype_indication (*note 6.5:
     S0187.) shall be an access_definition.  The subtype defined by the
     access_definition shall statically match the result subtype of the
     function.  The accessibility level of this anonymous access subtype
     is that of the result subtype.

5.4/3
   * If the result subtype of the function is class-wide, the
     accessibility level of the type of the subtype defined by the
     return_subtype_indication shall not be statically deeper than that
     of the master that elaborated the function body.

5.5/3
For any return statement that applies to a function body:

5.6/3
   * If the result subtype of the function is limited, then the
     expression of the return statement (if any) shall meet the
     restrictions described in *note 7.5::.

5.7/3
   * If the result subtype of the function is class-wide, the
     accessibility level of the type of the expression (if any) of the
     return statement shall not be statically deeper than that of the
     master that elaborated the function body.

5.8/3
   * If the subtype determined by the expression of the
     simple_return_statement or by the return_subtype_indication has one
     or more access discriminants, the accessibility level of the
     anonymous access type of each access discriminant shall not be
     statically deeper than that of the master that elaborated the
     function body.

5.9/3
If the keyword aliased is present in an
extended_return_object_declaration, the type of the extended return
object shall be immutably limited.

                          _Static Semantics_

5.10/3
Within an extended_return_statement, the <return object> is declared
with the given defining_identifier, with the nominal subtype defined by
the return_subtype_indication (*note 6.5: S0187.).  An
extended_return_statement with the reserved word constant is a full
constant declaration that declares the return object to be a constant
object.

                          _Dynamic Semantics_

5.11/3
For the execution of an extended_return_statement, the
subtype_indication or access_definition is elaborated.  This creates the
nominal subtype of the return object.  If there is an expression, it is
evaluated and converted to the nominal subtype (which might raise
Constraint_Error -- see *note 4.6::); the return object is created and
the converted value is assigned to the return object.  Otherwise, the
return object is created and initialized by default as for a stand-alone
object of its nominal subtype (see *note 3.3.1::).  If the nominal
subtype is indefinite, the return object is constrained by its initial
value.  A check is made that the value of the return object belongs to
the function result subtype.  Constraint_Error is raised if this check
fails.  

6/2
For the execution of a simple_return_statement (*note 6.5: S0183.), the
expression (if any) is first evaluated, converted to the result subtype,
and then is assigned to the anonymous <return object>.  

7/2
If the return object has any parts that are tasks, the activation of
those tasks does not occur until after the function returns (see *note
9.2::).

8/4
If the result type of a function is a specific tagged type, the tag of
the return object is that of the result type.  If the result type is
class-wide, the tag of the return object is that of the value of the
expression, unless the return object is defined by an
extended_return_object_declaration with a subtype_indication that is
specific, in which case it is that of the type of the
subtype_indication.  A check is made that the master of the type
identified by the tag of the result includes the elaboration of the
master that elaborated the function body.  If this check fails,
Program_Error is raised.  

8.1/3
If the result subtype of the function is defined by an access_definition
designating a specific tagged type <T>, a check is made that the result
value is null or the tag of the object designated by the result value
identifies <T>.  Constraint_Error is raised if this check fails.

<Paragraphs 9 through 20 were deleted.>

21/3
If any part of the specific type of the return object of a function (or
coextension thereof) has one or more access discriminants whose value is
not constrained by the result subtype of the function, a check is made
that the accessibility level of the anonymous access type of each access
discriminant, as determined by the expression or the
return_subtype_indication (*note 6.5: S0187.) of the return statement,
is not deeper than the level of the master of the call (see *note
3.10.2::).  If this check fails, Program_Error is raised.  

22/3
For the execution of an extended_return_statement (*note 6.5: S0186.),
the handled_sequence_of_statements (*note 11.2: S0265.) is executed.
Within this handled_sequence_of_statements (*note 11.2: S0265.), the
execution of a simple_return_statement (*note 6.5: S0183.) that applies
to the extended_return_statement (*note 6.5: S0186.) causes a transfer
of control that completes the extended_return_statement (*note 6.5:
S0186.).  Upon completion of a return statement that applies to a
callable construct by the normal completion of a simple_return_statement
(*note 6.5: S0183.) or by reaching the end return of an
extended_return_statement (*note 6.5: S0186.), a transfer of control is
performed which completes the execution of the callable construct, and
returns to the caller.

23/2
In the case of a function, the function_call denotes a constant view of
the return object.

                     _Implementation Permissions_

24/3
For a function call used to initialize a composite object with a
constrained nominal subtype or used to initialize a return object that
is built in place into such an object:

24.1/3
   * If the result subtype of the function is constrained, and
     conversion of an object of this subtype to the subtype of the
     object being initialized would raise Constraint_Error, then
     Constraint_Error may be raised before calling the function.

24.2/3
   * If the result subtype of the function is unconstrained, and a
     return statement is executed such that the return object is known
     to be constrained, and conversion of the return object to the
     subtype of the object being initialized would raise
     Constraint_Error, then Constraint_Error may be raised at the point
     of the call (after abandoning the execution of the function body).

                              _Examples_

25
<Examples of return statements:>

26/2
     return;                         --< in a procedure body, >entry_body<,>
                                     -- accept_statement<, or >extended_return_statement

27
     return Key_Value(Last_Index);   --< in a function body>

28/2
     return Node : Cell do           --< in a function body, see *note 3.10.1:: for Cell>
        Node.Value := Result;
        Node.Succ := Next_Node;
     end return;

* Menu:

* 6.5.1 ::    Nonreturning Procedures


File: arm2012.info,  Node: 6.5.1,  Up: 6.5

6.5.1 Nonreturning Procedures
-----------------------------

1/3
Specifying aspect No_Return to have the value True indicates that a
procedure cannot return normally; it may propagate an exception or loop
forever.

<Paragraphs 2 and 3 were moved to *note Annex J::, "*note Annex J::
Obsolescent Features".>

                          _Static Semantics_

3.1/3
For a procedure or generic procedure, the following language-defined
representation aspect may be specified:

3.2/3
No_Return
               The type of aspect No_Return is Boolean.  When aspect
               No_Return is True for an entity, the entity is said to be
               <nonreturning>.

3.3/3
               If directly specified, the aspect_definition shall be a
               static expression.  This aspect is never inherited; if
               not directly specified, the aspect is False.

3.4/3
If a generic procedure is nonreturning, then so are its instances.  If a
procedure declared within a generic unit is nonreturning, then so are
the corresponding copies of that procedure in instances.

                           _Legality Rules_

4/3
Aspect No_Return shall not be specified for a null procedure nor an
instance of a generic unit.

5/2
A return statement shall not apply to a nonreturning procedure or
generic procedure.

6/2
A procedure shall be nonreturning if it overrides a dispatching
nonreturning procedure.  In addition to the places where Legality Rules
normally apply (see *note 12.3::), this rule applies also in the private
part of an instance of a generic unit.

7/2
If a renaming-as-body completes a nonreturning procedure declaration,
then the renamed procedure shall be nonreturning.

<Paragraph 8 was deleted.>

                          _Dynamic Semantics_

9/2
If the body of a nonreturning procedure completes normally,
Program_Error is raised at the point of the call.  

                              _Examples_

10/3
     procedure Fail(Msg : String)  --< raises Fatal_Error exception>
        with No_Return;
        --< Inform compiler and reader that procedure never returns normally>


File: arm2012.info,  Node: 6.6,  Next: 6.7,  Prev: 6.5,  Up: 6

6.6 Overloading of Operators
============================

1
An <operator> is a function whose designator is an operator_symbol.
Operators, like other functions, may be overloaded.

                        _Name Resolution Rules_

2
Each use of a unary or binary operator is equivalent to a function_call
with <function_>prefix being the corresponding operator_symbol, and with
(respectively) one or two positional actual parameters being the
operand(s) of the operator (in order).

                           _Legality Rules_

3/3
The subprogram_specification of a unary or binary operator shall have
one or two parameters, respectively.  The parameters shall be of mode
in.  A generic function instantiation whose designator is an
operator_symbol is only allowed if the specification of the generic
function has the corresponding number of parameters, and they are all of
mode in.

4
Default_expressions are not allowed for the parameters of an operator
(whether the operator is declared with an explicit
subprogram_specification or by a generic_instantiation).

5
An explicit declaration of "/=" shall not have a result type of the
predefined type Boolean.

                          _Static Semantics_

6/3
An explicit declaration of "=" whose result type is Boolean implicitly
declares an operator "/=" that gives the complementary result.

     NOTES

7
     10  The operators "+" and "-" are both unary and binary operators,
     and hence may be overloaded with both one- and two-parameter
     functions.

                              _Examples_

8
<Examples of user-defined operators:>

9
     function "+" (Left, Right : Matrix) return Matrix;
     function "+" (Left, Right : Vector) return Vector;

     --<  assuming that A, B, and C are of the type Vector>
     --<  the following two statements are equivalent:>

     A := B + C;
     A := "+"(B, C);


File: arm2012.info,  Node: 6.7,  Next: 6.8,  Prev: 6.6,  Up: 6

6.7 Null Procedures
===================

1/2
A null_procedure_declaration provides a shorthand to declare a procedure
with an empty body.

                               _Syntax_

2/3
     null_procedure_declaration ::=
        [overriding_indicator]
        procedure_specification is null
            [aspect_specification];

                           _Legality Rules_

2.1/3
If a null_procedure_declaration is a completion, it shall be the
completion of a subprogram_declaration or
generic_subprogram_declaration.  The profile of a
null_procedure_declaration that completes a declaration shall conform
fully to that of the declaration.

                          _Static Semantics_

3/3
A null_procedure_declaration declares a <null procedure>.  A completion
is not allowed for a null_procedure_declaration; however, a
null_procedure_declaration can complete a previous declaration.

                          _Dynamic Semantics_

4/2
The execution of a null procedure is invoked by a subprogram call.  For
the execution of a subprogram call on a null procedure, the execution of
the subprogram_body has no effect.

5/3
The elaboration of a null_procedure_declaration has no other effect than
to establish that the null procedure can be called without failing the
Elaboration_Check.

                              _Examples_

6/2
     procedure Simplify(Expr : in out Expression) is null; --< see *note 3.9::>
     --< By default, Simplify does nothing, but it may be overridden in extensions of Expression>


File: arm2012.info,  Node: 6.8,  Prev: 6.7,  Up: 6

6.8 Expression Functions
========================

1/3
An expression_function_declaration provides a shorthand to declare a
function whose body consists of a single return statement.

                               _Syntax_

2/4
     expression_function_declaration ::=
        [overriding_indicator]
        function_specification is
            (expression)
            [aspect_specification];
      | [overriding_indicator]
        function_specification is
            aggregate
            [aspect_specification];

                        _Name Resolution Rules_

3/4
The expected type for the expression or aggregate of an
expression_function_declaration (*note 6.8: S0189.) is the result type
(see *note 6.5::) of the function.

                           _Legality Rules_

4/3
If an expression_function_declaration (*note 6.8: S0189.) is a
completion, it shall be the completion of a subprogram_declaration or
generic_subprogram_declaration.  The profile of an
expression_function_declaration (*note 6.8: S0189.) that completes a
declaration shall conform fully to that of the declaration.

5/4
If the result subtype has one or more unconstrained access
discriminants, the accessibility level of the anonymous access type of
each access discriminant, as determined by the expression or aggregate
of the expression_function_declaration (*note 6.8: S0189.), shall not be
statically deeper than that of the master that elaborated the
expression_function_declaration (*note 6.8: S0189.).

                          _Static Semantics_

6/4
An expression_function_declaration (*note 6.8: S0189.) declares an
<expression function>.  The <return expression> of an expression
function is the expression or aggregate of the
expression_function_declaration.  A completion is not allowed for an
expression_function_declaration (*note 6.8: S0189.); however, an
expression_function_declaration (*note 6.8: S0189.) can complete a
previous declaration.

                          _Dynamic Semantics_

7/4
The execution of an expression function is invoked by a subprogram call.
For the execution of a subprogram call on an expression function, the
execution of the subprogram_body executes an implicit function body
containing only a simple_return_statement whose expression is the return
expression of the expression function.

8/3
The elaboration of an expression_function_declaration (*note 6.8:
S0189.) has no other effect than to establish that the expression
function can be called without failing the Elaboration_Check.

                              _Examples_

9/3
     function Is_Origin (P : in Point) return Boolean is -- <see *note 3.9::>
        (P.X = 0.0 and P.Y = 0.0);


File: arm2012.info,  Node: 7,  Next: 8,  Prev: 6,  Up: Top

7 Packages
**********

1
Packages are program units that allow the specification of groups of
logically related entities.  Typically, a package contains the
declaration of a type (often a private type or private extension) along
with the declarations of primitive subprograms of the type, which can be
called from outside the package, while their inner workings remain
hidden from outside users.  

* Menu:

* 7.1 ::      Package Specifications and Declarations
* 7.2 ::      Package Bodies
* 7.3 ::      Private Types and Private Extensions
* 7.4 ::      Deferred Constants
* 7.5 ::      Limited Types
* 7.6 ::      Assignment and Finalization


File: arm2012.info,  Node: 7.1,  Next: 7.2,  Up: 7

7.1 Package Specifications and Declarations
===========================================

1
A package is generally provided in two parts: a package_specification
and a package_body.  Every package has a package_specification, but not
all packages have a package_body.

                               _Syntax_

2
     package_declaration ::= package_specification;

3/3
     package_specification ::=
         package defining_program_unit_name
             [aspect_specification] is
           {basic_declarative_item}
        [private
           {basic_declarative_item}]
         end [[parent_unit_name.]identifier]

4
     If an identifier or parent_unit_name.identifier appears at the end
     of a package_specification, then this sequence of lexical elements
     shall repeat the defining_program_unit_name.

                           _Legality Rules_

5/2
A package_declaration or generic_package_declaration requires a
completion (a body) if it contains any basic_declarative_item that
requires a completion, but whose completion is not in its
package_specification.

                          _Static Semantics_

6/2
The first list of basic_declarative_items of a package_specification of
a package other than a generic formal package is called the <visible
part> of the package.  The optional list of basic_declarative_items
after the reserved word private (of any package_specification) is called
the <private part> of the package.  If the reserved word private does
not appear, the package has an implicit empty private part.  Each list
of basic_declarative_items of a package_specification forms a
<declaration list> of the package.

7
An entity declared in the private part of a package is visible only
within the declarative region of the package itself (including any child
units -- see *note 10.1.1::).  In contrast, expanded names denoting
entities declared in the visible part can be used even outside the
package; furthermore, direct visibility of such entities can be achieved
by means of use_clauses (see *note 4.1.3:: and *note 8.4::).

                          _Dynamic Semantics_

8
The elaboration of a package_declaration consists of the elaboration of
its basic_declarative_items in the given order.

     NOTES

9
     1  The visible part of a package contains all the information that
     another program unit is able to know about the package.

10
     2  If a declaration occurs immediately within the specification of
     a package, and the declaration has a corresponding completion that
     is a body, then that body has to occur immediately within the body
     of the package.

                              _Examples_

11
<Example of a package declaration:>

12
     package Rational_Numbers is

13
        type Rational is
           record
              Numerator   : Integer;
              Denominator : Positive;
           end record;

14
        function "="(X,Y : Rational) return Boolean;

15
        function "/"  (X,Y : Integer)  return Rational;  --<  to construct a rational number>

16
        function "+"  (X,Y : Rational) return Rational;
        function "-"  (X,Y : Rational) return Rational;
        function "*"  (X,Y : Rational) return Rational;
        function "/"  (X,Y : Rational) return Rational;
     end Rational_Numbers;

17
There are also many examples of package declarations in the predefined
language environment (see *note Annex A::).


File: arm2012.info,  Node: 7.2,  Next: 7.3,  Prev: 7.1,  Up: 7

7.2 Package Bodies
==================

1
In contrast to the entities declared in the visible part of a package,
the entities declared in the package_body are visible only within the
package_body itself.  As a consequence, a package with a package_body
can be used for the construction of a group of related subprograms in
which the logical operations available to clients are clearly isolated
from the internal entities.

                               _Syntax_

2/3
     package_body ::=
         package body defining_program_unit_name
             [aspect_specification] is
            declarative_part
        [begin
             handled_sequence_of_statements]
         end [[parent_unit_name.]identifier];

3
     If an identifier or parent_unit_name.identifier appears at the end
     of a package_body, then this sequence of lexical elements shall
     repeat the defining_program_unit_name.

                           _Legality Rules_

4
A package_body shall be the completion of a previous package_declaration
(*note 7.1: S0190.) or generic_package_declaration (*note 12.1: S0273.).
A library package_declaration (*note 7.1: S0190.) or library
generic_package_declaration (*note 12.1: S0273.) shall not have a body
unless it requires a body; pragma Elaborate_Body can be used to require
a library_unit_declaration (*note 10.1.1: S0249.) to have a body (see
*note 10.2.1::) if it would not otherwise require one.

                          _Static Semantics_

5/3
In any package_body without statements there is an implicit
null_statement (*note 5.1: S0149.).  For any package_declaration (*note
7.1: S0190.) without an explicit completion, there is an implicit
package_body (*note 7.2: S0192.) containing a single null_statement.
For a noninstance, nonlibrary package, this body occurs at the end of
the declarative_part (*note 3.11: S0086.) of the innermost enclosing
program unit or block_statement (*note 5.6: S0160.); if there are
several such packages, the order of the implicit package_bodies is
unspecified.  (For an instance, the implicit package_body (*note 7.2:
S0192.) occurs at the place of the instantiation (see *note 12.3::).
For a library package, the place is partially determined by the
elaboration dependences (see Clause *note 10::).)

                          _Dynamic Semantics_

6
For the elaboration of a nongeneric package_body, its declarative_part
(*note 3.11: S0086.) is first elaborated, and its
handled_sequence_of_statements (*note 11.2: S0265.) is then executed.

     NOTES

7
     3  A variable declared in the body of a package is only visible
     within this body and, consequently, its value can only be changed
     within the package_body.  In the absence of local tasks, the value
     of such a variable remains unchanged between calls issued from
     outside the package to subprograms declared in the visible part.
     The properties of such a variable are similar to those of a
     "static" variable of C.

8
     4  The elaboration of the body of a subprogram explicitly declared
     in the visible part of a package is caused by the elaboration of
     the body of the package.  Hence a call of such a subprogram by an
     outside program unit raises the exception Program_Error if the call
     takes place before the elaboration of the package_body (see *note
     3.11::).

                              _Examples_

9
<Example of a package body (see *note 7.1::):>

10
     package body Rational_Numbers is

11
        procedure Same_Denominator (X,Y : in out Rational) is
        begin
           --<  reduces X and Y to the same denominator:>
           ...
        end Same_Denominator;

12
        function "="(X,Y : Rational) return Boolean is
           U : Rational := X;
           V : Rational := Y;
        begin
           Same_Denominator (U,V);
           return U.Numerator = V.Numerator;
        end "=";

13
        function "/" (X,Y : Integer) return Rational is
        begin
           if Y > 0 then
              return (Numerator => X,  Denominator => Y);
           else
              return (Numerator => -X, Denominator => -Y);
           end if;
        end "/";

14
        function "+" (X,Y : Rational) return Rational is ... end "+";
        function "-" (X,Y : Rational) return Rational is ... end "-";
        function "*" (X,Y : Rational) return Rational is ... end "*";
        function "/" (X,Y : Rational) return Rational is ... end "/";

15
     end Rational_Numbers;


File: arm2012.info,  Node: 7.3,  Next: 7.4,  Prev: 7.2,  Up: 7

7.3 Private Types and Private Extensions
========================================

1
The declaration (in the visible part of a package) of a type as a
private type or private extension serves to separate the characteristics
that can be used directly by outside program units (that is, the logical
properties) from other characteristics whose direct use is confined to
the package (the details of the definition of the type itself).  See
*note 3.9.1:: for an overview of type extensions.  

                               _Syntax_

2/3
     private_type_declaration ::=
        type defining_identifier [
     discriminant_part] is [[abstract] tagged] [limited] private
           [aspect_specification];

3/3
     private_extension_declaration ::=
        type defining_identifier [discriminant_part] is
          [abstract] [limited | synchronized] new <ancestor_>
     subtype_indication
          [and interface_list] with private
            [aspect_specification];

                           _Legality Rules_

4
A private_type_declaration or private_extension_declaration declares a
<partial view> of the type; such a declaration is allowed only as a
declarative_item of the visible part of a package, and it requires a
completion, which shall be a full_type_declaration that occurs as a
declarative_item of the private part of the package.  The view of the
type declared by the full_type_declaration is called the <full view>.  A
generic formal private type or a generic formal private extension is
also a partial view.

5
A type shall be completely defined before it is frozen (see *note
3.11.1:: and *note 13.14::).  Thus, neither the declaration of a
variable of a partial view of a type, nor the creation by an allocator
of an object of the partial view are allowed before the full declaration
of the type.  Similarly, before the full declaration, the name of the
partial view cannot be used in a generic_instantiation or in a
representation item.

6/2
A private type is limited if its declaration includes the reserved word
limited; a private extension is limited if its ancestor type is a
limited type that is not an interface type, or if the reserved word
limited or synchronized appears in its definition.  If the partial view
is nonlimited, then the full view shall be nonlimited.  If a tagged
partial view is limited, then the full view shall be limited.  On the
other hand, if an untagged partial view is limited, the full view may be
limited or nonlimited.

7
If the partial view is tagged, then the full view shall be tagged.  On
the other hand, if the partial view is untagged, then the full view may
be tagged or untagged.  In the case where the partial view is untagged
and the full view is tagged, no derivatives of the partial view are
allowed within the immediate scope of the partial view; derivatives of
the full view are allowed.

7.1/2
If a full type has a partial view that is tagged, then:

7.2/2
   * the partial view shall be a synchronized tagged type (see *note
     3.9.4::) if and only if the full type is a synchronized tagged
     type;

7.3/2
   * the partial view shall be a descendant of an interface type (see
     3.9.4) if and only if the full type is a descendant of the
     interface type.

8
The <ancestor subtype> of a private_extension_declaration is the subtype
defined by the <ancestor_>subtype_indication (*note 3.2.2: S0027.); the
ancestor type shall be a specific tagged type.  The full view of a
private extension shall be derived (directly or indirectly) from the
ancestor type.  In addition to the places where Legality Rules normally
apply (see *note 12.3::), the requirement that the ancestor be specific
applies also in the private part of an instance of a generic unit.

8.1/2
If the reserved word limited appears in a private_extension_declaration,
the ancestor type shall be a limited type.  If the reserved word
synchronized appears in a private_extension_declaration, the ancestor
type shall be a limited interface.

9
If the declaration of a partial view includes a known_discriminant_part,
then the full_type_declaration shall have a fully conforming (explicit)
known_discriminant_part (see *note 6.3.1::, "*note 6.3.1:: Conformance
Rules").  The ancestor subtype may be unconstrained; the parent subtype
of the full view is required to be constrained (see *note 3.7::).

10
If a private extension inherits known discriminants from the ancestor
subtype, then the full view shall also inherit its discriminants from
the ancestor subtype, and the parent subtype of the full view shall be
constrained if and only if the ancestor subtype is constrained.

10.1/3
If the full_type_declaration for a private extension includes a
derived_type_definition, then the reserved word limited shall appear in
the full_type_declaration if and only if it also appears in the
private_extension_declaration.

11
If a partial view has unknown discriminants, then the
full_type_declaration may define a definite or an indefinite subtype,
with or without discriminants.

12
If a partial view has neither known nor unknown discriminants, then the
full_type_declaration shall define a definite subtype.

13
If the ancestor subtype of a private extension has constrained
discriminants, then the parent subtype of the full view shall impose a
statically matching constraint on those discriminants.  

                          _Static Semantics_

14
A private_type_declaration declares a private type and its first
subtype.  Similarly, a private_extension_declaration (*note 7.3: S0194.)
declares a private extension and its first subtype.

15/3
A declaration of a partial view and the corresponding
full_type_declaration define two views of a single type.  The
declaration of a partial view together with the visible part define the
operations that are available to outside program units; the declaration
of the full view together with the private part define other operations
whose direct use is possible only within the declarative region of the
package itself.  Moreover, within the scope of the declaration of the
full view, the characteristics (see *note 3.4::) of the type are
determined by the full view; in particular, within its scope, the full
view determines the classes that include the type, which components,
entries, and protected subprograms are visible, what attributes and
other predefined operations are allowed, and whether the first subtype
is static.  See *note 7.3.1::.

16/3
For a private extension, the characteristics (including components, but
excluding discriminants if there is a new discriminant_part specified),
predefined operators, and inherited user-defined primitive subprograms
are determined by its ancestor type and its progenitor types (if any),
in the same way that those of a record extension are determined by those
of its parent type and its progenitor types (see *note 3.4:: and *note
7.3.1::).

                          _Dynamic Semantics_

17
The elaboration of a private_type_declaration creates a partial view of
a type.  The elaboration of a private_extension_declaration elaborates
the <ancestor_>subtype_indication, and creates a partial view of a type.

     NOTES

18
     5  The partial view of a type as declared by a
     private_type_declaration is defined to be a composite view (in
     *note 3.2::).  The full view of the type might or might not be
     composite.  A private extension is also composite, as is its full
     view.

19/2
     6  Declaring a private type with an unknown_discriminant_part is a
     way of preventing clients from creating uninitialized objects of
     the type; they are then forced to initialize each object by calling
     some operation declared in the visible part of the package.

20/2
     7  The ancestor type specified in a private_extension_declaration
     and the parent type specified in the corresponding declaration of a
     record extension given in the private part need not be the same.
     If the ancestor type is not an interface type, the parent type of
     the full view can be any descendant of the ancestor type.  In this
     case, for a primitive subprogram that is inherited from the
     ancestor type and not overridden, the formal parameter names and
     default expressions (if any) come from the corresponding primitive
     subprogram of the specified ancestor type, while the body comes
     from the corresponding primitive subprogram of the parent type of
     the full view.  See *note 3.9.2::.

20.1/2
     8  If the ancestor type specified in a
     private_extension_declaration is an interface type, the parent type
     can be any type so long as the full view is a descendant of the
     ancestor type.  The progenitor types specified in a
     private_extension_declaration and the progenitor types specified in
     the corresponding declaration of a record extension given in the
     private part need not be the same -- the only requirement is that
     the private extension and the record extension be descended from
     the same set of interfaces.

                              _Examples_

21
<Examples of private type declarations:>

22
     type Key is private;
     type File_Name is limited private;

23
<Example of a private extension declaration:>

24
     type List is new Ada.Finalization.Controlled with private;

* Menu:

* 7.3.1 ::    Private Operations
* 7.3.2 ::    Type Invariants


File: arm2012.info,  Node: 7.3.1,  Next: 7.3.2,  Up: 7.3

7.3.1 Private Operations
------------------------

1
For a type declared in the visible part of a package or generic package,
certain operations on the type do not become visible until later in the
package -- either in the private part or the body.  Such <private
operations> are available only inside the declarative region of the
package or generic package.

                          _Static Semantics_

2
The predefined operators that exist for a given type are determined by
the classes to which the type belongs.  For example, an integer type has
a predefined "+" operator.  In most cases, the predefined operators of a
type are declared immediately after the definition of the type; the
exceptions are explained below.  Inherited subprograms are also
implicitly declared immediately after the definition of the type, except
as stated below.

3/3
For a composite type, the characteristics (see *note 7.3::) of the type
are determined in part by the characteristics of its component types.
At the place where the composite type is declared, the only
characteristics of component types used are those characteristics
visible at that place.  If later immediately within the declarative
region in which the composite type is declared additional
characteristics become visible for a component type, then any
corresponding characteristics become visible for the composite type.
Any additional predefined operators are implicitly declared at that
place.  If there is no such place, then additional predefined operators
are not declared at all, but they still exist.

4/1
The corresponding rule applies to a type defined by a
derived_type_definition, if there is a place immediately within the
declarative region in which the type is declared where additional
characteristics of its parent type become visible.

5/1
For example, an array type whose component type is limited private
becomes nonlimited if the full view of the component type is nonlimited
and visible at some later place immediately within the declarative
region in which the array type is declared.  In such a case, the
predefined "=" operator is implicitly declared at that place, and
assignment is allowed after that place.

5.1/3
A type is a <descendant> of the full view of some ancestor of its parent
type only if the current view it has of its parent is a descendant of
the full view of that ancestor.  More generally, at any given place, a
type is descended from the same view of an ancestor as that from which
the current view of its parent is descended.  This view determines what
characteristics are inherited from the ancestor, and, for example,
whether the type is considered to be a descendant of a record type, or a
descendant only through record extensions of a more distant ancestor.

5.2/4
Furthermore, it is possible for there to be places where a derived type
is known to be derived indirectly from an ancestor type, but is not a
descendant of even a partial view of the ancestor type, because the
parent of the derived type is not visibly a descendant of the ancestor.
In this case, the derived type inherits no characteristics from that
ancestor, but nevertheless is within the derivation class of the
ancestor for the purposes of type conversion, the "covers" relationship,
and matching against a formal derived type.  In this case the derived
type is effectively a <descendant> of an incomplete view of the
ancestor.

6/3
Inherited primitive subprograms follow a different rule.  For a
derived_type_definition, each inherited primitive subprogram is
implicitly declared at the earliest place, if any, immediately within
the declarative region in which the type_declaration occurs, but after
the type_declaration, where the corresponding declaration from the
parent is visible.  If there is no such place, then the inherited
subprogram is not declared at all, but it still exists.  For a tagged
type, it is possible to dispatch to an inherited subprogram that is not
declared at all.

7
For a private_extension_declaration, each inherited subprogram is
declared immediately after the private_extension_declaration if the
corresponding declaration from the ancestor is visible at that place.
Otherwise, the inherited subprogram is not declared for the private
extension, though it might be for the full type.

8
The Class attribute is defined for tagged subtypes in *note 3.9::.  In
addition, for every subtype S of an untagged private type whose full
view is tagged, the following attribute is defined:

9
S'Class
               Denotes the class-wide subtype corresponding to the full
               view of S. This attribute is allowed only from the
               beginning of the private part in which the full view is
               declared, until the declaration of the full view.  After
               the full view, the Class attribute of the full view can
               be used.

     NOTES

10
     9  Because a partial view and a full view are two different views
     of one and the same type, outside of the defining package the
     characteristics of the type are those defined by the visible part.
     Within these outside program units the type is just a private type
     or private extension, and any language rule that applies only to
     another class of types does not apply.  The fact that the full
     declaration might implement a private type with a type of a
     particular class (for example, as an array type) is relevant only
     within the declarative region of the package itself including any
     child units.

11
     The consequences of this actual implementation are, however, valid
     everywhere.  For example: any default initialization of components
     takes place; the attribute Size provides the size of the full view;
     finalization is still done for controlled components of the full
     view; task dependence rules still apply to components that are task
     objects.

12/2
     10  Partial views provide initialization, membership tests,
     selected components for the selection of discriminants and
     inherited components, qualification, and explicit conversion.
     Nonlimited partial views also allow use of assignment_statements.

13
     11  For a subtype S of a partial view, S'Size is defined (see *note
     13.3::).  For an object A of a partial view, the attributes A'Size
     and A'Address are defined (see *note 13.3::).  The Position,
     First_Bit, and Last_Bit attributes are also defined for
     discriminants and inherited components.

                              _Examples_

14
<Example of a type with private operations:>

15
     package Key_Manager is
        type Key is private;
        Null_Key : constant Key; --< a deferred constant declaration (see *note 7.4::)>
        procedure Get_Key(K : out Key);
        function "<" (X, Y : Key) return Boolean;
     private
        type Key is new Natural;
        Null_Key : constant Key := Key'First;
     end Key_Manager;

16
     package body Key_Manager is
        Last_Key : Key := Null_Key;
        procedure Get_Key(K : out Key) is
        begin
           Last_Key := Last_Key + 1;
           K := Last_Key;
        end Get_Key;

17
        function "<" (X, Y : Key) return Boolean is
        begin
           return Natural(X) < Natural(Y);
        end "<";
     end Key_Manager;

     NOTES

18
     12  <Notes on the example:> Outside of the package Key_Manager, the
     operations available for objects of type Key include assignment,
     the comparison for equality or inequality, the procedure Get_Key
     and the operator "<"; they do not include other relational
     operators such as ">=", or arithmetic operators.

19
     The explicitly declared operator "<" hides the predefined operator
     "<" implicitly declared by the full_type_declaration.  Within the
     body of the function, an explicit conversion of X and Y to the
     subtype Natural is necessary to invoke the "<" operator of the
     parent type.  Alternatively, the result of the function could be
     written as not (X >= Y), since the operator ">=" is not redefined.

20
     The value of the variable Last_Key, declared in the package body,
     remains unchanged between calls of the procedure Get_Key.  (See
     also the NOTES of *note 7.2::.)


File: arm2012.info,  Node: 7.3.2,  Prev: 7.3.1,  Up: 7.3

7.3.2 Type Invariants
---------------------

1/4
For a private type, private extension, or interface, the following
language-defined aspects may be specified with an aspect_specification
(see *note 13.1.1::):

2/3
Type_Invariant
               This aspect shall be specified by an expression, called
               an <invariant expression>.  Type_Invariant may be
               specified on a private_type_declaration (*note 7.3:
               S0193.), on a private_extension_declaration (*note 7.3:
               S0194.), or on a full_type_declaration (*note 3.2.1:
               S0024.) that declares the completion of a private type or
               private extension.

3/4
Type_Invariant'Class
               This aspect shall be specified by an expression, called
               an <invariant expression>.  Type_Invariant'Class may be
               specified on a private_type_declaration (*note 7.3:
               S0193.), a private_extension_declaration (*note 7.3:
               S0194.), or a full_type_declaration (*note 3.2.1: S0024.)
               for an interface type.  Type_Invariant'Class determines a
               <class-wide type invariant> for a tagged type.

                        _Name Resolution Rules_

4/3
The expected type for an invariant expression is any boolean type.

5/4
Within an invariant expression, the identifier of the first subtype of
the associated type denotes the current instance of the type.  Within an
invariant expression for the Type_Invariant aspect of a type <T>, the
type of this current instance is <T>.  Within an invariant expression
for the Type_Invariant'Class aspect of a type <T>, the type of this
current instance is interpreted as though it had a (notional) type <NT>
that is a visible formal derived type whose ancestor type is <T>.  The
effect of this interpretation is that the only operations that can be
applied to this current instance are those defined for such a formal
derived type.

                           _Legality Rules_

6/3
The Type_Invariant'Class aspect shall not be specified for an untagged
type.  The Type_Invariant aspect shall not be specified for an abstract
type.

6.1/4
If a type extension occurs at a point where a private operation of some
ancestor is visible and inherited, and a Type_Invariant'Class expression
applies to that ancestor, then the inherited operation shall be abstract
or shall be overridden.

                          _Static Semantics_

7/3
If the Type_Invariant aspect is specified for a type <T>, then the
invariant expression applies to <T>.

8/3
If the Type_Invariant'Class aspect is specified for a tagged type <T>,
then the invariant expression applies to all descendants of <T>.

                          _Dynamic Semantics_

9/4
If one or more invariant expressions apply to a nonabstract type <T>,
then an invariant check is performed at the following places, on the
specified object(s):

10/4
   * After successful initialization of an object of type <T> by default
     (see *note 3.3.1::), the check is performed on the new object
     unless the partial view of <T> has unknown discriminants;

10.1/4
   * After successful explicit initialization of the completion of a
     deferred constant with a part of type <T>, if the completion is
     inside the immediate scope of the full view of <T>, and the
     deferred constant is visible outside the immediate scope of <T>,
     the check is performed on the part(s) of type <T>;

11/3
   * After successful conversion to type <T>, the check is performed on
     the result of the conversion;

12/3
   * For a view conversion, outside the immediate scope of <T>, that
     converts from a descendant of <T> (including <T> itself) to an
     ancestor of type <T> (other than <T> itself), a check is performed
     on the part of the object that is of type <T>:

13/3
             * after assigning to the view conversion; and

14/3
             * after successful return from a call that passes the view
               conversion as an in out or out parameter.

15/4
   * After a successful call on the Read or Input stream-oriented
     attribute of the type <T>, the check is performed on the object
     initialized by the attribute;

16/3
   * An invariant is checked upon successful return from a call on any
     subprogram or entry that:

17/4
        * is declared within the immediate scope of type <T> (or by an
          instance of a generic unit, and the generic is declared within
          the immediate scope of type <T>),

18/4
        * <This paragraph was deleted.>

19/4
        * and either:

19.1/4
             * has a result with a part of type <T>, or

19.2/4
             * has one or more out or in out parameters with a part of
               type <T>, or

19.3/4
             * has an access-to-object parameter or result whose
               designated type has a part of type <T>, or

19.4/4
             * is a procedure or entry that has an in parameter with a
               part of type <T>,

19.5/4
        * and either:

19.6/4
             * <T> is a private type or a private extension and the
               subprogram or entry is visible outside the immediate
               scope of type <T> or overrides an inherited operation
               that is visible outside the immediate scope of <T>, or

19.7/4
             * <T> is a record extension, and the subprogram or entry is
               a primitive operation visible outside the immediate scope
               of type <T> or overrides an inherited operation that is
               visible outside the immediate scope of <T>.

20/3
     The check is performed on each such part of type <T>.

20.1/4
   * For a view conversion to a class-wide type occurring within the
     immediate scope of <T>, from a specific type that is a descendant
     of <T> (including <T> itself), a check is performed on the part of
     the object that is of type <T>.

21/4
If performing checks is required by the Type_Invariant or
Type_Invariant'Class assertion policies (see *note 11.4.2::) in effect
at the point of the corresponding aspect specification applicable to a
given type, then the respective invariant expression is considered
<enabled>.

22/3
The invariant check consists of the evaluation of each enabled invariant
expression that applies to <T>, on each of the objects specified above.
If any of these evaluate to False, Assertions.Assertion_Error is raised
at the point of the object initialization, conversion, or call.  If a
given call requires more than one evaluation of an invariant expression,
either for multiple objects of a single type or for multiple types with
invariants, the evaluations are performed in an arbitrary order, and if
one of them evaluates to False, it is not specified whether the others
are evaluated.  Any invariant check is performed prior to copying back
any by-copy in out or out parameters.  Invariant checks, any
postcondition check, and any constraint or predicate checks associated
with in out or out parameters are performed in an arbitrary order.

22.1/4
For an invariant check on a value of type <T1> based on a class-wide
invariant expression inherited from an ancestor type <T>, any operations
within the invariant expression that were resolved as primitive
operations of the (notional) formal derived type <NT> are bound to the
corresponding operations of type <T1> in the evaluation of the invariant
expression for the check on <T1>.

23/3
The invariant checks performed on a call are determined by the
subprogram or entry actually invoked, whether directly, as part of a
dispatching call, or as part of a call through an access-to-subprogram
value.

     NOTES

24/3
     13  For a call of a primitive subprogram of type <NT> that is
     inherited from type <T>, the specified checks of the specific
     invariants of both the types <NT> and <T> are performed.  For a
     call of a primitive subprogram of type <NT> that is overridden for
     type <NT>, the specified checks of the specific invariants of only
     type <NT> are performed.


File: arm2012.info,  Node: 7.4,  Next: 7.5,  Prev: 7.3,  Up: 7

7.4 Deferred Constants
======================

1
Deferred constant declarations may be used to declare constants in the
visible part of a package, but with the value of the constant given in
the private part.  They may also be used to declare constants imported
from other languages (see *note Annex B::).

                           _Legality Rules_

2/3
A <deferred constant declaration> is an object_declaration with the
reserved word constant but no initialization expression.  The constant
declared by a deferred constant declaration is called a <deferred
constant>.  Unless the Import aspect (see *note B.1::) is True for a
deferred constant declaration, the deferred constant declaration
requires a completion, which shall be a full constant declaration
(called the <full declaration> of the deferred constant).  

3
A deferred constant declaration that is completed by a full constant
declaration shall occur immediately within the visible part of a
package_specification.  For this case, the following additional rules
apply to the corresponding full declaration:

4
   * The full declaration shall occur immediately within the private
     part of the same package;

5/2
   * The deferred and full constants shall have the same type, or shall
     have statically matching anonymous access subtypes;

6/3
   * If the deferred constant declaration includes a subtype_indication
     <S> that defines a constrained subtype, then the constraint defined
     by the subtype_indication in the full declaration shall match the
     constraint defined by <S> statically.  On the other hand, if the
     subtype of the deferred constant is unconstrained, then the full
     declaration is still allowed to impose a constraint.  The constant
     itself will be constrained, like all constants;

7/2
   * If the deferred constant declaration includes the reserved word
     aliased, then the full declaration shall also;

7.1/2
   * If the subtype of the deferred constant declaration excludes null,
     the subtype of the full declaration shall also exclude null.

8/3
A deferred constant declaration for which the Import aspect is True need
not appear in the visible part of a package_specification, and has no
full constant declaration.

9/2
The completion of a deferred constant declaration shall occur before the
constant is frozen (see *note 13.14::).

                          _Dynamic Semantics_

10/3
The elaboration of a deferred constant declaration elaborates the
subtype_indication, access_definition, or (only allowed in the case of
an imported constant) the array_type_definition.

     NOTES

11
     14  The full constant declaration for a deferred constant that is
     of a given private type or private extension is not allowed before
     the corresponding full_type_declaration.  This is a consequence of
     the freezing rules for types (see *note 13.14::).

                              _Examples_

12
<Examples of deferred constant declarations:>

13
     Null_Key : constant Key;      --< see *note 7.3.1::>

14/3
     CPU_Identifier : constant String(1..8)
        with Import => True, Convention => Assembler, Link_Name => "CPU_ID";
                                   --< see *note B.1::>


File: arm2012.info,  Node: 7.5,  Next: 7.6,  Prev: 7.4,  Up: 7

7.5 Limited Types
=================

1/2
A limited type is (a view of) a type for which copying (such as for an
assignment_statement) is not allowed.  A nonlimited type is a (view of
a) type for which copying is allowed.

                           _Legality Rules_

2/2
If a tagged record type has any limited components, then the reserved
word limited shall appear in its record_type_definition.  If the
reserved word limited appears in the definition of a
derived_type_definition, its parent type and any progenitor interfaces
shall be limited.

2.1/3
In the following contexts, an expression of a limited type is not
permitted unless it is an aggregate, a function_call, a parenthesized
expression or qualified_expression whose operand is permitted by this
rule, or a conditional_expression all of whose <dependent_>expressions
are permitted by this rule:

2.2/2
   * the initialization expression of an object_declaration (see *note
     3.3.1::)

2.3/2
   * the default_expression of a component_declaration (see *note 3.8::)

2.4/2
   * the expression of a record_component_association (see *note
     4.3.1::)

2.5/2
   * the expression for an ancestor_part of an extension_aggregate (see
     *note 4.3.2::)

2.6/2
   * an expression of a positional_array_aggregate or the expression of
     an array_component_association (see *note 4.3.3::)

2.7/2
   * the qualified_expression of an initialized allocator (see *note
     4.8::)

2.8/2
   * the expression of a return statement (see *note 6.5::)

2.9/4
   * the return expression of an expression function (see *note 6.8::)

2.10/3
   * the default_expression or actual parameter for a formal object of
     mode in (see *note 12.4::)

                          _Static Semantics_

3/3
A view of a type is <limited> if it is one of the following:

4/2
   * a type with the reserved word limited, synchronized, task, or
     protected in its definition;

5/3
   * a class-wide type whose specific type is limited;

6/2
   * a composite type with a limited component;

6.1/3
   * an incomplete view;

6.2/2
   * a derived type whose parent is limited and is not an interface.

7
Otherwise, the type is nonlimited.

8
There are no predefined equality operators for a limited type.

8.1/3
A type is <immutably limited> if it is one of the following:

8.2/3
   * An explicitly limited record type;

8.3/3
   * A record extension with the reserved word limited;

8.4/3
   * A nonformal limited private type that is tagged or has at least one
     access discriminant with a default_expression;

8.5/3
   * A task type, a protected type, or a synchronized interface;

8.6/3
   * A type derived from an immutably limited type.

8.7/3
A descendant of a generic formal limited private type is presumed to be
immutably limited except within the body of a generic unit or a body
declared within the declarative region of a generic unit, if the formal
type is declared within the formal part of the generic unit.

     NOTES

9/3
     15  While it is allowed to write initializations of limited
     objects, such initializations never copy a limited object.  The
     source of such an assignment operation must be an aggregate or
     function_call, and such aggregates and function_calls must be built
     directly in the target object (see *note 7.6::).

     <Paragraphs 10 through 15 were deleted.>

16
     16  As illustrated in *note 7.3.1::, an untagged limited type can
     become nonlimited under certain circumstances.

                              _Examples_

17
<Example of a package with a limited type:>

18
     package IO_Package is
        type File_Name is limited private;

19
        procedure Open (F : in out File_Name);
        procedure Close(F : in out File_Name);
        procedure Read (F : in File_Name; Item : out Integer);
        procedure Write(F : in File_Name; Item : in  Integer);
     private
        type File_Name is
           limited record
              Internal_Name : Integer := 0;
           end record;
     end IO_Package;

20
     package body IO_Package is
        Limit : constant := 200;
        type File_Descriptor is record  ...  end record;
        Directory : array (1 .. Limit) of File_Descriptor;
        ...
        procedure Open (F : in out File_Name) is  ...  end;
        procedure Close(F : in out File_Name) is  ...  end;
        procedure Read (F : in File_Name; Item : out Integer) is ... end;
        procedure Write(F : in File_Name; Item : in  Integer) is ... end;
     begin
        ...
     end IO_Package;

     NOTES

21
     17  <Notes on the example:> In the example above, an outside
     subprogram making use of IO_Package may obtain a file name by
     calling Open and later use it in calls to Read and Write.  Thus,
     outside the package, a file name obtained from Open acts as a kind
     of password; its internal properties (such as containing a numeric
     value) are not known and no other operations (such as addition or
     comparison of internal names) can be performed on a file name.
     Most importantly, clients of the package cannot make copies of
     objects of type File_Name.

22
     This example is characteristic of any case where complete control
     over the operations of a type is desired.  Such packages serve a
     dual purpose.  They prevent a user from making use of the internal
     structure of the type.  They also implement the notion of an
     encapsulated data type where the only operations on the type are
     those given in the package specification.

23/2
     The fact that the full view of File_Name is explicitly declared
     limited means that parameter passing will always be by reference
     and function results will always be built directly in the result
     object (see *note 6.2:: and *note 6.5::).


File: arm2012.info,  Node: 7.6,  Prev: 7.5,  Up: 7

7.6 Assignment and Finalization
===============================

1
Three kinds of actions are fundamental to the manipulation of objects:
initialization, finalization, and assignment.  Every object is
initialized, either explicitly or by default, after being created (for
example, by an object_declaration or allocator).  Every object is
finalized before being destroyed (for example, by leaving a
subprogram_body containing an object_declaration, or by a call to an
instance of Unchecked_Deallocation).  An assignment operation is used as
part of assignment_statements, explicit initialization, parameter
passing, and other operations.  

2
Default definitions for these three fundamental operations are provided
by the language, but a <controlled> type gives the user additional
control over parts of these operations.  In particular, the user can
define, for a controlled type, an Initialize procedure which is invoked
immediately after the normal default initialization of a controlled
object, a Finalize procedure which is invoked immediately before
finalization of any of the components of a controlled object, and an
Adjust procedure which is invoked as the last step of an assignment to a
(nonlimited) controlled object.

                          _Static Semantics_

3
The following language-defined library package exists:

4/3
     package Ada.Finalization is
         pragma Pure(Finalization);

5/2
         type Controlled is abstract tagged private;
         pragma Preelaborable_Initialization(Controlled);

6/2
         procedure Initialize (Object : in out Controlled) is null;
         procedure Adjust     (Object : in out Controlled) is null;
         procedure Finalize   (Object : in out Controlled) is null;

7/2
         type Limited_Controlled is abstract tagged limited private;
         pragma Preelaborable_Initialization(Limited_Controlled);

8/2
         procedure Initialize (Object : in out Limited_Controlled) is null;
         procedure Finalize   (Object : in out Limited_Controlled) is null;
     private
         ... -- <not specified by the language>
     end Ada.Finalization;

9/2
A controlled type is a descendant of Controlled or Limited_Controlled.
The predefined "=" operator of type Controlled always returns True,
since this operator is incorporated into the implementation of the
predefined equality operator of types derived from Controlled, as
explained in *note 4.5.2::.  The type Limited_Controlled is like
Controlled, except that it is limited and it lacks the primitive
subprogram Adjust.

9.1/2
A type is said to <need finalization> if:

9.2/2
   * it is a controlled type, a task type or a protected type; or

9.3/3
   * it has a component whose type needs finalization; or

9.4/3
   * it is a class-wide type; or

9.5/3
   * it is a partial view whose full view needs finalization; or

9.6/2
   * it is one of a number of language-defined types that are explicitly
     defined to need finalization.

                          _Dynamic Semantics_

10/2
During the elaboration or evaluation of a construct that causes an
object to be initialized by default, for every controlled subcomponent
of the object that is not assigned an initial value (as defined in *note
3.3.1::), Initialize is called on that subcomponent.  Similarly, if the
object that is initialized by default as a whole is controlled,
Initialize is called on the object.

11/2
For an extension_aggregate whose ancestor_part is a subtype_mark
denoting a controlled subtype, the Initialize procedure of the ancestor
type is called, unless that Initialize procedure is abstract.

12
Initialize and other initialization operations are done in an arbitrary
order, except as follows.  Initialize is applied to an object after
initialization of its subcomponents, if any (including both implicit
initialization and Initialize calls).  If an object has a component with
an access discriminant constrained by a per-object expression,
Initialize is applied to this component after any components that do not
have such discriminants.  For an object with several components with
such a discriminant, Initialize is applied to them in order of their
component_declarations.  For an allocator, any task activations follow
all calls on Initialize.

13
When a target object with any controlled parts is assigned a value,
either when created or in a subsequent assignment_statement, the
<assignment operation> proceeds as follows:

14
   * The value of the target becomes the assigned value.

15
   * The value of the target is <adjusted.>

16/3
To adjust the value of a composite object, the values of the components
of the object are first adjusted in an arbitrary order, and then, if the
object is nonlimited controlled, Adjust is called.  Adjusting the value
of an elementary object has no effect, nor does adjusting the value of a
composite object with no controlled parts.

17
For an assignment_statement, after the name and expression have been
evaluated, and any conversion (including constraint checking) has been
done, an anonymous object is created, and the value is assigned into it;
that is, the assignment operation is applied.  (Assignment includes
value adjustment.)  The target of the assignment_statement is then
finalized.  The value of the anonymous object is then assigned into the
target of the assignment_statement.  Finally, the anonymous object is
finalized.  As explained below, the implementation may eliminate the
intermediate anonymous object, so this description subsumes the one
given in *note 5.2::, "*note 5.2:: Assignment Statements".

17.1/3
When a function call or aggregate is used to initialize an object, the
result of the function call or aggregate is an anonymous object, which
is assigned into the newly-created object.  For such an assignment, the
anonymous object might be <built in place>, in which case the assignment
does not involve any copying.  Under certain circumstances, the
anonymous object is required to be built in place.  In particular:

17.2/3
   * If the full type of any part of the object is immutably limited,
     the anonymous object is built in place.

17.3/3
   * In the case of an aggregate, if the full type of any part of the
     newly-created object is controlled, the anonymous object is built
     in place.

17.4/3
   * In other cases, it is unspecified whether the anonymous object is
     built in place.

17.5/3
Notwithstanding what this International Standard says elsewhere, if an
object is built in place:

17.6/3
   * Upon successful completion of the return statement or aggregate,
     the anonymous object <mutates into> the newly-created object; that
     is, the anonymous object ceases to exist, and the newly-created
     object appears in its place.

17.7/3
   * Finalization is not performed on the anonymous object.

17.8/3
   * Adjustment is not performed on the newly-created object.

17.9/3
   * All access values that designate parts of the anonymous object now
     designate the corresponding parts of the newly-created object.

17.10/3
   * All renamings of parts of the anonymous object now denote views of
     the corresponding parts of the newly-created object.

17.11/3
   * Coextensions of the anonymous object become coextensions of the
     newly-created object.

                     _Implementation Permissions_

18/3
An implementation is allowed to relax the above rules for
assignment_statements in the following ways:

19/3
   * If an object is assigned the value of that same object, the
     implementation need not do anything.

20/3
   * For assignment of a noncontrolled type, the implementation may
     finalize and assign each component of the variable separately
     (rather than finalizing the entire variable and assigning the
     entire new value) unless a discriminant of the variable is changed
     by the assignment.

21/3
   * The implementation need not create an anonymous object if the value
     being assigned is the result of evaluating a name denoting an
     object (the source object) whose storage cannot overlap with the
     target.  If the source object might overlap with the target object,
     then the implementation can avoid the need for an intermediary
     anonymous object by exercising one of the above permissions and
     perform the assignment one component at a time (for an overlapping
     array assignment), or not at all (for an assignment where the
     target and the source of the assignment are the same object).

22/2
Furthermore, an implementation is permitted to omit implicit Initialize,
Adjust, and Finalize calls and associated assignment operations on an
object of a nonlimited controlled type provided that:

23/2
   * any omitted Initialize call is not a call on a user-defined
     Initialize procedure, and

24/2
   * any usage of the value of the object after the implicit Initialize
     or Adjust call and before any subsequent Finalize call on the
     object does not change the external effect of the program, and

25/2
   * after the omission of such calls and operations, any execution of
     the program that executes an Initialize or Adjust call on an object
     or initializes an object by an aggregate will also later execute a
     Finalize call on the object and will always do so prior to
     assigning a new value to the object, and

26/2
   * the assignment operations associated with omitted Adjust calls are
     also omitted.

27/2
This permission applies to Adjust and Finalize calls even if the
implicit calls have additional external effects.

* Menu:

* 7.6.1 ::    Completion and Finalization


File: arm2012.info,  Node: 7.6.1,  Up: 7.6

7.6.1 Completion and Finalization
---------------------------------

1
This subclause defines <completion> and <leaving> of the execution of
constructs and entities.  A <master> is the execution of a construct
that includes finalization of local objects after it is complete (and
after waiting for any local tasks -- see *note 9.3::), but before
leaving.  Other constructs and entities are left immediately upon
completion.  

                          _Dynamic Semantics_

2/2
The execution of a construct or entity is <complete> when the end of
that execution has been reached, or when a transfer of control (see
*note 5.1::) causes it to be abandoned.  Completion due to reaching the
end of execution, or due to the transfer of control of an
exit_statement, return statement, goto_statement, or requeue_statement
or of the selection of a terminate_alternative is <normal completion>.
Completion is <abnormal> otherwise -- when control is transferred out of
a construct due to abort or the raising of an exception.

3/2
After execution of a construct or entity is complete, it is <left>,
meaning that execution continues with the next action, as defined for
the execution that is taking place.  Leaving an execution happens
immediately after its completion, except in the case of a <master>: the
execution of a body other than a package_body; the execution of a
statement; or the evaluation of an expression, function_call, or range
that is not part of an enclosing expression, function_call, range, or
simple_statement (*note 5.1: S0147.) other than a
simple_return_statement (*note 6.5: S0183.).  A master is finalized
after it is complete, and before it is left.

4
For the <finalization> of a master, dependent tasks are first awaited,
as explained in *note 9.3::.  Then each object whose accessibility level
is the same as that of the master is finalized if the object was
successfully initialized and still exists.  These actions are performed
whether the master is left by reaching the last statement or via a
transfer of control.  When a transfer of control causes completion of an
execution, each included master is finalized in order, from innermost
outward.

5
For the <finalization> of an object:

6/3
   * If the full type of the object is an elementary type, finalization
     has no effect;

7/3
   * If the full type of the object is a tagged type, and the tag of the
     object identifies a controlled type, the Finalize procedure of that
     controlled type is called;

8/3
   * If the full type of the object is a protected type, or if the full
     type of the object is a tagged type and the tag of the object
     identifies a protected type, the actions defined in *note 9.4:: are
     performed;

9/3
   * If the full type of the object is a composite type, then after
     performing the above actions, if any, every component of the object
     is finalized in an arbitrary order, except as follows: if the
     object has a component with an access discriminant constrained by a
     per-object expression, this component is finalized before any
     components that do not have such discriminants; for an object with
     several components with such a discriminant, they are finalized in
     the reverse of the order of their component_declarations;

9.1/2
   * If the object has coextensions (see *note 3.10.2::), each
     coextension is finalized after the object whose access discriminant
     designates it.

10
Immediately before an instance of Unchecked_Deallocation reclaims the
storage of an object, the object is finalized.  If an instance of
Unchecked_Deallocation is never applied to an object created by an
allocator, the object will still exist when the corresponding master
completes, and it will be finalized then.

11/3
The finalization of a master performs finalization of objects created by
declarations in the master in the reverse order of their creation.
After the finalization of a master is complete, the objects finalized as
part of its finalization cease to <exist>, as do any types and subtypes
defined and created within the master.  

11.1/3
Each nonderived access type <T> has an associated <collection>, which is
the set of objects created by allocators of <T>, or of types derived
from <T>.  Unchecked_Deallocation removes an object from its collection.
Finalization of a collection consists of finalization of each object in
the collection, in an arbitrary order.  The collection of an access type
is an object implicitly declared at the following place:

11.2/3
   * For a named access type, the first freezing point (see *note
     13.14::) of the type.

11.3/3
   * For the type of an access parameter, the call that contains the
     allocator.

11.4/3
   * For the type of an access result, within the master of the call
     (see *note 3.10.2::).

11.5/3
   * For any other anonymous access type, the first freezing point of
     the innermost enclosing declaration.

12/2
The target of an assignment_statement is finalized before copying in the
new value, as explained in *note 7.6::.

13/3
The master of an object is the master enclosing its creation whose
accessibility level (see *note 3.10.2::) is equal to that of the object,
except in the case of an anonymous object representing the result of an
aggregate or function call.  If such an anonymous object is part of the
result of evaluating the actual parameter expression for an explicitly
aliased parameter of a function call, the master of the object is the
innermost master enclosing the evaluation of the aggregate or function
call, excluding the aggregate or function call itself.  Otherwise, the
master of such an anonymous object is the innermost master enclosing the
evaluation of the aggregate or function call, which may be the aggregate
or function call itself.

13.1/3
In the case of an expression that is a master, finalization of any
(anonymous) objects occurs after completing evaluation of the expression
and all use of the objects, prior to starting the execution of any
subsequent construct.

                      _Bounded (Run-Time) Errors_

14/1
It is a bounded error for a call on Finalize or Adjust that occurs as
part of object finalization or assignment to propagate an exception.
The possible consequences depend on what action invoked the Finalize or
Adjust operation:

15
   * For a Finalize invoked as part of an assignment_statement,
     Program_Error is raised at that point.

16/2
   * For an Adjust invoked as part of assignment operations other than
     those invoked as part of an assignment_statement, other adjustments
     due to be performed might or might not be performed, and then
     Program_Error is raised.  During its propagation, finalization
     might or might not be applied to objects whose Adjust failed.  For
     an Adjust invoked as part of an assignment_statement, any other
     adjustments due to be performed are performed, and then
     Program_Error is raised.

17
   * For a Finalize invoked as part of a call on an instance of
     Unchecked_Deallocation, any other finalizations due to be performed
     are performed, and then Program_Error is raised.

17.1/3
   * <This paragraph was deleted.>

17.2/1
   * For a Finalize invoked due to reaching the end of the execution of
     a master, any other finalizations associated with the master are
     performed, and Program_Error is raised immediately after leaving
     the master.

18/2
   * For a Finalize invoked by the transfer of control of an
     exit_statement, return statement, goto_statement, or
     requeue_statement (*note 9.5.4: S0226.), Program_Error is raised no
     earlier than after the finalization of the master being finalized
     when the exception occurred, and no later than the point where
     normal execution would have continued.  Any other finalizations due
     to be performed up to that point are performed before raising
     Program_Error.

19
   * For a Finalize invoked by a transfer of control that is due to
     raising an exception, any other finalizations due to be performed
     for the same master are performed; Program_Error is raised
     immediately after leaving the master.

20
   * For a Finalize invoked by a transfer of control due to an abort or
     selection of a terminate alternative, the exception is ignored; any
     other finalizations due to be performed are performed.

                     _Implementation Permissions_

20.1/3
If the execution of an allocator propagates an exception, any parts of
the allocated object that were successfully initialized may be finalized
as part of the finalization of the innermost master enclosing the
allocator.

20.2/3
The implementation may finalize objects created by allocators for an
access type whose storage pool supports subpools (see *note 13.11.4::)
as if the objects were created (in an arbitrary order) at the point
where the storage pool was elaborated instead of at the first freezing
point of the access type.

     NOTES

21/3
     18  The rules of Clause 10 imply that immediately prior to
     partition termination, Finalize operations are applied to
     library-level controlled objects (including those created by
     allocators of library-level access types, except those already
     finalized).  This occurs after waiting for library-level tasks to
     terminate.

22
     19  A constant is only constant between its initialization and
     finalization.  Both initialization and finalization are allowed to
     change the value of a constant.

23
     20  Abort is deferred during certain operations related to
     controlled types, as explained in *note 9.8::.  Those rules prevent
     an abort from causing a controlled object to be left in an
     ill-defined state.

24
     21  The Finalize procedure is called upon finalization of a
     controlled object, even if Finalize was called earlier, either
     explicitly or as part of an assignment; hence, if a controlled type
     is visibly controlled (implying that its Finalize primitive is
     directly callable), or is nonlimited (implying that assignment is
     allowed), its Finalize procedure should be designed to have no ill
     effect if it is applied a second time to the same object.


File: arm2012.info,  Node: 8,  Next: 9,  Prev: 7,  Up: Top

8 Visibility Rules
******************

1/3
The rules defining the scope of declarations and the rules defining
which identifiers, character_literals, and operator_symbols are visible
at (or from) various places in the text of the program are described in
this clause.  The formulation of these rules uses the notion of a
declarative region.

2/3
As explained in Clause *note 3::, a declaration declares a view of an
entity and associates a defining name with that view.  The view
comprises an identification of the viewed entity, and possibly
additional properties.  A usage name denotes a declaration.  It also
denotes the view declared by that declaration, and denotes the entity of
that view.  Thus, two different usage names might denote two different
views of the same entity; in this case they denote the same entity.

* Menu:

* 8.1 ::      Declarative Region
* 8.2 ::      Scope of Declarations
* 8.3 ::      Visibility
* 8.4 ::      Use Clauses
* 8.5 ::      Renaming Declarations
* 8.6 ::      The Context of Overload Resolution


File: arm2012.info,  Node: 8.1,  Next: 8.2,  Up: 8

8.1 Declarative Region
======================

                          _Static Semantics_

1
For each of the following constructs, there is a portion of the program
text called its <declarative region>, within which nested declarations
can occur:

2
   * any declaration, other than that of an enumeration type, that is
     not a completion of a previous declaration;

2.1/4
   * an access_definition;

3
   * a block_statement;

4
   * a loop_statement;

4.1/3
   * a quantified_expression;

4.2/3
   * an extended_return_statement;

5
   * an accept_statement;

6
   * an exception_handler.

7
The declarative region includes the text of the construct together with
additional text determined (recursively), as follows:

8
   * If a declaration is included, so is its completion, if any.

9
   * If the declaration of a library unit (including Standard -- see
     *note 10.1.1::) is included, so are the declarations of any child
     units (and their completions, by the previous rule).  The child
     declarations occur after the declaration.

10
   * If a body_stub is included, so is the corresponding subunit.

11
   * If a type_declaration is included, then so is a corresponding
     record_representation_clause, if any.

12
The declarative region of a declaration is also called the <declarative
region> of any view or entity declared by the declaration.

13
A declaration occurs <immediately within> a declarative region if this
region is the innermost declarative region that encloses the declaration
(the <immediately enclosing> declarative region), not counting the
declarative region (if any) associated with the declaration itself.

14
A declaration is <local> to a declarative region if the declaration
occurs immediately within the declarative region.  An entity is <local>
to a declarative region if the entity is declared by a declaration that
is local to the declarative region.

15
A declaration is <global> to a declarative region if the declaration
occurs immediately within another declarative region that encloses the
declarative region.  An entity is <global> to a declarative region if
the entity is declared by a declaration that is global to the
declarative region.

     NOTES

16
     1  The children of a parent library unit are inside the parent's
     declarative region, even though they do not occur inside the
     parent's declaration or body.  This implies that one can use (for
     example) "P.Q" to refer to a child of P whose defining name is Q,
     and that after "use P;" Q can refer (directly) to that child.

17
     2  As explained above and in *note 10.1.1::, "*note 10.1.1::
     Compilation Units - Library Units", all library units are
     descendants of Standard, and so are contained in the declarative
     region of Standard.  They are <not> inside the declaration or body
     of Standard, but they <are> inside its declarative region.

18
     3  For a declarative region that comes in multiple parts, the text
     of the declarative region does not contain any text that might
     appear between the parts.  Thus, when a portion of a declarative
     region is said to extend from one place to another in the
     declarative region, the portion does not contain any text that
     might appear between the parts of the declarative region.


File: arm2012.info,  Node: 8.2,  Next: 8.3,  Prev: 8.1,  Up: 8

8.2 Scope of Declarations
=========================

1
For each declaration, the language rules define a certain portion of the
program text called the <scope> of the declaration.  The scope of a
declaration is also called the scope of any view or entity declared by
the declaration.  Within the scope of an entity, and only there, there
are places where it is legal to refer to the declared entity.  These
places are defined by the rules of visibility and overloading.

                          _Static Semantics_

2
The <immediate scope> of a declaration is a portion of the declarative
region immediately enclosing the declaration.  The immediate scope
starts at the beginning of the declaration, except in the case of an
overloadable declaration, in which case the immediate scope starts just
after the place where the profile of the callable entity is determined
(which is at the end of the _specification for the callable entity, or
at the end of the generic_instantiation if an instance).  The immediate
scope extends to the end of the declarative region, with the following
exceptions:

3
   * The immediate scope of a library_item includes only its semantic
     dependents.

4
   * The immediate scope of a declaration in the private part of a
     library unit does not include the visible part of any public
     descendant of that library unit.  

5
The <visible part> of (a view of) an entity is a portion of the text of
its declaration containing declarations that are visible from outside.
The <private part> of (a view of) an entity that has a visible part
contains all declarations within the declaration of (the view of) the
entity, except those in the visible part; these are not visible from
outside.  Visible and private parts are defined only for these kinds of
entities: callable entities, other program units, and composite types.

6
   * The visible part of a view of a callable entity is its profile.

7
   * The visible part of a composite type other than a task or protected
     type consists of the declarations of all components declared
     (explicitly or implicitly) within the type_declaration.

8
   * The visible part of a generic unit includes the
     generic_formal_part.  For a generic package, it also includes the
     first list of basic_declarative_items of the package_specification.
     For a generic subprogram, it also includes the profile.

9
   * The visible part of a package, task unit, or protected unit
     consists of declarations in the program unit's declaration other
     than those following the reserved word private, if any; see *note
     7.1:: and *note 12.7:: for packages, *note 9.1:: for task units,
     and *note 9.4:: for protected units.

10
The scope of a declaration always contains the immediate scope of the
declaration.  In addition, for a given declaration that occurs
immediately within the visible part of an outer declaration, or is a
public child of an outer declaration, the scope of the given declaration
extends to the end of the scope of the outer declaration, except that
the scope of a library_item includes only its semantic dependents.

10.1/3
The scope of an attribute_definition_clause is identical to the scope of
a declaration that would occur at the point of the
attribute_definition_clause.  The scope of an aspect_specification is
identical to the scope of the associated declaration.

11
The immediate scope of a declaration is also the immediate scope of the
entity or view declared by the declaration.  Similarly, the scope of a
declaration is also the scope of the entity or view declared by the
declaration.

12/4
The immediate scope of a pragma that is not used as a configuration
pragma is defined to be the region extending from immediately after the
pragma to the end of the declarative region immediately enclosing the
pragma.

     NOTES

13/3
     4  There are notations for denoting visible declarations that are
     not directly visible.  For example, parameter_specification (*note
     6.1: S0175.)s are in the visible part of a subprogram_declaration
     (*note 6.1: S0163.) so that they can be used in named-notation
     calls appearing outside the called subprogram.  For another
     example, declarations of the visible part of a package can be
     denoted by expanded names appearing outside the package, and can be
     made directly visible by a use_clause.


File: arm2012.info,  Node: 8.3,  Next: 8.4,  Prev: 8.2,  Up: 8

8.3 Visibility
==============

1
The <visibility rules>, given below, determine which declarations are
visible and directly visible at each place within a program.  The
visibility rules apply to both explicit and implicit declarations.

                          _Static Semantics_

2
A declaration is defined to be <directly visible> at places where a name
consisting of only an identifier or operator_symbol is sufficient to
denote the declaration; that is, no selected_component notation or
special context (such as preceding => in a named association) is
necessary to denote the declaration.  A declaration is defined to be
<visible> wherever it is directly visible, as well as at other places
where some name (such as a selected_component) can denote the
declaration.

3
The syntactic category direct_name is used to indicate contexts where
direct visibility is required.  The syntactic category selector_name is
used to indicate contexts where visibility, but not direct visibility,
is required.

4
There are two kinds of direct visibility: <immediate visibility> and
<use-visibility>.  A declaration is immediately visible at a place if it
is directly visible because the place is within its immediate scope.  A
declaration is use-visible if it is directly visible because of a
use_clause (see *note 8.4::).  Both conditions can apply.

5
A declaration can be <hidden>, either from direct visibility, or from
all visibility, within certain parts of its scope.  Where <hidden from
all visibility>, it is not visible at all (neither using a direct_name
nor a selector_name).  Where <hidden from direct visibility>, only
direct visibility is lost; visibility using a selector_name is still
possible.

6
Two or more declarations are <overloaded> if they all have the same
defining name and there is a place where they are all directly visible.

7
The declarations of callable entities (including enumeration literals)
are <overloadable>, meaning that overloading is allowed for them.

8
Two declarations are <homographs> if they have the same defining name,
and, if both are overloadable, their profiles are type conformant.  An
inner declaration hides any outer homograph from direct visibility.

9/1
Two homographs are not generally allowed immediately within the same
declarative region unless one <overrides> the other (see Legality Rules
below).  The only declarations that are <overridable> are the implicit
declarations for predefined operators and inherited primitive
subprograms.  A declaration overrides another homograph that occurs
immediately within the same declarative region in the following cases:

10/1
   * A declaration that is not overridable overrides one that is
     overridable, regardless of which declaration occurs first;

11
   * The implicit declaration of an inherited operator overrides that of
     a predefined operator;

12
   * An implicit declaration of an inherited subprogram overrides a
     previous implicit declaration of an inherited subprogram.

12.1/2
   * If two or more homographs are implicitly declared at the same
     place:

12.2/2
             * If at least one is a subprogram that is neither a null
               procedure nor an abstract subprogram, and does not
               require overriding (see *note 3.9.3::), then they
               override those that are null procedures, abstract
               subprograms, or require overriding.  If more than one
               such homograph remains that is not thus overridden, then
               they are all hidden from all visibility.

12.3/2
             * Otherwise (all are null procedures, abstract subprograms,
               or require overriding), then any null procedure overrides
               all abstract subprograms and all subprograms that require
               overriding; if more than one such homograph remains that
               is not thus overridden, then if they are all fully
               conformant with one another, one is chosen arbitrarily;
               if not, they are all hidden from all visibility.  

13
   * For an implicit declaration of a primitive subprogram in a generic
     unit, there is a copy of this declaration in an instance.  However,
     a whole new set of primitive subprograms is implicitly declared for
     each type declared within the visible part of the instance.  These
     new declarations occur immediately after the type declaration, and
     override the copied ones.  The copied ones can be called only from
     within the instance; the new ones can be called only from outside
     the instance, although for tagged types, the body of a new one can
     be executed by a call to an old one.

14
A declaration is visible within its scope, except where hidden from all
visibility, as follows:

15
   * An overridden declaration is hidden from all visibility within the
     scope of the overriding declaration.

16
   * A declaration is hidden from all visibility until the end of the
     declaration, except:

17
             * For a record type or record extension, the declaration is
               hidden from all visibility only until the reserved word
               record;

18/3
             * For a package_declaration, generic_package_declaration
               (*note 12.1: S0273.), subprogram_body (*note 6.3:
               S0177.), or expression_function_declaration (*note 6.8:
               S0189.), the declaration is hidden from all visibility
               only until the reserved word is of the declaration;

18.1/2
             * For a task declaration or protected declaration, the
               declaration is hidden from all visibility only until the
               reserved word with of the declaration if there is one, or
               the reserved word is of the declaration if there is no
               with.

19
   * If the completion of a declaration is a declaration, then within
     the scope of the completion, the first declaration is hidden from
     all visibility.  Similarly, a discriminant_specification (*note
     3.7: S0062.) or parameter_specification (*note 6.1: S0175.) is
     hidden within the scope of a corresponding
     discriminant_specification (*note 3.7: S0062.) or
     parameter_specification (*note 6.1: S0175.) of a corresponding
     completion, or of a corresponding accept_statement (*note 9.5.2:
     S0219.).

20/2
   * The declaration of a library unit (including a
     library_unit_renaming_declaration) is hidden from all visibility at
     places outside its declarative region that are not within the scope
     of a nonlimited_with_clause that mentions it.  The limited view of
     a library package is hidden from all visibility at places that are
     not within the scope of a limited_with_clause that mentions it; in
     addition, the limited view is hidden from all visibility within the
     declarative region of the package, as well as within the scope of
     any nonlimited_with_clause that mentions the package.  Where the
     declaration of the limited view of a package is visible, any name
     that denotes the package denotes the limited view, including those
     provided by a package renaming.

20.1/2
   * For each declaration or renaming of a generic unit as a child of
     some parent generic package, there is a corresponding declaration
     nested immediately within each instance of the parent.  Such a
     nested declaration is hidden from all visibility except at places
     that are within the scope of a with_clause that mentions the child.

21
A declaration with a defining_identifier or defining_operator_symbol is
immediately visible (and hence directly visible) within its immediate
scope  except where hidden from direct visibility, as follows:

22
   * A declaration is hidden from direct visibility within the immediate
     scope of a homograph of the declaration, if the homograph occurs
     within an inner declarative region;

23
   * A declaration is also hidden from direct visibility where hidden
     from all visibility.

23.1/3
An attribute_definition_clause or an aspect_specification is <visible>
everywhere within its scope.

                        _Name Resolution Rules_

24
A direct_name shall resolve to denote a directly visible declaration
whose defining name is the same as the direct_name.  A selector_name
shall resolve to denote a visible declaration whose defining name is the
same as the selector_name.

25
These rules on visibility and direct visibility do not apply in a
context_clause, a parent_unit_name, or a pragma that appears at the
place of a compilation_unit.  For those contexts, see the rules in *note
10.1.6::, "*note 10.1.6:: Environment-Level Visibility Rules".

                           _Legality Rules_

26/2
A nonoverridable declaration is illegal if there is a homograph
occurring immediately within the same declarative region that is visible
at the place of the declaration, and is not hidden from all visibility
by the nonoverridable declaration.  In addition, a type extension is
illegal if somewhere within its immediate scope it has two visible
components with the same name.  Similarly, the context_clause for a
compilation unit is illegal if it mentions (in a with_clause) some
library unit, and there is a homograph of the library unit that is
visible at the place of the compilation unit, and the homograph and the
mentioned library unit are both declared immediately within the same
declarative region.  These rules also apply to dispatching operations
declared in the visible part of an instance of a generic unit.  However,
they do not apply to other overloadable declarations in an instance;
such declarations may have type conformant profiles in the instance, so
long as the corresponding declarations in the generic were not type
conformant.  

     NOTES

27
     5  Visibility for compilation units follows from the definition of
     the environment in *note 10.1.4::, except that it is necessary to
     apply a with_clause to obtain visibility to a
     library_unit_declaration or library_unit_renaming_declaration.

28
     6  In addition to the visibility rules given above, the meaning of
     the occurrence of a direct_name or selector_name at a given place
     in the text can depend on the overloading rules (see *note 8.6::).

29
     7  Not all contexts where an identifier, character_literal, or
     operator_symbol are allowed require visibility of a corresponding
     declaration.  Contexts where visibility is not required are
     identified by using one of these three syntactic categories
     directly in a syntax rule, rather than using direct_name or
     selector_name.

* Menu:

* 8.3.1 ::    Overriding Indicators


File: arm2012.info,  Node: 8.3.1,  Up: 8.3

8.3.1 Overriding Indicators
---------------------------

1/2
An overriding_indicator is used to declare that an operation is intended
to override (or not override) an inherited operation.

                               _Syntax_

2/2
     overriding_indicator ::= [not] overriding

                           _Legality Rules_

3/3
If an abstract_subprogram_declaration (*note 3.9.3: S0076.),
null_procedure_declaration (*note 6.7: S0188.),
expression_function_declaration (*note 6.8: S0189.), subprogram_body,
subprogram_body_stub (*note 10.1.3: S0259.),
subprogram_renaming_declaration (*note 8.5.4: S0203.),
generic_instantiation (*note 12.3: S0276.) of a subprogram, or
subprogram_declaration (*note 6.1: S0163.) other than a protected
subprogram has an overriding_indicator (*note 8.3.1: S0195.), then:

4/2
   * the operation shall be a primitive operation for some type;

5/2
   * if the overriding_indicator is overriding, then the operation shall
     override a homograph at the place of the declaration or body;

6/2
   * if the overriding_indicator is not overriding, then the operation
     shall not override any homograph (at any place).

7/2
In addition to the places where Legality Rules normally apply, these
rules also apply in the private part of an instance of a generic unit.

     NOTES

8/2
     8  Rules for overriding_indicators of task and protected entries
     and of protected subprograms are found in *note 9.5.2:: and *note
     9.4::, respectively.

                              _Examples_

9/2
The use of overriding_indicators allows the detection of errors at
compile-time that otherwise might not be detected at all.  For instance,
we might declare a security queue derived from the Queue interface of
3.9.4 as:

10/2
     type Security_Queue is new Queue with record ...;

11/2
     overriding
     procedure Append(Q : in out Security_Queue; Person : in Person_Name);

12/2
     overriding
     procedure Remove_First(Q : in out Security_Queue; Person : in Person_Name);

13/2
     overriding
     function Cur_Count(Q : in Security_Queue) return Natural;

14/2
     overriding
     function Max_Count(Q : in Security_Queue) return Natural;

15/2
     not overriding
     procedure Arrest(Q : in out Security_Queue; Person : in Person_Name);

16/2
The first four subprogram declarations guarantee that these subprograms
will override the four subprograms inherited from the Queue interface.
A misspelling in one of these subprograms will be detected by the
implementation.  Conversely, the declaration of Arrest guarantees that
this is a new operation.


File: arm2012.info,  Node: 8.4,  Next: 8.5,  Prev: 8.3,  Up: 8

8.4 Use Clauses
===============

1
A use_package_clause achieves direct visibility of declarations that
appear in the visible part of a package; a use_type_clause achieves
direct visibility of the primitive operators of a type.

                               _Syntax_

2
     use_clause ::= use_package_clause | use_type_clause

3
     use_package_clause ::= use <package_>name {, <package_>name};

4/3
     use_type_clause ::= use [all] type subtype_mark {, subtype_mark};

                           _Legality Rules_

5/2
A <package_>name of a use_package_clause shall denote a nonlimited view
of a package.

                          _Static Semantics_

6
For each use_clause, there is a certain region of text called the
<scope> of the use_clause.  For a use_clause within a context_clause of
a library_unit_declaration or library_unit_renaming_declaration, the
scope is the entire declarative region of the declaration.  For a
use_clause within a context_clause of a body, the scope is the entire
body and any subunits (including multiply nested subunits).  The scope
does not include context_clauses themselves.

7
For a use_clause immediately within a declarative region, the scope is
the portion of the declarative region starting just after the use_clause
and extending to the end of the declarative region.  However, the scope
of a use_clause in the private part of a library unit does not include
the visible part of any public descendant of that library unit.

7.1/2
A package is <named> in a use_package_clause if it is denoted by a
<package_>name of that clause.  A type is <named> in a use_type_clause
if it is determined by a subtype_mark of that clause.

8/3
For each package named in a use_package_clause whose scope encloses a
place, each declaration that occurs immediately within the declarative
region of the package is <potentially use-visible> at this place if the
declaration is visible at this place.  For each type <T> or <T>'Class
named in a use_type_clause whose scope encloses a place, the declaration
of each primitive operator of type <T> is potentially use-visible at
this place if its declaration is visible at this place.  If a
use_type_clause whose scope encloses a place includes the reserved word
all, then the following entities are also potentially use-visible at
this place if the declaration of the entity is visible at this place:

8.1/3
   * Each primitive subprogram of <T> including each enumeration literal
     (if any);

8.2/3
   * Each subprogram that is declared immediately within the declarative
     region in which an ancestor type of <T> is declared and that
     operates on a class-wide type that covers <T>.

8.3/3
Certain implicit declarations may become potentially use-visible in
certain contexts as described in *note 12.6::.

9
A declaration is <use-visible> if it is potentially use-visible, except
in these naming-conflict cases:

10
   * A potentially use-visible declaration is not use-visible if the
     place considered is within the immediate scope of a homograph of
     the declaration.

11
   * Potentially use-visible declarations that have the same identifier
     are not use-visible unless each of them is an overloadable
     declaration.

                          _Dynamic Semantics_

12
The elaboration of a use_clause has no effect.

                              _Examples_

13
<Example of a use clause in a context clause:>

14
     with Ada.Calendar; use Ada;

15
<Example of a use type clause:>

16
     use type Rational_Numbers.Rational; --< see *note 7.1::>
     Two_Thirds: Rational_Numbers.Rational := 2/3;


File: arm2012.info,  Node: 8.5,  Next: 8.6,  Prev: 8.4,  Up: 8

8.5 Renaming Declarations
=========================

1
A renaming_declaration declares another name for an entity, such as an
object, exception, package, subprogram, entry, or generic unit.
Alternatively, a subprogram_renaming_declaration can be the completion
of a previous subprogram_declaration.

                               _Syntax_

2
     renaming_declaration ::=
           object_renaming_declaration
         | exception_renaming_declaration
         | package_renaming_declaration
         | subprogram_renaming_declaration
         | generic_renaming_declaration

                          _Dynamic Semantics_

3
The elaboration of a renaming_declaration evaluates the name that
follows the reserved word renames and thereby determines the view and
entity denoted by this name (the <renamed view> and <renamed entity>).
A name that denotes the renaming_declaration denotes (a new view of) the
renamed entity.

     NOTES

4
     9  Renaming may be used to resolve name conflicts and to act as a
     shorthand.  Renaming with a different identifier or operator_symbol
     does not hide the old name; the new name and the old name need not
     be visible at the same places.

5
     10  A task or protected object that is declared by an explicit
     object_declaration can be renamed as an object.  However, a single
     task or protected object cannot be renamed since the corresponding
     type is anonymous (meaning it has no nameable subtypes).  For
     similar reasons, an object of an anonymous array or access type
     cannot be renamed.

6
     11  A subtype defined without any additional constraint can be used
     to achieve the effect of renaming another subtype (including a task
     or protected subtype) as in

7
             subtype Mode is Ada.Text_IO.File_Mode;

* Menu:

* 8.5.1 ::    Object Renaming Declarations
* 8.5.2 ::    Exception Renaming Declarations
* 8.5.3 ::    Package Renaming Declarations
* 8.5.4 ::    Subprogram Renaming Declarations
* 8.5.5 ::    Generic Renaming Declarations


File: arm2012.info,  Node: 8.5.1,  Next: 8.5.2,  Up: 8.5

8.5.1 Object Renaming Declarations
----------------------------------

1
An object_renaming_declaration is used to rename an object.

                               _Syntax_

2/3
     object_renaming_declaration ::=
         defining_identifier : [null_exclusion] 
     subtype_mark renames <object_>name
             [aspect_specification];
       | defining_identifier : access_definition renames <object_>name
             [aspect_specification];

                        _Name Resolution Rules_

3/2
The type of the <object_>name shall resolve to the type determined by
the subtype_mark, or in the case where the type is defined by an
access_definition, to an anonymous access type.  If the anonymous access
type is an access-to-object type, the type of the <object_>name shall
have the same designated type as that of the access_definition.  If the
anonymous access type is an access-to-subprogram type, the type of the
<object_>name shall have a designated profile that is type conformant
with that of the access_definition.

                           _Legality Rules_

4
The renamed entity shall be an object.

4.1/2
In the case where the type is defined by an access_definition, the type
of the renamed object and the type defined by the access_definition:

4.2/2
   * shall both be access-to-object types with statically matching
     designated subtypes and with both or neither being
     access-to-constant types; or 

4.3/2
   * shall both be access-to-subprogram types with subtype conformant
     designated profiles.  

4.4/2
For an object_renaming_declaration with a null_exclusion or an
access_definition that has a null_exclusion:

4.5/2
   * if the <object_>name denotes a generic formal object of a generic
     unit <G>, and the object_renaming_declaration occurs within the
     body of <G> or within the body of a generic unit declared within
     the declarative region of <G>, then the declaration of the formal
     object of <G> shall have a null_exclusion;

4.6/2
   * otherwise, the subtype of the <object_>name shall exclude null.  In
     addition to the places where Legality Rules normally apply (see
     *note 12.3::), this rule applies also in the private part of an
     instance of a generic unit.

5/3
The renamed entity shall not be a subcomponent that depends on
discriminants of an object whose nominal subtype is unconstrained unless
the object is known to be constrained.  A slice of an array shall not be
renamed if this restriction disallows renaming of the array.  In
addition to the places where Legality Rules normally apply, these rules
apply also in the private part of an instance of a generic unit.

                          _Static Semantics_

6/2
An object_renaming_declaration declares a new view of the renamed object
whose properties are identical to those of the renamed view.  Thus, the
properties of the renamed object are not affected by the
renaming_declaration.  In particular, its value and whether or not it is
a constant are unaffected; similarly, the null exclusion or constraints
that apply to an object are not affected by renaming (any constraint
implied by the subtype_mark or access_definition of the
object_renaming_declaration is ignored).

                              _Examples_

7
<Example of renaming an object:>

8
     declare
        L : Person renames Leftmost_Person; --< see *note 3.10.1::>
     begin
        L.Age := L.Age + 1;
     end;


File: arm2012.info,  Node: 8.5.2,  Next: 8.5.3,  Prev: 8.5.1,  Up: 8.5

8.5.2 Exception Renaming Declarations
-------------------------------------

1
An exception_renaming_declaration is used to rename an exception.

                               _Syntax_

2/3
     exception_renaming_declaration ::=
     defining_identifier : exception renames <exception_>name
        [aspect_specification];

                           _Legality Rules_

3
The renamed entity shall be an exception.

                          _Static Semantics_

4
An exception_renaming_declaration declares a new view of the renamed
exception.

                              _Examples_

5
<Example of renaming an exception:>

6
     EOF : exception renames Ada.IO_Exceptions.End_Error; <-- see *note A.13::>


File: arm2012.info,  Node: 8.5.3,  Next: 8.5.4,  Prev: 8.5.2,  Up: 8.5

8.5.3 Package Renaming Declarations
-----------------------------------

1
A package_renaming_declaration is used to rename a package.

                               _Syntax_

2/3
     package_renaming_declaration ::= package 
     defining_program_unit_name renames <package_>name
        [aspect_specification];

                           _Legality Rules_

3
The renamed entity shall be a package.

3.1/2
If the <package_>name of a package_renaming_declaration denotes a
limited view of a package <P>, then a name that denotes the
package_renaming_declaration shall occur only within the immediate scope
of the renaming or the scope of a with_clause that mentions the package
<P> or, if <P> is a nested package, the innermost library package
enclosing <P>.

                          _Static Semantics_

4
A package_renaming_declaration declares a new view of the renamed
package.

4.1/2
At places where the declaration of the limited view of the renamed
package is visible, a name that denotes the package_renaming_declaration
denotes a limited view of the package (see *note 10.1.1::).

                              _Examples_

5
<Example of renaming a package:>

6
     package TM renames Table_Manager;


File: arm2012.info,  Node: 8.5.4,  Next: 8.5.5,  Prev: 8.5.3,  Up: 8.5

8.5.4 Subprogram Renaming Declarations
--------------------------------------

1/3
A subprogram_renaming_declaration can serve as the completion of a
subprogram_declaration; such a renaming_declaration is called a
<renaming-as-body>.  A subprogram_renaming_declaration that is not a
completion is called a <renaming-as-declaration>, and is used to rename
a subprogram (possibly an enumeration literal) or an entry.

                               _Syntax_

2/3
     subprogram_renaming_declaration ::=
         [overriding_indicator]
         subprogram_specification renames <callable_entity_>name
             [aspect_specification];

                        _Name Resolution Rules_

3
The expected profile for the <callable_entity_>name is the profile given
in the subprogram_specification.

                           _Legality Rules_

4/3
The profile of a renaming-as-declaration shall be mode conformant, with
that of the renamed callable entity.  

4.1/2
For a parameter or result subtype of the subprogram_specification that
has an explicit null_exclusion:

4.2/2
   * if the <callable_entity_>name denotes a generic formal subprogram
     of a generic unit <G>, and the subprogram_renaming_declaration
     occurs within the body of a generic unit <G> or within the body of
     a generic unit declared within the declarative region of the
     generic unit <G>, then the corresponding parameter or result
     subtype of the formal subprogram of <G> shall have a
     null_exclusion;

4.3/2
   * otherwise, the subtype of the corresponding parameter or result
     type of the renamed callable entity shall exclude null.  In
     addition to the places where Legality Rules normally apply (see
     *note 12.3::), this rule applies also in the private part of an
     instance of a generic unit.

5/3
The profile of a renaming-as-body shall conform fully to that of the
declaration it completes.  If the renaming-as-body completes that
declaration before the subprogram it declares is frozen, the profile
shall be mode conformant with that of the renamed callable entity and
the subprogram it declares takes its convention from the renamed
subprogram; otherwise, the profile shall be subtype conformant with that
of the renamed callable entity and the convention of the renamed
subprogram shall not be Intrinsic.  A renaming-as-body is illegal if the
declaration occurs before the subprogram whose declaration it completes
is frozen, and the renaming renames the subprogram itself, through one
or more subprogram renaming declarations, none of whose subprograms has
been frozen.

5.1/2
The <callable_entity_>name of a renaming shall not denote a subprogram
that requires overriding (see *note 3.9.3::).

5.2/2
The <callable_entity_>name of a renaming-as-body shall not denote an
abstract subprogram.

6
A name that denotes a formal parameter of the subprogram_specification
is not allowed within the <callable_entity_>name.

                          _Static Semantics_

7
A renaming-as-declaration declares a new view of the renamed entity.
The profile of this new view takes its subtypes, parameter modes, and
calling convention from the original profile of the callable entity,
while taking the formal parameter names and default_expressions from the
profile given in the subprogram_renaming_declaration.  The new view is a
function or procedure, never an entry.

                          _Dynamic Semantics_

7.1/1
For a call to a subprogram whose body is given as a renaming-as-body,
the execution of the renaming-as-body is equivalent to the execution of
a subprogram_body that simply calls the renamed subprogram with its
formal parameters as the actual parameters and, if it is a function,
returns the value of the call.

8/3
For a call on a renaming of a dispatching subprogram that is overridden,
if the overriding occurred before the renaming, then the body executed
is that of the overriding declaration, even if the overriding
declaration is not visible at the place of the renaming; otherwise, the
inherited or predefined subprogram is called.  A corresponding rule
applies to a call on a renaming of a predefined equality operator for an
untagged record type.

                      _Bounded (Run-Time) Errors_

8.1/1
If a subprogram directly or indirectly renames itself, then it is a
bounded error to call that subprogram.  Possible consequences are that
Program_Error or Storage_Error is raised, or that the call results in
infinite recursion.

     NOTES

9
     12  A procedure can only be renamed as a procedure.  A function
     whose defining_designator is either an identifier or an
     operator_symbol can be renamed with either an identifier or an
     operator_symbol; for renaming as an operator, the subprogram
     specification given in the renaming_declaration is subject to the
     rules given in *note 6.6:: for operator declarations.  Enumeration
     literals can be renamed as functions; similarly,
     attribute_references that denote functions (such as references to
     Succ and Pred) can be renamed as functions.  An entry can only be
     renamed as a procedure; the new name is only allowed to appear in
     contexts that allow a procedure name.  An entry of a family can be
     renamed, but an entry family cannot be renamed as a whole.

10
     13  The operators of the root numeric types cannot be renamed
     because the types in the profile are anonymous, so the
     corresponding specifications cannot be written; the same holds for
     certain attributes, such as Pos.

11
     14  Calls with the new name of a renamed entry are
     procedure_call_statements and are not allowed at places where the
     syntax requires an entry_call_statement in conditional_ and
     timed_entry_calls, nor in an asynchronous_select; similarly, the
     Count attribute is not available for the new name.

12
     15  The primitiveness of a renaming-as-declaration is determined by
     its profile, and by where it occurs, as for any declaration of (a
     view of) a subprogram; primitiveness is not determined by the
     renamed view.  In order to perform a dispatching call, the
     subprogram name has to denote a primitive subprogram, not a
     nonprimitive renaming of a primitive subprogram.

                              _Examples_

13
<Examples of subprogram renaming declarations:>

14
     procedure My_Write(C : in Character) renames Pool(K).Write; --<  see *note 4.1.3::>

15
     function Real_Plus(Left, Right : Real   ) return Real    renames "+";
     function Int_Plus (Left, Right : Integer) return Integer renames "+";

16
     function Rouge return Color renames Red;  --<  see *note 3.5.1::>
     function Rot   return Color renames Red;
     function Rosso return Color renames Rouge;

17
     function Next(X : Color) return Color renames Color'Succ; --< see *note 3.5.1::>

18
<Example of a subprogram renaming declaration with new parameter names:>

19
     function "*" (X,Y : Vector) return Real renames Dot_Product; --< see *note 6.1::>

20
<Example of a subprogram renaming declaration with a new default
expression:>

21
     function Minimum(L : Link := Head) return Cell renames Min_Cell; --< see *note 6.1::>


File: arm2012.info,  Node: 8.5.5,  Prev: 8.5.4,  Up: 8.5

8.5.5 Generic Renaming Declarations
-----------------------------------

1
A generic_renaming_declaration is used to rename a generic unit.

                               _Syntax_

2/3
     generic_renaming_declaration ::=
         generic package   
     defining_program_unit_name renames <generic_package_>name
             [aspect_specification];
       | generic procedure   
     defining_program_unit_name renames <generic_procedure_>name
             [aspect_specification];
       | generic function   
     defining_program_unit_name renames <generic_function_>name
             [aspect_specification];

                           _Legality Rules_

3
The renamed entity shall be a generic unit of the corresponding kind.

                          _Static Semantics_

4
A generic_renaming_declaration declares a new view of the renamed
generic unit.

     NOTES

5
     16  Although the properties of the new view are the same as those
     of the renamed view, the place where the
     generic_renaming_declaration occurs may affect the legality of
     subsequent renamings and instantiations that denote the
     generic_renaming_declaration, in particular if the renamed generic
     unit is a library unit (see *note 10.1.1::).

                              _Examples_

6
<Example of renaming a generic unit:>

7
     generic package Enum_IO renames Ada.Text_IO.Enumeration_IO;  <-- see *note A.10.10::>


File: arm2012.info,  Node: 8.6,  Prev: 8.5,  Up: 8

8.6 The Context of Overload Resolution
======================================

1/3
Because declarations can be overloaded, it is possible for an occurrence
of a usage name to have more than one possible interpretation; in most
cases, ambiguity is disallowed.  This subclause describes how the
possible interpretations resolve to the actual interpretation.

2
Certain rules of the language (the Name Resolution Rules) are considered
"overloading rules".  If a possible interpretation violates an
overloading rule, it is assumed not to be the intended interpretation;
some other possible interpretation is assumed to be the actual
interpretation.  On the other hand, violations of nonoverloading rules
do not affect which interpretation is chosen; instead, they cause the
construct to be illegal.  To be legal, there usually has to be exactly
one acceptable interpretation of a construct that is a "complete
context", not counting any nested complete contexts.

3
The syntax rules of the language and the visibility rules given in *note
8.3:: determine the possible interpretations.  Most type checking rules
(rules that require a particular type, or a particular class of types,
for example) are overloading rules.  Various rules for the matching of
formal and actual parameters are overloading rules.

                        _Name Resolution Rules_

4
Overload resolution is applied separately to each <complete context>,
not counting inner complete contexts.  Each of the following constructs
is a <complete context>:

5
   * A context_item.

6
   * A declarative_item or declaration.

7
   * A statement.

8
   * A pragma_argument_association.

9/4
   * The <selecting_>expression of a case_statement or case_expression.

10
An (overall) <interpretation> of a complete context embodies its
meaning, and includes the following information about the constituents
of the complete context, not including constituents of inner complete
contexts:

11
   * for each constituent of the complete context, to which syntactic
     categories it belongs, and by which syntax rules; and

12
   * for each usage name, which declaration it denotes (and, therefore,
     which view and which entity it denotes); and

13
   * for a complete context that is a declarative_item, whether or not
     it is a completion of a declaration, and (if so) which declaration
     it completes.

14
A <possible interpretation> is one that obeys the syntax rules and the
visibility rules.  An <acceptable interpretation> is a possible
interpretation that obeys the <overloading rules>, that is, those rules
that specify an expected type or expected profile, or specify how a
construct shall <resolve> or be <interpreted>.

15
The <interpretation> of a constituent of a complete context is
determined from the overall interpretation of the complete context as a
whole.  Thus, for example, "interpreted as a function_call," means that
the construct's interpretation says that it belongs to the syntactic
category function_call.

16
Each occurrence of a usage name <denotes> the declaration determined by
its interpretation.  It also denotes the view declared by its denoted
declaration, except in the following cases:

17/3
   * If a usage name appears within the declarative region of a
     type_declaration and denotes that same type_declaration, then it
     denotes the <current instance> of the type (rather than the type
     itself); the current instance of a type is the object or value of
     the type that is associated with the execution that evaluates the
     usage name.  Similarly, if a usage name appears within the
     declarative region of a subtype_declaration and denotes that same
     subtype_declaration, then it denotes the current instance of the
     subtype.  These rules do not apply if the usage name appears within
     the subtype_mark of an access_definition for an access-to-object
     type, or within the subtype of a parameter or result of an
     access-to-subprogram type.

17.1/4
     Within an aspect_specification for a type or subtype, the current
     instance represents a value of the type; it is not an object.  The
     nominal subtype of this value is given by the subtype itself (the
     first subtype in the case of a type_declaration), prior to applying
     any predicate specified directly on the type or subtype.  If the
     type or subtype is by-reference, the associated object with the
     value is the object associated (see *note 6.2::) with the execution
     of the usage name.

18
   * If a usage name appears within the declarative region of a
     generic_declaration (but not within its generic_formal_part) and it
     denotes that same generic_declaration, then it denotes the <current
     instance> of the generic unit (rather than the generic unit
     itself).  See also *note 12.3::.

19
A usage name that denotes a view also denotes the entity of that view.

20/2
The <expected type> for a given expression, name, or other construct
determines, according to the <type resolution rules> given below, the
types considered for the construct during overload resolution.  The type
resolution rules provide support for class-wide programming, universal
literals, dispatching operations, and anonymous access types:

21
   * If a construct is expected to be of any type in a class of types,
     or of the universal or class-wide type for a class, then the type
     of the construct shall resolve to a type in that class or to a
     universal type that covers the class.

22
   * If the expected type for a construct is a specific type <T>, then
     the type of the construct shall resolve either to <T>, or:

23
             * to <T>'Class; or

24
             * to a universal type that covers <T>; or

25/2
             * when <T> is a specific anonymous access-to-object type
               (see *note 3.10::) with designated type <D>, to an
               access-to-object type whose designated type is <D>'Class
               or is covered by <D>; or

25.1/3
             * when <T> is a named general access-to-object type (see
               *note 3.10::) with designated type <D>, to an anonymous
               access-to-object type whose designated type covers or is
               covered by <D>; or

25.2/3
             * when <T> is an anonymous access-to-subprogram type (see
               *note 3.10::), to an access-to-subprogram type whose
               designated profile is type conformant with that of <T>.

26
In certain contexts, such as in a subprogram_renaming_declaration, the
Name Resolution Rules define an <expected profile> for a given name; in
such cases, the name shall resolve to the name of a callable entity
whose profile is type conformant with the expected profile.  

                           _Legality Rules_

27/2
When a construct is one that requires that its expected type be a
<single> type in a given class, the type of the construct shall be
determinable solely from the context in which the construct appears,
excluding the construct itself, but using the requirement that it be in
the given class.  Furthermore, the context shall not be one that expects
any type in some class that contains types of the given class; in
particular, the construct shall not be the operand of a type_conversion.

27.1/4
Other than for the <tested_>simple_expression of a membership test, if
the expected type for a name or expression is not the same as the actual
type of the name or expression, the actual type shall be convertible to
the expected type (see *note 4.6::); further, if the expected type is a
named access-to-object type with designated type <D1> and the actual
type is an anonymous access-to-object type with designated type <D2>,
then <D1> shall cover <D2>, and the name or expression shall denote a
view with an accessibility level for which the statically deeper
relationship applies; in particular it shall not denote an access
parameter nor a stand-alone access object.

28
A complete context shall have at least one acceptable interpretation; if
there is exactly one, then that one is chosen.

29
There is a <preference> for the primitive operators (and ranges) of the
root numeric types <root_integer> and <root_real>.  In particular, if
two acceptable interpretations of a constituent of a complete context
differ only in that one is for a primitive operator (or range) of the
type <root_integer> or <root_real>, and the other is not, the
interpretation using the primitive operator (or range) of the root
numeric type is <preferred>.

29.1/3
Similarly, there is a preference for the equality operators of the
<universal_access> type (see *note 4.5.2::).  If two acceptable
interpretations of a constituent of a complete context differ only in
that one is for an equality operator of the <universal_access> type, and
the other is not, the interpretation using the equality operator of the
<universal_access> type is preferred.

30
For a complete context, if there is exactly one overall acceptable
interpretation where each constituent's interpretation is the same as or
preferred (in the above sense) over those in all other overall
acceptable interpretations, then that one overall acceptable
interpretation is chosen.  Otherwise, the complete context is
<ambiguous>.

31
A complete context other than a pragma_argument_association shall not be
ambiguous.

32
A complete context that is a pragma_argument_association is allowed to
be ambiguous (unless otherwise specified for the particular pragma), but
only if every acceptable interpretation of the pragma argument is as a
name that statically denotes a callable entity.  Such a name denotes all
of the declarations determined by its interpretations, and all of the
views declared by these declarations.

     NOTES

33
     17  If a usage name has only one acceptable interpretation, then it
     denotes the corresponding entity.  However, this does not mean that
     the usage name is necessarily legal since other requirements exist
     which are not considered for overload resolution; for example, the
     fact that an expression is static, whether an object is constant,
     mode and subtype conformance rules, freezing rules, order of
     elaboration, and so on.

34
     Similarly, subtypes are not considered for overload resolution (the
     violation of a constraint does not make a program illegal but
     raises an exception during program execution).


File: arm2012.info,  Node: 9,  Next: 10,  Prev: 8,  Up: Top

9 Tasks and Synchronization
***************************

1/3
The execution of an Ada program consists of the execution of one or more
<tasks>.  Each task represents a separate thread of control that
proceeds independently and concurrently between the points where it
<interacts> with other tasks.  The various forms of task interaction are
described in this clause, and include: 

2
   * the activation and termination of a task;

3
   * a call on a protected subprogram of a <protected object>, providing
     exclusive read-write access, or concurrent read-only access to
     shared data;

4
   * a call on an entry, either of another task, allowing for
     synchronous communication with that task, or of a protected object,
     allowing for asynchronous communication with one or more other
     tasks using that same protected object;

5
   * a timed operation, including a simple delay statement, a timed
     entry call or accept, or a timed asynchronous select statement (see
     next item);

6
   * an asynchronous transfer of control as part of an asynchronous
     select statement, where a task stops what it is doing and begins
     execution at a different point in response to the completion of an
     entry call or the expiration of a delay;

7
   * an abort statement, allowing one task to cause the termination of
     another task.

8
In addition, tasks can communicate indirectly by reading and updating
(unprotected) shared variables, presuming the access is properly
synchronized through some other kind of task interaction.

                          _Static Semantics_

9
The properties of a task are defined by a corresponding task declaration
and task_body, which together define a program unit called a <task
unit>.

                          _Dynamic Semantics_

10
Over time, tasks proceed through various <states>.  A task is initially
<inactive>; upon activation, and prior to its <termination> it is either
<blocked> (as part of some task interaction) or <ready> to run.  While
ready, a task competes for the available <execution resources> that it
requires to run.

     NOTES

11
     1  Concurrent task execution may be implemented on multicomputers,
     multiprocessors, or with interleaved execution on a single physical
     processor.  On the other hand, whenever an implementation can
     determine that the required semantic effects can be achieved when
     parts of the execution of a given task are performed by different
     physical processors acting in parallel, it may choose to perform
     them in this way.

* Menu:

* 9.1 ::      Task Units and Task Objects
* 9.2 ::      Task Execution - Task Activation
* 9.3 ::      Task Dependence - Termination of Tasks
* 9.4 ::      Protected Units and Protected Objects
* 9.5 ::      Intertask Communication
* 9.6 ::      Delay Statements, Duration, and Time
* 9.7 ::      Select Statements
* 9.8 ::      Abort of a Task - Abort of a Sequence of Statements
* 9.9 ::      Task and Entry Attributes
* 9.10 ::     Shared Variables
* 9.11 ::     Example of Tasking and Synchronization


File: arm2012.info,  Node: 9.1,  Next: 9.2,  Up: 9

9.1 Task Units and Task Objects
===============================

1
A task unit is declared by a <task declaration>, which has a
corresponding task_body.  A task declaration may be a
task_type_declaration, in which case it declares a named task type;
alternatively, it may be a single_task_declaration, in which case it
defines an anonymous task type, as well as declaring a named task object
of that type.

                               _Syntax_

2/3
     task_type_declaration ::=
        task type defining_identifier [known_discriminant_part]
             [aspect_specification] [is
          [new interface_list with]
          task_definition];

3/3
     single_task_declaration ::=
        task defining_identifier 
             [aspect_specification][is
          [new interface_list with]
          task_definition];

4
     task_definition ::=
          {task_item}
       [ private
          {task_item}]
       end [<task_>identifier]

5/1
     task_item ::= entry_declaration | aspect_clause

6/3
     task_body ::=
        task body defining_identifier
             [aspect_specification] is
          declarative_part
        begin
          handled_sequence_of_statements
        end [<task_>identifier];

7
     If a <task_>identifier appears at the end of a task_definition or
     task_body, it shall repeat the defining_identifier.

<Paragraph 8 was deleted.>

                          _Static Semantics_

9
A task_definition defines a task type and its first subtype.  The first
list of task_items of a task_definition (*note 9.1: S0207.), together
with the known_discriminant_part (*note 3.7: S0061.), if any, is called
the visible part of the task unit.  The optional list of task_items
after the reserved word private is called the private part of the task
unit.

9.1/1
For a task declaration without a task_definition, a task_definition
without task_items is assumed.

9.2/3
For a task declaration with an interface_list, the task type inherits
user-defined primitive subprograms from each progenitor type (see *note
3.9.4::), in the same way that a derived type inherits user-defined
primitive subprograms from its progenitor types (see *note 3.4::).  If
the first parameter of a primitive inherited subprogram is of the task
type or an access parameter designating the task type, and there is an
entry_declaration for a single entry with the same identifier within the
task declaration, whose profile is type conformant with the prefixed
view profile of the inherited subprogram, the inherited subprogram is
said to be <implemented> by the conforming task entry using an
implicitly declared nonabstract subprogram which has the same profile as
the inherited subprogram and which overrides it.

                           _Legality Rules_

9.3/2
A task declaration requires a completion, which shall be a task_body,
and every task_body shall be the completion of some task declaration.

9.4/2
Each <interface_>subtype_mark of an interface_list appearing within a
task declaration shall denote a limited interface type that is not a
protected interface.

9.5/3
The prefixed view profile of an explicitly declared primitive subprogram
of a tagged task type shall not be type conformant with any entry of the
task type, if the subprogram has the same defining name as the entry and
the first parameter of the subprogram is of the task type or is an
access parameter designating the task type.

9.6/2
For each primitive subprogram inherited by the type declared by a task
declaration, at most one of the following shall apply:

9.7/2
   * the inherited subprogram is overridden with a primitive subprogram
     of the task type, in which case the overriding subprogram shall be
     subtype conformant with the inherited subprogram and not abstract;
     or

9.8/2
   * the inherited subprogram is implemented by a single entry of the
     task type; in which case its prefixed view profile shall be subtype
     conformant with that of the task entry.  

9.9/2
If neither applies, the inherited subprogram shall be a null procedure.In addition to the places where Legality Rules normally apply (see *note
12.3::), these rules also apply in the private part of an instance of a
generic unit.

                          _Dynamic Semantics_

10
The elaboration of a task declaration elaborates the task_definition.
The elaboration of a single_task_declaration (*note 9.1: S0206.) also
creates an object of an (anonymous) task type.

11
The elaboration of a task_definition creates the task type and its first
subtype; it also includes the elaboration of the entry_declarations in
the given order.

12/1
As part of the initialization of a task object, any aspect_clauses and
any per-object constraints associated with entry_declaration (*note
9.5.2: S0218.)s of the corresponding task_definition (*note 9.1: S0207.)
are elaborated in the given order.

13
The elaboration of a task_body has no effect other than to establish
that tasks of the type can from then on be activated without failing the
Elaboration_Check.

14
The execution of a task_body is invoked by the activation of a task of
the corresponding type (see *note 9.2::).

15
The content of a task object of a given task type includes:

16
   * The values of the discriminants of the task object, if any;

17
   * An entry queue for each entry of the task object;

18
   * A representation of the state of the associated task.

     NOTES

19/2
     2  Other than in an access_definition, the name of a task unit
     within the declaration or body of the task unit denotes the current
     instance of the unit (see *note 8.6::), rather than the first
     subtype of the corresponding task type (and thus the name cannot be
     used as a subtype_mark).

20
     3  The notation of a selected_component can be used to denote a
     discriminant of a task (see *note 4.1.3::).  Within a task unit,
     the name of a discriminant of the task type denotes the
     corresponding discriminant of the current instance of the unit.

21/2
     4  A task type is a limited type (see *note 7.5::), and hence
     precludes use of assignment_statements and predefined equality
     operators.  If an application needs to store and exchange task
     identities, it can do so by defining an access type designating the
     corresponding task objects and by using access values for
     identification purposes.  Assignment is available for such an
     access type as for any access type.  Alternatively, if the
     implementation supports the Systems Programming Annex, the Identity
     attribute can be used for task identification (see *note C.7.1::).

                              _Examples_

22
<Examples of declarations of task types:>

23
     task type Server is
        entry Next_Work_Item(WI : in Work_Item);
        entry Shut_Down;
     end Server;

24/2
     task type Keyboard_Driver(ID : Keyboard_ID := New_ID) is
           new Serial_Device with  --< see *note 3.9.4::>
        entry Read (C : out Character);
        entry Write(C : in  Character);
     end Keyboard_Driver;

25
<Examples of declarations of single tasks:>

26
     task Controller is
        entry Request(Level)(D : Item);  --<  a family of entries>
     end Controller;

27
     task Parser is
        entry Next_Lexeme(L : in  Lexical_Element);
        entry Next_Action(A : out Parser_Action);
     end;

28
     task User;  --<  has no entries>

29
<Examples of task objects:>

30
     Agent    : Server;
     Teletype : Keyboard_Driver(TTY_ID);
     Pool     : array(1 .. 10) of Keyboard_Driver;

31
<Example of access type designating task objects:>

32
     type Keyboard is access Keyboard_Driver;
     Terminal : Keyboard := new Keyboard_Driver(Term_ID);


File: arm2012.info,  Node: 9.2,  Next: 9.3,  Prev: 9.1,  Up: 9

9.2 Task Execution - Task Activation
====================================

                          _Dynamic Semantics_

1
The execution of a task of a given task type consists of the execution
of the corresponding task_body.  The initial part of this execution is
called the <activation> of the task; it consists of the elaboration of
the declarative_part of the task_body.  Should an exception be
propagated by the elaboration of its declarative_part, the activation of
the task is defined to have <failed>, and it becomes a completed task.

2/2
A task object (which represents one task) can be a part of a stand-alone
object, of an object created by an allocator, or of an anonymous object
of a limited type, or a coextension of one of these.  All tasks that are
part or coextensions of any of the stand-alone objects created by the
elaboration of object_declaration (*note 3.3.1: S0032.)s (or
generic_associations of formal objects of mode in) of a single
declarative region are activated together.  All tasks that are part or
coextensions of a single object that is not a stand-alone object are
activated together.

3/2
For the tasks of a given declarative region, the activations are
initiated within the context of the handled_sequence_of_statements
(*note 11.2: S0265.) (and its associated exception_handler (*note 11.2:
S0266.)s if any -- see *note 11.2::), just prior to executing the
statements of the handled_sequence_of_statements.  For a package without
an explicit body or an explicit handled_sequence_of_statements (*note
11.2: S0265.), an implicit body or an implicit null_statement (*note
5.1: S0149.) is assumed, as defined in *note 7.2::.

4/2
For tasks that are part or coextensions of a single object that is not a
stand-alone object, activations are initiated after completing any
initialization of the outermost object enclosing these tasks, prior to
performing any other operation on the outermost object.  In particular,
for tasks that are part or coextensions of the object created by the
evaluation of an allocator, the activations are initiated as the last
step of evaluating the allocator, prior to returning the new access
value.  For tasks that are part or coextensions of an object that is the
result of a function call, the activations are not initiated until after
the function returns.

5
The task that created the new tasks and initiated their activations (the
<activator>) is blocked until all of these activations complete
(successfully or not).  Once all of these activations are complete, if
the activation of any of the tasks has failed (due to the propagation of
an exception), Tasking_Error is raised in the activator, at the place at
which it initiated the activations.  Otherwise, the activator proceeds
with its execution normally.  Any tasks that are aborted prior to
completing their activation are ignored when determining whether to
raise Tasking_Error.

6/3
If the master that directly encloses the point where the activation of a
task <T> would be initiated, completes before the activation of <T> is
initiated, <T> becomes terminated and is never activated.  Furthermore,
if a return statement is left such that the return object is not
returned to the caller, any task that was created as a part of the
return object or one of its coextensions immediately becomes terminated
and is never activated.

     NOTES

7
     5  An entry of a task can be called before the task has been
     activated.

8
     6  If several tasks are activated together, the execution of any of
     these tasks need not await the end of the activation of the other
     tasks.

9
     7  A task can become completed during its activation either because
     of an exception or because it is aborted (see *note 9.8::).

                              _Examples_

10
<Example of task activation:>

11
     procedure P is
        A, B : Server;    --<  elaborate the task objects A, B>
        C    : Server;    --<  elaborate the task object C>
     begin
        --<  the tasks A, B, C are activated together before the first statement>
        ...
     end;


File: arm2012.info,  Node: 9.3,  Next: 9.4,  Prev: 9.2,  Up: 9

9.3 Task Dependence - Termination of Tasks
==========================================

                          _Dynamic Semantics_

1
Each task (other than an environment task -- see *note 10.2::) <depends>
on one or more masters (see *note 7.6.1::), as follows:

2/4
   * If the task is created by the evaluation of an allocator for a
     given named access type, it depends on each master that includes
     the elaboration of the declaration of the ultimate ancestor of the
     given access type.

3
   * If the task is created by the elaboration of an object_declaration,
     it depends on each master that includes this elaboration.

3.1/2
   * Otherwise, the task depends on the master of the outermost object
     of which it is a part (as determined by the accessibility level of
     that object -- see *note 3.10.2:: and *note 7.6.1::), as well as on
     any master whose execution includes that of the master of the
     outermost object.

4
Furthermore, if a task depends on a given master, it is defined to
depend on the task that executes the master, and (recursively) on any
master of that task.

5
A task is said to be <completed> when the execution of its corresponding
task_body is completed.  A task is said to be <terminated> when any
finalization of the task_body has been performed (see *note 7.6.1::).
The first step of finalizing a master (including a task_body) is to wait
for the termination of any tasks dependent on the master.  The task
executing the master is blocked until all the dependents have
terminated.  Any remaining finalization is then performed and the master
is left.

6/1
Completion of a task (and the corresponding task_body) can occur when
the task is blocked at a select_statement (*note 9.7: S0230.) with an
open terminate_alternative (see *note 9.7.1::); the open
terminate_alternative is selected if and only if the following
conditions are satisfied:

7/2
   * The task depends on some completed master; and

8
   * Each task that depends on the master considered is either already
     terminated or similarly blocked at a select_statement with an open
     terminate_alternative.

9
When both conditions are satisfied, the task considered becomes
completed, together with all tasks that depend on the master considered
that are not yet completed.

     NOTES

10
     8  The full view of a limited private type can be a task type, or
     can have subcomponents of a task type.  Creation of an object of
     such a type creates dependences according to the full type.

11
     9  An object_renaming_declaration defines a new view of an existing
     entity and hence creates no further dependence.

12
     10  The rules given for the collective completion of a group of
     tasks all blocked on select_statements with open
     terminate_alternatives ensure that the collective completion can
     occur only when there are no remaining active tasks that could call
     one of the tasks being collectively completed.

13
     11  If two or more tasks are blocked on select_statements with open
     terminate_alternatives, and become completed collectively, their
     finalization actions proceed concurrently.

14
     12  The completion of a task can occur due to any of the following:

15
        * the raising of an exception during the elaboration of the
          declarative_part of the corresponding task_body;

16
        * the completion of the handled_sequence_of_statements of the
          corresponding task_body;

17
        * the selection of an open terminate_alternative of a
          select_statement in the corresponding task_body;

18
        * the abort of the task.

                              _Examples_

19
<Example of task dependence:>

20
     declare
        type Global is access Server;        --<  see *note 9.1::>
        A, B : Server;
        G    : Global;
     begin
        --<  activation of A and B>
        declare
           type Local is access Server;
           X : Global := new Server;  --<  activation of X.all>
           L : Local  := new Server;  --<  activation of L.all>
           C : Server;
        begin
           --<  activation of C>
           G := X;  --<  both G and X designate the same task object>
           ...
        end;  --<  await termination of C and L.all (but not X.all)>
        ...
     end;  --<  await termination of A, B, and G.all>


File: arm2012.info,  Node: 9.4,  Next: 9.5,  Prev: 9.3,  Up: 9

9.4 Protected Units and Protected Objects
=========================================

1
A <protected object> provides coordinated access to shared data, through
calls on its visible <protected operations>, which can be <protected
subprograms> or <protected entries>.  A <protected unit> is declared by
a <protected declaration>, which has a corresponding protected_body.  A
protected declaration may be a protected_type_declaration, in which case
it declares a named protected type; alternatively, it may be a
single_protected_declaration, in which case it defines an anonymous
protected type, as well as declaring a named protected object of that
type.  

                               _Syntax_

2/3
     protected_type_declaration ::=
       protected type defining_identifier [known_discriminant_part]
             [aspect_specification] is
          [new interface_list with]
          protected_definition;

3/3
     single_protected_declaration ::=
       protected defining_identifier
             [aspect_specification] is
          [new interface_list with]
          protected_definition;

4
     protected_definition ::=
         { protected_operation_declaration }
     [ private
         { protected_element_declaration } ]
       end [<protected_>identifier]

5/1
     protected_operation_declaration ::= subprogram_declaration
          | entry_declaration
          | aspect_clause

6
     protected_element_declaration ::= protected_operation_declaration
          | component_declaration

7/3
     protected_body ::=
       protected body defining_identifier
             [aspect_specification] is
        { protected_operation_item }
       end [<protected_>identifier];

8/4
     protected_operation_item ::= subprogram_declaration
          | subprogram_body
          | null_procedure_declaration
          | expression_function_declaration
          | entry_body
          | aspect_clause

9
     If a <protected_>identifier appears at the end of a
     protected_definition or protected_body, it shall repeat the
     defining_identifier.

<Paragraph 10 was deleted.>

                          _Static Semantics_

11/2
A protected_definition defines a protected type and its first subtype.
The list of protected_operation_declaration (*note 9.4: S0213.)s of a
protected_definition (*note 9.4: S0212.), together with the
known_discriminant_part (*note 3.7: S0061.), if any, is called the
visible part of the protected unit.  The optional list of
protected_element_declaration (*note 9.4: S0214.)s after the reserved
word private is called the private part of the protected unit.

11.1/3
For a protected declaration with an interface_list, the protected type
inherits user-defined primitive subprograms from each progenitor type
(see *note 3.9.4::), in the same way that a derived type inherits
user-defined primitive subprograms from its progenitor types (see *note
3.4::).  If the first parameter of a primitive inherited subprogram is
of the protected type or an access parameter designating the protected
type, and there is a protected_operation_declaration for a protected
subprogram or single entry with the same identifier within the protected
declaration, whose profile is type conformant with the prefixed view
profile of the inherited subprogram, the inherited subprogram is said to
be <implemented> by the conforming protected subprogram or entry using
an implicitly declared nonabstract subprogram which has the same profile
as the inherited subprogram and which overrides it.  

                           _Legality Rules_

11.2/2
A protected declaration requires a completion, which shall be a
protected_body (*note 9.4: S0215.), and every protected_body (*note 9.4:
S0215.) shall be the completion of some protected declaration.

11.3/2
Each <interface_>subtype_mark of an interface_list appearing within a
protected declaration shall denote a limited interface type that is not
a task interface.

11.4/3
The prefixed view profile of an explicitly declared primitive subprogram
of a tagged protected type shall not be type conformant with any
protected operation of the protected type, if the subprogram has the
same defining name as the protected operation and the first parameter of
the subprogram is of the protected type or is an access parameter
designating the protected type.

11.5/2
For each primitive subprogram inherited by the type declared by a
protected declaration, at most one of the following shall apply:

11.6/2
   * the inherited subprogram is overridden with a primitive subprogram
     of the protected type, in which case the overriding subprogram
     shall be subtype conformant with the inherited subprogram and not
     abstract; or

11.7/2
   * the inherited subprogram is implemented by a protected subprogram
     or single entry of the protected type, in which case its prefixed
     view profile shall be subtype conformant with that of the protected
     subprogram or entry.  

11.8/2
If neither applies, the inherited subprogram shall be a null procedure.In addition to the places where Legality Rules normally apply (see *note
12.3::), these rules also apply in the private part of an instance of a
generic unit.

11.9/3
If an inherited subprogram is implemented by a protected procedure or an
entry, then the first parameter of the inherited subprogram shall be of
mode out or in out, or an access-to-variable parameter.  If an inherited
subprogram is implemented by a protected function, then the first
parameter of the inherited subprogram shall be of mode in, but not an
access-to-variable parameter.

11.10/2
If a protected subprogram declaration has an overriding_indicator, then
at the point of the declaration:

11.11/2
   * if the overriding_indicator is overriding, then the subprogram
     shall implement an inherited subprogram;

11.12/2
   * if the overriding_indicator is not overriding, then the subprogram
     shall not implement any inherited subprogram.

11.13/2
In addition to the places where Legality Rules normally apply (see *note
12.3::), these rules also apply in the private part of an instance of a
generic unit.

                          _Dynamic Semantics_

12
The elaboration of a protected declaration elaborates the
protected_definition.  The elaboration of a single_protected_declaration
(*note 9.4: S0211.) also creates an object of an (anonymous) protected
type.

13
The elaboration of a protected_definition creates the protected type and
its first subtype; it also includes the elaboration of the
component_declarations and protected_operation_declarations in the given
order.

14
As part of the initialization of a protected object, any per-object
constraints (see *note 3.8::) are elaborated.

15
The elaboration of a protected_body has no other effect than to
establish that protected operations of the type can from then on be
called without failing the Elaboration_Check.

16
The content of an object of a given protected type includes:

17
   * The values of the components of the protected object, including
     (implicitly) an entry queue for each entry declared for the
     protected object;

18
   * A representation of the state of the execution resource
     <associated> with the protected object (one such resource is
     associated with each protected object).

19
The execution resource associated with a protected object has to be
acquired to read or update any components of the protected object; it
can be acquired (as part of a protected action -- see *note 9.5.1::)
either for concurrent read-only access, or for exclusive read-write
access.

20
As the first step of the <finalization> of a protected object, each call
remaining on any entry queue of the object is removed from its queue and
Program_Error is raised at the place of the corresponding
entry_call_statement (*note 9.5.3: S0225.).

                      _Bounded (Run-Time) Errors_

20.1/2
It is a bounded error to call an entry or subprogram of a protected
object after that object is finalized.  If the error is detected,
Program_Error is raised.  Otherwise, the call proceeds normally, which
may leave a task queued forever.

     NOTES

21/2
     13  Within the declaration or body of a protected unit other than
     in an access_definition, the name of the protected unit denotes the
     current instance of the unit (see *note 8.6::), rather than the
     first subtype of the corresponding protected type (and thus the
     name cannot be used as a subtype_mark).

22
     14  A selected_component can be used to denote a discriminant of a
     protected object (see *note 4.1.3::).  Within a protected unit, the
     name of a discriminant of the protected type denotes the
     corresponding discriminant of the current instance of the unit.

23/2
     15  A protected type is a limited type (see *note 7.5::), and hence
     precludes use of assignment_statements and predefined equality
     operators.

24
     16  The bodies of the protected operations given in the
     protected_body define the actions that take place upon calls to the
     protected operations.

25
     17  The declarations in the private part are only visible within
     the private part and the body of the protected unit.

                              _Examples_

26
<Example of declaration of protected type and corresponding body:>

27
     protected type Resource is
        entry Seize;
        procedure Release;
     private
        Busy : Boolean := False;
     end Resource;

28
     protected body Resource is
        entry Seize when not Busy is
        begin
           Busy := True;
        end Seize;

29
        procedure Release is
        begin
           Busy := False;
        end Release;
     end Resource;

30
<Example of a single protected declaration and corresponding body:>

31
     protected Shared_Array is
        --<  Index, Item, and Item_Array are global types>
        function  Component    (N : in Index) return Item;
        procedure Set_Component(N : in Index; E : in  Item);
     private
        Table : Item_Array(Index) := (others => Null_Item);
     end Shared_Array;

32
     protected body Shared_Array is
        function Component(N : in Index) return Item is
        begin
           return Table(N);
        end Component;

33
        procedure Set_Component(N : in Index; E : in Item) is
        begin
           Table(N) := E;
        end Set_Component;
     end Shared_Array;

34
<Examples of protected objects:>

35
     Control  : Resource;
     Flags    : array(1 .. 100) of Resource;


File: arm2012.info,  Node: 9.5,  Next: 9.6,  Prev: 9.4,  Up: 9

9.5 Intertask Communication
===========================

1
The primary means for intertask communication is provided by calls on
entries and protected subprograms.  Calls on protected subprograms allow
coordinated access to shared data objects.  Entry calls allow for
blocking the caller until a given condition is satisfied (namely, that
the corresponding entry is open -- see *note 9.5.3::), and then
communicating data or control information directly with another task or
indirectly via a shared protected object.

                          _Static Semantics_

2/3
When a name or prefix denotes an entry, protected subprogram, or a
prefixed view of a primitive subprogram of a limited interface whose
first parameter is a controlling parameter, the name or prefix
determines a <target object>, as follows:

3/3
   * If it is a direct_name or expanded name that denotes the
     declaration (or body) of the operation, then the target object is
     implicitly specified to be the current instance of the task or
     protected unit immediately enclosing the operation; a call using
     such a name is defined to be an <internal call>;

4/3
   * If it is a selected_component that is not an expanded name, then
     the target object is explicitly specified to be the object denoted
     by the prefix of the name; a call using such a name is defined to
     be an <external call>;

5/3
   * If the name or prefix is a dereference (implicit or explicit) of an
     access-to-protected-subprogram value, then the target object is
     determined by the prefix of the Access attribute_reference that
     produced the access value originally; a call using such a name is
     defined to be an <external call>;

6
   * If the name or prefix denotes a subprogram_renaming_declaration,
     then the target object is as determined by the name of the renamed
     entity.

6.1/3
A call on an entry or a protected subprogram either uses a name or
prefix that determines a target object implicitly, as above, or is a
call on (a non-prefixed view of) a primitive subprogram of a limited
interface whose first parameter is a controlling parameter, in which
case the target object is identified explicitly by the first parameter.
This latter case is an <external call>.

7
A corresponding definition of target object applies to a
requeue_statement (see *note 9.5.4::), with a corresponding distinction
between an <internal requeue> and an <external requeue>.

                           _Legality Rules_

7.1/3
If a name or prefix determines a target object, and the name denotes a
protected entry or procedure, then the target object shall be a
variable, unless the prefix is for an attribute_reference to the Count
attribute (see *note 9.9::).

                          _Dynamic Semantics_

8
Within the body of a protected operation, the current instance (see
*note 8.6::) of the immediately enclosing protected unit is determined
by the target object specified (implicitly or explicitly) in the call
(or requeue) on the protected operation.

9
Any call on a protected procedure or entry of a target protected object
is defined to be an update to the object, as is a requeue on such an
entry.

                               _Syntax_

10/3
     synchronization_kind ::=
     By_Entry | By_Protected_Procedure | Optional

                          _Static Semantics_

11/3
For the declaration of a primitive procedure of a synchronized tagged
type the following language-defined representation aspect may be
specified with an aspect_specification (see *note 13.1.1::):

12/3
Synchronization
               If specified, the aspect definition shall be a
               synchronization_kind.

13/3
Inherited subprograms inherit the Synchronization aspect, if any, from
the corresponding subprogram of the parent or progenitor type.  If an
overriding operation does not have a directly specified Synchronization
aspect then the Synchronization aspect of the inherited operation is
inherited by the overriding operation.

                           _Legality Rules_

14/3
The synchronization_kind By_Protected_Procedure shall not be applied to
a primitive procedure of a task interface.

15/3
A procedure for which the specified synchronization_kind is By_Entry
shall be implemented by an entry.  A procedure for which the specified
synchronization_kind is By_Protected_Procedure shall be implemented by a
protected procedure.  A procedure for which the specified
synchronization_kind is Optional may be implemented by an entry or by a
procedure (including a protected procedure).

16/3
If a primitive procedure overrides an inherited operation for which the
Synchronization aspect has been specified to be By_Entry or
By_Protected_Procedure, then any specification of the aspect
Synchronization applied to the overriding operation shall have the same
synchronization_kind.

17/3
In addition to the places where Legality Rules normally apply (see *note
12.3::), these rules also apply in the private part of an instance of a
generic unit.

     NOTES

18/3
     18  The synchronization_kind By_Protected_Procedure implies that
     the operation will not block.

* Menu:

* 9.5.1 ::    Protected Subprograms and Protected Actions
* 9.5.2 ::    Entries and Accept Statements
* 9.5.3 ::    Entry Calls
* 9.5.4 ::    Requeue Statements


File: arm2012.info,  Node: 9.5.1,  Next: 9.5.2,  Up: 9.5

9.5.1 Protected Subprograms and Protected Actions
-------------------------------------------------

1
A <protected subprogram> is a subprogram declared immediately within a
protected_definition.  Protected procedures provide exclusive read-write
access to the data of a protected object; protected functions provide
concurrent read-only access to the data.

                          _Static Semantics_

2
Within the body of a protected function (or a function declared
immediately within a protected_body), the current instance of the
enclosing protected unit is defined to be a constant (that is, its
subcomponents may be read but not updated).  Within the body of a
protected procedure (or a procedure declared immediately within a
protected_body), and within an entry_body, the current instance is
defined to be a variable (updating is permitted).

2.1/4
For a type declared by a protected_type_declaration or for the anonymous
type of an object declared by a single_protected_declaration, the
following language-defined type-related representation aspect may be
specified:

2.2/4
Exclusive_Functions
               The type of aspect Exclusive_Functions is Boolean.  If
               not specified (including by inheritance), the aspect is
               False.

2.3/4

               A value of True for this aspect indicates that protected
               functions behave in the same way as protected procedures
               with respect to mutual exclusion and queue servicing (see
               below).

2.4/4
A protected procedure or entry is an <exclusive> protected operation.  A
protected function of a protected type <P> is an exclusive protected
operation if the Exclusive_Functions aspect of <P> is True.

                          _Dynamic Semantics_

3
For the execution of a call on a protected subprogram, the evaluation of
the name or prefix and of the parameter associations, and any assigning
back of in out or out parameters, proceeds as for a normal subprogram
call (see *note 6.4::).  If the call is an internal call (see *note
9.5::), the body of the subprogram is executed as for a normal
subprogram call.  If the call is an external call, then the body of the
subprogram is executed as part of a new <protected action> on the target
protected object; the protected action completes after the body of the
subprogram is executed.  A protected action can also be started by an
entry call (see *note 9.5.3::).

4/4
A new protected action is not started on a protected object while
another protected action on the same protected object is underway,
unless both actions are the result of a call on a nonexclusive protected
function.  This rule is expressible in terms of the execution resource
associated with the protected object:

5/4
   * <Starting> a protected action on a protected object corresponds to
     <acquiring> the execution resource associated with the protected
     object, either for exclusive read-write access if the protected
     action is for a call on an exclusive protected operation, or for
     concurrent read-only access otherwise;

6
   * <Completing> the protected action corresponds to <releasing> the
     associated execution resource.

7/4
After performing an exclusive protected operation on a protected object,
but prior to completing the associated protected action, the entry
queues (if any) of the protected object are serviced (see *note
9.5.3::).

                      _Bounded (Run-Time) Errors_

8
During a protected action, it is a bounded error to invoke an operation
that is <potentially blocking>.  The following are defined to be
potentially blocking operations:

9
   * a select_statement;

10
   * an accept_statement;

11
   * an entry_call_statement;

12
   * a delay_statement;

13
   * an abort_statement;

14
   * task creation or activation;

15
   * an external call on a protected subprogram (or an external requeue)
     with the same target object as that of the protected action;

16
   * a call on a subprogram whose body contains a potentially blocking
     operation.

17
If the bounded error is detected, Program_Error is raised.  If not
detected, the bounded error might result in deadlock or a (nested)
protected action on the same target object.

18
Certain language-defined subprograms are potentially blocking.  In
particular, the subprograms of the language-defined input-output
packages that manipulate files (implicitly or explicitly) are
potentially blocking.  Other potentially blocking subprograms are
identified where they are defined.  When not specified as potentially
blocking, a language-defined subprogram is nonblocking.

     NOTES

19
     19  If two tasks both try to start a protected action on a
     protected object, and at most one is calling a protected function,
     then only one of the tasks can proceed.  Although the other task
     cannot proceed, it is not considered blocked, and it might be
     consuming processing resources while it awaits its turn.  There is
     no language-defined ordering or queuing presumed for tasks
     competing to start a protected action -- on a multiprocessor such
     tasks might use busy-waiting; for monoprocessor considerations, see
     *note D.3::, "*note D.3:: Priority Ceiling Locking".

20
     20  The body of a protected unit may contain declarations and
     bodies for local subprograms.  These are not visible outside the
     protected unit.

21
     21  The body of a protected function can contain internal calls on
     other protected functions, but not protected procedures, because
     the current instance is a constant.  On the other hand, the body of
     a protected procedure can contain internal calls on both protected
     functions and procedures.

22
     22  From within a protected action, an internal call on a protected
     subprogram, or an external call on a protected subprogram with a
     different target object is not considered a potentially blocking
     operation.

22.1/2
     23  The pragma Detect_Blocking may be used to ensure that all
     executions of potentially blocking operations during a protected
     action raise Program_Error.  See *note H.5::.

                              _Examples_

23
<Examples of protected subprogram calls (see *note 9.4::):>

24
     Shared_Array.Set_Component(N, E);
     E := Shared_Array.Component(M);
     Control.Release;


File: arm2012.info,  Node: 9.5.2,  Next: 9.5.3,  Prev: 9.5.1,  Up: 9.5

9.5.2 Entries and Accept Statements
-----------------------------------

1
Entry_declarations, with the corresponding entry_bodies or
accept_statements, are used to define potentially queued operations on
tasks and protected objects.

                               _Syntax_

2/3
     entry_declaration ::=
        [overriding_indicator]
        entry defining_identifier [(discrete_subtype_definition)] 
     parameter_profile
           [aspect_specification];

3
     accept_statement ::=
        accept <entry_>direct_name [(entry_index)] parameter_profile [do
          handled_sequence_of_statements
        end [<entry_>identifier]];

4
     entry_index ::= expression

5
     entry_body ::=
       entry defining_identifier  entry_body_formal_part  
     entry_barrier is
         declarative_part
       begin
         handled_sequence_of_statements
       end [<entry_>identifier];

6
     entry_body_formal_part ::= [(entry_index_specification)] 
     parameter_profile

7
     entry_barrier ::= when condition

8
     entry_index_specification ::= for defining_identifier in 
     discrete_subtype_definition

9
     If an <entry_>identifier appears at the end of an accept_statement,
     it shall repeat the <entry_>direct_name (*note 4.1: S0092.).  If an
     <entry_>identifier appears at the end of an entry_body (*note
     9.5.2: S0221.), it shall repeat the defining_identifier (*note 3.1:
     S0022.).

10
     An entry_declaration is allowed only in a protected or task
     declaration.

10.1/2
     An overriding_indicator is not allowed in an entry_declaration that
     includes a discrete_subtype_definition.

                        _Name Resolution Rules_

11
In an accept_statement, the expected profile for the <entry_>direct_name
is that of the entry_declaration (*note 9.5.2: S0218.); the expected
type for an entry_index is that of the subtype defined by the
discrete_subtype_definition (*note 3.6: S0055.) of the corresponding
entry_declaration (*note 9.5.2: S0218.).

12
Within the handled_sequence_of_statements of an accept_statement, if a
selected_component (*note 4.1.3: S0098.) has a prefix that denotes the
corresponding entry_declaration (*note 9.5.2: S0218.), then the entity
denoted by the prefix is the accept_statement (*note 9.5.2: S0219.), and
the selected_component (*note 4.1.3: S0098.) is interpreted as an
expanded name (see *note 4.1.3::); the selector_name of the
selected_component (*note 4.1.3: S0098.) has to be the identifier for
some formal parameter of the accept_statement (*note 9.5.2: S0219.).

                           _Legality Rules_

13
An entry_declaration in a task declaration shall not contain a
specification for an access parameter (see *note 3.10::).

13.1/2
If an entry_declaration has an overriding_indicator, then at the point
of the declaration:

13.2/2
   * if the overriding_indicator is overriding, then the entry shall
     implement an inherited subprogram;

13.3/2
   * if the overriding_indicator is not overriding, then the entry shall
     not implement any inherited subprogram.

13.4/2
In addition to the places where Legality Rules normally apply (see *note
12.3::), these rules also apply in the private part of an instance of a
generic unit.

14
For an accept_statement, the innermost enclosing body shall be a
task_body, and the <entry_>direct_name (*note 4.1: S0092.) shall denote
an entry_declaration (*note 9.5.2: S0218.) in the corresponding task
declaration; the profile of the accept_statement (*note 9.5.2: S0219.)
shall conform fully to that of the corresponding entry_declaration
(*note 9.5.2: S0218.).  An accept_statement (*note 9.5.2: S0219.) shall
have a parenthesized entry_index (*note 9.5.2: S0220.) if and only if
the corresponding entry_declaration (*note 9.5.2: S0218.) has a
discrete_subtype_definition (*note 3.6: S0055.).

15
An accept_statement shall not be within another accept_statement that
corresponds to the same entry_declaration (*note 9.5.2: S0218.), nor
within an asynchronous_select (*note 9.7.4: S0241.) inner to the
enclosing task_body.

16
An entry_declaration of a protected unit requires a completion, which
shall be an entry_body, and every entry_body (*note 9.5.2: S0221.) shall
be the completion of an entry_declaration (*note 9.5.2: S0218.) of a
protected unit.  The profile of the entry_body (*note 9.5.2: S0221.)
shall conform fully to that of the corresponding declaration.  

17
An entry_body_formal_part shall have an entry_index_specification (*note
9.5.2: S0224.) if and only if the corresponding entry_declaration (*note
9.5.2: S0218.) has a discrete_subtype_definition (*note 3.6: S0055.).
In this case, the discrete_subtype_definition (*note 3.6: S0055.)s of
the entry_declaration (*note 9.5.2: S0218.) and the
entry_index_specification (*note 9.5.2: S0224.) shall fully conform to
one another (see *note 6.3.1::).  

18
A name that denotes a formal parameter of an entry_body is not allowed
within the entry_barrier of the entry_body.

                          _Static Semantics_

19
The parameter modes defined for parameters in the parameter_profile of
an entry_declaration are the same as for a subprogram_declaration and
have the same meaning (see *note 6.2::).

20
An entry_declaration with a discrete_subtype_definition (see *note
3.6::) declares a <family> of distinct entries having the same profile,
with one such entry for each value of the <entry index subtype> defined
by the discrete_subtype_definition (*note 3.6: S0055.).  A name for an
entry of a family takes the form of an indexed_component, where the
prefix denotes the entry_declaration for the family, and the index value
identifies the entry within the family.  The term <single entry> is used
to refer to any entry other than an entry of an entry family.

21
In the entry_body for an entry family, the entry_index_specification
declares a named constant whose subtype is the entry index subtype
defined by the corresponding entry_declaration; the value of the <named
entry index> identifies which entry of the family was called.

                          _Dynamic Semantics_

22/1
The elaboration of an entry_declaration for an entry family consists of
the elaboration of the discrete_subtype_definition (*note 3.6: S0055.),
as described in *note 3.8::.  The elaboration of an entry_declaration
(*note 9.5.2: S0218.) for a single entry has no effect.

23
The actions to be performed when an entry is called are specified by the
corresponding accept_statement (*note 9.5.2: S0219.)s (if any) for an
entry of a task unit, and by the corresponding entry_body (*note 9.5.2:
S0221.) for an entry of a protected unit.

24
For the execution of an accept_statement, the entry_index, if any, is
first evaluated and converted to the entry index subtype; this index
value identifies which entry of the family is to be accepted.  Further
execution of the accept_statement is then blocked until a caller of the
corresponding entry is selected (see *note 9.5.3::), whereupon the
handled_sequence_of_statements, if any, of the accept_statement is
executed, with the formal parameters associated with the corresponding
actual parameters of the selected entry call.  Upon completion of the
handled_sequence_of_statements, the accept_statement completes and is
left.  When an exception is propagated from the
handled_sequence_of_statements of an accept_statement, the same
exception is also raised by the execution of the corresponding
entry_call_statement.

25
The above interaction between a calling task and an accepting task is
called a <rendezvous>.  After a rendezvous, the two tasks continue their
execution independently.

26
An entry_body is executed when the condition of the entry_barrier
evaluates to True and a caller of the corresponding single entry, or
entry of the corresponding entry family, has been selected (see *note
9.5.3::).  For the execution of the entry_body (*note 9.5.2: S0221.),
the declarative_part (*note 3.11: S0086.) of the entry_body (*note
9.5.2: S0221.) is elaborated, and the handled_sequence_of_statements
(*note 11.2: S0265.) of the body is executed, as for the execution of a
subprogram_body.  The value of the named entry index, if any, is
determined by the value of the entry index specified in the <entry_>name
of the selected entry call (or intermediate requeue_statement (*note
9.5.4: S0226.) -- see *note 9.5.4::).

     NOTES

27
     24  A task entry has corresponding accept_statements (zero or
     more), whereas a protected entry has a corresponding entry_body
     (exactly one).

28
     25  A consequence of the rule regarding the allowed placements of
     accept_statements is that a task can execute accept_statements only
     for its own entries.

29/2
     26  A return statement (see *note 6.5::) or a requeue_statement
     (see *note 9.5.4::) may be used to complete the execution of an
     accept_statement or an entry_body.

30
     27  The condition in the entry_barrier may reference anything
     visible except the formal parameters of the entry.  This includes
     the entry index (if any), the components (including discriminants)
     of the protected object, the Count attribute of an entry of that
     protected object, and data global to the protected unit.

31
     The restriction against referencing the formal parameters within an
     entry_barrier ensures that all calls of the same entry see the same
     barrier value.  If it is necessary to look at the parameters of an
     entry call before deciding whether to handle it, the entry_barrier
     can be "when True" and the caller can be requeued (on some private
     entry) when its parameters indicate that it cannot be handled
     immediately.

                              _Examples_

32
<Examples of entry declarations:>

33
     entry Read(V : out Item);
     entry Seize;
     entry Request(Level)(D : Item);  --<  a family of entries>

34
<Examples of accept statements:>

35
     accept Shut_Down;

36
     accept Read(V : out Item) do
        V := Local_Item;
     end Read;

37
     accept Request(Low)(D : Item) do
        ...
     end Request;


File: arm2012.info,  Node: 9.5.3,  Next: 9.5.4,  Prev: 9.5.2,  Up: 9.5

9.5.3 Entry Calls
-----------------

1
An entry_call_statement (an <entry call>) can appear in various
contexts.  A <simple> entry call is a stand-alone statement that
represents an unconditional call on an entry of a target task or a
protected object.  Entry calls can also appear as part of
select_statements (see *note 9.7::).

                               _Syntax_

2
     entry_call_statement ::= <entry_>name [actual_parameter_part];

                        _Name Resolution Rules_

3
The <entry_>name given in an entry_call_statement shall resolve to
denote an entry.  The rules for parameter associations are the same as
for subprogram calls (see *note 6.4:: and *note 6.4.1::).

                          _Static Semantics_

4
The <entry_>name of an entry_call_statement specifies (explicitly or
implicitly) the target object of the call, the entry or entry family,
and the entry index, if any (see *note 9.5::).

                          _Dynamic Semantics_

5
Under certain circumstances (detailed below), an entry of a task or
protected object is checked to see whether it is <open> or <closed>:

6/3
   * An entry of a task is open if the task is blocked on an
     accept_statement that corresponds to the entry (see *note 9.5.2::),
     or on a selective_accept (see *note 9.7.1::) with an open
     accept_alternative that corresponds to the entry; otherwise, it is
     closed.

7/3
   * An entry of a protected object is open if the condition of the
     entry_barrier of the corresponding entry_body evaluates to True;
     otherwise, it is closed.  If the evaluation of the condition
     propagates an exception, the exception Program_Error is propagated
     to all current callers of all entries of the protected object.

8
For the execution of an entry_call_statement, evaluation of the name and
of the parameter associations is as for a subprogram call (see *note
6.4::).  The entry call is then <issued>: For a call on an entry of a
protected object, a new protected action is started on the object (see
*note 9.5.1::).  The named entry is checked to see if it is open; if
open, the entry call is said to be <selected immediately>, and the
execution of the call proceeds as follows:

9
   * For a call on an open entry of a task, the accepting task becomes
     ready and continues the execution of the corresponding
     accept_statement (see *note 9.5.2::).

10
   * For a call on an open entry of a protected object, the
     corresponding entry_body is executed (see *note 9.5.2::) as part of
     the protected action.

11
If the accept_statement or entry_body completes other than by a requeue
(see *note 9.5.4::), return is made to the caller (after servicing the
entry queues -- see below); any necessary assigning back of formal to
actual parameters occurs, as for a subprogram call (see *note 6.4.1::);
such assignments take place outside of any protected action.

12
If the named entry is closed, the entry call is added to an <entry
queue> (as part of the protected action, for a call on a protected
entry), and the call remains queued until it is selected or cancelled;
there is a separate (logical) entry queue for each entry of a given task
or protected object (including each entry of an entry family).

13
When a queued call is <selected>, it is removed from its entry queue.
Selecting a queued call from a particular entry queue is called
<servicing> the entry queue.  An entry with queued calls can be serviced
under the following circumstances:

14
   * When the associated task reaches a corresponding accept_statement,
     or a selective_accept with a corresponding open accept_alternative;

15/4
   * If after performing, as part of a protected action on the
     associated protected object, an exclusive protected operation on
     the object, the entry is checked and found to be open.

16
If there is at least one call on a queue corresponding to an open entry,
then one such call is selected according to the <entry queuing policy>
in effect (see below), and the corresponding accept_statement or
entry_body is executed as above for an entry call that is selected
immediately.

17
The entry queuing policy controls selection among queued calls both for
task and protected entry queues.  The default entry queuing policy is to
select calls on a given entry queue in order of arrival.  If calls from
two or more queues are simultaneously eligible for selection, the
default entry queuing policy does not specify which queue is serviced
first.  Other entry queuing policies can be specified by pragmas (see
*note D.4::).

18
For a protected object, the above servicing of entry queues continues
until there are no open entries with queued calls, at which point the
protected action completes.

19
For an entry call that is added to a queue, and that is not the
triggering_statement of an asynchronous_select (*note 9.7.4: S0241.)
(see *note 9.7.4::), the calling task is blocked until the call is
cancelled, or the call is selected and a corresponding accept_statement
or entry_body completes without requeuing.  In addition, the calling
task is blocked during a rendezvous.

20
An attempt can be made to cancel an entry call upon an abort (see *note
9.8::) and as part of certain forms of select_statement (see *note
9.7.2::, *note 9.7.3::, and *note 9.7.4::).  The cancellation does not
take place until a point (if any) when the call is on some entry queue,
and not protected from cancellation as part of a requeue (see *note
9.5.4::); at such a point, the call is removed from the entry queue and
the call completes due to the cancellation.  The cancellation of a call
on an entry of a protected object is a protected action, and as such
cannot take place while any other protected action is occurring on the
protected object.  Like any protected action, it includes servicing of
the entry queues (in case some entry barrier depends on a Count
attribute).

21
A call on an entry of a task that has already completed its execution
raises the exception Tasking_Error at the point of the call; similarly,
this exception is raised at the point of the call if the called task
completes its execution or becomes abnormal before accepting the call or
completing the rendezvous (see *note 9.8::).  This applies equally to a
simple entry call and to an entry call as part of a select_statement.

                     _Implementation Permissions_

22
An implementation may perform the sequence of steps of a protected
action using any thread of control; it need not be that of the task that
started the protected action.  If an entry_body completes without
requeuing, then the corresponding calling task may be made ready without
waiting for the entire protected action to complete.

23/4
When the entry of a protected object is checked to see whether it is
open, the implementation need not reevaluate the condition of the
corresponding entry_barrier if no variable or attribute referenced by
the condition (directly or indirectly) has been altered by the execution
(or cancellation) of a call to an exclusive protected operation of the
object since the condition was last evaluated.

24
An implementation may evaluate the conditions of all entry_barriers of a
given protected object any time any entry of the object is checked to
see if it is open.

25
When an attempt is made to cancel an entry call, the implementation need
not make the attempt using the thread of control of the task (or
interrupt) that initiated the cancellation; in particular, it may use
the thread of control of the caller itself to attempt the cancellation,
even if this might allow the entry call to be selected in the interim.

     NOTES

26
     28  If an exception is raised during the execution of an
     entry_body, it is propagated to the corresponding caller (see *note
     11.4::).

27
     29  For a call on a protected entry, the entry is checked to see if
     it is open prior to queuing the call, and again thereafter if its
     Count attribute (see *note 9.9::) is referenced in some entry
     barrier.

28
     30  In addition to simple entry calls, the language permits timed,
     conditional, and asynchronous entry calls (see *note 9.7.2::, *note
     9.7.3::, and see *note 9.7.4::).

29
     31  The condition of an entry_barrier is allowed to be evaluated by
     an implementation more often than strictly necessary, even if the
     evaluation might have side effects.  On the other hand, an
     implementation need not reevaluate the condition if nothing it
     references was updated by an intervening protected action on the
     protected object, even if the condition references some global
     variable that might have been updated by an action performed from
     outside of a protected action.

                              _Examples_

30
<Examples of entry calls:>

31
     Agent.Shut_Down;                      --<  see *note 9.1::>
     Parser.Next_Lexeme(E);                --<  see *note 9.1::>
     Pool(5).Read(Next_Char);              --<  see *note 9.1::>
     Controller.Request(Low)(Some_Item);   --<  see *note 9.1::>
     Flags(3).Seize;                       --<  see *note 9.4::>


File: arm2012.info,  Node: 9.5.4,  Prev: 9.5.3,  Up: 9.5

9.5.4 Requeue Statements
------------------------

1
A requeue_statement can be used to complete an accept_statement or
entry_body, while redirecting the corresponding entry call to a new (or
the same) entry queue.  Such a <requeue> can be performed with or
without allowing an intermediate cancellation of the call, due to an
abort or the expiration of a delay.  

                               _Syntax_

2/3
     requeue_statement ::= requeue <procedure_or_entry_>
     name [with abort];

                        _Name Resolution Rules_

3/3
The <procedure_or_entry_>name of a requeue_statement shall resolve to
denote a procedure or an entry (the <requeue ><target>).  The profile of
the entry, or the profile or prefixed profile of the procedure, shall
either have no parameters, or be type conformant (see *note 6.3.1::)
with the profile of the innermost enclosing entry_body (*note 9.5.2:
S0221.) or accept_statement (*note 9.5.2: S0219.).  

                           _Legality Rules_

4
A requeue_statement shall be within a callable construct that is either
an entry_body or an accept_statement, and this construct shall be the
innermost enclosing body or callable construct.

5/3
If the requeue target has parameters, then its (prefixed) profile shall
be subtype conformant with the profile of the innermost enclosing
callable construct.  

5.1/4
Given a requeue_statement where the innermost enclosing callable
construct is for an entry <E1>, for every specific or class-wide
postcondition expression <P1> that applies to <E1>, there shall exist a
postcondition expression <P2> that applies to the requeue target <E2>
such that

5.2/4
   * <P1> is fully conformant with the expression produced by replacing
     each reference in <P2> to a formal parameter of <E2> with a
     reference to the corresponding formal paramter of <E1>; and

5.3/4
   * if <P1> is enabled, then <P2> is also enabled.

5.4/4
The requeue target shall not have an applicable specific or class-wide
postcondition which includes an Old attribute_reference.

5.5/4
If the requeue target is declared immediately within the task_definition
of a named task type or the protected_definition of a named protected
type, and if the requeue statement occurs within the body of that type,
and if the requeue is an external requeue, then the requeue target shall
not have a specific or class-wide postcondition which includes a name
denoting either the current instance of that type or any entity declared
within the declaration of that type.

5.6/4
If the target is a procedure, the name shall denote a renaming of an
entry, or shall denote a view or a prefixed view of a primitive
subprogram of a synchronized interface, where the first parameter of the
unprefixed view of the primitive subprogram shall be a controlling
parameter, and the Synchronization aspect shall be specified with
synchronization_kind By_Entry for the primitive subprogram.

6/3
In a requeue_statement of an accept_statement of some task unit, either
the target object shall be a part of a formal parameter of the
accept_statement, or the accessibility level of the target object shall
not be equal to or statically deeper than any enclosing accept_statement
of the task unit.  In a requeue_statement (*note 9.5.4: S0226.) of an
entry_body (*note 9.5.2: S0221.) of some protected unit, either the
target object shall be a part of a formal parameter of the entry_body
(*note 9.5.2: S0221.), or the accessibility level of the target object
shall not be statically deeper than that of the entry_declaration for
the entry_body.

                          _Dynamic Semantics_

7/4
The execution of a requeue_statement proceeds by first evaluating the
<procedure_or_entry_>name, including the prefix identifying the target
task or protected object and the expression identifying the entry within
an entry family, if any.  Precondition checks are then performed as for
a call to the requeue target entry or subprogram.  The entry_body or
accept_statement enclosing the requeue_statement is then completed,
finalized, and left (see *note 7.6.1::).

8
For the execution of a requeue on an entry of a target task, after
leaving the enclosing callable construct, the named entry is checked to
see if it is open and the requeued call is either selected immediately
or queued, as for a normal entry call (see *note 9.5.3::).

9
For the execution of a requeue on an entry of a target protected object,
after leaving the enclosing callable construct:

10
   * if the requeue is an internal requeue (that is, the requeue is back
     on an entry of the same protected object -- see *note 9.5::), the
     call is added to the queue of the named entry and the ongoing
     protected action continues (see *note 9.5.1::);

11
   * if the requeue is an external requeue (that is, the target
     protected object is not implicitly the same as the current object
     -- see *note 9.5::), a protected action is started on the target
     object and proceeds as for a normal entry call (see *note 9.5.3::).

12/4
If the requeue target named in the requeue_statement has formal
parameters, then during the execution of the accept_statement or
entry_body corresponding to the new entry and during the checking of any
preconditions of the new entry, the formal parameters denote the same
objects as did the corresponding formal parameters of the callable
construct completed by the requeue.  In any case, no parameters are
specified in a requeue_statement; any parameter passing is implicit.

13
If the requeue_statement includes the reserved words with abort (it is a
<requeue-with-abort>), then:

14
   * if the original entry call has been aborted (see *note 9.8::), then
     the requeue acts as an abort completion point for the call, and the
     call is cancelled and no requeue is performed;

15
   * if the original entry call was timed (or conditional), then the
     original expiration time is the expiration time for the requeued
     call.

16
If the reserved words with abort do not appear, then the call remains
protected against cancellation while queued as the result of the
requeue_statement.

     NOTES

17
     32  A requeue is permitted from a single entry to an entry of an
     entry family, or vice-versa.  The entry index, if any, plays no
     part in the subtype conformance check between the profiles of the
     two entries; an entry index is part of the <entry_>name for an
     entry of a family.  

                              _Examples_

18
<Examples of requeue statements:>

19
     requeue Request(Medium) with abort;
                         --< requeue on a member of an entry family of the current task, see *note 9.1::>

20
     requeue Flags(I).Seize;
                         --< requeue on an entry of an array component, see *note 9.4::>


File: arm2012.info,  Node: 9.6,  Next: 9.7,  Prev: 9.5,  Up: 9

9.6 Delay Statements, Duration, and Time
========================================

1
A delay_statement is used to block further execution until a specified
<expiration time> is reached.  The expiration time can be specified
either as a particular point in time (in a delay_until_statement (*note
9.6: S0228.)), or in seconds from the current time (in a
delay_relative_statement (*note 9.6: S0229.)).  The language-defined
package Calendar provides definitions for a type Time and associated
operations, including a function Clock that returns the current time.  

                               _Syntax_

2
     delay_statement ::= delay_until_statement | 
     delay_relative_statement

3
     delay_until_statement ::= delay until <delay_>expression;

4
     delay_relative_statement ::= delay <delay_>expression;

                        _Name Resolution Rules_

5
The expected type for the <delay_>expression in a
delay_relative_statement is the predefined type Duration.  The
<delay_>expression in a delay_until_statement is expected to be of any
nonlimited type.

                           _Legality Rules_

6/3
There can be multiple time bases, each with a corresponding clock, and a
corresponding <time type>.  The type of the <delay_>expression in a
delay_until_statement shall be a time type -- either the type Time
defined in the language-defined package Calendar (see below), the type
Time in the package Real_Time (see *note D.8::), or some other
implementation-defined time type.

                          _Static Semantics_

7
There is a predefined fixed point type named Duration, declared in the
visible part of package Standard; a value of type Duration is used to
represent the length of an interval of time, expressed in seconds.  The
type Duration is not specific to a particular time base, but can be used
with any time base.

8/3
A value of the type Time in package Calendar, or of some other time
type, represents a time as reported by a corresponding clock.

9
The following language-defined library package exists:

10

     package Ada.Calendar is
       type Time is private;

11/2
       subtype Year_Number  is Integer range 1901 .. 2399;
       subtype Month_Number is Integer range 1 .. 12;
       subtype Day_Number   is Integer range 1 .. 31;
       subtype Day_Duration is Duration range 0.0 .. 86_400.0;

12
       function Clock return Time;

13
       function Year   (Date : Time) return Year_Number;
       function Month  (Date : Time) return Month_Number;
       function Day    (Date : Time) return Day_Number;
       function Seconds(Date : Time) return Day_Duration;

14
       procedure Split (Date  : in Time;
                        Year    : out Year_Number;
                        Month   : out Month_Number;
                        Day     : out Day_Number;
                        Seconds : out Day_Duration);

15
       function Time_Of(Year  : Year_Number;
                        Month   : Month_Number;
                        Day     : Day_Number;
                        Seconds : Day_Duration := 0.0)
        return Time;

16
       function "+" (Left : Time;   Right : Duration) return Time;
       function "+" (Left : Duration; Right : Time) return Time;
       function "-" (Left : Time;   Right : Duration) return Time;
       function "-" (Left : Time;   Right : Time) return Duration;

17
       function "<" (Left, Right : Time) return Boolean;
       function "<="(Left, Right : Time) return Boolean;
       function ">" (Left, Right : Time) return Boolean;
       function ">="(Left, Right : Time) return Boolean;

18
       Time_Error : exception;

19
     private
        ... -- <not specified by the language>
     end Ada.Calendar;

                          _Dynamic Semantics_

20
For the execution of a delay_statement, the <delay_>expression is first
evaluated.  For a delay_until_statement, the expiration time for the
delay is the value of the <delay_>expression, in the time base
associated with the type of the expression.  For a
delay_relative_statement, the expiration time is defined as the current
time, in the time base associated with relative delays, plus the value
of the <delay_>expression converted to the type Duration, and then
rounded up to the next clock tick.  The time base associated with
relative delays is as defined in *note D.9::, "*note D.9:: Delay
Accuracy" or is implementation defined.

21
The task executing a delay_statement is blocked until the expiration
time is reached, at which point it becomes ready again.  If the
expiration time has already passed, the task is not blocked.

22/3
If an attempt is made to <cancel> the delay_statement (as part of an
asynchronous_select (*note 9.7.4: S0241.) or abort -- see *note 9.7.4::
and *note 9.8::), the statement is cancelled if the expiration time has
not yet passed, thereby completing the delay_statement.

23
The time base associated with the type Time of package Calendar is
implementation defined.  The function Clock of package Calendar returns
a value representing the current time for this time base.  The
implementation-defined value of the named number System.Tick (see *note
13.7::) is an approximation of the length of the real-time interval
during which the value of Calendar.Clock remains constant.

24/2
The functions Year, Month, Day, and Seconds return the corresponding
values for a given value of the type Time, as appropriate to an
implementation-defined time zone; the procedure Split returns all four
corresponding values.  Conversely, the function Time_Of combines a year
number, a month number, a day number, and a duration, into a value of
type Time.  The operators "+" and "-" for addition and subtraction of
times and durations, and the relational operators for times, have the
conventional meaning.

25
If Time_Of is called with a seconds value of 86_400.0, the value
returned is equal to the value of Time_Of for the next day with a
seconds value of 0.0.  The value returned by the function Seconds or
through the Seconds parameter of the procedure Split is always less than
86_400.0.

26/1
The exception Time_Error is raised by the function Time_Of if the actual
parameters do not form a proper date.  This exception is also raised by
the operators "+" and "-" if the result is not representable in the type
Time or Duration, as appropriate.  This exception is also raised by the
functions Year, Month, Day, and Seconds and the procedure Split if the
year number of the given date is outside of the range of the subtype
Year_Number.

                     _Implementation Requirements_

27
The implementation of the type Duration shall allow representation of
time intervals (both positive and negative) up to at least 86400 seconds
(one day); Duration'Small shall not be greater than twenty milliseconds.
The implementation of the type Time shall allow representation of all
dates with year numbers in the range of Year_Number; it may allow
representation of other dates as well (both earlier and later).

                     _Implementation Permissions_

28/3
An implementation may define additional time types.

29
An implementation may raise Time_Error if the value of a
<delay_>expression in a delay_until_statement of a select_statement
represents a time more than 90 days past the current time.  The actual
limit, if any, is implementation-defined.

                        _Implementation Advice_

30
Whenever possible in an implementation, the value of Duration'Small
should be no greater than 100 microseconds.

31
The time base for delay_relative_statements should be monotonic; it need
not be the same time base as used for Calendar.Clock.

     NOTES

32
     33  A delay_relative_statement with a negative value of the
     <delay_>expression is equivalent to one with a zero value.

33
     34  A delay_statement may be executed by the environment task;
     consequently delay_statements may be executed as part of the
     elaboration of a library_item or the execution of the main
     subprogram.  Such statements delay the environment task (see *note
     10.2::).

34
     35  A delay_statement is an abort completion point and a
     potentially blocking operation, even if the task is not actually
     blocked.

35
     36  There is no necessary relationship between System.Tick (the
     resolution of the clock of package Calendar) and Duration'Small
     (the <small> of type Duration).

36
     37  Additional requirements associated with delay_statements are
     given in *note D.9::, "*note D.9:: Delay Accuracy".

                              _Examples_

37
<Example of a relative delay statement:>

38
     delay 3.0;  --< delay 3.0 seconds>

39
<Example of a periodic task:>

40
     declare
        use Ada.Calendar;
        Next_Time : Time := Clock + Period;
                           --< Period is a global constant of type Duration>
     begin
        loop               --< repeated every Period seconds>
           delay until Next_Time;
           ... --< perform some actions>
           Next_Time := Next_Time + Period;
        end loop;
     end;

* Menu:

* 9.6.1 ::    Formatting, Time Zones, and other operations for Time


File: arm2012.info,  Node: 9.6.1,  Up: 9.6

9.6.1 Formatting, Time Zones, and other operations for Time
-----------------------------------------------------------

                          _Static Semantics_

1/2
The following language-defined library packages exist:

2/2
     package Ada.Calendar.Time_Zones is

3/2
        -- <Time zone manipulation:>

4/2
        type Time_Offset is range -28*60 .. 28*60;

5/2
        Unknown_Zone_Error : exception;

6/2
        function UTC_Time_Offset (Date : Time := Clock) return Time_Offset;

7/2
     end Ada.Calendar.Time_Zones;

8/2

     package Ada.Calendar.Arithmetic is

9/2
        -- <Arithmetic on days:>

10/2
        type Day_Count is range
          -366*(1+Year_Number'Last - Year_Number'First)
          ..
          366*(1+Year_Number'Last - Year_Number'First);

11/2
        subtype Leap_Seconds_Count is Integer range -2047 .. 2047;

12/2
        procedure Difference (Left, Right : in Time;
                              Days : out Day_Count;
                              Seconds : out Duration;
                              Leap_Seconds : out Leap_Seconds_Count);

13/2
        function "+" (Left : Time; Right : Day_Count) return Time;
        function "+" (Left : Day_Count; Right : Time) return Time;
        function "-" (Left : Time; Right : Day_Count) return Time;
        function "-" (Left, Right : Time) return Day_Count;

14/2
     end Ada.Calendar.Arithmetic;

15/2

     with Ada.Calendar.Time_Zones;
     package Ada.Calendar.Formatting is

16/2
        -- <Day of the week:>

17/2
        type Day_Name is (Monday, Tuesday, Wednesday, Thursday,
            Friday, Saturday, Sunday);

18/2
        function Day_of_Week (Date : Time) return Day_Name;

19/2
        -- <Hours:Minutes:Seconds access:>

20/2
        subtype Hour_Number         is Natural range 0 .. 23;
        subtype Minute_Number       is Natural range 0 .. 59;
        subtype Second_Number       is Natural range 0 .. 59;
        subtype Second_Duration     is Day_Duration range 0.0 .. 1.0;

21/2
        function Year       (Date : Time;
                             Time_Zone  : Time_Zones.Time_Offset := 0)
                                return Year_Number;

22/2
        function Month      (Date : Time;
                             Time_Zone  : Time_Zones.Time_Offset := 0)
                                return Month_Number;

23/2
        function Day        (Date : Time;
                             Time_Zone  : Time_Zones.Time_Offset := 0)
                                return Day_Number;

24/2
        function Hour       (Date : Time;
                             Time_Zone  : Time_Zones.Time_Offset := 0)
                                return Hour_Number;

25/2
        function Minute     (Date : Time;
                             Time_Zone  : Time_Zones.Time_Offset := 0)
                                return Minute_Number;

26/2
        function Second     (Date : Time)
                                return Second_Number;

27/2
        function Sub_Second (Date : Time)
                                return Second_Duration;

28/2
        function Seconds_Of (Hour   :  Hour_Number;
                             Minute : Minute_Number;
                             Second : Second_Number := 0;
                             Sub_Second : Second_Duration := 0.0)
            return Day_Duration;

29/2
        procedure Split (Seconds    : in Day_Duration;
                         Hour       : out Hour_Number;
                         Minute     : out Minute_Number;
                         Second     : out Second_Number;
                         Sub_Second : out Second_Duration);

30/2
        function Time_Of (Year       : Year_Number;
                          Month      : Month_Number;
                          Day        : Day_Number;
                          Hour       : Hour_Number;
                          Minute     : Minute_Number;
                          Second     : Second_Number;
                          Sub_Second : Second_Duration := 0.0;
                          Leap_Second: Boolean := False;
                          Time_Zone  : Time_Zones.Time_Offset := 0)
                                  return Time;

31/2
        function Time_Of (Year       : Year_Number;
                          Month      : Month_Number;
                          Day        : Day_Number;
                          Seconds    : Day_Duration := 0.0;
                          Leap_Second: Boolean := False;
                          Time_Zone  : Time_Zones.Time_Offset := 0)
                                  return Time;

32/2
        procedure Split (Date       : in Time;
                         Year       : out Year_Number;
                         Month      : out Month_Number;
                         Day        : out Day_Number;
                         Hour       : out Hour_Number;
                         Minute     : out Minute_Number;
                         Second     : out Second_Number;
                         Sub_Second : out Second_Duration;
                         Time_Zone  : in Time_Zones.Time_Offset := 0);

33/2
        procedure Split (Date       : in Time;
                         Year       : out Year_Number;
                         Month      : out Month_Number;
                         Day        : out Day_Number;
                         Hour       : out Hour_Number;
                         Minute     : out Minute_Number;
                         Second     : out Second_Number;
                         Sub_Second : out Second_Duration;
                         Leap_Second: out Boolean;
                         Time_Zone  : in Time_Zones.Time_Offset := 0);

34/2
        procedure Split (Date       : in Time;
                         Year       : out Year_Number;
                         Month      : out Month_Number;
                         Day        : out Day_Number;
                         Seconds    : out Day_Duration;
                         Leap_Second: out Boolean;
                         Time_Zone  : in Time_Zones.Time_Offset := 0);

35/2
        -- <Simple image and value:>
        function Image (Date : Time;
                        Include_Time_Fraction : Boolean := False;
                        Time_Zone  : Time_Zones.Time_Offset := 0) return String;

36/2
        function Value (Date : String;
                        Time_Zone  : Time_Zones.Time_Offset := 0) return Time;

37/2
        function Image (Elapsed_Time : Duration;
                        Include_Time_Fraction : Boolean := False) return String;

38/2
        function Value (Elapsed_Time : String) return Duration;

39/2
     end Ada.Calendar.Formatting;

40/2
Type Time_Offset represents the number of minutes difference between the
implementation-defined time zone used by Calendar and another time zone.

41/2
     function UTC_Time_Offset (Date : Time := Clock) return Time_Offset;

42/3
          Returns, as a number of minutes, the result of subtracting the
          implementation-defined time zone of Calendar from UTC time, at
          the time Date.  If the time zone of the Calendar
          implementation is unknown, then Unknown_Zone_Error is raised.

43/2
     procedure Difference (Left, Right : in Time;
                           Days : out Day_Count;
                           Seconds : out Duration;
                           Leap_Seconds : out Leap_Seconds_Count);

44/2
          Returns the difference between Left and Right.  Days is the
          number of days of difference, Seconds is the remainder seconds
          of difference excluding leap seconds, and Leap_Seconds is the
          number of leap seconds.  If Left < Right, then Seconds <= 0.0,
          Days <= 0, and Leap_Seconds <= 0.  Otherwise, all values are
          nonnegative.  The absolute value of Seconds is always less
          than 86_400.0.  For the returned values, if Days = 0, then
          Seconds + Duration(Leap_Seconds) = Calendar."-" (Left, Right).

45/2
     function "+" (Left : Time; Right : Day_Count) return Time;
     function "+" (Left : Day_Count; Right : Time) return Time;

46/2
          Adds a number of days to a time value.  Time_Error is raised
          if the result is not representable as a value of type Time.

47/2
     function "-" (Left : Time; Right : Day_Count) return Time;

48/2
          Subtracts a number of days from a time value.  Time_Error is
          raised if the result is not representable as a value of type
          Time.

49/2
     function "-" (Left, Right : Time) return Day_Count;

50/2
          Subtracts two time values, and returns the number of days
          between them.  This is the same value that Difference would
          return in Days.

51/2
     function Day_of_Week (Date : Time) return Day_Name;

52/2
          Returns the day of the week for Time.  This is based on the
          Year, Month, and Day values of Time.

53/2
     function Year       (Date : Time;
                          Time_Zone  : Time_Zones.Time_Offset := 0)
                             return Year_Number;

54/2
          Returns the year for Date, as appropriate for the specified
          time zone offset.

55/2
     function Month      (Date : Time;
                          Time_Zone  : Time_Zones.Time_Offset := 0)
                             return Month_Number;

56/2
          Returns the month for Date, as appropriate for the specified
          time zone offset.

57/2
     function Day        (Date : Time;
                          Time_Zone  : Time_Zones.Time_Offset := 0)
                             return Day_Number;

58/2
          Returns the day number for Date, as appropriate for the
          specified time zone offset.

59/2
     function Hour       (Date : Time;
                          Time_Zone  : Time_Zones.Time_Offset := 0)
                             return Hour_Number;

60/2
          Returns the hour for Date, as appropriate for the specified
          time zone offset.

61/2
     function Minute     (Date : Time;
                          Time_Zone  : Time_Zones.Time_Offset := 0)
                             return Minute_Number;

62/2
          Returns the minute within the hour for Date, as appropriate
          for the specified time zone offset.

63/2
     function Second     (Date : Time)
                             return Second_Number;

64/2
          Returns the second within the hour and minute for Date.

65/2
     function Sub_Second (Date : Time)
                             return Second_Duration;

66/2
          Returns the fraction of second for Date (this has the same
          accuracy as Day_Duration).  The value returned is always less
          than 1.0.

67/2
     function Seconds_Of (Hour   : Hour_Number;
                          Minute : Minute_Number;
                          Second : Second_Number := 0;
                          Sub_Second : Second_Duration := 0.0)
         return Day_Duration;

68/2
          Returns a Day_Duration value for the combination of the given
          Hour, Minute, Second, and Sub_Second.  This value can be used
          in Calendar.Time_Of as well as the argument to Calendar."+"
          and Calendar."-".  If Seconds_Of is called with a Sub_Second
          value of 1.0, the value returned is equal to the value of
          Seconds_Of for the next second with a Sub_Second value of 0.0.

69/2
     procedure Split (Seconds    : in Day_Duration;
                      Hour       : out Hour_Number;
                      Minute     : out Minute_Number;
                      Second     : out Second_Number;
                      Sub_Second : out Second_Duration);

70/3
          Splits Seconds into Hour, Minute, Second and Sub_Second in
          such a way that the resulting values all belong to their
          respective subtypes.  The value returned in the Sub_Second
          parameter is always less than 1.0.  If Seconds = 86400.0,
          Split propagates Time_Error.

71/2
     function Time_Of (Year       : Year_Number;
                       Month      : Month_Number;
                       Day        : Day_Number;
                       Hour       : Hour_Number;
                       Minute     : Minute_Number;
                       Second     : Second_Number;
                       Sub_Second : Second_Duration := 0.0;
                       Leap_Second: Boolean := False;
                       Time_Zone  : Time_Zones.Time_Offset := 0)
                               return Time;

72/2
          If Leap_Second is False, returns a Time built from the date
          and time values, relative to the specified time zone offset.
          If Leap_Second is True, returns the Time that represents the
          time within the leap second that is one second later than the
          time specified by the other parameters.  Time_Error is raised
          if the parameters do not form a proper date or time.  If
          Time_Of is called with a Sub_Second value of 1.0, the value
          returned is equal to the value of Time_Of for the next second
          with a Sub_Second value of 0.0.

73/2
     function Time_Of (Year       : Year_Number;
                       Month      : Month_Number;
                       Day        : Day_Number;
                       Seconds    : Day_Duration := 0.0;
                       Leap_Second: Boolean := False;
                       Time_Zone  : Time_Zones.Time_Offset := 0)
                               return Time;

74/2
          If Leap_Second is False, returns a Time built from the date
          and time values, relative to the specified time zone offset.
          If Leap_Second is True, returns the Time that represents the
          time within the leap second that is one second later than the
          time specified by the other parameters.  Time_Error is raised
          if the parameters do not form a proper date or time.  If
          Time_Of is called with a Seconds value of 86_400.0, the value
          returned is equal to the value of Time_Of for the next day
          with a Seconds value of 0.0.

75/2
     procedure Split (Date       : in Time;
                      Year       : out Year_Number;
                      Month      : out Month_Number;
                      Day        : out Day_Number;
                      Hour       : out Hour_Number;
                      Minute     : out Minute_Number;
                      Second     : out Second_Number;
                      Sub_Second : out Second_Duration;
                      Leap_Second: out Boolean;
                      Time_Zone  : in Time_Zones.Time_Offset := 0);

76/2
          If Date does not represent a time within a leap second, splits
          Date into its constituent parts (Year, Month, Day, Hour,
          Minute, Second, Sub_Second), relative to the specified time
          zone offset, and sets Leap_Second to False.  If Date
          represents a time within a leap second, set the constituent
          parts to values corresponding to a time one second earlier
          than that given by Date, relative to the specified time zone
          offset, and sets Leap_Seconds to True.  The value returned in
          the Sub_Second parameter is always less than 1.0.

77/2
     procedure Split (Date       : in Time;
                      Year       : out Year_Number;
                      Month      : out Month_Number;
                      Day        : out Day_Number;
                      Hour       : out Hour_Number;
                      Minute     : out Minute_Number;
                      Second     : out Second_Number;
                      Sub_Second : out Second_Duration;
                      Time_Zone  : in Time_Zones.Time_Offset := 0);

78/2
          Splits Date into its constituent parts (Year, Month, Day,
          Hour, Minute, Second, Sub_Second), relative to the specified
          time zone offset.  The value returned in the Sub_Second
          parameter is always less than 1.0.

79/2
     procedure Split (Date       : in Time;
                      Year       : out Year_Number;
                      Month      : out Month_Number;
                      Day        : out Day_Number;
                      Seconds    : out Day_Duration;
                      Leap_Second: out Boolean;
                      Time_Zone  : in Time_Zones.Time_Offset := 0);

80/2
          If Date does not represent a time within a leap second, splits
          Date into its constituent parts (Year, Month, Day, Seconds),
          relative to the specified time zone offset, and sets
          Leap_Second to False.  If Date represents a time within a leap
          second, set the constituent parts to values corresponding to a
          time one second earlier than that given by Date, relative to
          the specified time zone offset, and sets Leap_Seconds to True.
          The value returned in the Seconds parameter is always less
          than 86_400.0.

81/2
     function Image (Date : Time;
                     Include_Time_Fraction : Boolean := False;
                     Time_Zone  : Time_Zones.Time_Offset := 0) return String;

82/2
          Returns a string form of the Date relative to the given
          Time_Zone.  The format is "Year-Month-Day Hour:Minute:Second",
          where the Year is a 4-digit value, and all others are 2-digit
          values, of the functions defined in Calendar and
          Calendar.Formatting, including a leading zero, if needed.  The
          separators between the values are a minus, another minus, a
          colon, and a single space between the Day and Hour.  If
          Include_Time_Fraction is True, the integer part of
          Sub_Seconds*100 is suffixed to the string as a point followed
          by a 2-digit value.

83/2
     function Value (Date : String;
                     Time_Zone  : Time_Zones.Time_Offset := 0) return Time;

84/2
          Returns a Time value for the image given as Date, relative to
          the given time zone.  Constraint_Error is raised if the string
          is not formatted as described for Image, or the function
          cannot interpret the given string as a Time value.

85/2
     function Image (Elapsed_Time : Duration;
                     Include_Time_Fraction : Boolean := False) return String;

86/2
          Returns a string form of the Elapsed_Time.  The format is
          "Hour:Minute:Second", where all values are 2-digit values,
          including a leading zero, if needed.  The separators between
          the values are colons.  If Include_Time_Fraction is True, the
          integer part of Sub_Seconds*100 is suffixed to the string as a
          point followed by a 2-digit value.  If Elapsed_Time < 0.0, the
          result is Image (abs Elapsed_Time, Include_Time_Fraction)
          prefixed with a minus sign.  If abs Elapsed_Time represents
          100 hours or more, the result is implementation-defined.

87/2
     function Value (Elapsed_Time : String) return Duration;

88/2
          Returns a Duration value for the image given as Elapsed_Time.
          Constraint_Error is raised if the string is not formatted as
          described for Image, or the function cannot interpret the
          given string as a Duration value.

                        _Implementation Advice_

89/2
An implementation should support leap seconds if the target system
supports them.  If leap seconds are not supported, Difference should
return zero for Leap_Seconds, Split should return False for Leap_Second,
and Time_Of should raise Time_Error if Leap_Second is True.

     NOTES

90/2
     38  The implementation-defined time zone of package Calendar may,
     but need not, be the local time zone.  UTC_Time_Offset always
     returns the difference relative to the implementation-defined time
     zone of package Calendar.  If UTC_Time_Offset does not raise
     Unknown_Zone_Error, UTC time can be safely calculated (within the
     accuracy of the underlying time-base).

91/2
     39  Calling Split on the results of subtracting
     Duration(UTC_Time_Offset*60) from Clock provides the components
     (hours, minutes, and so on) of the UTC time.  In the United States,
     for example, UTC_Time_Offset will generally be negative.


File: arm2012.info,  Node: 9.7,  Next: 9.8,  Prev: 9.6,  Up: 9

9.7 Select Statements
=====================

1
There are four forms of the select_statement.  One form provides a
selective wait for one or more select_alternatives.  Two provide timed
and conditional entry calls.  The fourth provides asynchronous transfer
of control.

                               _Syntax_

2
     select_statement ::=
        selective_accept
       | timed_entry_call
       | conditional_entry_call
       | asynchronous_select

                              _Examples_

3
<Example of a select statement:>

4
     select
        accept Driver_Awake_Signal;
     or
        delay 30.0*Seconds;
        Stop_The_Train;
     end select;

* Menu:

* 9.7.1 ::    Selective Accept
* 9.7.2 ::    Timed Entry Calls
* 9.7.3 ::    Conditional Entry Calls
* 9.7.4 ::    Asynchronous Transfer of Control


File: arm2012.info,  Node: 9.7.1,  Next: 9.7.2,  Up: 9.7

9.7.1 Selective Accept
----------------------

1
This form of the select_statement allows a combination of waiting for,
and selecting from, one or more alternatives.  The selection may depend
on conditions associated with each alternative of the selective_accept.
                               _Syntax_

2
     selective_accept ::=
       select
        [guard]
          select_alternative
     { or
        [guard]
          select_alternative }
     [ else
        sequence_of_statements ]
       end select;

3
     guard ::= when condition =>

4
     select_alternative ::=
        accept_alternative
       | delay_alternative
       | terminate_alternative

5
     accept_alternative ::=
       accept_statement [sequence_of_statements]

6
     delay_alternative ::=
       delay_statement [sequence_of_statements]

7
     terminate_alternative ::= terminate;

8
     A selective_accept shall contain at least one accept_alternative.
     In addition, it can contain:

9
        * a terminate_alternative (only one); or

10
        * one or more delay_alternatives; or

11
        * an <else part> (the reserved word else followed by a
          sequence_of_statements).

12
     These three possibilities are mutually exclusive.

                           _Legality Rules_

13
If a selective_accept contains more than one delay_alternative, then all
shall be delay_relative_statement (*note 9.6: S0229.)s, or all shall be
delay_until_statement (*note 9.6: S0228.)s for the same time type.

                          _Dynamic Semantics_

14
A select_alternative is said to be <open> if it is not immediately
preceded by a guard, or if the condition of its guard evaluates to True.
It is said to be <closed> otherwise.

15
For the execution of a selective_accept, any guard conditions are
evaluated; open alternatives are thus determined.  For an open
delay_alternative, the <delay_>expression is also evaluated.  Similarly,
for an open accept_alternative for an entry of a family, the entry_index
is also evaluated.  These evaluations are performed in an arbitrary
order, except that a <delay_>expression or entry_index is not evaluated
until after evaluating the corresponding condition, if any.  Selection
and execution of one open alternative, or of the else part, then
completes the execution of the selective_accept; the rules for this
selection are described below.

16
Open accept_alternatives are first considered.  Selection of one such
alternative takes place immediately if the corresponding entry already
has queued calls.  If several alternatives can thus be selected, one of
them is selected according to the entry queuing policy in effect (see
*note 9.5.3:: and *note D.4::).  When such an alternative is selected,
the selected call is removed from its entry queue and the
handled_sequence_of_statements (*note 11.2: S0265.) (if any) of the
corresponding accept_statement is executed; after the rendezvous
completes any subsequent sequence_of_statements (*note 5.1: S0145.) of
the alternative is executed.  If no selection is immediately possible
(in the above sense) and there is no else part, the task blocks until an
open alternative can be selected.

17
Selection of the other forms of alternative or of an else part is
performed as follows:

18
   * An open delay_alternative is selected when its expiration time is
     reached if no accept_alternative (*note 9.7.1: S0234.) or other
     delay_alternative (*note 9.7.1: S0235.) can be selected prior to
     the expiration time.  If several delay_alternative (*note 9.7.1:
     S0235.)s have this same expiration time, one of them is selected
     according to the queuing policy in effect (see *note D.4::); the
     default queuing policy chooses arbitrarily among the
     delay_alternative (*note 9.7.1: S0235.)s whose expiration time has
     passed.

19
   * The else part is selected and its sequence_of_statements (*note
     5.1: S0145.) is executed if no accept_alternative can immediately
     be selected; in particular, if all alternatives are closed.

20/3
   * An open terminate_alternative is selected if the conditions stated
     at the end of subclause *note 9.3:: are satisfied.

21
The exception Program_Error is raised if all alternatives are closed and
there is no else part.

     NOTES

22
     40  A selective_accept is allowed to have several open
     delay_alternatives.  A selective_accept is allowed to have several
     open accept_alternatives for the same entry.

                              _Examples_

23
<Example of a task body with a selective accept:>

24
     task body Server is
        Current_Work_Item : Work_Item;
     begin
        loop
           select
              accept Next_Work_Item(WI : in Work_Item) do
                 Current_Work_Item := WI;
              end;
              Process_Work_Item(Current_Work_Item);
           or
              accept Shut_Down;
              exit;       --< Premature shut down requested>
           or
              terminate;  --< Normal shutdown at end of scope>
           end select;
        end loop;
     end Server;


File: arm2012.info,  Node: 9.7.2,  Next: 9.7.3,  Prev: 9.7.1,  Up: 9.7

9.7.2 Timed Entry Calls
-----------------------

1/2
A timed_entry_call issues an entry call that is cancelled if the call
(or a requeue-with-abort of the call) is not selected before the
expiration time is reached.  A procedure call may appear rather than an
entry call for cases where the procedure might be implemented by an
entry.  

                               _Syntax_

2
     timed_entry_call ::=
       select
        entry_call_alternative
       or
        delay_alternative
       end select;

3/2
     entry_call_alternative ::=
       procedure_or_entry_call [sequence_of_statements]

3.1/2
     procedure_or_entry_call ::=
       procedure_call_statement | entry_call_statement

                           _Legality Rules_

3.2/2
If a procedure_call_statement is used for a procedure_or_entry_call, the
<procedure_>name or <procedure_>prefix of the procedure_call_statement
shall statically denote an entry renamed as a procedure or (a view of) a
primitive subprogram of a limited interface whose first parameter is a
controlling parameter (see *note 3.9.2::).

                          _Dynamic Semantics_

4/2
For the execution of a timed_entry_call, the <entry_>name,
<procedure_>name, or <procedure_>prefix, and any actual parameters are
evaluated, as for a simple entry call (see *note 9.5.3::) or procedure
call (see *note 6.4::).  The expiration time (see *note 9.6::) for the
call is determined by evaluating the <delay_>expression of the
delay_alternative.  If the call is an entry call or a call on a
procedure implemented by an entry, the entry call is then issued.
Otherwise, the call proceeds as described in *note 6.4:: for a procedure
call, followed by the sequence_of_statements (*note 5.1: S0145.) of the
entry_call_alternative (*note 9.7.2: S0238.); the sequence_of_statements
(*note 5.1: S0145.) of the delay_alternative (*note 9.7.1: S0235.) is
ignored.

5
If the call is queued (including due to a requeue-with-abort), and not
selected before the expiration time is reached, an attempt to cancel the
call is made.  If the call completes due to the cancellation, the
optional sequence_of_statements (*note 5.1: S0145.) of the
delay_alternative (*note 9.7.1: S0235.) is executed; if the entry call
completes normally, the optional sequence_of_statements (*note 5.1:
S0145.) of the entry_call_alternative (*note 9.7.2: S0238.) is executed.

                              _Examples_

6
<Example of a timed entry call:>

7
     select
        Controller.Request(Medium)(Some_Item);
     or
        delay 45.0;
        --<  controller too busy, try something else>
     end select;


File: arm2012.info,  Node: 9.7.3,  Next: 9.7.4,  Prev: 9.7.2,  Up: 9.7

9.7.3 Conditional Entry Calls
-----------------------------

1/2
A conditional_entry_call issues an entry call that is then cancelled if
it is not selected immediately (or if a requeue-with-abort of the call
is not selected immediately).  A procedure call may appear rather than
an entry call for cases where the procedure might be implemented by an
entry.

                               _Syntax_

2
     conditional_entry_call ::=
       select
        entry_call_alternative
       else
        sequence_of_statements
       end select;

                          _Dynamic Semantics_

3
The execution of a conditional_entry_call is defined to be equivalent to
the execution of a timed_entry_call (*note 9.7.2: S0237.) with a
delay_alternative (*note 9.7.1: S0235.) specifying an immediate
expiration time and the same sequence_of_statements (*note 5.1: S0145.)
as given after the reserved word else.

     NOTES

4
     41  A conditional_entry_call may briefly increase the Count
     attribute of the entry, even if the conditional call is not
     selected.

                              _Examples_

5
<Example of a conditional entry call:>

6
     procedure Spin(R : in Resource) is
     begin
        loop
           select
              R.Seize;
              return;
           else
              null;  --<  busy waiting>
           end select;
        end loop;
     end;


File: arm2012.info,  Node: 9.7.4,  Prev: 9.7.3,  Up: 9.7

9.7.4 Asynchronous Transfer of Control
--------------------------------------

1
An asynchronous select_statement provides asynchronous transfer of
control upon completion of an entry call or the expiration of a delay.

                               _Syntax_

2
     asynchronous_select ::=
       select
        triggering_alternative
       then abort
        abortable_part
       end select;

3
     triggering_alternative ::= triggering_statement [
     sequence_of_statements]

4/2
     triggering_statement ::= procedure_or_entry_call | delay_statement

5
     abortable_part ::= sequence_of_statements

                          _Dynamic Semantics_

6/2
For the execution of an asynchronous_select whose triggering_statement
(*note 9.7.4: S0243.) is a procedure_or_entry_call, the <entry_>name,
<procedure_>name, or <procedure_>prefix, and actual parameters are
evaluated as for a simple entry call (see *note 9.5.3::) or procedure
call (see *note 6.4::).  If the call is an entry call or a call on a
procedure implemented by an entry, the entry call is issued.  If the
entry call is queued (or requeued-with-abort), then the abortable_part
is executed.  If the entry call is selected immediately, and never
requeued-with-abort, then the abortable_part is never started.  If the
call is on a procedure that is not implemented by an entry, the call
proceeds as described in *note 6.4::, followed by the
sequence_of_statements (*note 5.1: S0145.) of the triggering_alternative
(*note 9.7.4: S0242.); the abortable_part is never started.

7
For the execution of an asynchronous_select whose triggering_statement
(*note 9.7.4: S0243.) is a delay_statement, the <delay_>expression is
evaluated and the expiration time is determined, as for a normal
delay_statement.  If the expiration time has not already passed, the
abortable_part is executed.

8
If the abortable_part completes and is left prior to completion of the
triggering_statement (*note 9.7.4: S0243.), an attempt to cancel the
triggering_statement (*note 9.7.4: S0243.) is made.  If the attempt to
cancel succeeds (see *note 9.5.3:: and *note 9.6::), the
asynchronous_select is complete.

9
If the triggering_statement (*note 9.7.4: S0243.) completes other than
due to cancellation, the abortable_part is aborted (if started but not
yet completed -- see *note 9.8::).  If the triggering_statement (*note
9.7.4: S0243.) completes normally, the optional sequence_of_statements
(*note 5.1: S0145.) of the triggering_alternative (*note 9.7.4: S0242.)
is executed after the abortable_part is left.

                              _Examples_

10
<Example of a main command loop for a command interpreter:>

11
     loop
        select
           Terminal.Wait_For_Interrupt;
           Put_Line("Interrupted");
        then abort
           -- <This will be abandoned upon terminal interrupt>
           Put_Line("-> ");
           Get_Line(Command, Last);
           Process_Command(Command(1..Last));
        end select;
     end loop;

12
<Example of a time-limited calculation:> 

13
     select
        delay 5.0;
        Put_Line("Calculation does not converge");
     then abort
        -- <This calculation should finish in 5.0 seconds;>
        -- < if not, it is assumed to diverge.>
        Horribly_Complicated_Recursive_Function(X, Y);
     end select;

14/4
Note that these examples presume that there are abort completion points
within the execution of the abortable_part.


File: arm2012.info,  Node: 9.8,  Next: 9.9,  Prev: 9.7,  Up: 9

9.8 Abort of a Task - Abort of a Sequence of Statements
=======================================================

1
An abort_statement causes one or more tasks to become abnormal, thus
preventing any further interaction with such tasks.  The completion of
the triggering_statement (*note 9.7.4: S0243.) of an asynchronous_select
causes a sequence_of_statements (*note 5.1: S0145.) to be aborted.

                               _Syntax_

2
     abort_statement ::= abort <task_>name {, <task_>name};

                        _Name Resolution Rules_

3
Each <task_>name is expected to be of any task type; they need not all
be of the same task type.

                          _Dynamic Semantics_

4
For the execution of an abort_statement, the given <task_>names are
evaluated in an arbitrary order.  Each named task is then <aborted>,
which consists of making the task <abnormal> and aborting the execution
of the corresponding task_body, unless it is already completed.

5
When the execution of a construct is <aborted> (including that of a
task_body (*note 9.1: S0209.) or of a sequence_of_statements (*note 5.1:
S0145.)), the execution of every construct included within the aborted
execution is also aborted, except for executions included within the
execution of an <abort-deferred> operation; the execution of an
abort-deferred operation continues to completion without being affected
by the abort; the following are the abort-deferred operations:

6
   * a protected action;

7
   * waiting for an entry call to complete (after having initiated the
     attempt to cancel it -- see below);

8
   * waiting for the termination of dependent tasks;

9
   * the execution of an Initialize procedure as the last step of the
     default initialization of a controlled object;

10
   * the execution of a Finalize procedure as part of the finalization
     of a controlled object;

11
   * an assignment operation to an object with a controlled part.

12
The last three of these are discussed further in *note 7.6::.

13
When a master is aborted, all tasks that depend on that master are
aborted.

14
The order in which tasks become abnormal as the result of an
abort_statement or the abort of a sequence_of_statements (*note 5.1:
S0145.) is not specified by the language.

15
If the execution of an entry call is aborted, an immediate attempt is
made to cancel the entry call (see *note 9.5.3::).  If the execution of
a construct is aborted at a time when the execution is blocked, other
than for an entry call, at a point that is outside the execution of an
abort-deferred operation, then the execution of the construct completes
immediately.  For an abort due to an abort_statement, these immediate
effects occur before the execution of the abort_statement completes.
Other than for these immediate cases, the execution of a construct that
is aborted does not necessarily complete before the abort_statement
completes.  However, the execution of the aborted construct completes no
later than its next <abort completion point> (if any) that occurs
outside of an abort-deferred operation; the following are abort
completion points for an execution:

16
   * the point where the execution initiates the activation of another
     task;

17
   * the end of the activation of a task;

18
   * the start or end of the execution of an entry call,
     accept_statement, delay_statement, or abort_statement;

19
   * the start of the execution of a select_statement, or of the
     sequence_of_statements (*note 5.1: S0145.) of an exception_handler.

                      _Bounded (Run-Time) Errors_

20/3
An attempt to execute an asynchronous_select as part of the execution of
an abort-deferred operation is a bounded error.  Similarly, an attempt
to create a task that depends on a master that is included entirely
within the execution of an abort-deferred operation is a bounded error.In both cases, Program_Error is raised if the error is detected by the
implementation; otherwise, the operations proceed as they would outside
an abort-deferred operation, except that an abort of the abortable_part
or the created task might or might not have an effect.

                         _Erroneous Execution_

21
If an assignment operation completes prematurely due to an abort, the
assignment is said to be <disrupted>; the target of the assignment or
its parts can become abnormal, and certain subsequent uses of the object
can be erroneous, as explained in *note 13.9.1::.

     NOTES

22
     42  An abort_statement should be used only in situations requiring
     unconditional termination.

23
     43  A task is allowed to abort any task it can name, including
     itself.

24
     44  Additional requirements associated with abort are given in
     *note D.6::, "*note D.6:: Preemptive Abort".


File: arm2012.info,  Node: 9.9,  Next: 9.10,  Prev: 9.8,  Up: 9

9.9 Task and Entry Attributes
=============================

                          _Dynamic Semantics_

1
For a prefix T that is of a task type (after any implicit dereference),
the following attributes are defined:

2
T'Callable
               Yields the value True when the task denoted by T is
               <callable>, and False otherwise; a task is callable
               unless it is completed or abnormal.  The value of this
               attribute is of the predefined type Boolean.

3
T'Terminated
               Yields the value True if the task denoted by T is
               terminated, and False otherwise.  The value of this
               attribute is of the predefined type Boolean.

4
For a prefix E that denotes an entry of a task or protected unit, the
following attribute is defined.  This attribute is only allowed within
the body of the task or protected unit, but excluding, in the case of an
entry of a task unit, within any program unit that is, itself, inner to
the body of the task unit.

5
E'Count
               Yields the number of calls presently queued on the entry
               E of the current instance of the unit.  The value of this
               attribute is of the type <universal_integer>.

     NOTES

6
     45  For the Count attribute, the entry can be either a single entry
     or an entry of a family.  The name of the entry or entry family can
     be either a direct_name or an expanded name.

7
     46  Within task units, algorithms interrogating the attribute
     E'Count should take precautions to allow for the increase of the
     value of this attribute for incoming entry calls, and its decrease,
     for example with timed_entry_calls.  Also, a conditional_entry_call
     may briefly increase this value, even if the conditional call is
     not accepted.

8
     47  Within protected units, algorithms interrogating the attribute
     E'Count in the entry_barrier for the entry E should take
     precautions to allow for the evaluation of the condition of the
     barrier both before and after queuing a given caller.


File: arm2012.info,  Node: 9.10,  Next: 9.11,  Prev: 9.9,  Up: 9

9.10 Shared Variables
=====================

                          _Static Semantics_

1/3
If two different objects, including nonoverlapping parts of the same
object, are <independently addressable>, they can be manipulated
concurrently by two different tasks without synchronization.  Any two
nonoverlapping objects are independently addressable if either object is
specified as independently addressable (see *note C.6::).  Otherwise,
two nonoverlapping objects are independently addressable except when
they are both parts of a composite object for which a nonconfirming
value is specified for any of the following representation aspects:
(record) Layout, Component_Size, Pack, Atomic, or Convention; in this
case it is unspecified whether the parts are independently addressable.

                          _Dynamic Semantics_

2
Separate tasks normally proceed independently and concurrently with one
another.  However, task interactions can be used to synchronize the
actions of two or more tasks to allow, for example, meaningful
communication by the direct updating and reading of variables shared
between the tasks.  The actions of two different tasks are synchronized
in this sense when an action of one task <signals> an action of the
other task; an action A1 is defined to signal an action A2 under the
following circumstances:

3
   * If A1 and A2 are part of the execution of the same task, and the
     language rules require A1 to be performed before A2;

4
   * If A1 is the action of an activator that initiates the activation
     of a task, and A2 is part of the execution of the task that is
     activated;

5
   * If A1 is part of the activation of a task, and A2 is the action of
     waiting for completion of the activation;

6
   * If A1 is part of the execution of a task, and A2 is the action of
     waiting for the termination of the task;

6.1/3
   * If A1 is the termination of a task T, and A2 is either an
     evaluation of the expression T'Terminated that results in True, or
     a call to Ada.Task_Identification.Is_Terminated with an actual
     parameter that identifies T and a result of True (see *note
     C.7.1::);

7/3
   * If A1 is the action of issuing an entry call, and A2 is part of the
     corresponding execution of the appropriate entry_body or
     accept_statement;

8
   * If A1 is part of the execution of an accept_statement or
     entry_body, and A2 is the action of returning from the
     corresponding entry call;

9
   * If A1 is part of the execution of a protected procedure body or
     entry_body for a given protected object, and A2 is part of a later
     execution of an entry_body for the same protected object;

10
   * If A1 signals some action that in turn signals A2.

                         _Erroneous Execution_

11
Given an action of assigning to an object, and an action of reading or
updating a part of the same object (or of a neighboring object if the
two are not independently addressable), then the execution of the
actions is erroneous unless the actions are <sequential>.  Two actions
are sequential if one of the following is true:

12
   * One action signals the other;

13
   * Both actions occur as part of the execution of the same task;

14
   * Both actions occur as part of protected actions on the same
     protected object, and at most one of the actions is part of a call
     on a protected function of the protected object.

15/3
Aspect Atomic or aspect Atomic_Components may also be specified to
ensure that certain reads and updates are sequential -- see *note C.6::.


File: arm2012.info,  Node: 9.11,  Prev: 9.10,  Up: 9

9.11 Example of Tasking and Synchronization
===========================================

                              _Examples_

1
The following example defines a buffer protected object to smooth
variations between the speed of output of a producing task and the speed
of input of some consuming task.  For instance, the producing task might
have the following structure:

2
     task Producer;

3/2
     task body Producer is
        Person : Person_Name; --< see *note 3.10.1::>
     begin
        loop
           ... --<  simulate arrival of the next customer>
           Buffer.Append_Wait(Person);
           exit when Person = null;
        end loop;
     end Producer;

4
and the consuming task might have the following structure:

5
     task Consumer;

6/2
     task body Consumer is
        Person : Person_Name;
     begin
        loop
           Buffer.Remove_First_Wait(Person);
           exit when Person = null;
           ... --<  simulate serving a customer>
        end loop;
     end Consumer;

7/2
The buffer object contains an internal array of person names managed in
a round-robin fashion.  The array has two indices, an In_Index denoting
the index for the next input person name and an Out_Index denoting the
index for the next output person name.

7.1/2
The Buffer is defined as an extension of the Synchronized_Queue
interface (see *note 3.9.4::), and as such promises to implement the
abstraction defined by that interface.  By doing so, the Buffer can be
passed to the Transfer class-wide operation defined for objects of a
type covered by Queue'Class.

8/2
     protected Buffer is new Synchronized_Queue with  --< see *note 3.9.4::>
        entry Append_Wait(Person : in Person_Name);
        entry Remove_First_Wait(Person : out Person_Name);
        function Cur_Count return Natural;
        function Max_Count return Natural;
        procedure Append(Person : in Person_Name);
        procedure Remove_First(Person : out Person_Name);
     private
        Pool      : Person_Name_Array(1 .. 100);
        Count     : Natural := 0;
        In_Index, Out_Index : Positive := 1;
     end Buffer;

9/2
     protected body Buffer is
        entry Append_Wait(Person : in Person_Name)
           when Count < Pool'Length is
        begin
           Append(Person);
        end Append_Wait;

9.1/2
        procedure Append(Person : in Person_Name) is
        begin
           if Count = Pool'Length then
              raise Queue_Error with "Buffer Full";  --< see *note 11.3::>
           end if;
           Pool(In_Index) := Person;
           In_Index       := (In_Index mod Pool'Length) + 1;
           Count          := Count + 1;
        end Append;

10/2
        entry Remove_First_Wait(Person : out Person_Name)
           when Count > 0 is
        begin
           Remove_First(Person);
        end Remove_First_Wait;

11/2
        procedure Remove_First(Person : out Person_Name) is
        begin
           if Count = 0 then
              raise Queue_Error with "Buffer Empty"; --< see *note 11.3::>
           end if;
           Person    := Pool(Out_Index);
           Out_Index := (Out_Index mod Pool'Length) + 1;
           Count     := Count - 1;
        end Remove_First;

12/2
        function Cur_Count return Natural is
        begin
            return Buffer.Count;
        end Cur_Count;

13/2
        function Max_Count return Natural is
        begin
            return Pool'Length;
        end Max_Count;
     end Buffer;


File: arm2012.info,  Node: 10,  Next: 11,  Prev: 9,  Up: Top

10 Program Structure and Compilation Issues
*******************************************

1/3
The overall structure of programs and the facilities for separate
compilation are described in this clause.  A <program> is a set of
<partitions>, each of which may execute in a separate address space,
possibly on a separate computer.

2
As explained below, a partition is constructed from <library units>.
Syntactically, the declaration of a library unit is a library_item, as
is the body of a library unit.  An implementation may support a concept
of a <program library> (or simply, a "library"), which contains
library_items and their subunits.  Library units may be organized into a
hierarchy of children, grandchildren, and so on.

3/3
This clause has two subclauses: *note 10.1::, "*note 10.1:: Separate
Compilation" discusses compile-time issues related to separate
compilation.  *note 10.2::, "*note 10.2:: Program Execution" discusses
issues related to what is traditionally known as "link time" and "run
time" -- building and executing partitions.

* Menu:

* 10.1 ::     Separate Compilation
* 10.2 ::     Program Execution


File: arm2012.info,  Node: 10.1,  Next: 10.2,  Up: 10

10.1 Separate Compilation
=========================

1
A <program unit> is either a package, a task unit, a protected unit, a
protected entry, a generic unit, or an explicitly declared subprogram
other than an enumeration literal.  Certain kinds of program units can
be separately compiled.  Alternatively, they can appear physically
nested within other program units.

2
The text of a program can be submitted to the compiler in one or more
compilations.  Each compilation is a succession of compilation_units.  A
compilation_unit contains either the declaration, the body, or a
renaming of a program unit.  The representation for a compilation is
implementation-defined.

3
A library unit is a separately compiled program unit, and is always a
package, subprogram, or generic unit.  Library units may have other
(logically nested) library units as children, and may have other program
units physically nested within them.  A root library unit, together with
its children and grandchildren and so on, form a <subsystem>.

                     _Implementation Permissions_

4
An implementation may impose implementation-defined restrictions on
compilations that contain multiple compilation_units.

* Menu:

* 10.1.1 ::   Compilation Units - Library Units
* 10.1.2 ::   Context Clauses - With Clauses
* 10.1.3 ::   Subunits of Compilation Units
* 10.1.4 ::   The Compilation Process
* 10.1.5 ::   Pragmas and Program Units
* 10.1.6 ::   Environment-Level Visibility Rules


File: arm2012.info,  Node: 10.1.1,  Next: 10.1.2,  Up: 10.1

10.1.1 Compilation Units - Library Units
----------------------------------------

1
A library_item is a compilation unit that is the declaration, body, or
renaming of a library unit.  Each library unit (except Standard) has a
<parent unit>, which is a library package or generic library package.  A
library unit is a <child> of its parent unit.  The <root> library units
are the children of the predefined library package Standard.

                               _Syntax_

2
     compilation ::= {compilation_unit}

3
     compilation_unit ::=
         context_clause library_item
       | context_clause subunit

4
     library_item ::= [private] library_unit_declaration
       | library_unit_body
       | [private] library_unit_renaming_declaration

5
     library_unit_declaration ::=
          subprogram_declaration   | package_declaration
        | generic_declaration   | generic_instantiation

6
     library_unit_renaming_declaration ::=
        package_renaming_declaration
      | generic_renaming_declaration
      | subprogram_renaming_declaration

7
     library_unit_body ::= subprogram_body | package_body

8
     parent_unit_name ::= name

8.1/2
     An overriding_indicator is not allowed in a subprogram_declaration,
     generic_instantiation, or subprogram_renaming_declaration that
     declares a library unit.

9
A <library unit> is a program unit that is declared by a library_item.
When a program unit is a library unit, the prefix "library" is used to
refer to it (or "generic library" if generic), as well as to its
declaration and body, as in "library procedure", "library package_body",
or "generic library package".  The term <compilation unit> is used to
refer to a compilation_unit.  When the meaning is clear from context,
the term is also used to refer to the library_item of a compilation_unit
or to the proper_body of a subunit (that is, the compilation_unit
without the context_clause and the separate (parent_unit_name)).

10
The <parent declaration> of a library_item (and of the library unit) is
the declaration denoted by the parent_unit_name (*note 10.1.1: S0252.),
if any, of the defining_program_unit_name (*note 6.1: S0169.) of the
library_item.  If there is no parent_unit_name (*note 10.1.1: S0252.),
the parent declaration is the declaration of Standard, the library_item
is a <root> library_item, and the library unit (renaming) is a <root>
library unit (renaming).  The declaration and body of Standard itself
have no parent declaration.  The <parent unit> of a library_item or
library unit is the library unit declared by its parent declaration.

11
The children of a library unit occur immediately within the declarative
region of the declaration of the library unit.  The <ancestors> of a
library unit are itself, its parent, its parent's parent, and so on.
(Standard is an ancestor of every library unit.)  The <descendant>
relation is the inverse of the ancestor relation.

12
A library_unit_declaration or a library_unit_renaming_declaration (*note
10.1.1: S0250.) is <private> if the declaration is immediately preceded
by the reserved word private; it is otherwise <public>.  A library unit
is private or public according to its declaration.  The <public
descendants> of a library unit are the library unit itself, and the
public descendants of its public children.  Its other descendants are
<private descendants>.

12.1/2
For each library package_declaration in the environment, there is an
implicit declaration of a <limited view> of that library package.  The
limited view of a package contains:

12.2/3
   * For each package_declaration occurring immediately within the
     visible part, a declaration of the limited view of that package,
     with the same defining_program_unit_name.

12.3/3
   * For each type_declaration occurring immediately within the visible
     part that is not an incomplete_type_declaration, an incomplete view
     of the type with no discriminant_part; if the type_declaration is
     tagged, then the view is a tagged incomplete view.

12.4/2
The limited view of a library package_declaration is private if that
library package_declaration is immediately preceded by the reserved word
private.

12.5/2
There is no syntax for declaring limited views of packages, because they
are always implicit.  The implicit declaration of a limited view of a
library package is not the declaration of a library unit (the library
package_declaration is); nonetheless, it is a library_item.  The
implicit declaration of the limited view of a library package forms an
(implicit) compilation unit whose context_clause is empty.

12.6/2
A library package_declaration is the completion of the declaration of
its limited view.

                           _Legality Rules_

13
The parent unit of a library_item shall be a library package or generic
library package.

14
If a defining_program_unit_name of a given declaration or body has a
parent_unit_name, then the given declaration or body shall be a
library_item.  The body of a program unit shall be a library_item if and
only if the declaration of the program unit is a library_item.  In a
library_unit_renaming_declaration (*note 10.1.1: S0250.), the (old) name
shall denote a library_item.

15/2
A parent_unit_name (which can be used within a
defining_program_unit_name of a library_item and in the separate clause
of a subunit), and each of its prefixes, shall not denote a
renaming_declaration.  On the other hand, a name that denotes a
library_unit_renaming_declaration (*note 10.1.1: S0250.) is allowed in a
nonlimited_with_clause and other places where the name of a library unit
is allowed.

16
If a library package is an instance of a generic package, then every
child of the library package shall either be itself an instance or be a
renaming of a library unit.

17/3
A child of a generic library package shall either be itself a generic
unit or be a renaming of some other child of the same generic unit.

18
A child of a parent generic package shall be instantiated or renamed
only within the declarative region of the parent generic.

19/2
For each child <C> of some parent generic package <P>, there is a
corresponding declaration <C> nested immediately within each instance of
<P>.  For the purposes of this rule, if a child <C> itself has a child
<D>, each corresponding declaration for <C> has a corresponding child
<D>.  The corresponding declaration for a child within an instance is
visible only within the scope of a with_clause that mentions the
(original) child generic unit.

20
A library subprogram shall not override a primitive subprogram.

21
The defining name of a function that is a compilation unit shall not be
an operator_symbol.

                          _Static Semantics_

22
A subprogram_renaming_declaration that is a
library_unit_renaming_declaration (*note 10.1.1: S0250.) is a
renaming-as-declaration, not a renaming-as-body.

23
There are two kinds of dependences among compilation units:

24
   * The <semantic dependences> (see below) are the ones needed to check
     the compile-time rules across compilation unit boundaries; a
     compilation unit depends semantically on the other compilation
     units needed to determine its legality.  The visibility rules are
     based on the semantic dependences.

25
   * The <elaboration dependences> (see *note 10.2::) determine the
     order of elaboration of library_items.

26/2
A library_item depends semantically upon its parent declaration.  A
subunit depends semantically upon its parent body.  A library_unit_body
depends semantically upon the corresponding library_unit_declaration, if
any.  The declaration of the limited view of a library package depends
semantically upon the declaration of the limited view of its parent.
The declaration of a library package depends semantically upon the
declaration of its limited view.  A compilation unit depends
semantically upon each library_item mentioned in a with_clause of the
compilation unit.  In addition, if a given compilation unit contains an
attribute_reference of a type defined in another compilation unit, then
the given compilation unit depends semantically upon the other
compilation unit.  The semantic dependence relationship is transitive.

                          _Dynamic Semantics_

26.1/2
The elaboration of the declaration of the limited view of a package has
no effect.

     NOTES

27
     1  A simple program may consist of a single compilation unit.  A
     compilation need not have any compilation units; for example, its
     text can consist of pragmas.

28
     2  The designator of a library function cannot be an
     operator_symbol, but a nonlibrary renaming_declaration is allowed
     to rename a library function as an operator.  Within a partition,
     two library subprograms are required to have distinct names and
     hence cannot overload each other.  However, renaming_declarations
     are allowed to define overloaded names for such subprograms, and a
     locally declared subprogram is allowed to overload a library
     subprogram.  The expanded name Standard.L can be used to denote a
     root library unit L (unless the declaration of Standard is hidden)
     since root library unit declarations occur immediately within the
     declarative region of package Standard.

                              _Examples_

29
<Examples of library units:>

30
     package Rational_Numbers.IO is  --< public child of Rational_Numbers, see *note 7.1::>
        procedure Put(R : in  Rational);
        procedure Get(R : out Rational);
     end Rational_Numbers.IO;

31
     private procedure Rational_Numbers.Reduce(R : in out Rational);
                                     --< private child of Rational_Numbers>

32
     with Rational_Numbers.Reduce;   --< refer to a private child>
     package body Rational_Numbers is
        ...
     end Rational_Numbers;

33
     with Rational_Numbers.IO; use Rational_Numbers;
     with Ada.Text_io;               --< see *note A.10::>
     procedure Main is               --< a root library procedure>
        R : Rational;
     begin
        R := 5/3;                    --< construct a rational number, see *note 7.1::>
        Ada.Text_IO.Put("The answer is: ");
        IO.Put(R);
        Ada.Text_IO.New_Line;
     end Main;

34
     with Rational_Numbers.IO;
     package Rational_IO renames Rational_Numbers.IO;
                                     --< a library unit renaming declaration>

35
Each of the above library_items can be submitted to the compiler
separately.


File: arm2012.info,  Node: 10.1.2,  Next: 10.1.3,  Prev: 10.1.1,  Up: 10.1

10.1.2 Context Clauses - With Clauses
-------------------------------------

1
A context_clause is used to specify the library_items whose names are
needed within a compilation unit.

                               _Syntax_

2
     context_clause ::= {context_item}

3
     context_item ::= with_clause | use_clause

4/2
     with_clause ::= limited_with_clause | nonlimited_with_clause

4.1/2
     limited_with_clause ::= limited [private] with <library_unit_>
     name {, <library_unit_>name};

4.2/2
     nonlimited_with_clause ::= [private] with <library_unit_>
     name {, <library_unit_>name};

                        _Name Resolution Rules_

5
The <scope> of a with_clause that appears on a library_unit_declaration
(*note 10.1.1: S0249.) or library_unit_renaming_declaration (*note
10.1.1: S0250.) consists of the entire declarative region of the
declaration, which includes all children and subunits.  The scope of a
with_clause that appears on a body consists of the body, which includes
all subunits.

6/2
A library_item (and the corresponding library unit) is <named> in a
with_clause if it is denoted by a <library_unit_>name in the
with_clause.  A library_item (and the corresponding library unit) is
<mentioned> in a with_clause if it is named in the with_clause or if it
is denoted by a prefix in the with_clause.

7
Outside its own declarative region, the declaration or renaming of a
library unit can be visible only within the scope of a with_clause that
mentions it.  The visibility of the declaration or renaming of a library
unit otherwise follows from its placement in the environment.

                           _Legality Rules_

8/2
If a with_clause of a given compilation_unit mentions a private child of
some library unit, then the given compilation_unit shall be one of:

9/2
   * the declaration, body, or subunit of a private descendant of that
     library unit;

10/2
   * the body or subunit of a public descendant of that library unit,
     but not a subprogram body acting as a subprogram declaration (see
     *note 10.1.4::); or

11/2
   * the declaration of a public descendant of that library unit, in
     which case the with_clause shall include the reserved word private.

12/3
A name denoting a library_item (or the corresponding declaration for a
child of a generic within an instance -- see *note 10.1.1::), if it is
visible only due to being mentioned in one or more with_clauses that
include the reserved word private, shall appear only within:

13/2
   * a private part;

14/2
   * a body, but not within the subprogram_specification of a library
     subprogram body;

15/2
   * a private descendant of the unit on which one of these with_clauses
     appear; or

16/2
   * a pragma within a context clause.

17/2
A library_item mentioned in a limited_with_clause shall be the implicit
declaration of the limited view of a library package, not the
declaration of a subprogram, generic unit, generic instance, or a
renaming.

18/2
A limited_with_clause shall not appear on a library_unit_body, subunit,
or library_unit_renaming_declaration (*note 10.1.1: S0250.).

19/2
A limited_with_clause that names a library package shall not appear:

20/3
   * in the context_clause for the explicit declaration of the named
     library package or any of its descendants;

21/3
   * within a context_clause for a library_item that is within the scope
     of a nonlimited_with_clause that mentions the same library package;
     or

22/3
   * within a context_clause for a library_item that is within the scope
     of a use_clause that names an entity declared within the
     declarative region of the library package.

     NOTES

23/2
     3  A library_item mentioned in a nonlimited_with_clause of a
     compilation unit is visible within the compilation unit and hence
     acts just like an ordinary declaration.  Thus, within a compilation
     unit that mentions its declaration, the name of a library package
     can be given in use_clauses and can be used to form expanded names,
     a library subprogram can be called, and instances of a generic
     library unit can be declared.  If a child of a parent generic
     package is mentioned in a nonlimited_with_clause, then the
     corresponding declaration nested within each visible instance is
     visible within the compilation unit.  Similarly, a library_item
     mentioned in a limited_with_clause of a compilation unit is visible
     within the compilation unit and thus can be used to form expanded
     names.

                              _Examples_

24/2
     package Office is
     end Office;

25/2
     with Ada.Strings.Unbounded;
     package Office.Locations is
        type Location is new Ada.Strings.Unbounded.Unbounded_String;
     end Office.Locations;

26/2
     limited with Office.Departments;  --< types are incomplete>
     private with Office.Locations;    --< only visible in private part>
     package Office.Employees is
        type Employee is private;

27/2
        function Dept_Of(Emp : Employee) return access Departments.Department;
        procedure Assign_Dept(Emp  : in out Employee;
                              Dept : access Departments.Department);

28/2
        ...
     private
        type Employee is
           record
              Dept : access Departments.Department;
              Loc : Locations.Location;
              ...
           end record;
     end Office.Employees;

29/2
     limited with Office.Employees;
     package Office.Departments is
        type Department is private;

30/2
        function Manager_Of(Dept : Department) return access Employees.Employee;
        procedure Assign_Manager(Dept : in out Department;
                                 Mgr  : access Employees.Employee);
        ...
     end Office.Departments;

31/2
The limited_with_clause may be used to support mutually dependent
abstractions that are split across multiple packages.  In this case, an
employee is assigned to a department, and a department has a manager who
is an employee.  If a with_clause with the reserved word private appears
on one library unit and mentions a second library unit, it provides
visibility to the second library unit, but restricts that visibility to
the private part and body of the first unit.  The compiler checks that
no use is made of the second unit in the visible part of the first unit.


File: arm2012.info,  Node: 10.1.3,  Next: 10.1.4,  Prev: 10.1.2,  Up: 10.1

10.1.3 Subunits of Compilation Units
------------------------------------

1
Subunits are like child units, with these (important) differences:
subunits support the separate compilation of bodies only (not
declarations); the parent contains a body_stub to indicate the existence
and place of each of its subunits; declarations appearing in the
parent's body can be visible within the subunits.

                               _Syntax_

2
     body_stub ::= subprogram_body_stub | package_body_stub | 
     task_body_stub | protected_body_stub

3/3
     subprogram_body_stub ::=
        [overriding_indicator]
        subprogram_specification is separate
           [aspect_specification];

4/3
     package_body_stub ::=
        package body defining_identifier is separate
           [aspect_specification];

5/3
     task_body_stub ::=
        task body defining_identifier is separate
           [aspect_specification];

6/3
     protected_body_stub ::=
        protected body defining_identifier is separate
           [aspect_specification];

7
     subunit ::= separate (parent_unit_name) proper_body

                           _Legality Rules_

8/2
The <parent body> of a subunit is the body of the program unit denoted
by its parent_unit_name.   The term <subunit> is used to refer to a
subunit and also to the proper_body of a subunit.  The <subunits of a
program unit> include any subunit that names that program unit as its
parent, as well as any subunit that names such a subunit as its parent
(recursively).

9
The parent body of a subunit shall be present in the current
environment, and shall contain a corresponding body_stub with the same
defining_identifier as the subunit.

10/3
A package_body_stub shall be the completion of a package_declaration
(*note 7.1: S0190.) or generic_package_declaration (*note 12.1: S0273.);
a task_body_stub (*note 10.1.3: S0261.) shall be the completion of a
task declaration; a protected_body_stub (*note 10.1.3: S0262.) shall be
the completion of a protected declaration.

11
In contrast, a subprogram_body_stub need not be the completion of a
previous declaration, in which case the _stub declares the subprogram.
If the _stub is a completion, it shall be the completion of a
subprogram_declaration or generic_subprogram_declaration.  The profile
of a subprogram_body_stub that completes a declaration shall conform
fully to that of the declaration.  

12
A subunit that corresponds to a body_stub shall be of the same kind
(package_, subprogram_, task_, or protected_) as the body_stub.  The
profile of a subprogram_body subunit shall be fully conformant to that
of the corresponding body_stub.  

13
A body_stub shall appear immediately within the declarative_part of a
compilation unit body.  This rule does not apply within an instance of a
generic unit.

14
The defining_identifiers of all body_stubs that appear immediately
within a particular declarative_part shall be distinct.

                       _Post-Compilation Rules_

15
For each body_stub, there shall be a subunit containing the
corresponding proper_body.

     NOTES

16
     4  The rules in *note 10.1.4::, "*note 10.1.4:: The Compilation
     Process" say that a body_stub is equivalent to the corresponding
     proper_body.  This implies:

17
        * Visibility within a subunit is the visibility that would be
          obtained at the place of the corresponding body_stub (within
          the parent body) if the context_clause of the subunit were
          appended to that of the parent body.

18
        * The effect of the elaboration of a body_stub is to elaborate
          the subunit.

                              _Examples_

19
The package Parent is first written without subunits:

20
     package Parent is
         procedure Inner;
     end Parent;

21
     with Ada.Text_IO;
     package body Parent is
         Variable : String := "Hello, there.";
         procedure Inner is
         begin
             Ada.Text_IO.Put_Line(Variable);
         end Inner;
     end Parent;

22
The body of procedure Inner may be turned into a subunit by rewriting
the package body as follows (with the declaration of Parent remaining
the same):

23
     package body Parent is
         Variable : String := "Hello, there.";
         procedure Inner is separate;
     end Parent;

24
     with Ada.Text_IO;
     separate(Parent)
     procedure Inner is
     begin
         Ada.Text_IO.Put_Line(Variable);
     end Inner;


File: arm2012.info,  Node: 10.1.4,  Next: 10.1.5,  Prev: 10.1.3,  Up: 10.1

10.1.4 The Compilation Process
------------------------------

1
Each compilation unit submitted to the compiler is compiled in the
context of an <environment> declarative_part (or simply, an
<environment>), which is a conceptual declarative_part that forms the
outermost declarative region of the context of any compilation.  At run
time, an environment forms the declarative_part of the body of the
environment task of a partition (see *note 10.2::, "*note 10.2:: Program
Execution").

2
The declarative_items of the environment are library_items appearing in
an order such that there are no forward semantic dependences.  Each
included subunit occurs in place of the corresponding stub.  The
visibility rules apply as if the environment were the outermost
declarative region, except that with_clause (*note 10.1.2: S0255.)s are
needed to make declarations of library units visible (see *note
10.1.2::).

3/2
The mechanisms for creating an environment and for adding and replacing
compilation units within an environment are implementation defined.  The
mechanisms for adding a compilation unit mentioned in a
limited_with_clause to an environment are implementation defined.

                        _Name Resolution Rules_

4/3
If a library_unit_body that is a subprogram_body is submitted to the
compiler, it is interpreted only as a completion if a
library_unit_declaration with the same defining_program_unit_name
already exists in the environment for a subprogram other than an
instance of a generic subprogram or for a generic subprogram (even if
the profile of the body is not type conformant with that of the
declaration); otherwise, the subprogram_body is interpreted as both the
declaration and body of a library subprogram.  

                           _Legality Rules_

5
When a compilation unit is compiled, all compilation units upon which it
depends semantically shall already exist in the environment; the set of
these compilation units shall be <consistent> in the sense that the new
compilation unit shall not semantically depend (directly or indirectly)
on two different versions of the same compilation unit, nor on an
earlier version of itself.

                     _Implementation Permissions_

6/2
The implementation may require that a compilation unit be legal before
it can be mentioned in a limited_with_clause or it can be inserted into
the environment.

7/3
When a compilation unit that declares or renames a library unit is added
to the environment, the implementation may remove from the environment
any preexisting library_item or subunit with the same full expanded
name.  When a compilation unit that is a subunit or the body of a
library unit is added to the environment, the implementation may remove
from the environment any preexisting version of the same compilation
unit.  When a compilation unit that contains a body_stub is added to the
environment, the implementation may remove any preexisting library_item
or subunit with the same full expanded name as the body_stub.  When a
given compilation unit is removed from the environment, the
implementation may also remove any compilation unit that depends
semantically upon the given one.  If the given compilation unit contains
the body of a subprogram for which aspect Inline is True, the
implementation may also remove any compilation unit containing a call to
that subprogram.

     NOTES

8
     5  The rules of the language are enforced across compilation and
     compilation unit boundaries, just as they are enforced within a
     single compilation unit.

9
     6  An implementation may support a concept of a <library>, which
     contains library_items.  If multiple libraries are supported, the
     implementation has to define how a single environment is
     constructed when a compilation unit is submitted to the compiler.
     Naming conflicts between different libraries might be resolved by
     treating each library as the root of a hierarchy of child library
     units.  

10
     7  A compilation unit containing an instantiation of a separately
     compiled generic unit does not semantically depend on the body of
     the generic unit.  Therefore, replacing the generic body in the
     environment does not result in the removal of the compilation unit
     containing the instantiation.


File: arm2012.info,  Node: 10.1.5,  Next: 10.1.6,  Prev: 10.1.4,  Up: 10.1

10.1.5 Pragmas and Program Units
--------------------------------

1
This subclause discusses pragmas related to program units, library
units, and compilations.

                        _Name Resolution Rules_

2
Certain pragmas are defined to be <program unit pragmas>.  A name given
as the argument of a program unit pragma shall resolve to denote the
declarations or renamings of one or more program units that occur
immediately within the declarative region or compilation in which the
pragma immediately occurs, or it shall resolve to denote the declaration
of the immediately enclosing program unit (if any); the pragma applies
to the denoted program unit(s).  If there are no names given as
arguments, the pragma applies to the immediately enclosing program unit.

                           _Legality Rules_

3
A program unit pragma shall appear in one of these places:

4
   * At the place of a compilation_unit, in which case the pragma shall
     immediately follow in the same compilation (except for other
     pragmas) a library_unit_declaration (*note 10.1.1: S0249.) that is
     a subprogram_declaration (*note 6.1: S0163.),
     generic_subprogram_declaration (*note 12.1: S0272.), or
     generic_instantiation (*note 12.3: S0276.), and the pragma shall
     have an argument that is a name denoting that declaration.

5/1
   * Immediately within the visible part of a program unit and before
     any nested declaration (but not within a generic formal part), in
     which case the argument, if any, shall be a direct_name that
     denotes the immediately enclosing program unit declaration.

6
   * At the place of a declaration other than the first, of a
     declarative_part or program unit declaration, in which case the
     pragma shall have an argument, which shall be a direct_name that
     denotes one or more of the following (and nothing else): a
     subprogram_declaration (*note 6.1: S0163.), a
     generic_subprogram_declaration (*note 12.1: S0272.), or a
     generic_instantiation (*note 12.3: S0276.), of the same
     declarative_part (*note 3.11: S0086.) or program unit declaration.

7/3
Certain program unit pragmas are defined to be <library unit pragmas>.
If a library unit pragma applies to a program unit, the program unit
shall be a library unit.

                          _Static Semantics_

7.1/1
A library unit pragma that applies to a generic unit does not apply to
its instances, unless a specific rule for the pragma specifies the
contrary.

                       _Post-Compilation Rules_

8
Certain pragmas are defined to be <configuration pragmas>; they shall
appear before the first compilation_unit of a compilation.  They are
generally used to select a partition-wide or system-wide option.  The
pragma applies to all compilation_units appearing in the compilation,
unless there are none, in which case it applies to all future
compilation_units compiled into the same environment.

                     _Implementation Permissions_

9/2
An implementation may require that configuration pragmas that select
partition-wide or system-wide options be compiled when the environment
contains no library_items other than those of the predefined
environment.  In this case, the implementation shall still accept
configuration pragmas in individual compilations that confirm the
initially selected partition-wide or system-wide options.

                        _Implementation Advice_

10/1
When applied to a generic unit, a program unit pragma that is not a
library unit pragma should apply to each instance of the generic unit
for which there is not an overriding pragma applied directly to the
instance.


File: arm2012.info,  Node: 10.1.6,  Prev: 10.1.5,  Up: 10.1

10.1.6 Environment-Level Visibility Rules
-----------------------------------------

1
The normal visibility rules do not apply within a parent_unit_name or a
context_clause, nor within a pragma that appears at the place of a
compilation unit.  The special visibility rules for those contexts are
given here.

                          _Static Semantics_

2/2
Within the parent_unit_name at the beginning of an explicit
library_item, and within a nonlimited_with_clause, the only declarations
that are visible are those that are explicit library_items of the
environment, and the only declarations that are directly visible are
those that are explicit root library_items of the environment.  Within a
limited_with_clause, the only declarations that are visible are those
that are the implicit declaration of the limited view of a library
package of the environment, and the only declarations that are directly
visible are those that are the implicit declaration of the limited view
of a root library package.

3
Within a use_clause or pragma that is within a context_clause, each
library_item mentioned in a previous with_clause of the same
context_clause is visible, and each root library_item so mentioned is
directly visible.  In addition, within such a use_clause, if a given
declaration is visible or directly visible, each declaration that occurs
immediately within the given declaration's visible part is also visible.
No other declarations are visible or directly visible.

4
Within the parent_unit_name of a subunit, library_items are visible as
they are in the parent_unit_name of a library_item; in addition, the
declaration corresponding to each body_stub in the environment is also
visible.

5
Within a pragma that appears at the place of a compilation unit, the
immediately preceding library_item and each of its ancestors is visible.
The ancestor root library_item is directly visible.

6/2
Notwithstanding the rules of *note 4.1.3::, an expanded name in a
with_clause, a pragma in a context_clause, or a pragma that appears at
the place of a compilation unit may consist of a prefix that denotes a
generic package and a selector_name that denotes a child of that generic
package.  (The child is necessarily a generic unit; see *note 10.1.1::.)


File: arm2012.info,  Node: 10.2,  Prev: 10.1,  Up: 10

10.2 Program Execution
======================

1
An Ada <program> consists of a set of <partitions>, which can execute in
parallel with one another, possibly in a separate address space, and
possibly on a separate computer.

                       _Post-Compilation Rules_

2
A partition is a program or part of a program that can be invoked from
outside the Ada implementation.  For example, on many systems, a
partition might be an executable file generated by the system linker.
The user can <explicitly assign> library units to a partition.  The
assignment is done in an implementation-defined manner.  The compilation
units included in a partition are those of the explicitly assigned
library units, as well as other compilation units <needed by> those
library units.  The compilation units needed by a given compilation unit
are determined as follows (unless specified otherwise via an
implementation-defined pragma, or by some other implementation-defined
means): 

3
   * A compilation unit needs itself;

4
   * If a compilation unit is needed, then so are any compilation units
     upon which it depends semantically;

5
   * If a library_unit_declaration is needed, then so is any
     corresponding library_unit_body;

6/2
   * If a compilation unit with stubs is needed, then so are any
     corresponding subunits;

6.1/2
   * If the (implicit) declaration of the limited view of a library
     package is needed, then so is the explicit declaration of the
     library package.

7
The user can optionally designate (in an implementation-defined manner)
one subprogram as the <main subprogram> for the partition.  A main
subprogram, if specified, shall be a subprogram.

8
Each partition has an anonymous <environment task>, which is an implicit
outermost task whose execution elaborates the library_items of the
environment declarative_part, and then calls the main subprogram, if
there is one.  A partition's execution is that of its tasks.

9
The order of elaboration of library units is determined primarily by the
<elaboration dependences>.  There is an elaboration dependence of a
given library_item upon another if the given library_item or any of its
subunits depends semantically on the other library_item.  In addition,
if a given library_item or any of its subunits has a pragma Elaborate or
Elaborate_All that names another library unit, then there is an
elaboration dependence of the given library_item upon the body of the
other library unit, and, for Elaborate_All only, upon each library_item
needed by the declaration of the other library unit.

10
The environment task for a partition has the following structure:

11
     task <Environment_Task>;

12
     task body <Environment_Task> is
         ... (1) --< The environment >declarative_part
                 --< (that is, the sequence of >library_item<s) goes here.>
     begin
         ... (2) --< Call the main subprogram, if there is one.>
     end <Environment_Task>;

13
The environment declarative_part at (1) is a sequence of
declarative_items consisting of copies of the library_items included in
the partition.  The order of elaboration of library_items is the order
in which they appear in the environment declarative_part:

14
   * The order of all included library_items is such that there are no
     forward elaboration dependences.

15/3
   * Any included library_unit_declaration for which aspect
     Elaborate_Body is True (including when a pragma Elaborate_Body
     applies) is immediately followed by its library_unit_body, if
     included.

16
   * All library_items declared pure occur before any that are not
     declared pure.

17
   * All preelaborated library_items occur before any that are not
     preelaborated.

18
There shall be a total order of the library_items that obeys the above
rules.  The order is otherwise implementation defined.

19
The full expanded names of the library units and subunits included in a
given partition shall be distinct.

20
The sequence_of_statements of the environment task (see (2) above)
consists of either:

21
   * A call to the main subprogram, if the partition has one.  If the
     main subprogram has parameters, they are passed; where the actuals
     come from is implementation defined.  What happens to the result of
     a main function is also implementation defined.

22
or:

23
   * A null_statement, if there is no main subprogram.

24
The mechanisms for building and running partitions are implementation
defined.  These might be combined into one operation, as, for example,
in dynamic linking, or "load-and-go" systems.

                          _Dynamic Semantics_

25
The execution of a program consists of the execution of a set of
partitions.  Further details are implementation defined.  The execution
of a partition starts with the execution of its environment task, ends
when the environment task terminates, and includes the executions of all
tasks of the partition.  The execution of the (implicit) task_body of
the environment task acts as a master for all other tasks created as
part of the execution of the partition.  When the environment task
completes (normally or abnormally), it waits for the termination of all
such tasks, and then finalizes any remaining objects of the partition.

                      _Bounded (Run-Time) Errors_

26
Once the environment task has awaited the termination of all other tasks
of the partition, any further attempt to create a task (during
finalization) is a bounded error, and may result in the raising of
Program_Error either upon creation or activation of the task.  If such a
task is activated, it is not specified whether the task is awaited prior
to termination of the environment task.

                     _Implementation Requirements_

27
The implementation shall ensure that all compilation units included in a
partition are consistent with one another, and are legal according to
the rules of the language.

                     _Implementation Permissions_

28/3
The kind of partition described in this subclause is known as an
<active> partition.  An implementation is allowed to support other kinds
of partitions, with implementation-defined semantics.

29
An implementation may restrict the kinds of subprograms it supports as
main subprograms.  However, an implementation is required to support all
main subprograms that are public parameterless library procedures.

30
If the environment task completes abnormally, the implementation may
abort any dependent tasks.

     NOTES

31
     8  An implementation may provide inter-partition communication
     mechanism(s) via special packages and pragmas.  Standard pragmas
     for distribution and methods for specifying inter-partition
     communication are defined in *note Annex E::, "*note Annex E::
     Distributed Systems".  If no such mechanisms are provided, then
     each partition is isolated from all others, and behaves as a
     program in and of itself.

32
     9  Partitions are not required to run in separate address spaces.
     For example, an implementation might support dynamic linking via
     the partition concept.

33
     10  An order of elaboration of library_items that is consistent
     with the partial ordering defined above does not always ensure that
     each library_unit_body is elaborated before any other compilation
     unit whose elaboration necessitates that the library_unit_body be
     already elaborated.  (In particular, there is no requirement that
     the body of a library unit be elaborated as soon as possible after
     the library_unit_declaration is elaborated, unless the pragmas in
     subclause *note 10.2.1:: are used.)

34
     11  A partition (active or otherwise) need not have a main
     subprogram.  In such a case, all the work done by the partition
     would be done by elaboration of various library_items, and by tasks
     created by that elaboration.  Passive partitions, which cannot have
     main subprograms, are defined in *note Annex E::, "*note Annex E::
     Distributed Systems".

* Menu:

* 10.2.1 ::   Elaboration Control


File: arm2012.info,  Node: 10.2.1,  Up: 10.2

10.2.1 Elaboration Control
--------------------------

1
This subclause defines pragmas that help control the elaboration order
of library_items.

                               _Syntax_

2
     The form of a pragma Preelaborate is as follows:

3
       pragma Preelaborate[(<library_unit_>name)];

4
     A pragma Preelaborate is a library unit pragma.

4.1/2
     The form of a pragma Preelaborable_Initialization is as follows:

4.2/2
       pragma Preelaborable_Initialization(direct_name);

                           _Legality Rules_

5
An elaborable construct is preelaborable unless its elaboration performs
any of the following actions:

6
   * The execution of a statement other than a null_statement.

7
   * A call to a subprogram other than a static function.

8
   * The evaluation of a primary that is a name of an object, unless the
     name is a static expression, or statically denotes a discriminant
     of an enclosing type.

9/3
   * The creation of an object (including a component) that is
     initialized by default, if its type does not have preelaborable
     initialization.  Similarly, the evaluation of an
     extension_aggregate (*note 4.3.2: S0111.) with an ancestor
     subtype_mark (*note 3.2.2: S0028.) denoting a subtype of such a
     type.

10/2
A generic body is preelaborable only if elaboration of a corresponding
instance body would not perform any such actions, presuming that: 

10.1/3
   * the actual for each discriminated formal derived type, formal
     private type, or formal private extension declared within the
     formal part of the generic unit is a type that does not have
     preelaborable initialization, unless pragma
     Preelaborable_Initialization has been applied to the formal type;

10.2/2
   * the actual for each formal type is nonstatic;

10.3/2
   * the actual for each formal object is nonstatic; and

10.4/2
   * the actual for each formal subprogram is a user-defined subprogram.

11/3
A pragma Preelaborate (or pragma Pure -- see below) is used to specify
that a library unit is <preelaborated>, namely that the Preelaborate
aspect of the library unit is True; all compilation units of the library
unit are preelaborated.  The declaration and body of a preelaborated
library unit, and all subunits that are elaborated as part of
elaborating the library unit, shall be preelaborable.  All compilation
units of a preelaborated library unit shall depend semantically only on
declared pure or preelaborated library_items.  In addition to the places
where Legality Rules normally apply (see *note 12.3::), these rules also
apply in the private part of an instance of a generic unit.  If a
library unit is preelaborated, then its declaration, if any, and body,
if any, are elaborated prior to all nonpreelaborated library_items of
the partition.

11.1/2
The following rules specify which entities have <preelaborable
initialization>:

11.2/3
   * The partial view of a private type or private extension, a
     protected type without entry_declarations, a generic formal private
     type, or a generic formal derived type, has preelaborable
     initialization if and only if the pragma
     Preelaborable_Initialization has been applied to them.  A protected
     type with entry_declarations or a task type never has preelaborable
     initialization.

11.3/2
   * A component (including a discriminant) of a record or protected
     type has preelaborable initialization if its declaration includes a
     default_expression whose execution does not perform any actions
     prohibited in preelaborable constructs as described above, or if
     its declaration does not include a default expression and its type
     has preelaborable initialization.

11.4/3
   * A derived type has preelaborable initialization if its parent type
     has preelaborable initialization and if the noninherited components
     all have preelaborable initialization.  However, a controlled type
     with an Initialize procedure that is not a null procedure does not
     have preelaborable initialization.

11.5/2
   * A view of a type has preelaborable initialization if it is an
     elementary type, an array type whose component type has
     preelaborable initialization, a record type whose components all
     have preelaborable initialization, or an interface type.

11.6/2
A pragma Preelaborable_Initialization specifies that a type has
preelaborable initialization.  This pragma shall appear in the visible
part of a package or generic package.

11.7/3
If the pragma appears in the first list of basic_declarative_items of a
package_specification, then the direct_name shall denote the first
subtype of a composite type, and the type shall be declared immediately
within the same package as the pragma.  If the pragma is applied to a
private type or a private extension, the full view of the type shall
have preelaborable initialization.  If the pragma is applied to a
protected type, the protected type shall not have entries, and each
component of the protected type shall have preelaborable initialization.
For any other composite type, the type shall have preelaborable
initialization.  In addition to the places where Legality Rules normally
apply (see *note 12.3::), these rules apply also in the private part of
an instance of a generic unit.

11.8/2
If the pragma appears in a generic_formal_part, then the direct_name
shall denote a generic formal private type or a generic formal derived
type declared in the same generic_formal_part as the pragma.  In a
generic_instantiation the corresponding actual type shall have
preelaborable initialization.

                        _Implementation Advice_

12
In an implementation, a type declared in a preelaborated package should
have the same representation in every elaboration of a given version of
the package, whether the elaborations occur in distinct executions of
the same program, or in executions of distinct programs or partitions
that include the given version.

                               _Syntax_

13
     The form of a pragma Pure is as follows:

14
       pragma Pure[(<library_unit_>name)];

15
     A pragma Pure is a library unit pragma.

                          _Static Semantics_

15.1/3
A <pure> compilation unit is a preelaborable compilation unit whose
elaboration does not perform any of the following actions:

15.2/2
   * the elaboration of a variable declaration;

15.3/2
   * the evaluation of an allocator of an access-to-variable type; for
     the purposes of this rule, the partial view of a type is presumed
     to have nonvisible components whose default initialization
     evaluates such an allocator;

15.4/3
   * the elaboration of the declaration of a nonderived named
     access-to-variable type unless the Storage_Size of the type has
     been specified by a static expression with value zero or is defined
     by the language to be zero;

15.5/3
   * the elaboration of the declaration of a nonderived named
     access-to-constant type for which the Storage_Size has been
     specified by an expression other than a static expression with
     value zero.

15.6/3
A generic body is pure only if elaboration of a corresponding instance
body would not perform any such actions presuming any composite formal
types have nonvisible components whose default initialization evaluates
an allocator of an access-to-variable type.

15.7/2
The Storage_Size for an anonymous access-to-variable type declared at
library level in a library unit that is declared pure is defined to be
zero.

                           _Legality Rules_

16/2
<This paragraph was deleted.>

17/3
A pragma Pure is used to specify that a library unit is <declared pure>,
namely that the Pure aspect of the library unit is True; all compilation
units of the library unit are declared pure.  In addition, the limited
view of any library package is declared pure.  The declaration and body
of a declared pure library unit, and all subunits that are elaborated as
part of elaborating the library unit, shall be pure.  All compilation
units of a declared pure library unit shall depend semantically only on
declared pure library_items.  In addition to the places where Legality
Rules normally apply (see *note 12.3::), these rules also apply in the
private part of an instance of a generic unit.  Furthermore, the full
view of any partial view declared in the visible part of a declared pure
library unit that has any available stream attributes shall support
external streaming (see *note 13.13.2::).

                         _Erroneous Execution_

17.1/4
Execution is erroneous if some operation (other than the initialization
or finalization of the object) modifies the value of a constant object
declared at library-level in a pure package.

                     _Implementation Permissions_

18/3
If a library unit is declared pure, then the implementation is permitted
to omit a call on a library-level subprogram of the library unit if the
results are not needed after the call.  In addition, the implementation
may omit a call on such a subprogram and simply reuse the results
produced by an earlier call on the same subprogram, provided that none
of the parameters nor any object accessible via access values from the
parameters have any part that is of a type whose full type is an
immutably limited type, and the addresses and values of all by-reference
actual parameters, the values of all by-copy-in actual parameters, and
the values of all objects accessible via access values from the
parameters, are the same as they were at the earlier call.  This
permission applies even if the subprogram produces other side effects
when called.

                               _Syntax_

19
     The form of a pragma Elaborate, Elaborate_All, or Elaborate_Body is
     as follows:

20
       pragma Elaborate(<library_unit_>name{, <library_unit_>name});

21
       pragma Elaborate_All(<library_unit_>name{, <library_unit_>name});

22
       pragma Elaborate_Body[(<library_unit_>name)];

23
     A pragma Elaborate or Elaborate_All is only allowed within a
     context_clause.

24
     A pragma Elaborate_Body is a library unit pragma.

                           _Legality Rules_

25/3
If the aspect Elaborate_Body is True for a declaration (including when
pragma Elaborate_Body applies), then the declaration requires a
completion (a body).

25.1/2
The <library_unit_>name of a pragma Elaborate or Elaborate_All shall
denote a nonlimited view of a library unit.

                          _Static Semantics_

26/3
A pragma Elaborate specifies that the body of the named library unit is
elaborated before the current library_item.  A pragma Elaborate_All
specifies that each library_item that is needed by the named library
unit declaration is elaborated before the current library_item.

26.1/3
A pragma Elaborate_Body sets the Elaborate_Body representation aspect of
the library unit to which it applies to the value True.  If the
Elaborate_Body aspect of a library unit is True, the body of the library
unit is elaborated immediately after its declaration.

     NOTES

27
     12  A preelaborated library unit is allowed to have
     nonpreelaborable children.

28
     13  A library unit that is declared pure is allowed to have impure
     children.


File: arm2012.info,  Node: 11,  Next: 12,  Prev: 10,  Up: Top

11 Exceptions
*************

1/3
This clause defines the facilities for dealing with errors or other
exceptional situations that arise during program execution.  An
<exception> represents a kind of exceptional situation; an occurrence of
such a situation (at run time) is called an <exception occurrence>.  To
<raise> an exception is to abandon normal program execution so as to
draw attention to the fact that the corresponding situation has arisen.Performing some actions in response to the arising of an exception is
called <handling> the exception.

2/3
An exception_declaration declares a name for an exception.  An exception
can be raised explicitly (for example, by a raise_statement) or
implicitly (for example, by the failure of a language-defined check).
When an exception arises, control can be transferred to a user-provided
exception_handler at the end of a handled_sequence_of_statements (*note
11.2: S0265.), or it can be propagated to a dynamically enclosing
execution.

* Menu:

* 11.1 ::     Exception Declarations
* 11.2 ::     Exception Handlers
* 11.3 ::     Raise Statements and Raise Expressions
* 11.4 ::     Exception Handling
* 11.5 ::     Suppressing Checks
* 11.6 ::     Exceptions and Optimization


File: arm2012.info,  Node: 11.1,  Next: 11.2,  Up: 11

11.1 Exception Declarations
===========================

1
An exception_declaration declares a name for an exception.

                               _Syntax_

2/3
     exception_declaration ::= defining_identifier_list : exception
        [aspect_specification];

                          _Static Semantics_

3
Each single exception_declaration declares a name for a different
exception.  If a generic unit includes an exception_declaration, the
exception_declarations implicitly generated by different instantiations
of the generic unit refer to distinct exceptions (but all have the same
defining_identifier).  The particular exception denoted by an exception
name is determined at compilation time and is the same regardless of how
many times the exception_declaration is elaborated.

4
The <predefined> exceptions are the ones declared in the declaration of
package Standard: Constraint_Error, Program_Error, Storage_Error, and
Tasking_Error; one of them is raised when a language-defined check
fails.

                          _Dynamic Semantics_

5
The elaboration of an exception_declaration has no effect.

6
The execution of any construct raises Storage_Error if there is
insufficient storage for that execution.  The amount of storage needed
for the execution of constructs is unspecified.

                              _Examples_

7
<Examples of user-defined exception declarations:>

8
     Singular : exception;
     Error    : exception;
     Overflow, Underflow : exception;


File: arm2012.info,  Node: 11.2,  Next: 11.3,  Prev: 11.1,  Up: 11

11.2 Exception Handlers
=======================

1
The response to one or more exceptions is specified by an
exception_handler.

                               _Syntax_

2
     handled_sequence_of_statements ::=
          sequence_of_statements
       [exception
          exception_handler
         {exception_handler}]

3
     exception_handler ::=
       when [choice_parameter_specification:] exception_choice {| 
     exception_choice} =>
          sequence_of_statements

4
     choice_parameter_specification ::= defining_identifier

5
     exception_choice ::= <exception_>name | others

                           _Legality Rules_

5.1/4
An <exception_>name of an exception_choice shall denote an exception.

6
A choice with an <exception_>name <covers> the named exception.  A
choice with others covers all exceptions not named by previous choices
of the same handled_sequence_of_statements (*note 11.2: S0265.).  Two
choices in different exception_handlers of the same
handled_sequence_of_statements (*note 11.2: S0265.) shall not cover the
same exception.

7
A choice with others is allowed only for the last handler of a
handled_sequence_of_statements and as the only choice of that handler.

8
An <exception_>name of a choice shall not denote an exception declared
in a generic formal package.

                          _Static Semantics_

9
A choice_parameter_specification declares a <choice parameter>, which is
a constant object of type Exception_Occurrence (see *note 11.4.1::).
During the handling of an exception occurrence, the choice parameter, if
any, of the handler represents the exception occurrence that is being
handled.

                          _Dynamic Semantics_

10
The execution of a handled_sequence_of_statements consists of the
execution of the sequence_of_statements (*note 5.1: S0145.).  The
optional handlers are used to handle any exceptions that are propagated
by the sequence_of_statements (*note 5.1: S0145.).

                              _Examples_

11
<Example of an exception handler:>

12
     begin
        Open(File, In_File, "input.txt");   --< see *note A.8.2::>
     exception
        when E : Name_Error =>
           Put("Cannot open input file : ");
           Put_Line(Exception_Message(E));  --< see *note 11.4.1::>
           raise;
     end;


File: arm2012.info,  Node: 11.3,  Next: 11.4,  Prev: 11.2,  Up: 11

11.3 Raise Statements and Raise Expressions
===========================================

1
A raise_statement raises an exception.

                               _Syntax_

2/2
     raise_statement ::= raise;
           | raise <exception_>name [with <string_>expression];

2.1/4
     raise_expression ::= raise <exception_>name [with <string_>
     simple_expression]

2.2/4
     If a raise_expression appears within the expression of one of the
     following contexts, the raise_expression shall appear within a pair
     of parentheses within the expression:

2.3/4
        * object_declaration;

2.4/4
        * modular_type_definition;

2.5/4
        * floating_point_definition;

2.6/4
        * ordinary_fixed_point_definition;

2.7/4
        * decimal_fixed_point_definition;

2.8/4
        * default_expression;

2.9/4
        * ancestor_part.

                           _Legality Rules_

3/4
The <exception_>name, if any, of a raise_statement or raise_expression
shall denote an exception.  A raise_statement with no <exception_>name
(that is, a <re-raise statement>) shall be within a handler, but not
within a body enclosed by that handler.

                        _Name Resolution Rules_

3.1/4
The <string_>expression or <string_>simple_expression, if any, of a
raise_statement or raise_expression is expected to be of type String.

3.2/4
The expected type for a raise_expression shall be any single type.

                          _Dynamic Semantics_

4/4
To <raise an exception> is to raise a new occurrence of that exception,
as explained in *note 11.4::.  For the execution of a raise_statement
with an <exception_>name, the named exception is raised.  Similarly, for
the evaluation of a raise_expression, the named exception is raised.  In
both of these cases, if a <string_>expression or
<string_>simple_expression is present, the expression is evaluated and
its value is associated with the exception occurrence.  For the
execution of a re-raise statement, the exception occurrence that caused
transfer of control to the innermost enclosing handler is raised again.

     NOTES

4.1/4
     1  If the evaluation of a <string_>expression or
     <string_>simple_expression raises an exception, that exception is
     propagated instead of the one denoted by the <exception_>name of
     the raise_statement or raise_expression.

                              _Examples_

5
<Examples of raise statements:>

6/2
     raise Ada.IO_Exceptions.Name_Error;   --< see *note A.13::>
     raise Queue_Error with "Buffer Full"; --< see *note 9.11::>

7
     raise;                                --< re-raise the current exception>


File: arm2012.info,  Node: 11.4,  Next: 11.5,  Prev: 11.3,  Up: 11

11.4 Exception Handling
=======================

1
When an exception occurrence is raised, normal program execution is
abandoned and control is transferred to an applicable exception_handler,
if any.  To <handle> an exception occurrence is to respond to the
exceptional event.  To <propagate> an exception occurrence is to raise
it again in another context; that is, to fail to respond to the
exceptional event in the present context.

                          _Dynamic Semantics_

2
Within a given task, if the execution of construct <a> is defined by
this International Standard to consist (in part) of the execution of
construct <b>, then while <b> is executing, the execution of <a> is said
to <dynamically enclose> the execution of <b>.  The <innermost
dynamically enclosing> execution of a given execution is the dynamically
enclosing execution that started most recently.

3
When an exception occurrence is raised by the execution of a given
construct, the rest of the execution of that construct is <abandoned>;
that is, any portions of the execution that have not yet taken place are
not performed.  The construct is first completed, and then left, as
explained in *note 7.6.1::.  Then:

4
   * If the construct is a task_body, the exception does not propagate
     further;

5
   * If the construct is the sequence_of_statements of a
     handled_sequence_of_statements that has a handler with a choice
     covering the exception, the occurrence is handled by that handler;

6
   * Otherwise, the occurrence is <propagated> to the innermost
     dynamically enclosing execution, which means that the occurrence is
     raised again in that context.

7
When an occurrence is <handled> by a given handler, the
choice_parameter_specification, if any, is first elaborated, which
creates the choice parameter and initializes it to the occurrence.
Then, the sequence_of_statements of the handler is executed; this
execution replaces the abandoned portion of the execution of the
sequence_of_statements.

     NOTES

8
     2  Note that exceptions raised in a declarative_part of a body are
     not handled by the handlers of the handled_sequence_of_statements
     (*note 11.2: S0265.) of that body.

* Menu:

* 11.4.1 ::   The Package Exceptions
* 11.4.2 ::   Pragmas Assert and Assertion_Policy
* 11.4.3 ::   Example of Exception Handling


File: arm2012.info,  Node: 11.4.1,  Next: 11.4.2,  Up: 11.4

11.4.1 The Package Exceptions
-----------------------------

                          _Static Semantics_

1
The following language-defined library package exists:

2/2
     with Ada.Streams;
     package Ada.Exceptions is
         pragma Preelaborate(Exceptions);
         type Exception_Id is private;
         pragma Preelaborable_Initialization(Exception_Id);
         Null_Id : constant Exception_Id;
         function Exception_Name(Id : Exception_Id) return String;
         function Wide_Exception_Name(Id : Exception_Id) return Wide_String;
         function Wide_Wide_Exception_Name(Id : Exception_Id)
             return Wide_Wide_String;

3/2
         type Exception_Occurrence is limited private;
         pragma Preelaborable_Initialization(Exception_Occurrence);
         type Exception_Occurrence_Access is access all Exception_Occurrence;
         Null_Occurrence : constant Exception_Occurrence;

4/3
         procedure Raise_Exception(E : in Exception_Id;
                                   Message : in String := "")
             with No_Return;
         function Exception_Message(X : Exception_Occurrence) return String;
         procedure Reraise_Occurrence(X : in Exception_Occurrence);

5/2
         function Exception_Identity(X : Exception_Occurrence)
                                     return Exception_Id;
         function Exception_Name(X : Exception_Occurrence) return String;
             --< Same as Exception_Name(Exception_Identity(X)).>
         function Wide_Exception_Name(X : Exception_Occurrence)
             return Wide_String;
             --< Same as Wide_Exception_Name(Exception_Identity(X)).>
         function Wide_Wide_Exception_Name(X : Exception_Occurrence)
             return Wide_Wide_String;
             --< Same as Wide_Wide_Exception_Name(Exception_Identity(X)).>
         function Exception_Information(X : Exception_Occurrence) return String;

6/2
         procedure Save_Occurrence(Target : out Exception_Occurrence;
                                   Source : in Exception_Occurrence);
         function Save_Occurrence(Source : Exception_Occurrence)
                                  return Exception_Occurrence_Access;

6.1/2
         procedure Read_Exception_Occurrence
            (Stream : not null access Ada.Streams.Root_Stream_Type'Class;
             Item   : out Exception_Occurrence);
         procedure Write_Exception_Occurrence
            (Stream : not null access Ada.Streams.Root_Stream_Type'Class;
             Item   : in Exception_Occurrence);

6.2/2
         for Exception_Occurrence'Read use Read_Exception_Occurrence;
         for Exception_Occurrence'Write use Write_Exception_Occurrence;

6.3/2
     private
        ... --< not specified by the language>
     end Ada.Exceptions;

7
Each distinct exception is represented by a distinct value of type
Exception_Id.  Null_Id does not represent any exception, and is the
default initial value of type Exception_Id.  Each occurrence of an
exception is represented by a value of type Exception_Occurrence.
Null_Occurrence does not represent any exception occurrence, and is the
default initial value of type Exception_Occurrence.

8/1
For a prefix E that denotes an exception, the following attribute is
defined:

9
E'Identity
               E'Identity returns the unique identity of the exception.
               The type of this attribute is Exception_Id.

10/2
Raise_Exception raises a new occurrence of the identified exception.

10.1/4
Exception_Message returns the message associated with the given
Exception_Occurrence.  For an occurrence raised by a call to
Raise_Exception, the message is the Message parameter passed to
Raise_Exception.  For the occurrence raised by a raise_statement or
raise_expression with an <exception_>name and a <string_>expression or
<string_>simple_expression, the message is the <string_>expression or
<string_>simple_expression.  For the occurrence raised by a
raise_statement or raise_expression with an <exception_>name but without
a <string_>expression or <string_>simple_expression, the message is a
string giving implementation-defined information about the exception
occurrence.  For an occurrence originally raised in some other manner
(including by the failure of a language-defined check), the message is
an unspecified string.  In all cases, Exception_Message returns a string
with lower bound 1.

10.2/2
Reraise_Occurrence reraises the specified exception occurrence.

11
Exception_Identity returns the identity of the exception of the
occurrence.

12/2
The Wide_Wide_Exception_Name functions return the full expanded name of
the exception, in upper case, starting with a root library unit.  For an
exception declared immediately within package Standard, the
defining_identifier (*note 3.1: S0022.) is returned.  The result is
implementation defined if the exception is declared within an unnamed
block_statement.

12.1/2
The Exception_Name functions (respectively, Wide_Exception_Name) return
the same sequence of graphic characters as that defined for
Wide_Wide_Exception_Name, if all the graphic characters are defined in
Character (respectively, Wide_Character); otherwise, the sequence of
characters is implementation defined, but no shorter than that returned
by Wide_Wide_Exception_Name for the same value of the argument.

12.2/2
The string returned by the Exception_Name, Wide_Exception_Name, and
Wide_Wide_Exception_Name functions has lower bound 1.

13/2
Exception_Information returns implementation-defined information about
the exception occurrence.  The returned string has lower bound 1.

14/2
Reraise_Occurrence has no effect in the case of Null_Occurrence.
Raise_Exception and Exception_Name raise Constraint_Error for a Null_Id.
Exception_Message, Exception_Name, and Exception_Information raise
Constraint_Error for a Null_Occurrence.  Exception_Identity applied to
Null_Occurrence returns Null_Id.

15
The Save_Occurrence procedure copies the Source to the Target.  The
Save_Occurrence function uses an allocator of type
Exception_Occurrence_Access to create a new object, copies the Source to
this new object, and returns an access value designating this new
object; the result may be deallocated using an instance of
Unchecked_Deallocation.

15.1/2
Write_Exception_Occurrence writes a representation of an exception
occurrence to a stream; Read_Exception_Occurrence reconstructs an
exception occurrence from a stream (including one written in a different
partition).

<Paragraph 16 was deleted.>

                     _Implementation Permissions_

17
An implementation of Exception_Name in a space-constrained environment
may return the defining_identifier (*note 3.1: S0022.) instead of the
full expanded name.

18
The string returned by Exception_Message may be truncated (to no less
than 200 characters) by the Save_Occurrence procedure (not the
function), the Reraise_Occurrence procedure, and the re-raise statement.

                        _Implementation Advice_

19
Exception_Message (by default) and Exception_Information should produce
information useful for debugging.  Exception_Message should be short
(about one line), whereas Exception_Information can be long.
Exception_Message should not include the Exception_Name.
Exception_Information should include both the Exception_Name and the
Exception_Message.


File: arm2012.info,  Node: 11.4.2,  Next: 11.4.3,  Prev: 11.4.1,  Up: 11.4

11.4.2 Pragmas Assert and Assertion_Policy
------------------------------------------

1/3
Pragma Assert is used to assert the truth of a boolean expression at a
point within a sequence of declarations or statements.

1.1/3
Assert pragmas, subtype predicates (see *note 3.2.4::), preconditions
and postconditions (see *note 6.1.1::), and type invariants (see *note
7.3.2::) are collectively referred to as <assertions>; their boolean
expressions are referred to as <assertion expressions>.

1.2/3
Pragma Assertion_Policy is used to control whether assertions are to be
ignored by the implementation, checked at run time, or handled in some
implementation-defined manner.

                               _Syntax_

2/2
     The form of a pragma Assert is as follows:

3/2
       pragma Assert([Check =>] <boolean_>expression[, [Message =>]
     <string_>expression]);

4/2
     A pragma Assert is allowed at the place where a declarative_item or
     a statement is allowed.

5/2
     The form of a pragma Assertion_Policy is as follows:

6/2
       pragma Assertion_Policy(<policy_>identifier);

6.1/3
       pragma Assertion_Policy(
              <assertion_>aspect_mark => <policy_>identifier
          {, <assertion_>aspect_mark => <policy_>identifier});

7/3
     A pragma Assertion_Policy is allowed only immediately within a
     declarative_part, immediately within a package_specification, or as
     a configuration pragma.

                        _Name Resolution Rules_

8/2
The expected type for the <boolean_>expression of a pragma Assert is any
boolean type.  The expected type for the <string_>expression of a pragma
Assert is type String.

                           _Legality Rules_

9/3
The <assertion_>aspect_mark of a pragma Assertion_Policy shall be one of
Assert, Static_Predicate, Dynamic_Predicate, Pre, Pre'Class, Post,
Post'Class, Type_Invariant, Type_Invariant'Class, or some implementation
defined aspect_mark.  The <policy_>identifier shall be either Check,
Ignore, or some implementation-defined identifier.

                          _Static Semantics_

10/3
A pragma Assertion_Policy determines for each assertion aspect named in
the pragma_argument_associations whether assertions of the given aspect
are to be enforced by a run-time check.  The <policy_>identifier Check
requires that assertion expressions of the given aspect be checked that
they evaluate to True at the points specified for the given aspect; the
<policy_>identifier Ignore requires that the assertion expression not be
evaluated at these points, and the run-time checks not be performed.
Note that for subtype predicate aspects (see *note 3.2.4::), even when
the applicable Assertion_Policy is Ignore, the predicate will still be
evaluated as part of membership tests and Valid attribute_references,
and if static, will still have an effect on loop iteration over the
subtype, and the selection of case_statement_alternatives and variants.

10.1/3
If no <assertion_>aspect_marks are specified in the pragma, the
specified policy applies to all assertion aspects.

10.2/3
A pragma Assertion_Policy applies to the named assertion aspects in a
specific region, and applies to all assertion expressions specified in
that region.  A pragma Assertion_Policy given in a declarative_part or
immediately within a package_specification applies from the place of the
pragma to the end of the innermost enclosing declarative region.  The
region for a pragma Assertion_Policy given as a configuration pragma is
the declarative region for the entire compilation unit (or units) to
which it applies.

10.3/3
If a pragma Assertion_Policy applies to a generic_instantiation, then
the pragma Assertion_Policy applies to the entire instance.

10.4/3
If multiple Assertion_Policy pragmas apply to a given construct for a
given assertion aspect, the assertion policy is determined by the one in
the innermost enclosing region of a pragma Assertion_Policy specifying a
policy for the assertion aspect.  If no such Assertion_Policy pragma
exists, the policy is implementation defined.

11/2
The following language-defined library package exists:

12/2
     package Ada.Assertions is
        pragma Pure(Assertions);

13/2
        Assertion_Error : exception;

14/2
        procedure Assert(Check : in Boolean);
        procedure Assert(Check : in Boolean; Message : in String);

15/2
     end Ada.Assertions;

16/3
A compilation unit containing a check for an assertion (including a
pragma Assert) has a semantic dependence on the Assertions library unit.

17/3
<This paragraph was deleted.>

                          _Dynamic Semantics_

18/3
If performing checks is required by the Assert assertion policy in
effect at the place of a pragma Assert, the elaboration of the pragma
consists of evaluating the boolean expression, and if the result is
False, evaluating the Message argument, if any, and raising the
exception Assertions.Assertion_Error, with a message if the Message
argument is provided.

19/2
Calling the procedure Assertions.Assert without a Message parameter is
equivalent to:

20/2
     if Check = False then
        raise Ada.Assertions.Assertion_Error;
     end if;

21/2
Calling the procedure Assertions.Assert with a Message parameter is
equivalent to:

22/2
     if Check = False then
        raise Ada.Assertions.Assertion_Error with Message;
     end if;

23/2
The procedures Assertions.Assert have these effects independently of the
assertion policy in effect.

                      _Bounded (Run-Time) Errors_

23.1/3
It is a bounded error to invoke a potentially blocking operation (see
*note 9.5.1::) during the evaluation of an assertion expression
associated with a call on, or return from, a protected operation.  If
the bounded error is detected, Program_Error is raised.  If not
detected, execution proceeds normally, but if it is invoked within a
protected action, it might result in deadlock or a (nested) protected
action.

                     _Implementation Permissions_

24/2
Assertion_Error may be declared by renaming an implementation-defined
exception from another package.

25/2
Implementations may define their own assertion policies.

26/3
If the result of a function call in an assertion is not needed to
determine the value of the assertion expression, an implementation is
permitted to omit the function call.  This permission applies even if
the function has side effects.

27/3
An implementation need not allow the specification of an assertion
expression if the evaluation of the expression has a side effect such
that an immediate reevaluation of the expression could produce a
different value.  Similarly, an implementation need not allow the
specification of an assertion expression that is checked as part of a
call on or return from a callable entity <C>, if the evaluation of the
expression has a side effect such that the evaluation of some other
assertion expression associated with the same call of (or return from)
<C> could produce a different value than it would if the first
expression had not been evaluated.

     NOTES

28/2
     3  Normally, the boolean expression in a pragma Assert should not
     call functions that have significant side effects when the result
     of the expression is True, so that the particular assertion policy
     in effect will not affect normal operation of the program.


File: arm2012.info,  Node: 11.4.3,  Prev: 11.4.2,  Up: 11.4

11.4.3 Example of Exception Handling
------------------------------------

                              _Examples_

1
Exception handling may be used to separate the detection of an error
from the response to that error:

2/2
     package File_System is
         type File_Handle is limited private;

3
         File_Not_Found : exception;
         procedure Open(F : in out File_Handle; Name : String);
             --< raises File_Not_Found if named file does not exist>

4
         End_Of_File : exception;
         procedure Read(F : in out File_Handle; Data : out Data_Type);
             --< raises End_Of_File if the file is not open>

5
         ...
     end File_System;

6/2
     package body File_System is
         procedure Open(F : in out File_Handle; Name : String) is
         begin
             if File_Exists(Name) then
                 ...
             else
                 raise File_Not_Found with "File not found: " & Name & ".";
             end if;
         end Open;

7
         procedure Read(F : in out File_Handle; Data : out Data_Type) is
         begin
             if F.Current_Position <= F.Last_Position then
                 ...
             else
                 raise End_Of_File;
             end if;
         end Read;

8
         ...

9
     end File_System;

10
     with Ada.Text_IO;
     with Ada.Exceptions;
     with File_System; use File_System;
     use Ada;
     procedure Main is
     begin
         ... --< call operations in File_System>
     exception
         when End_Of_File =>
             Close(Some_File);
         when Not_Found_Error : File_Not_Found =>
             Text_IO.Put_Line(Exceptions.Exception_Message(Not_Found_Error));
         when The_Error : others =>
             Text_IO.Put_Line("Unknown error:");
             if Verbosity_Desired then
                 Text_IO.Put_Line(Exceptions.Exception_Information(The_Error));
             else
                 Text_IO.Put_Line(Exceptions.Exception_Name(The_Error));
                 Text_IO.Put_Line(Exceptions.Exception_Message(The_Error));
             end if;
             raise;
     end Main;

11
In the above example, the File_System package contains information about
detecting certain exceptional situations, but it does not specify how to
handle those situations.  Procedure Main specifies how to handle them;
other clients of File_System might have different handlers, even though
the exceptional situations arise from the same basic causes.


File: arm2012.info,  Node: 11.5,  Next: 11.6,  Prev: 11.4,  Up: 11

11.5 Suppressing Checks
=======================

1/2
<Checking pragmas> give instructions to an implementation on handling
language-defined checks.  A pragma Suppress gives permission to an
implementation to omit certain language-defined checks, while a pragma
Unsuppress revokes the permission to omit checks..

2/3
A <language-defined check> (or simply, a "check") is one of the
situations defined by this International Standard that requires a check
to be made at run time to determine whether some condition is true.  A
check <fails> when the condition being checked is False, causing an
exception to be raised.

                               _Syntax_

3/2
     The forms of checking pragmas are as follows:

4/2
       pragma Suppress(identifier);

4.1/2
       pragma Unsuppress(identifier);

5/2
     A checking pragma is allowed only immediately within a
     declarative_part, immediately within a package_specification (*note
     7.1: S0191.), or as a configuration pragma.

                           _Legality Rules_

6/2
The identifier shall be the name of a check.

7/2
<This paragraph was deleted.>

                          _Static Semantics_

7.1/2
A checking pragma applies to the named check in a specific region, and
applies to all entities in that region.  A checking pragma given in a
declarative_part or immediately within a package_specification applies
from the place of the pragma to the end of the innermost enclosing
declarative region.  The region for a checking pragma given as a
configuration pragma is the declarative region for the entire
compilation unit (or units) to which it applies.

7.2/3
If a checking pragma applies to a generic_instantiation, then the
checking pragma also applies to the entire instance.

8/2
A pragma Suppress gives permission to an implementation to omit the
named check (or every check in the case of All_Checks) for any entities
to which it applies.  If permission has been given to suppress a given
check, the check is said to be <suppressed>.

8.1/2
A pragma Unsuppress revokes the permission to omit the named check (or
every check in the case of All_Checks) given by any pragma Suppress that
applies at the point of the pragma Unsuppress.  The permission is
revoked for the region to which the pragma Unsuppress applies.  If there
is no such permission at the point of a pragma Unsuppress, then the
pragma has no effect.  A later pragma Suppress can renew the permission.

9
The following are the language-defined checks:

10
   * The following checks correspond to situations in which the
     exception Constraint_Error is raised upon failure.

11/2
Access_Check
               When evaluating a dereference (explicit or implicit),
               check that the value of the name is not null.  When
               converting to a subtype that excludes null, check that
               the converted value is not null.

12
Discriminant_Check
               Check that the discriminants of a composite value have
               the values imposed by a discriminant constraint.  Also,
               when accessing a record component, check that it exists
               for the current discriminant values.

13/2
Division_Check
               Check that the second operand is not zero for the
               operations /, rem and mod.

14
Index_Check
               Check that the bounds of an array value are equal to the
               corresponding bounds of an index constraint.  Also, when
               accessing a component of an array object, check for each
               dimension that the given index value belongs to the range
               defined by the bounds of the array object.  Also, when
               accessing a slice of an array object, check that the
               given discrete range is compatible with the range defined
               by the bounds of the array object.

15
Length_Check
               Check that two arrays have matching components, in the
               case of array subtype conversions, and logical operators
               for arrays of boolean components.

16
Overflow_Check
               Check that a scalar value is within the base range of its
               type, in cases where the implementation chooses to raise
               an exception instead of returning the correct
               mathematical result.

17
Range_Check
               Check that a scalar value satisfies a range constraint.
               Also, for the elaboration of a subtype_indication, check
               that the constraint (if present) is compatible with the
               subtype denoted by the subtype_mark.  Also, for an
               aggregate, check that an index or discriminant value
               belongs to the corresponding subtype.  Also, check that
               when the result of an operation yields an array, the
               value of each component belongs to the component subtype.

18
Tag_Check
               Check that operand tags in a dispatching call are all
               equal.  Check for the correct tag on tagged type
               conversions, for an assignment_statement, and when
               returning a tagged limited object from a function.

19
   * The following checks correspond to situations in which the
     exception Program_Error is raised upon failure.

19.1/2
Accessibility_Check
               Check the accessibility level of an entity or view.

19.2/2
Allocation_Check
               For an allocator, check that the master of any tasks to
               be created by the allocator is not yet completed or some
               dependents have not yet terminated, and that the
               finalization of the collection has not started.

20
Elaboration_Check
               When a subprogram or protected entry is called, a task
               activation is accomplished, or a generic instantiation is
               elaborated, check that the body of the corresponding unit
               has already been elaborated.

21/2

               <This paragraph was deleted.>

22
   * The following check corresponds to situations in which the
     exception Storage_Error is raised upon failure.

23
Storage_Check
               Check that evaluation of an allocator does not require
               more space than is available for a storage pool.  Check
               that the space available for a task or subprogram has not
               been exceeded.

24
   * The following check corresponds to all situations in which any
     predefined exception is raised.

25/3
All_Checks
               Represents the union of all checks; suppressing
               All_Checks suppresses all checks other than those
               associated with assertions.  In addition, an
               implementation is allowed (but not required) to behave as
               if a pragma Assertion_Policy(Ignore) applies to any
               region to which pragma Suppress(All_Checks) applies.

                         _Erroneous Execution_

26
If a given check has been suppressed, and the corresponding error
situation occurs, the execution of the program is erroneous.

                     _Implementation Permissions_

27/2
An implementation is allowed to place restrictions on checking pragmas,
subject only to the requirement that pragma Unsuppress shall allow any
check names supported by pragma Suppress.  An implementation is allowed
to add additional check names, with implementation-defined semantics.
When Overflow_Check has been suppressed, an implementation may also
suppress an unspecified subset of the Range_Checks.

27.1/2
An implementation may support an additional parameter on pragma
Unsuppress similar to the one allowed for pragma Suppress (see *note
J.10::).  The meaning of such a parameter is implementation-defined.

                        _Implementation Advice_

28
The implementation should minimize the code executed for checks that
have been suppressed.

     NOTES

29
     4  There is no guarantee that a suppressed check is actually
     removed; hence a pragma Suppress should be used only for efficiency
     reasons.

29.1/2
     5  It is possible to give both a pragma Suppress and Unsuppress for
     the same check immediately within the same declarative_part.  In
     that case, the last pragma given determines whether or not the
     check is suppressed.  Similarly, it is possible to resuppress a
     check which has been unsuppressed by giving a pragma Suppress in an
     inner declarative region.

                              _Examples_

30/2
<Examples of suppressing and unsuppressing checks:>

31/2
     pragma Suppress(Index_Check);
     pragma Unsuppress(Overflow_Check);


File: arm2012.info,  Node: 11.6,  Prev: 11.5,  Up: 11

11.6 Exceptions and Optimization
================================

1/3
This subclause gives permission to the implementation to perform certain
"optimizations" that do not necessarily preserve the canonical
semantics.

                          _Dynamic Semantics_

2/3
The rest of this International Standard (outside this subclause) defines
the <canonical semantics> of the language.  The canonical semantics of a
given (legal) program determines a set of possible external effects that
can result from the execution of the program with given inputs.

3/3
As explained in *note 1.1.3::, "*note 1.1.3:: Conformity of an
Implementation with the Standard", the external effect of a program is
defined in terms of its interactions with its external environment.
Hence, the implementation can perform any internal actions whatsoever,
in any order or in parallel, so long as the external effect of the
execution of the program is one that is allowed by the canonical
semantics, or by the rules of this subclause.

                     _Implementation Permissions_

4
The following additional permissions are granted to the implementation:

5
   * An implementation need not always raise an exception when a
     language-defined check fails.  Instead, the operation that failed
     the check can simply yield an <undefined result>.  The exception
     need be raised by the implementation only if, in the absence of
     raising it, the value of this undefined result would have some
     effect on the external interactions of the program.  In determining
     this, the implementation shall not presume that an undefined result
     has a value that belongs to its subtype, nor even to the base range
     of its type, if scalar.  Having removed the raise of the exception,
     the canonical semantics will in general allow the implementation to
     omit the code for the check, and some or all of the operation
     itself.

6/3
   * If an exception is raised due to the failure of a language-defined
     check, then upon reaching the corresponding exception_handler (or
     the termination of the task, if none), the external interactions
     that have occurred need reflect only that the exception was raised
     somewhere within the execution of the sequence_of_statements with
     the handler (or the task_body), possibly earlier (or later if the
     interactions are independent of the result of the checked
     operation) than that defined by the canonical semantics, but not
     within the execution of some abort-deferred operation or
     <independent> subprogram that does not dynamically enclose the
     execution of the construct whose check failed.  An independent
     subprogram is one that is defined outside the library unit
     containing the construct whose check failed, and for which the
     Inline aspect is False.  Any assignment that occurred outside of
     such abort-deferred operations or independent subprograms can be
     disrupted by the raising of the exception, causing the object or
     its parts to become abnormal, and certain subsequent uses of the
     object to be erroneous, as explained in *note 13.9.1::.

     NOTES

7/3
     6  The permissions granted by this subclause can have an effect on
     the semantics of a program only if the program fails a
     language-defined check.


File: arm2012.info,  Node: 12,  Next: 13,  Prev: 11,  Up: Top

12 Generic Units
****************

1
A <generic unit> is a program unit that is either a generic subprogram
or a generic package.  A generic unit is a <template>, which can be
parameterized, and from which corresponding (nongeneric) subprograms or
packages can be obtained.  The resulting program units are said to be
<instances> of the original generic unit.  

2
A generic unit is declared by a generic_declaration.  This form of
declaration has a generic_formal_part (*note 12.1: S0274.) declaring any
generic formal parameters.  An instance of a generic unit is obtained as
the result of a generic_instantiation with appropriate generic actual
parameters for the generic formal parameters.  An instance of a generic
subprogram is a subprogram.  An instance of a generic package is a
package.

3
Generic units are templates.  As templates they do not have the
properties that are specific to their nongeneric counterparts.  For
example, a generic subprogram can be instantiated but it cannot be
called.  In contrast, an instance of a generic subprogram is a
(nongeneric) subprogram; hence, this instance can be called but it
cannot be used to produce further instances.

* Menu:

* 12.1 ::     Generic Declarations
* 12.2 ::     Generic Bodies
* 12.3 ::     Generic Instantiation
* 12.4 ::     Formal Objects
* 12.5 ::     Formal Types
* 12.6 ::     Formal Subprograms
* 12.7 ::     Formal Packages
* 12.8 ::     Example of a Generic Package


File: arm2012.info,  Node: 12.1,  Next: 12.2,  Up: 12

12.1 Generic Declarations
=========================

1
A generic_declaration declares a generic unit, which is either a generic
subprogram or a generic package.  A generic_declaration includes a
generic_formal_part declaring any generic formal parameters.  A generic
formal parameter can be an object; alternatively (unlike a parameter of
a subprogram), it can be a type, a subprogram, or a package.

                               _Syntax_

2
     generic_declaration ::= generic_subprogram_declaration | 
     generic_package_declaration

3/3
     generic_subprogram_declaration ::=
          generic_formal_part  subprogram_specification
             [aspect_specification];

4
     generic_package_declaration ::=
          generic_formal_part  package_specification;

5
     generic_formal_part ::= generic {
     generic_formal_parameter_declaration | use_clause}

6
     generic_formal_parameter_declaration ::=
           formal_object_declaration
         | formal_type_declaration
         | formal_subprogram_declaration
         | formal_package_declaration

7
     The only form of subtype_indication allowed within a
     generic_formal_part is a subtype_mark (that is, the
     subtype_indication shall not include an explicit constraint).  The
     defining name of a generic subprogram shall be an identifier (not
     an operator_symbol).

                          _Static Semantics_

8/2
A generic_declaration declares a generic unit -- a generic package,
generic procedure, or generic function, as appropriate.

9
An entity is a <generic formal> entity if it is declared by a
generic_formal_parameter_declaration.  "Generic formal," or simply
"formal," is used as a prefix in referring to objects, subtypes (and
types), functions, procedures and packages, that are generic formal
entities, as well as to their respective declarations.  Examples:
"generic formal procedure" or a "formal integer type declaration."

                          _Dynamic Semantics_

10
The elaboration of a generic_declaration has no effect.

     NOTES

11
     1  Outside a generic unit a name that denotes the
     generic_declaration denotes the generic unit.  In contrast, within
     the declarative region of the generic unit, a name that denotes the
     generic_declaration denotes the current instance.

12
     2  Within a generic subprogram_body, the name of this program unit
     acts as the name of a subprogram.  Hence this name can be
     overloaded, and it can appear in a recursive call of the current
     instance.  For the same reason, this name cannot appear after the
     reserved word new in a (recursive) generic_instantiation.

13
     3  A default_expression or default_name appearing in a
     generic_formal_part is not evaluated during elaboration of the
     generic_formal_part; instead, it is evaluated when used.  (The
     usual visibility rules apply to any name used in a default: the
     denoted declaration therefore has to be visible at the place of the
     expression.)

                              _Examples_

14
<Examples of generic formal parts:>

15
     generic     --<  parameterless >

16
     generic
        Size : Natural;  --<  formal object >

17
     generic
        Length : Integer := 200;          --< formal object with a default expression>

18
        Area   : Integer := Length*Length; --< formal object with a default expression>

19
     generic
        type Item  is private;                       --< formal type>
        type Index is (<>);                          --< formal type>
        type Row   is array(Index range <>) of Item; --< formal type>
        with function "<"(X, Y : Item) return Boolean;    --< formal subprogram >

20
<Examples of generic declarations declaring generic subprograms Exchange
and Squaring:>

21
     generic
        type Elem is private;
     procedure Exchange(U, V : in out Elem);

22
     generic
        type Item is private;
        with function "*"(U, V : Item) return Item is <>;
     function Squaring(X : Item) return Item;

23
<Example of a generic declaration declaring a generic package:>

24
     generic
        type Item   is private;
        type Vector is array (Positive range <>) of Item;
        with function Sum(X, Y : Item) return Item;
     package On_Vectors is
        function Sum  (A, B : Vector) return Vector;
        function Sigma(A    : Vector) return Item;
        Length_Error : exception;
     end On_Vectors;


File: arm2012.info,  Node: 12.2,  Next: 12.3,  Prev: 12.1,  Up: 12

12.2 Generic Bodies
===================

1
The body of a generic unit (a <generic body>) is a template for the
instance bodies.  The syntax of a generic body is identical to that of a
nongeneric body.

                          _Dynamic Semantics_

2
The elaboration of a generic body has no other effect than to establish
that the generic unit can from then on be instantiated without failing
the Elaboration_Check.  If the generic body is a child of a generic
package, then its elaboration establishes that each corresponding
declaration nested in an instance of the parent (see *note 10.1.1::) can
from then on be instantiated without failing the Elaboration_Check.

     NOTES

3
     4  The syntax of generic subprograms implies that a generic
     subprogram body is always the completion of a declaration.

                              _Examples_

4
<Example of a generic procedure body:>

5
     procedure Exchange(U, V : in out Elem) is  --< see *note 12.1::>
        T : Elem;  --<  the generic formal type>
     begin
        T := U;
        U := V;
        V := T;
     end Exchange;

6
<Example of a generic function body:>

7
     function Squaring(X : Item) return Item is  --<  see *note 12.1::>
     begin
        return X*X;  --<  the formal operator "*">
     end Squaring;

8
<Example of a generic package body:>

9
     package body On_Vectors is  --<  see *note 12.1::>

10
        function Sum(A, B : Vector) return Vector is
           Result : Vector(A'Range); --<  the formal type Vector>
           Bias   : constant Integer := B'First - A'First;
        begin
           if A'Length /= B'Length then
              raise Length_Error;
           end if;

11
           for N in A'Range loop
              Result(N) := Sum(A(N), B(N + Bias)); --< the formal function Sum>
           end loop;
           return Result;
        end Sum;

12
        function Sigma(A : Vector) return Item is
           Total : Item := A(A'First); --<  the formal type Item>
        begin
           for N in A'First + 1 .. A'Last loop
              Total := Sum(Total, A(N)); --<  the formal function Sum>
           end loop;
           return Total;
        end Sigma;
     end On_Vectors;


File: arm2012.info,  Node: 12.3,  Next: 12.4,  Prev: 12.2,  Up: 12

12.3 Generic Instantiation
==========================

1
An instance of a generic unit is declared by a generic_instantiation.

                               _Syntax_

2/3
     generic_instantiation ::=
          package defining_program_unit_name is
              new <generic_package_>name [generic_actual_part]
                 [aspect_specification];
        | [overriding_indicator]
          procedure defining_program_unit_name is
              new <generic_procedure_>name [generic_actual_part]
                 [aspect_specification];
        | [overriding_indicator]
          function defining_designator is
              new <generic_function_>name [generic_actual_part]
                 [aspect_specification];

3
     generic_actual_part ::=
        (generic_association {, generic_association})

4
     generic_association ::=
        [<generic_formal_parameter_>selector_name =>] 
     explicit_generic_actual_parameter

5
     explicit_generic_actual_parameter ::= expression | <variable_>name
        | <subprogram_>name | <entry_>name | subtype_mark
        | <package_instance_>name

6
     A generic_association is <named> or <positional> according to
     whether or not the <generic_formal_parameter_>selector_name (*note
     4.1.3: S0099.) is specified.  Any positional associations shall
     precede any named associations.

7/3
The <generic actual parameter> is either the
explicit_generic_actual_parameter given in a generic_association (*note
12.3: S0278.) for each formal, or the corresponding default_expression
(*note 3.7: S0063.) or default_name (*note 12.6: S0300.) if no
generic_association (*note 12.3: S0278.) is given for the formal.  When
the meaning is clear from context, the term "generic actual," or simply
"actual," is used as a synonym for "generic actual parameter" and also
for the view denoted by one, or the value of one.

                           _Legality Rules_

8
In a generic_instantiation for a particular kind of program unit
(package, procedure, or function), the name shall denote a generic unit
of the corresponding kind (generic package, generic procedure, or
generic function, respectively).

9/3
The <generic_formal_parameter_>selector_name of a named
generic_association shall denote a generic_formal_parameter_declaration
of the generic unit being instantiated.  If two or more formal
subprograms have the same defining name, then named associations are not
allowed for the corresponding actuals.

9.1/3
The generic_formal_parameter_declaration for a positional
generic_association is the parameter with the corresponding position in
the generic_formal_part of the generic unit being instantiated.

10
A generic_instantiation shall contain at most one generic_association
for each formal.  Each formal without an association shall have a
default_expression or subprogram_default.

11
In a generic unit Legality Rules are enforced at compile time of the
generic_declaration and generic body, given the properties of the
formals.  In the visible part and formal part of an instance, Legality
Rules are enforced at compile time of the generic_instantiation, given
the properties of the actuals.  In other parts of an instance, Legality
Rules are not enforced; this rule does not apply when a given rule
explicitly specifies otherwise.

                          _Static Semantics_

12
A generic_instantiation declares an instance; it is equivalent to the
instance declaration (a package_declaration (*note 7.1: S0190.) or
subprogram_declaration (*note 6.1: S0163.)) immediately followed by the
instance body, both at the place of the instantiation.

13
The instance is a copy of the text of the template.  Each use of a
formal parameter becomes (in the copy) a use of the actual, as explained
below.  An instance of a generic package is a package, that of a generic
procedure is a procedure, and that of a generic function is a function.

14
The interpretation of each construct within a generic declaration or
body is determined using the overloading rules when that generic
declaration or body is compiled.  In an instance, the interpretation of
each (copied) construct is the same, except in the case of a name that
denotes the generic_declaration or some declaration within the generic
unit; the corresponding name in the instance then denotes the
corresponding copy of the denoted declaration.  The overloading rules do
not apply in the instance.

15
In an instance, a generic_formal_parameter_declaration declares a view
whose properties are identical to those of the actual, except as
specified in *note 12.4::, "*note 12.4:: Formal Objects" and *note
12.6::, "*note 12.6:: Formal Subprograms".  Similarly, for a declaration
within a generic_formal_parameter_declaration, the corresponding
declaration in an instance declares a view whose properties are
identical to the corresponding declaration within the declaration of the
actual.

16
Implicit declarations are also copied, and a name that denotes an
implicit declaration in the generic denotes the corresponding copy in
the instance.  However, for a type declared within the visible part of
the generic, a whole new set of primitive subprograms is implicitly
declared for use outside the instance, and may differ from the copied
set if the properties of the type in some way depend on the properties
of some actual type specified in the instantiation.  For example, if the
type in the generic is derived from a formal private type, then in the
instance the type will inherit subprograms from the corresponding actual
type.

17
These new implicit declarations occur immediately after the type
declaration in the instance, and override the copied ones.  The copied
ones can be called only from within the instance; the new ones can be
called only from outside the instance, although for tagged types, the
body of a new one can be executed by a call to an old one.

18
In the visible part of an instance, an explicit declaration overrides an
implicit declaration if they are homographs, as described in *note
8.3::.  On the other hand, an explicit declaration in the private part
of an instance overrides an implicit declaration in the instance, only
if the corresponding explicit declaration in the generic overrides a
corresponding implicit declaration in the generic.  Corresponding rules
apply to the other kinds of overriding described in *note 8.3::.

                       _Post-Compilation Rules_

19
Recursive generic instantiation is not allowed in the following sense:
if a given generic unit includes an instantiation of a second generic
unit, then the instance generated by this instantiation shall not
include an instance of the first generic unit (whether this instance is
generated directly, or indirectly by intermediate instantiations).

                          _Dynamic Semantics_

20
For the elaboration of a generic_instantiation, each generic_association
is first evaluated.  If a default is used, an implicit
generic_association is assumed for this rule.  These evaluations are
done in an arbitrary order, except that the evaluation for a default
actual takes place after the evaluation for another actual if the
default includes a name that denotes the other one.  Finally, the
instance declaration and body are elaborated.

21
For the evaluation of a generic_association the generic actual parameter
is evaluated.  Additional actions are performed in the case of a formal
object of mode in (see *note 12.4::).

     NOTES

22
     5  If a formal type is not tagged, then the type is treated as an
     untagged type within the generic body.  Deriving from such a type
     in a generic body is permitted; the new type does not get a new tag
     value, even if the actual is tagged.  Overriding operations for
     such a derived type cannot be dispatched to from outside the
     instance.

                              _Examples_

23
<Examples of generic instantiations (see *note 12.1::):>

24
     procedure Swap is new Exchange(Elem => Integer);
     procedure Swap is new Exchange(Character);     --<  Swap is overloaded >
     function Square is new Squaring(Integer);    --<  "*" of Integer used by default>
     function Square is new Squaring(Item => Matrix, "*" => Matrix_Product);
     function Square is new Squaring(Matrix, Matrix_Product); --< same as previous    >

25
     package Int_Vectors is new On_Vectors(Integer, Table, "+");

26
<Examples of uses of instantiated units:>

27
     Swap(A, B);
     A := Square(A);

28
     T : Table(1 .. 5) := (10, 20, 30, 40, 50);
     N : Integer := Int_Vectors.Sigma(T);  --<  150 (see *note 12.2::, "*note 12.2:: Generic Bodies" for the body of Sigma)>

29
     use Int_Vectors;
     M : Integer := Sigma(T);  --<  150>


File: arm2012.info,  Node: 12.4,  Next: 12.5,  Prev: 12.3,  Up: 12

12.4 Formal Objects
===================

1
A generic formal object can be used to pass a value or variable to a
generic unit.

                               _Syntax_

2/3
     formal_object_declaration ::=
         defining_identifier_list : mode [null_exclusion] 
     subtype_mark [:= default_expression]
             [aspect_specification];
       |  defining_identifier_list : mode access_definition [:= 
     default_expression]
             [aspect_specification];

                        _Name Resolution Rules_

3
The expected type for the default_expression, if any, of a formal object
is the type of the formal object.

4
For a generic formal object of mode in, the expected type for the actual
is the type of the formal.

5/2
For a generic formal object of mode in out, the type of the actual shall
resolve to the type determined by the subtype_mark, or for a
formal_object_declaration with an access_definition, to a specific
anonymous access type.  If the anonymous access type is an
access-to-object type, the type of the actual shall have the same
designated type as that of the access_definition.  If the anonymous
access type is an access-to-subprogram type, the type of the actual
shall have a designated profile which is type conformant with that of
the access_definition.  

                           _Legality Rules_

6
If a generic formal object has a default_expression, then the mode shall
be in (either explicitly or by default); otherwise, its mode shall be
either in or in out.

7
For a generic formal object of mode in, the actual shall be an
expression.  For a generic formal object of mode in out, the actual
shall be a name that denotes a variable for which renaming is allowed
(see *note 8.5.1::).

8/2
In the case where the type of the formal is defined by an
access_definition, the type of the actual and the type of the formal:

8.1/2
   * shall both be access-to-object types with statically matching
     designated subtypes and with both or neither being
     access-to-constant types; or 

8.2/2
   * shall both be access-to-subprogram types with subtype conformant
     designated profiles.  

8.3/2
For a formal_object_declaration with a null_exclusion or an
access_definition that has a null_exclusion:

8.4/2
   * if the actual matching the formal_object_declaration denotes the
     generic formal object of another generic unit <G>, and the
     instantiation containing the actual occurs within the body of <G>
     or within the body of a generic unit declared within the
     declarative region of <G>, then the declaration of the formal
     object of <G> shall have a null_exclusion;

8.5/2
   * otherwise, the subtype of the actual matching the
     formal_object_declaration shall exclude null.  In addition to the
     places where Legality Rules normally apply (see *note 12.3::), this
     rule applies also in the private part of an instance of a generic
     unit.

                          _Static Semantics_

9/2
A formal_object_declaration declares a generic formal object.  The
default mode is in.  For a formal object of mode in, the nominal subtype
is the one denoted by the subtype_mark or access_definition in the
declaration of the formal.  For a formal object of mode in out, its type
is determined by the subtype_mark or access_definition in the
declaration; its nominal subtype is nonstatic, even if the subtype_mark
denotes a static subtype; for a composite type, its nominal subtype is
unconstrained if the first subtype of the type is unconstrained, even if
the subtype_mark denotes a constrained subtype.

10/2
In an instance, a formal_object_declaration of mode in is a <full
constant declaration> and declares a new stand-alone constant object
whose initialization expression is the actual, whereas a
formal_object_declaration of mode in out declares a view whose
properties are identical to those of the actual.

                          _Dynamic Semantics_

11
For the evaluation of a generic_association for a formal object of mode
in, a constant object is created, the value of the actual parameter is
converted to the nominal subtype of the formal object, and assigned to
the object, including any value adjustment -- see *note 7.6::.  

     NOTES

12
     6  The constraints that apply to a generic formal object of mode in
     out are those of the corresponding generic actual parameter (not
     those implied by the subtype_mark that appears in the
     formal_object_declaration).  Therefore, to avoid confusion, it is
     recommended that the name of a first subtype be used for the
     declaration of such a formal object.


File: arm2012.info,  Node: 12.5,  Next: 12.6,  Prev: 12.4,  Up: 12

12.5 Formal Types
=================

1/2
A generic formal subtype can be used to pass to a generic unit a subtype
whose type is in a certain category of types.

                               _Syntax_

2/3
     formal_type_declaration ::=
           formal_complete_type_declaration
         | formal_incomplete_type_declaration

2.1/3
     formal_complete_type_declaration ::=
         type defining_identifier[discriminant_part] is 
     formal_type_definition
             [aspect_specification];

2.2/3
     formal_incomplete_type_declaration ::=
         type defining_identifier[discriminant_part] [is tagged];

3/2
     formal_type_definition ::=
           formal_private_type_definition
         | formal_derived_type_definition
         | formal_discrete_type_definition
         | formal_signed_integer_type_definition
         | formal_modular_type_definition
         | formal_floating_point_definition
         | formal_ordinary_fixed_point_definition
         | formal_decimal_fixed_point_definition
         | formal_array_type_definition
         | formal_access_type_definition
         | formal_interface_type_definition

                           _Legality Rules_

4
For a generic formal subtype, the actual shall be a subtype_mark; it
denotes the <(generic) actual subtype>.

                          _Static Semantics_

5
A formal_type_declaration declares a <(generic) formal type>, and its
first subtype, the <(generic) formal subtype>.

6/3
The form of a formal_type_definition <determines a category (of types)>
to which the formal type belongs.  For a formal_private_type_definition
the reserved words tagged and limited indicate the category of types
(see *note 12.5.1::).  The reserved word tagged also plays this role in
the case of a formal_incomplete_type_declaration.  For a
formal_derived_type_definition the category of types is the derivation
class rooted at the ancestor type.  For other formal types, the name of
the syntactic category indicates the category of types; a
formal_discrete_type_definition defines a discrete type, and so on.

                           _Legality Rules_

7/2
The actual type shall be in the category determined for the formal.

                          _Static Semantics_

8/3
The formal type also belongs to each category that contains the
determined category.  The primitive subprograms of the type are as for
any type in the determined category.  For a formal type other than a
formal derived type, these are the predefined operators of the type.
For an elementary formal type, the predefined operators are implicitly
declared immediately after the declaration of the formal type.  For a
composite formal type, the predefined operators are implicitly declared
either immediately after the declaration of the formal type, or later
immediately within the declarative region in which the type is declared
according to the rules of *note 7.3.1::.  In an instance, the copy of
such an implicit declaration declares a view of the predefined operator
of the actual type, even if this operator has been overridden for the
actual type and even if it is never declared for the actual type.  The
rules specific to formal derived types are given in *note 12.5.1::.

     NOTES

9
     7  Generic formal types, like all types, are not named.  Instead, a
     name can denote a generic formal subtype.  Within a generic unit, a
     generic formal type is considered as being distinct from all other
     (formal or nonformal) types.

10
     8  A discriminant_part is allowed only for certain kinds of types,
     and therefore only for certain kinds of generic formal types.  See
     *note 3.7::.

                              _Examples_

11
<Examples of generic formal types:>

12
     type Item is private;
     type Buffer(Length : Natural) is limited private;

13
     type Enum  is (<>);
     type Int   is range <>;
     type Angle is delta <>;
     type Mass  is digits <>;

14
     type Table is array (Enum) of Item;

15
<Example of a generic formal part declaring a formal integer type:>

16
     generic
        type Rank is range <>;
        First  : Rank := Rank'First;
        Second : Rank := First + 1;  --<  the operator "+" of the type Rank  >

* Menu:

* 12.5.1 ::   Formal Private and Derived Types
* 12.5.2 ::   Formal Scalar Types
* 12.5.3 ::   Formal Array Types
* 12.5.4 ::   Formal Access Types
* 12.5.5 ::   Formal Interface Types


File: arm2012.info,  Node: 12.5.1,  Next: 12.5.2,  Up: 12.5

12.5.1 Formal Private and Derived Types
---------------------------------------

1/3
In its most general form, the category determined for a formal private
type is all types, but the category can be restricted to only nonlimited
types or to only tagged types.  Similarly, the category for a formal
incomplete type is all types but the category can be restricted to only
tagged types; unlike other formal types, the actual type does not need
to be able to be frozen (see *note 13.14::).  The category determined
for a formal derived type is the derivation class rooted at the ancestor
type.

                               _Syntax_

2
     formal_private_type_definition ::=
     [[abstract] tagged] [limited] private

3/2
     formal_derived_type_definition ::=
          [abstract] [limited | synchronized] new subtype_mark [[and 
     interface_list]with private]

                           _Legality Rules_

4
If a generic formal type declaration has a known_discriminant_part, then
it shall not include a default_expression for a discriminant.

5/3
The <ancestor subtype> of a formal derived type is the subtype denoted
by the subtype_mark of the formal_derived_type_definition.  For a formal
derived type declaration, the reserved words with private shall appear
if and only if the ancestor type is a tagged type; in this case the
formal derived type is a private extension of the ancestor type and the
ancestor shall not be a class-wide type.  Similarly, an interface_list
or the optional reserved words abstract or synchronized shall appear
only if the ancestor type is a tagged type.  The reserved word limited
or synchronized shall appear only if the ancestor type and any
progenitor types are limited types.  The reserved word synchronized
shall appear (rather than limited) if the ancestor type or any of the
progenitor types are synchronized interfaces.  The ancestor type shall
be a limited interface if the reserved word synchronized appears.

5.1/4
The actual type for a formal derived type shall be a descendant of the
ancestor type and every progenitor of the formal type.  If the formal
type is nonlimited, the actual type shall be nonlimited.  The actual
type for a formal derived type shall be tagged if and only if the formal
derived type is a private extension.  If the reserved word synchronized
appears in the declaration of the formal derived type, the actual type
shall be a synchronized tagged type.

6/3
If a formal private or derived subtype is definite, then the actual
subtype shall also be definite.

6.1/3
A formal_incomplete_type_declaration declares a formal incomplete type.
The only view of a formal incomplete type is an incomplete view.  Thus,
a formal incomplete type is subject to the same usage restrictions as
any other incomplete type -- see *note 3.10.1::.

7
For a generic formal derived type with no discriminant_part:

8
   * If the ancestor subtype is constrained, the actual subtype shall be
     constrained, and shall be statically compatible with the ancestor;

9
   * If the ancestor subtype is an unconstrained access or composite
     subtype, the actual subtype shall be unconstrained.

10
   * If the ancestor subtype is an unconstrained discriminated subtype,
     then the actual shall have the same number of discriminants, and
     each discriminant of the actual shall correspond to a discriminant
     of the ancestor, in the sense of *note 3.7::.

10.1/2
   * If the ancestor subtype is an access subtype, the actual subtype
     shall exclude null if and only if the ancestor subtype excludes
     null.

11/3
The declaration of a formal derived type shall not have a
known_discriminant_part.  For a generic formal private or incomplete
type with a known_discriminant_part:

12
   * The actual type shall be a type with the same number of
     discriminants.

13
   * The actual subtype shall be unconstrained.

14
   * The subtype of each discriminant of the actual type shall
     statically match the subtype of the corresponding discriminant of
     the formal type.  

15
For a generic formal type with an unknown_discriminant_part, the actual
may, but need not, have discriminants, and may be definite or
indefinite.

15.1/4
When enforcing Legality Rules, for the purposes of determining within a
generic body whether a type is unconstrained in any partial view, a
discriminated subtype is considered to have a constrained partial view
if it is a descendant of an untagged generic formal private or derived
type.

                          _Static Semantics_

16/2
The category determined for a formal private type is as follows:

17/2
     <Type Definition>    <Determined Category>

     limited private    the category of all types
     private    the category of all nonlimited types
     tagged limited private    the category of all tagged types
     tagged private    the category of all nonlimited tagged types

18
The presence of the reserved word abstract determines whether the actual
type may be abstract.

18.1/3
The category determined for a formal incomplete type is the category of
all types, unless the formal_type_declaration includes the reserved word
tagged; in this case, it is the category of all tagged types.

19
A formal private or derived type is a private or derived type,
respectively.  A formal derived tagged type is a private extension.  A
formal private or derived type is abstract if the reserved word abstract
appears in its declaration.

20/3
For a formal derived type, the characteristics (including components,
but excluding discriminants if there is a new discriminant_part),
predefined operators, and inherited user-defined primitive subprograms
are determined by its ancestor type and its progenitor types (if any),
in the same way that those of a derived type are determined by those of
its parent type and its progenitor types (see *note 3.4:: and *note
7.3.1::).

21/3
In an instance, the copy of an implicit declaration of a primitive
subprogram of a formal derived type declares a view of the corresponding
primitive subprogram of the ancestor or progenitor of the formal derived
type, even if this primitive has been overridden for the actual type and
even if it is never declared for the actual type.  When the ancestor or
progenitor of the formal derived type is itself a formal type, the copy
of the implicit declaration declares a view of the corresponding copied
operation of the ancestor or progenitor.  In the case of a formal
private extension, however, the tag of the formal type is that of the
actual type, so if the tag in a call is statically determined to be that
of the formal type, the body executed will be that corresponding to the
actual type.

22/1
For a prefix S that denotes a formal indefinite subtype, the following
attribute is defined:

23/3
S'Definite
               S'Definite yields True if the actual subtype
               corresponding to S is definite; otherwise, it yields
               False.  The value of this attribute is of the predefined
               type Boolean.

                          _Dynamic Semantics_

23.1/3
In the case where a formal type has unknown discriminants, and the
actual type is a class-wide type <T>'Class:

23.2/2
   * For the purposes of defining the primitive operations of the formal
     type, each of the primitive operations of the actual type is
     considered to be a subprogram (with an intrinsic calling convention
     -- see *note 6.3.1::) whose body consists of a dispatching call
     upon the corresponding operation of <T>, with its formal parameters
     as the actual parameters.  If it is a function, the result of the
     dispatching call is returned.

23.3/2
   * If the corresponding operation of <T> has no controlling formal
     parameters, then the controlling tag value is determined by the
     context of the call, according to the rules for tag-indeterminate
     calls (see *note 3.9.2:: and *note 5.2::).  In the case where the
     tag would be statically determined to be that of the formal type,
     the call raises Program_Error.  If such a function is renamed, any
     call on the renaming raises Program_Error.  

     NOTES

24/2
     9  In accordance with the general rule that the actual type shall
     belong to the category determined for the formal (see *note 12.5::,
     "*note 12.5:: Formal Types"):

25
        * If the formal type is nonlimited, then so shall be the actual;

26
        * For a formal derived type, the actual shall be in the class
          rooted at the ancestor subtype.

27
     10  The actual type can be abstract only if the formal type is
     abstract (see *note 3.9.3::).

28
     11  If the formal has a discriminant_part, the actual can be either
     definite or indefinite.  Otherwise, the actual has to be definite.


File: arm2012.info,  Node: 12.5.2,  Next: 12.5.3,  Prev: 12.5.1,  Up: 12.5

12.5.2 Formal Scalar Types
--------------------------

1/2
A <formal scalar type> is one defined by any of the
formal_type_definitions in this subclause.  The category determined for
a formal scalar type is the category of all discrete, signed integer,
modular, floating point, ordinary fixed point, or decimal types.

                               _Syntax_

2
     formal_discrete_type_definition ::= (<>)

3
     formal_signed_integer_type_definition ::= range <>

4
     formal_modular_type_definition ::= mod <>

5
     formal_floating_point_definition ::= digits <>

6
     formal_ordinary_fixed_point_definition ::= delta <>

7
     formal_decimal_fixed_point_definition ::= delta <> digits <>

                           _Legality Rules_

8
The actual type for a formal scalar type shall not be a nonstandard
numeric type.

     NOTES

9
     12  The actual type shall be in the class of types implied by the
     syntactic category of the formal type definition (see *note 12.5::,
     "*note 12.5:: Formal Types").  For example, the actual for a
     formal_modular_type_definition shall be a modular type.


File: arm2012.info,  Node: 12.5.3,  Next: 12.5.4,  Prev: 12.5.2,  Up: 12.5

12.5.3 Formal Array Types
-------------------------

1/2
The category determined for a formal array type is the category of all
array types.

                               _Syntax_

2
     formal_array_type_definition ::= array_type_definition

                           _Legality Rules_

3
The only form of discrete_subtype_definition that is allowed within the
declaration of a generic formal (constrained) array subtype is a
subtype_mark.

4
For a formal array subtype, the actual subtype shall satisfy the
following conditions:

5
   * The formal array type and the actual array type shall have the same
     dimensionality; the formal subtype and the actual subtype shall be
     either both constrained or both unconstrained.

6
   * For each index position, the index types shall be the same, and the
     index subtypes (if unconstrained), or the index ranges (if
     constrained), shall statically match (see *note 4.9.1::).  

7
   * The component subtypes of the formal and actual array types shall
     statically match.  

8
   * If the formal type has aliased components, then so shall the
     actual.

                              _Examples_

9
<Example of formal array types:>

10
     --<  given the generic package >

11
     generic
        type Item   is private;
        type Index  is (<>);
        type Vector is array (Index range <>) of Item;
        type Table  is array (Index) of Item;
     package P is
        ...
     end P;

12
     --<  and the types >

13
     type Mix    is array (Color range <>) of Boolean;
     type Option is array (Color) of Boolean;

14
     --<  then Mix can match Vector and Option can match Table >

15
     package R is new P(Item   => Boolean, Index => Color,
                        Vector => Mix,     Table => Option);

16
     --<  Note that Mix cannot match Table and Option cannot match Vector>


File: arm2012.info,  Node: 12.5.4,  Next: 12.5.5,  Prev: 12.5.3,  Up: 12.5

12.5.4 Formal Access Types
--------------------------

1/2
The category determined for a formal access type is the category of all
access types.

                               _Syntax_

2
     formal_access_type_definition ::= access_type_definition

                           _Legality Rules_

3
For a formal access-to-object type, the designated subtypes of the
formal and actual types shall statically match.  

4/2
If and only if the general_access_modifier constant applies to the
formal, the actual shall be an access-to-constant type.  If the
general_access_modifier all applies to the formal, then the actual shall
be a general access-to-variable type (see *note 3.10::).  If and only if
the formal subtype excludes null, the actual subtype shall exclude null.

5/3
For a formal access-to-subprogram subtype, the designated profiles of
the formal and the actual shall be subtype conformant.  

                              _Examples_

6
<Example of formal access types:>

7
     --<  the formal types of the generic package >

8
     generic
        type Node is private;
        type Link is access Node;
     package P is
        ...
     end P;

9
     --<  can be matched by the actual types >

10
     type Car;
     type Car_Name is access Car;

11
     type Car is
        record
           Pred, Succ : Car_Name;
           Number     : License_Number;
           Owner      : Person;
        end record;

12
     --<  in the following generic instantiation >

13
     package R is new P(Node => Car, Link => Car_Name);


File: arm2012.info,  Node: 12.5.5,  Prev: 12.5.4,  Up: 12.5

12.5.5 Formal Interface Types
-----------------------------

1/2
The category determined for a formal interface type is the category of
all interface types.

                               _Syntax_

2/2
     formal_interface_type_definition ::= interface_type_definition

                           _Legality Rules_

3/2
The actual type shall be a descendant of every progenitor of the formal
type.

4/2
The actual type shall be a limited, task, protected, or synchronized
interface if and only if the formal type is also, respectively, a
limited, task, protected, or synchronized interface.

                              _Examples_

5/2
     type Root_Work_Item is tagged private;

6/2
     generic
        type Managed_Task is task interface;
        type Work_Item(<>) is new Root_Work_Item with private;
     package Server_Manager is
        task type Server is new Managed_Task with
           entry Start(Data : in out Work_Item);
        end Server;
     end Server_Manager;

7/2
This generic allows an application to establish a standard interface
that all tasks need to implement so they can be managed appropriately by
an application-specific scheduler.


File: arm2012.info,  Node: 12.6,  Next: 12.7,  Prev: 12.5,  Up: 12

12.6 Formal Subprograms
=======================

1
Formal subprograms can be used to pass callable entities to a generic
unit.

                               _Syntax_

2/2
     formal_subprogram_declaration ::=
     formal_concrete_subprogram_declaration
         | formal_abstract_subprogram_declaration

2.1/3
     formal_concrete_subprogram_declaration ::=
          with subprogram_specification [is subprogram_default]
             [aspect_specification];

2.2/3
     formal_abstract_subprogram_declaration ::=
          with subprogram_specification is abstract [subprogram_default]
             [aspect_specification];

3/2
     subprogram_default ::= default_name | <> | null

4
     default_name ::= name

4.1/2
     A subprogram_default of null shall not be specified for a formal
     function or for a formal_abstract_subprogram_declaration.

                        _Name Resolution Rules_

5
The expected profile for the default_name, if any, is that of the formal
subprogram.

6
For a generic formal subprogram, the expected profile for the actual is
that of the formal subprogram.

                           _Legality Rules_

7/3
The profiles of the formal and any named default shall be mode
conformant.  

8/3
The profiles of the formal and actual shall be mode conformant.  

8.1/2
For a parameter or result subtype of a formal_subprogram_declaration
that has an explicit null_exclusion:

8.2/2
   * if the actual matching the formal_subprogram_declaration denotes a
     generic formal object of another generic unit <G>, and the
     instantiation containing the actual that occurs within the body of
     a generic unit <G> or within the body of a generic unit declared
     within the declarative region of the generic unit <G>, then the
     corresponding parameter or result type of the formal subprogram of
     <G> shall have a null_exclusion;

8.3/2
   * otherwise, the subtype of the corresponding parameter or result
     type of the actual matching the formal_subprogram_declaration shall
     exclude null.  In addition to the places where Legality Rules
     normally apply (see *note 12.3::), this rule applies also in the
     private part of an instance of a generic unit.

8.4/3
If a formal parameter of a formal_abstract_subprogram_declaration (*note
12.6: S0298.) is of a specific tagged type <T> or of an anonymous access
type designating a specific tagged type <T>, <T> is called a
<controlling type> of the formal_abstract_subprogram_declaration (*note
12.6: S0298.).  Similarly, if the result of a
formal_abstract_subprogram_declaration (*note 12.6: S0298.) for a
function is of a specific tagged type <T> or of an anonymous access type
designating a specific tagged type <T>, <T> is called a controlling type
of the formal_abstract_subprogram_declaration (*note 12.6: S0298.).  A
formal_abstract_subprogram_declaration (*note 12.6: S0298.) shall have
exactly one controlling type, and that type shall not be incomplete.  

8.5/2
The actual subprogram for a formal_abstract_subprogram_declaration
(*note 12.6: S0298.) shall be a dispatching operation of the controlling
type or of the actual type corresponding to the controlling type.

                          _Static Semantics_

9
A formal_subprogram_declaration declares a generic formal subprogram.
The types of the formal parameters and result, if any, of the formal
subprogram are those determined by the subtype_marks given in the
formal_subprogram_declaration; however, independent of the particular
subtypes that are denoted by the subtype_marks, the nominal subtypes of
the formal parameters and result, if any, are defined to be nonstatic,
and unconstrained if of an array type (no applicable index constraint is
provided in a call on a formal subprogram).  In an instance, a
formal_subprogram_declaration declares a view of the actual.  The
profile of this view takes its subtypes and calling convention from the
original profile of the actual entity, while taking the formal parameter
names and default_expression (*note 3.7: S0063.)s from the profile given
in the formal_subprogram_declaration (*note 12.6: S0296.).  The view is
a function or procedure, never an entry.

9.1/3
If a subtype_mark in the profile of the formal_subprogram_declaration
denotes a formal private or formal derived type and the actual type for
this formal type is a class-wide type <T>'Class, then for the purposes
of resolving the corresponding actual subprogram at the point of the
instantiation, certain implicit declarations may be available as
possible resolutions as follows:

9.2/3
          For each primitive subprogram of <T> that is directly visible
          at the point of the instantiation, and that has at least one
          controlling formal parameter, a corresponding implicitly
          declared subprogram with the same defining name, and having
          the same profile as the primitive subprogram except that <T>
          is systematically replaced by <T>'Class in the types of its
          profile, is potentially use-visible.  The body of such a
          subprogram is as defined in *note 12.5.1:: for primitive
          subprograms of a formal type when the actual type is
          class-wide.

10
If a generic unit has a subprogram_default specified by a box, and the
corresponding actual parameter is omitted, then it is equivalent to an
explicit actual parameter that is a usage name identical to the defining
name of the formal.

10.1/2
If a generic unit has a subprogram_default specified by the reserved
word null, and the corresponding actual parameter is omitted, then it is
equivalent to an explicit actual parameter that is a null procedure
having the profile given in the formal_subprogram_declaration (*note
12.6: S0296.).

10.2/2
The subprogram declared by a formal_abstract_subprogram_declaration
(*note 12.6: S0298.) with a controlling type <T> is a dispatching
operation of type <T>.

     NOTES

11
     13  The matching rules for formal subprograms state requirements
     that are similar to those applying to
     subprogram_renaming_declarations (see *note 8.5.4::).  In
     particular, the name of a parameter of the formal subprogram need
     not be the same as that of the corresponding parameter of the
     actual subprogram; similarly, for these parameters,
     default_expressions need not correspond.

12
     14  The constraints that apply to a parameter of a formal
     subprogram are those of the corresponding formal parameter of the
     matching actual subprogram (not those implied by the corresponding
     subtype_mark in the _specification of the formal subprogram).  A
     similar remark applies to the result of a function.  Therefore, to
     avoid confusion, it is recommended that the name of a first subtype
     be used in any declaration of a formal subprogram.

13
     15  The subtype specified for a formal parameter of a generic
     formal subprogram can be any visible subtype, including a generic
     formal subtype of the same generic_formal_part.

14
     16  A formal subprogram is matched by an attribute of a type if the
     attribute is a function with a matching specification.  An
     enumeration literal of a given type matches a parameterless formal
     function whose result type is the given type.

15
     17  A default_name denotes an entity that is visible or directly
     visible at the place of the generic_declaration; a box used as a
     default is equivalent to a name that denotes an entity that is
     directly visible at the place of the _instantiation.

16/2
     18  The actual subprogram cannot be abstract unless the formal
     subprogram is a formal_abstract_subprogram_declaration (*note 12.6:
     S0298.) (see *note 3.9.3::).

16.1/2
     19  The subprogram declared by a
     formal_abstract_subprogram_declaration (*note 12.6: S0298.) is an
     abstract subprogram.  All calls on a subprogram declared by a
     formal_abstract_subprogram_declaration (*note 12.6: S0298.) must be
     dispatching calls.  See *note 3.9.3::.

16.2/2
     20  A null procedure as a subprogram default has convention
     Intrinsic (see *note 6.3.1::).

                              _Examples_

17
<Examples of generic formal subprograms:>

18/2
     with function "+"(X, Y : Item) return Item is <>;
     with function Image(X : Enum) return String is Enum'Image;
     with procedure Update is Default_Update;
     with procedure Pre_Action(X : in Item) is null;  --< defaults to no action>
     with procedure Write(S    : not null access Root_Stream_Type'Class;
                          Desc : Descriptor)
                          is abstract Descriptor'Write;  --< see *note 13.13.2::>
     --< Dispatching operation on Descriptor with default>

19
     --<  given the generic procedure declaration >

20
     generic
        with procedure Action (X : in Item);
     procedure Iterate(Seq : in Item_Sequence);

21
     --<  and the procedure >

22
     procedure Put_Item(X : in Item);

23
     --<  the following instantiation is possible >

24
     procedure Put_List is new Iterate(Action => Put_Item);


File: arm2012.info,  Node: 12.7,  Next: 12.8,  Prev: 12.6,  Up: 12

12.7 Formal Packages
====================

1
Formal packages can be used to pass packages to a generic unit.  The
formal_package_declaration declares that the formal package is an
instance of a given generic package.  Upon instantiation, the actual
package has to be an instance of that generic package.

                               _Syntax_

2/3
     formal_package_declaration ::=
         with package defining_identifier is new <generic_package_>
     name  formal_package_actual_part
             [aspect_specification];

3/2
     formal_package_actual_part ::=
         ([others =>] <>)
       | [generic_actual_part]
       | (formal_package_association {, 
     formal_package_association} [, others => <>])

3.1/2
     formal_package_association ::=
         generic_association
       | <generic_formal_parameter_>selector_name => <>

3.2/2
     Any positional formal_package_associations shall precede any named
     formal_package_associations.

                           _Legality Rules_

4
The <generic_package_>name shall denote a generic package (the
<template> for the formal package); the formal package is an instance of
the template.

4.1/3
The <generic_formal_parameter_>selector_name of a
formal_package_association shall denote a
generic_formal_parameter_declaration of the template.  If two or more
formal subprograms of the template have the same defining name, then
named associations are not allowed for the corresponding actuals.

4.2/3
A formal_package_actual_part shall contain at most one
formal_package_association for each formal parameter.  If the
formal_package_actual_part does not include "others => <>", each formal
parameter without an association shall have a default_expression or
subprogram_default.

4.3/3
The rules for matching between formal_package_associations and the
generic formals of the template are as follows:

4.4/3
   * If all of the formal_package_associations are given by generic
     associations, the explicit_generic_actual_parameters of the
     formal_package_associations shall be legal for an instantiation of
     the template.

4.5/3
   * If a formal_package_association for a formal type <T> of the
     template is given by <>, then the formal_package_association for
     any other generic_formal_parameter_declaration of the template that
     mentions <T> directly or indirectly must be given by <> as well.

5/2
The actual shall be an instance of the template.  If the
formal_package_actual_part is (<>) or (others => <>), then the actual
may be any instance of the template; otherwise, certain of the actual
parameters of the actual instance shall match the corresponding actual
parameters of the formal package, determined as follows:

5.1/2
   * If the formal_package_actual_part (*note 12.7: S0302.) includes
     generic_associations as well as associations with <>, then only the
     actual parameters specified explicitly with generic_associations
     are required to match;

5.2/2
   * Otherwise, all actual parameters shall match, whether any actual
     parameter is given explicitly or by default.

5.3/2
The rules for matching of actual parameters between the actual instance
and the formal package are as follows:

6/2
   * For a formal object of mode in, the actuals match if they are
     static expressions with the same value, or if they statically
     denote the same constant, or if they are both the literal null.

7
   * For a formal subtype, the actuals match if they denote statically
     matching subtypes.  

8
   * For other kinds of formals, the actuals match if they statically
     denote the same entity.

8.1/1
For the purposes of matching, any actual parameter that is the name of a
formal object of mode in is replaced by the formal object's actual
expression (recursively).

                          _Static Semantics_

9
A formal_package_declaration declares a generic formal package.

10/2
The visible part of a formal package includes the first list of
basic_declarative_items of the package_specification (*note 7.1:
S0191.).  In addition, for each actual parameter that is not required to
match, a copy of the declaration of the corresponding formal parameter
of the template is included in the visible part of the formal package.
If the copied declaration is for a formal type, copies of the implicit
declarations of the primitive subprograms of the formal type are also
included in the visible part of the formal package.

11/2
For the purposes of matching, if the actual instance <A> is itself a
formal package, then the actual parameters of <A> are those specified
explicitly or implicitly in the formal_package_actual_part for <A>,
plus, for those not specified, the copies of the formal parameters of
the template included in the visible part of <A>.

                              _Examples_

12/2
<Example of a generic package with formal package parameters:>

13/2
     with Ada.Containers.Ordered_Maps;  --< see *note A.18.6::>
     generic
        with package Mapping_1 is new Ada.Containers.Ordered_Maps(<>);
        with package Mapping_2 is new Ada.Containers.Ordered_Maps
                                         (Key_Type => Mapping_1.Element_Type,
                                          others => <>);
     package Ordered_Join is
        --< Provide a "join" between two mappings>

14/2
        subtype Key_Type is Mapping_1.Key_Type;
        subtype Element_Type is Mapping_2.Element_Type;

15/2
        function Lookup(Key : Key_Type) return Element_Type;

16/2
        ...
     end Ordered_Join;

17/2
<Example of an instantiation of a package with formal packages:>

18/2
     with Ada.Containers.Ordered_Maps;
     package Symbol_Package is

19/2
        type String_Id is ...

20/2
        type Symbol_Info is ...

21/2
        package String_Table is new Ada.Containers.Ordered_Maps
                (Key_Type => String,
                 Element_Type => String_Id);

22/2
        package Symbol_Table is new Ada.Containers.Ordered_Maps
                (Key_Type => String_Id,
                 Element_Type => Symbol_Info);

23/2
        package String_Info is new Ordered_Join(Mapping_1 => String_Table,
                                                Mapping_2 => Symbol_Table);

24/2
        Apple_Info : constant Symbol_Info := String_Info.Lookup("Apple");

25/2
     end Symbol_Package;


File: arm2012.info,  Node: 12.8,  Prev: 12.7,  Up: 12

12.8 Example of a Generic Package
=================================

1
The following example provides a possible formulation of stacks by means
of a generic package.  The size of each stack and the type of the stack
elements are provided as generic formal parameters.

                              _Examples_

2/1
<This paragraph was deleted.>

3
     generic
        Size : Positive;
        type Item is private;
     package Stack is
        procedure Push(E : in  Item);
        procedure Pop (E : out Item);
        Overflow, Underflow : exception;
     end Stack;

4
     package body Stack is

5
        type Table is array (Positive range <>) of Item;
        Space : Table(1 .. Size);
        Index : Natural := 0;

6
        procedure Push(E : in Item) is
        begin
           if Index >= Size then
              raise Overflow;
           end if;
           Index := Index + 1;
           Space(Index) := E;
        end Push;

7
        procedure Pop(E : out Item) is
        begin
           if Index = 0 then
              raise Underflow;
           end if;
           E := Space(Index);
           Index := Index - 1;
        end Pop;

8
     end Stack;

9
Instances of this generic package can be obtained as follows:

10
     package Stack_Int  is new Stack(Size => 200, Item => Integer);
     package Stack_Bool is new Stack(100, Boolean);

11
Thereafter, the procedures of the instantiated packages can be called as
follows:

12
     Stack_Int.Push(N);
     Stack_Bool.Push(True);

13
Alternatively, a generic formulation of the type Stack can be given as
follows (package body omitted):

14
     generic
        type Item is private;
     package On_Stacks is
        type Stack(Size : Positive) is limited private;
        procedure Push(S : in out Stack; E : in  Item);
        procedure Pop (S : in out Stack; E : out Item);
        Overflow, Underflow : exception;
     private
        type Table is array (Positive range <>) of Item;
        type Stack(Size : Positive) is
           record
              Space : Table(1 .. Size);
              Index : Natural := 0;
           end record;
     end On_Stacks;

15
In order to use such a package, an instance has to be created and
thereafter stacks of the corresponding type can be declared:

16
     declare
        package Stack_Real is new On_Stacks(Real); use Stack_Real;
        S : Stack(100);
     begin
        ...
        Push(S, 2.54);
        ...
     end;


File: arm2012.info,  Node: 13,  Next: Annex A,  Prev: 12,  Up: Top

13 Representation Issues
************************

1/3
This clause describes features for querying and controlling certain
aspects of entities and for interfacing to hardware.

* Menu:

* 13.1 ::     Operational and Representation Aspects
* 13.2 ::     Packed Types
* 13.3 ::     Operational and Representation Attributes
* 13.4 ::     Enumeration Representation Clauses
* 13.5 ::     Record Layout
* 13.6 ::     Change of Representation
* 13.7 ::     The Package System
* 13.8 ::     Machine Code Insertions
* 13.9 ::     Unchecked Type Conversions
* 13.10 ::    Unchecked Access Value Creation
* 13.11 ::    Storage Management
* 13.12 ::    Pragma Restrictions and Pragma Profile
* 13.13 ::    Streams
* 13.14 ::    Freezing Rules


File: arm2012.info,  Node: 13.1,  Next: 13.2,  Up: 13

13.1 Operational and Representation Aspects
===========================================

0.1/3
Two kinds of aspects of entities can be specified: representation
aspects and operational aspects.  Representation aspects affect how the
types and other entities of the language are to be mapped onto the
underlying machine.  Operational aspects determine other properties of
entities.

0.2/3
Either kind of aspect of an entity may be specified by means of an
aspect_specification (see *note 13.1.1::), which is an optional element
of most kinds of declarations and applies to the entity or entities
being declared.  Aspects may also be specified by certain other
constructs occurring subsequent to the declaration of the affected
entity: a representation aspect value may be specified by means of a
representation item and an operational aspect value may be specified by
means of an operational item.

1/1
There are six kinds of <representation items>:
attribute_definition_clause (*note 13.3: S0310.)s for representation
attributes, enumeration_representation_clause (*note 13.4: S0311.)s,
record_representation_clause (*note 13.5.1: S0313.)s, at_clauses,
component_clauses, and <representation pragmas>.  They can be provided
to give more efficient representation or to interface with features that
are outside the domain of the language (for example, peripheral
hardware).

1.1/1
An <operational item> is an attribute_definition_clause for an
operational attribute.

1.2/1
An operational item or a representation item applies to an entity
identified by a local_name, which denotes an entity declared local to
the current declarative region, or a library unit declared immediately
preceding a representation pragma in a compilation.

                               _Syntax_

2/1
     aspect_clause ::= attribute_definition_clause
           | enumeration_representation_clause
           | record_representation_clause
           | at_clause

3
     local_name ::= direct_name
           | direct_name'attribute_designator
           | <library_unit_>name

4/1
     A representation pragma is allowed only at places where an
     aspect_clause or compilation_unit is allowed.  

                        _Name Resolution Rules_

5/1
In an operational item or representation item, if the local_name is a
direct_name, then it shall resolve to denote a declaration (or, in the
case of a pragma, one or more declarations) that occurs immediately
within the same declarative region as the item.  If the local_name has
an attribute_designator, then it shall resolve to denote an
implementation-defined component (see *note 13.5.1::) or a class-wide
type implicitly declared immediately within the same declarative region
as the item.  A local_name that is a <library_unit_>name (only permitted
in a representation pragma) shall resolve to denote the library_item
that immediately precedes (except for other pragmas) the representation
pragma.

                           _Legality Rules_

6/1
The local_name of an aspect_clause or representation pragma shall
statically denote an entity (or, in the case of a pragma, one or more
entities) declared immediately preceding it in a compilation, or within
the same declarative_part (*note 3.11: S0086.), package_specification
(*note 7.1: S0191.), task_definition (*note 9.1: S0207.),
protected_definition (*note 9.4: S0212.), or record_definition (*note
3.8: S0067.) as the representation or operational item.  If a local_name
denotes a local callable entity, it may do so through a local
subprogram_renaming_declaration (*note 8.5.4: S0203.) (as a way to
resolve ambiguity in the presence of overloading); otherwise, the
local_name shall not denote a renaming_declaration (*note 8.5: S0199.).

7/2
The <representation> of an object consists of a certain number of bits
(the <size> of the object).  For an object of an elementary type, these
are the bits that are normally read or updated by the machine code when
loading, storing, or operating-on the value of the object.  For an
object of a composite type, these are the bits reserved for this object,
and include bits occupied by subcomponents of the object.  If the size
of an object is greater than that of its subtype, the additional bits
are padding bits.  For an elementary object, these padding bits are
normally read and updated along with the others.  For a composite
object, padding bits might not be read or updated in any given composite
operation, depending on the implementation.

8/3
A representation item <directly specifies> a <representation aspect> of
the entity denoted by the local_name, except in the case of a
type-related representation item, whose local_name shall denote a first
subtype, and which directly specifies an aspect of the subtype's type.  
A representation item that names a subtype is either <subtype-specific>
(Size and Alignment clauses) or <type-related> (all others).
Subtype-specific aspects may differ for different subtypes of the same
type.

8.1/3
An operational item <directly specifies> an <operational aspect> of the
entity denoted by the local_name, except in the case of a type-related
operational item, whose local_name shall denote a first subtype, and
which directly specifies an aspect of the type of the subtype.  

9/4
A representation item that directly specifies an aspect of a subtype or
type shall appear after the type is completely defined (see *note
3.11.1::), and before the subtype or type is frozen (see *note 13.14::).

9.1/4
An operational item that directly specifies an aspect of an entity shall
appear before the entity is frozen (see *note 13.14::).

9.2/4
If a representation item, operational item, or aspect_specification is
given that directly specifies an aspect of an entity, then it is illegal
to give another representation item, operational item, or
aspect_specification that directly specifies the same aspect of the
entity.

9.3/4
Unless otherwise specified, it is illegal to specify an operational or
representation aspect of a generic formal parameter.

10/4
For an untagged derived type, it is illegal to specify a type-related
representation aspect if the parent type is a by-reference type, or has
any user-defined primitive subprograms.  Similarly, it is illegal to
specify a nonconfirming type-related representation aspect for an
untagged by-reference type after one or more types have been derived
from it.

11/3
Operational and representation aspects of a generic formal parameter are
the same as those of the actual.  Operational and representation aspects
are the same for all views of a type.  Specification of a type-related
representation aspect is not allowed for a descendant of a generic
formal untagged type.

12/3
The specification of the Size aspect for a given subtype, or the size or
storage place for an object (including a component) of a given subtype,
shall allow for enough storage space to accommodate any value of the
subtype.

13/3
If a specification of a representation or operational aspect is not
supported by the implementation, it is illegal or raises an exception at
run time.

13.1/3
A type_declaration is illegal if it has one or more progenitors, and a
nonconfirming value was specified for a representation aspect of an
ancestor, and this conflicts with the representation of some other
ancestor.  The cases that cause conflicts are implementation defined.

                          _Static Semantics_

14
If two subtypes statically match, then their subtype-specific aspects
(Size and Alignment) are the same.  

15/3
A derived type inherits each type-related representation aspect of its
parent type that was directly specified before the declaration of the
derived type, or (in the case where the parent is derived) that was
inherited by the parent type from the grandparent type.  A derived
subtype inherits each subtype-specific representation aspect of its
parent subtype that was directly specified before the declaration of the
derived type, or (in the case where the parent is derived) that was
inherited by the parent subtype from the grandparent subtype, but only
if the parent subtype statically matches the first subtype of the parent
type.  An inherited representation aspect is overridden by a subsequent
aspect_specification or representation item that specifies a different
value for the same aspect of the type or subtype.

15.1/3
In contrast, whether operational aspects are inherited by a derived type
depends on each specific aspect; unless specified, an operational aspect
is not inherited.  When operational aspects are inherited by a derived
type, aspects that were directly specified by aspect_specifications or
operational items that are visible at the point of the derived type
declaration, or (in the case where the parent is derived) that were
inherited by the parent type from the grandparent type are inherited.
An inherited operational aspect is overridden by a subsequent
aspect_specification or operational item that specifies the same aspect
of the type.

15.2/2
When an aspect that is a subprogram is inherited, the derived type
inherits the aspect in the same way that a derived type inherits a
user-defined primitive subprogram from its parent (see *note 3.4::).

16
Each aspect of representation of an entity is as follows:

17
   * If the aspect is <specified> for the entity, meaning that it is
     either directly specified or inherited, then that aspect of the
     entity is as specified, except in the case of Storage_Size, which
     specifies a minimum.

18
   * If an aspect of representation of an entity is not specified, it is
     chosen by default in an unspecified manner.

18.1/1
If an operational aspect is <specified> for an entity (meaning that it
is either directly specified or inherited), then that aspect of the
entity is as specified.  Otherwise, the aspect of the entity has the
default value for that aspect.

18.2/3
An aspect_specification or representation item that specifies a
representation aspect that would have been chosen in the absence of the
aspect_specification or representation item is said to be <confirming>.
The aspect value specified in this case is said to be a <confirming>
representation aspect value.  Other values of the aspect are said to be
<nonconfirming>, as are the aspect_specifications and representation
items that specified them.  

                          _Dynamic Semantics_

19/1
For the elaboration of an aspect_clause, any evaluable constructs within
it are evaluated.

                     _Implementation Permissions_

20/3
An implementation may interpret representation aspects in an
implementation-defined manner.  An implementation may place
implementation-defined restrictions on the specification of
representation aspects.  A <recommended level of support> is defined for
the specification of representation aspects and related features in each
subclause.  These recommendations are changed to requirements for
implementations that support the Systems Programming Annex (see *note
C.2::, "*note C.2:: Required Representation Support").

                        _Implementation Advice_

21/3
The recommended level of support for the specification of all
representation aspects is qualified as follows:

21.1/3
   * A confirming specification for a representation aspect should be
     supported.

22/3
   * An implementation need not support the specification for a
     representation aspect that contains nonstatic expressions, unless
     each nonstatic expression is a name that statically denotes a
     constant declared before the entity.

23
   * An implementation need not support a specification for the Size for
     a given composite subtype, nor the size or storage place for an
     object (including a component) of a given composite subtype, unless
     the constraints on the subtype and its composite subcomponents (if
     any) are all static constraints.

24/3
   * An implementation need not support specifying a nonconfirming
     representation aspect value if it could cause an aliased object or
     an object of a by-reference type to be allocated at a
     nonaddressable location or, when the alignment attribute of the
     subtype of such an object is nonzero, at an address that is not an
     integral multiple of that alignment.

25/3
   * An implementation need not support specifying a nonconfirming
     representation aspect value if it could cause an aliased object of
     an elementary type to have a size other than that which would have
     been chosen by default.

26/3
   * An implementation need not support specifying a nonconfirming
     representation aspect value if it could cause an aliased object of
     a composite type, or an object whose type is by-reference, to have
     a size smaller than that which would have been chosen by default.

27/3
   * An implementation need not support specifying a nonconfirming
     subtype-specific representation aspect value for an indefinite or
     abstract subtype.

28/3
For purposes of these rules, the determination of whether specifying a
representation aspect value for a type <could cause> an object to have
some property is based solely on the properties of the type itself, not
on any available information about how the type is used.  In particular,
it presumes that minimally aligned objects of this type might be
declared at some point.

     NOTES

29/3
     1  Aspects that can be specified are defined throughout this
     International Standard, and are summarized in *note K.1::.

* Menu:

* 13.1.1 ::   Aspect Specifications


File: arm2012.info,  Node: 13.1.1,  Up: 13.1

13.1.1 Aspect Specifications
----------------------------

1/3
Certain representation or operational aspects of an entity may be
specified as part of its declaration using an aspect_specification,
rather than using a separate representation or operational item.  The
declaration with the aspect_specification is termed the <associated
declaration>.

                               _Syntax_

2/3
     aspect_specification ::=
        with aspect_mark [=> aspect_definition] {,
                aspect_mark [=> aspect_definition] }

3/3
     aspect_mark ::= <aspect_>identifier['Class]

4/3
     aspect_definition ::= name | expression | identifier

                        _Name Resolution Rules_

5/3
An aspect_mark identifies an aspect of the entity defined by the
associated declaration (the <associated entity>); the aspect denotes an
object, a value, an expression, a subprogram, or some other kind of
entity.  If the aspect_mark identifies:

6/3
   * an aspect that denotes an object, the aspect_definition shall be a
     name.  The expected type for the name is the type of the identified
     aspect of the associated entity;

7/3
   * an aspect that is a value or an expression, the aspect_definition
     shall be an expression.  The expected type for the expression is
     the type of the identified aspect of the associated entity;

8/3
   * an aspect that denotes a subprogram, the aspect_definition shall be
     a name; the expected profile for the name is the profile required
     for the aspect of the associated entity;

9/3
   * an aspect that denotes some other kind of entity, the
     aspect_definition shall be a name, and the name shall resolve to
     denote an entity of the appropriate kind;

10/3
   * an aspect that is given by an identifier specific to the aspect,
     the aspect_definition shall be an identifier, and the identifier
     shall be one of the identifiers specific to the identified aspect.

11/3
The usage names in an aspect_definition are not resolved at the point of
the associated declaration, but rather are resolved at the end of the
immediately enclosing declaration list.

12/3
If the associated declaration is for a subprogram or entry, the names of
the formal parameters are directly visible within the aspect_definition,
as are certain attributes, as specified elsewhere in this International
Standard for the identified aspect.  If the associated declaration is a
type_declaration, within the aspect_definition the names of any
components are directly visible, and the name of the first subtype
denotes the current instance of the type (see *note 8.6::).  If the
associated declaration is a subtype_declaration, within the
aspect_definition the name of the new subtype denotes the current
instance of the subtype.

                           _Legality Rules_

13/3
If the first freezing point of the associated entity comes before the
end of the immediately enclosing declaration list, then each usage name
in the aspect_definition shall resolve to the same entity at the first
freezing point as it does at the end of the immediately enclosing
declaration list.

14/3
At most one occurrence of each aspect_mark is allowed within a single
aspect_specification.  The aspect identified by the aspect_mark shall be
an aspect that can be specified for the associated entity (or view of
the entity defined by the associated declaration).

15/3
The aspect_definition associated with a given aspect_mark may be omitted
only when the aspect_mark identifies an aspect of a boolean type, in
which case it is equivalent to the aspect_definition being specified as
True.

16/3
If the aspect_mark includes 'Class, then the associated entity shall be
a tagged type or a primitive subprogram of a tagged type.

17/3
There are no language-defined aspects that may be specified on a
renaming_declaration, a generic_formal_parameter_declaration, a subunit,
a package_body, a task_body, a protected_body, or a body_stub other than
a subprogram_body_stub.

18/4
A language-defined aspect shall not be specified in an
aspect_specification given on a completion of a subprogram or generic
subprogram.

18.1/4
If an aspect of a derived type is inherited from an ancestor type and
has the boolean value True, the inherited value shall not be overridden
to have the value False for the derived type, unless otherwise specified
in this International Standard.

18.2/4
Certain type-related aspects are defined to be <nonoverridable>; all
such aspects are specified using an aspect_definition that is a name.

18.3/4
If a nonoverridable aspect is directly specified for a type <T>, then
any explicit specification of that aspect for any other descendant of
<T> shall be <confirming>; that is, the specified name shall <match> the
inherited aspect, meaning that the specified name shall denote the same
declarations as would the inherited name.

18.4/4
If a full type has a partial view, and a given nonoverridable aspect is
allowed for both the full view and the partial view, then the given
aspect for the partial view and the full view shall be the same: the
aspect shall be directly specified only on the partial view; if the full
type inherits the aspect, then a matching definition shall be specified
(directly or by inheritance) for the partial view.

18.5/4
In addition to the places where Legality Rules normally apply (see *note
12.3::), these rules about nonoverridable aspects also apply in the
private part of an instance of a generic unit.

18.6/4
The Default_Iterator, Iterator_Element, Implicit_Dereference,
Constant_Indexing, and Variable_Indexing aspects are nonoverridable.

                          _Static Semantics_

19/3
Depending on which aspect is identified by the aspect_mark, an
aspect_definition specifies:

20/3
   * a name that denotes a subprogram, object, or other kind of entity;

21/3
   * an expression, which is either evaluated to produce a single value,
     or which (as in a precondition) is to be evaluated at particular
     points during later execution; or

22/3
   * an identifier specific to the aspect.

23/3
The identified aspect of the associated entity, or in some cases, the
view of the entity defined by the declaration, is as specified by the
aspect_definition (or by the default of True when boolean).  Whether an
aspect_specification <applies> to an entity or only to the particular
view of the entity defined by the declaration is determined by the
aspect_mark and the kind of entity.  The following aspects are view
specific:

24/3
   * An aspect specified on an object_declaration;

25/3
   * An aspect specified on a subprogram_declaration;

26/3
   * An aspect specified on a renaming_declaration.

27/3
All other aspect_specifications are associated with the entity, and
<apply> to all views of the entity, unless otherwise specified in this
International Standard.

28/4
If the aspect_mark includes 'Class (a <class-wide aspect>), then, unless
specified otherwise for a particular class-wide aspect:

29/3
   * if the associated entity is a tagged type, the specification
     <applies> to all descendants of the type;

30/3
   * if the associated entity is a primitive subprogram of a tagged type
     <T>, the specification <applies> to the corresponding primitive
     subprogram of all descendants of <T>.

31/3
All specifiable operational and representation attributes may be
specified with an aspect_specification instead of an
attribute_definition_clause (see *note 13.3::).

32/4
Any aspect specified by a representation pragma or library unit pragma
that has a local_name as its single argument may be specified by an
aspect_specification, with the entity being the local_name.  The
aspect_definition is expected to be of type Boolean.  The expression
shall be static.  Notwithstanding what this International Standard says
elsewhere, the expression of an aspect that can be specified by a
library unit pragma is resolved and evaluated at the point where it
occurs in the aspect_specification, rather than the first freezing point
of the associated package.

33/3
In addition, other operational and representation aspects not associated
with specifiable attributes or representation pragmas may be specified,
as specified elsewhere in this International Standard.

34/4
<This paragraph was deleted.>

35/3
If a Legality Rule or Static Semantics rule only applies when a
particular aspect has been specified, the aspect is considered to have
been specified only when the aspect_specification or
attribute_definition_clause is visible (see *note 8.3::) at the point of
the application of the rule.

36/3
Alternative legality and semantics rules may apply for particular
aspects, as specified elsewhere in this International Standard.

                          _Dynamic Semantics_

37/3
At the freezing point of the associated entity, the aspect_specification
is elaborated.  The elaboration of the aspect_specification includes the
evaluation of the name or expression, if any, unless the aspect itself
is an expression.  If the corresponding aspect represents an expression
(as in a precondition), the elaboration has no effect; the expression is
evaluated later at points within the execution as specified elsewhere in
this International Standard for the particular aspect.

                     _Implementation Permissions_

38/3
Implementations may support implementation-defined aspects.  The
aspect_specification for an implementation-defined aspect may use an
implementation-defined syntax for the aspect_definition, and may follow
implementation-defined legality and semantics rules.


File: arm2012.info,  Node: 13.2,  Next: 13.3,  Prev: 13.1,  Up: 13

13.2 Packed Types
=================

1/3
The Pack aspect having the value True specifies that storage
minimization should be the main criterion when selecting the
representation of a composite type.

<Paragraphs 2 through 4 were moved to *note Annex J::, "*note Annex J::
Obsolescent Features".>

                          _Static Semantics_

5/3
For a full type declaration of a composite type, the following
language-defined representation aspect may be specified:

5.1/3
Pack
               The type of aspect Pack is Boolean.  When aspect Pack is
               True for a type, the type (or the extension part) is said
               to be <packed>.  For a type extension, the parent part is
               packed as for the parent type, and specifying Pack causes
               packing only of the extension part.  

5.2/3
               If directly specified, the aspect_definition shall be a
               static expression.  If not specified (including by
               inheritance), the aspect is False.

                        _Implementation Advice_

6
If a type is packed, then the implementation should try to minimize
storage allocated to objects of the type, possibly at the expense of
speed of accessing components, subject to reasonable complexity in
addressing calculations.

6.1/4
<This paragraph was deleted.>

7/3
The recommended level of support for the Pack aspect is:

7.1/4
   * Any component of a packed type that is of a by-reference type, that
     is specified as independently addressable, or that contains an
     aliased part, shall be aligned according to the alignment of its
     subtype.

8/4
   * For a packed record type, the components should be packed as
     tightly as possible subject to the above alignment requirements,
     the Sizes of the component subtypes, and any
     record_representation_clause that applies to the type; the
     implementation may, but need not, reorder components or cross
     aligned word boundaries to improve the packing.  A component whose
     Size is greater than the word size may be allocated an integral
     number of words.

9/4
   * For a packed array type, if the Size of the component subtype is
     less than or equal to the word size, Component_Size should be less
     than or equal to the Size of the component subtype, rounded up to
     the nearest factor of the word size, unless this would violate the
     above alignment requirements.


File: arm2012.info,  Node: 13.3,  Next: 13.4,  Prev: 13.2,  Up: 13

13.3 Operational and Representation Attributes
==============================================

1/1
The values of certain implementation-dependent characteristics can be
obtained by interrogating appropriate operational or representation
attributes.  Some of these attributes are specifiable via an
attribute_definition_clause.

                               _Syntax_

2
     attribute_definition_clause ::=
           for local_name'attribute_designator use expression;
         | for local_name'attribute_designator use name;

                        _Name Resolution Rules_

3
For an attribute_definition_clause that specifies an attribute that
denotes a value, the form with an expression shall be used.  Otherwise,
the form with a name shall be used.

4
For an attribute_definition_clause that specifies an attribute that
denotes a value or an object, the expected type for the expression or
name is that of the attribute.  For an attribute_definition_clause that
specifies an attribute that denotes a subprogram, the expected profile
for the name is the profile required for the attribute.  For an
attribute_definition_clause that specifies an attribute that denotes
some other kind of entity, the name shall resolve to denote an entity of
the appropriate kind.

                           _Legality Rules_

5/3
An attribute_designator is allowed in an attribute_definition_clause
only if this International Standard explicitly allows it, or for an
implementation-defined attribute if the implementation allows it.  Each
specifiable attribute constitutes an operational aspect or aspect of
representation; the name of the aspect is that of the attribute.

6
For an attribute_definition_clause that specifies an attribute that
denotes a subprogram, the profile shall be mode conformant with the one
required for the attribute, and the convention shall be Ada.  Additional
requirements are defined for particular attributes.  

                          _Static Semantics_

7/2
A <Size clause> is an attribute_definition_clause whose
attribute_designator is Size.  Similar definitions apply to the other
specifiable attributes.

8
A <storage element> is an addressable element of storage in the machine.
A <word> is the largest amount of storage that can be conveniently and
efficiently manipulated by the hardware, given the implementation's
run-time model.  A word consists of an integral number of storage
elements.

8.1/3
A <machine scalar> is an amount of storage that can be conveniently and
efficiently loaded, stored, or operated upon by the hardware.  Machine
scalars consist of an integral number of storage elements.  The set of
machine scalars is implementation defined, but includes at least the
storage element and the word.  Machine scalars are used to interpret
component_clauses when the nondefault bit ordering applies.

9/3
The following representation attributes are defined: Address, Alignment,
Size, Storage_Size, Component_Size, Has_Same_Storage, and
Overlaps_Storage.

10/1
For a prefix X that denotes an object, program unit, or label:

11
X'Address
               Denotes the address of the first of the storage elements
               allocated to X. For a program unit or label, this value
               refers to the machine code associated with the
               corresponding body or statement.  The value of this
               attribute is of type System.Address.

11.1/3
               The prefix of X'Address shall not statically denote a
               subprogram that has convention Intrinsic.  X'Address
               raises Program_Error if X denotes a subprogram that has
               convention Intrinsic.

12
               Address may be specified for stand-alone objects and for
               program units via an attribute_definition_clause.

                         _Erroneous Execution_

13/3
If an Address is specified, it is the programmer's responsibility to
ensure that the address is valid and appropriate for the entity and its
use; otherwise, program execution is erroneous.

                        _Implementation Advice_

14
For an array X, X'Address should point at the first component of the
array, and not at the array bounds.

15
The recommended level of support for the Address attribute is:

16
   * X'Address should produce a useful result if X is an object that is
     aliased or of a by-reference type, or is an entity whose Address
     has been specified.

17
   * An implementation should support Address clauses for imported
     subprograms.

18/2
   * <This paragraph was deleted.>

19
   * If the Address of an object is specified, or it is imported or
     exported, then the implementation should not perform optimizations
     based on assumptions of no aliases.

     NOTES

20
     2  The specification of a link name with the Link_Name aspect (see
     *note B.1::) for a subprogram or object is an alternative to
     explicit specification of its link-time address, allowing a
     link-time directive to place the subprogram or object within
     memory.

21
     3  The rules for the Size attribute imply, for an aliased object X,
     that if X'Size = Storage_Unit, then X'Address points at a storage
     element containing all of the bits of X, and only the bits of X.

                          _Static Semantics_

22/2
For a prefix X that denotes an object:

23/2
X'Alignment
               The value of this attribute is of type
               <universal_integer>, and nonnegative; zero means that the
               object is not necessarily aligned on a storage element
               boundary.  If X'Alignment is not zero, then X is aligned
               on a storage unit boundary and X'Address is an integral
               multiple of X'Alignment (that is, the Address modulo the
               Alignment is zero).

24/2

               <This paragraph was deleted.>

25/2
               Alignment may be specified for stand-alone objects via an
               attribute_definition_clause (*note 13.3: S0310.); the
               expression of such a clause shall be static, and its
               value nonnegative.

26/2

               <This paragraph was deleted.>

26.1/2
For every subtype S:

26.2/2
S'Alignment
               The value of this attribute is of type
               <universal_integer>, and nonnegative.

26.3/2
               For an object X of subtype S, if S'Alignment is not zero,
               then X'Alignment is a nonzero integral multiple of
               S'Alignment unless specified otherwise by a
               representation item.

26.4/2
               Alignment may be specified for first subtypes via an
               attribute_definition_clause (*note 13.3: S0310.); the
               expression of such a clause shall be static, and its
               value nonnegative.

                         _Erroneous Execution_

27
Program execution is erroneous if an Address clause is given that
conflicts with the Alignment.

28/2
For an object that is not allocated under control of the implementation,
execution is erroneous if the object is not aligned according to its
Alignment.

                        _Implementation Advice_

28.1/3
For any tagged specific subtype <S>, <S>'Class'Alignment should equal
<S>'Alignment.

29
The recommended level of support for the Alignment attribute for
subtypes is:

30/2
   * An implementation should support an Alignment clause for a discrete
     type, fixed point type, record type, or array type, specifying an
     Alignment value that is zero or a power of two, subject to the
     following:

31/2
   * An implementation need not support an Alignment clause for a signed
     integer type specifying an Alignment greater than the largest
     Alignment value that is ever chosen by default by the
     implementation for any signed integer type.  A corresponding
     limitation may be imposed for modular integer types, fixed point
     types, enumeration types, record types, and array types.

32/2
   * An implementation need not support a nonconfirming Alignment clause
     which could enable the creation of an object of an elementary type
     which cannot be easily loaded and stored by available machine
     instructions.

32.1/2
   * An implementation need not support an Alignment specified for a
     derived tagged type which is not a multiple of the Alignment of the
     parent type.  An implementation need not support a nonconfirming
     Alignment specified for a derived untagged by-reference type.

33
The recommended level of support for the Alignment attribute for objects
is:

34/2
   * <This paragraph was deleted.>

35
   * For stand-alone library-level objects of statically constrained
     subtypes, the implementation should support all Alignments
     supported by the target linker.  For example, page alignment is
     likely to be supported for such objects, but not for subtypes.

35.1/2
   * For other objects, an implementation should at least support the
     alignments supported for their subtype, subject to the following:

35.2/2
   * An implementation need not support Alignments specified for objects
     of a by-reference type or for objects of types containing aliased
     subcomponents if the specified Alignment is not a multiple of the
     Alignment of the subtype of the object.

     NOTES

36
     4  Alignment is a subtype-specific attribute.

37/2
     <This paragraph was deleted.>

38/3
     5  A component_clause, Component_Size clause, or specifying the
     Pack aspect as True can override a specified Alignment.

                          _Static Semantics_

39/1
For a prefix X that denotes an object:

40
X'Size
               Denotes the size in bits of the representation of the
               object.  The value of this attribute is of the type
               <universal_integer>.

41
               Size may be specified for stand-alone objects via an
               attribute_definition_clause; the expression of such a
               clause shall be static and its value nonnegative.

                        _Implementation Advice_

41.1/2
The size of an array object should not include its bounds.

42/2
The recommended level of support for the Size attribute of objects is
the same as for subtypes (see below), except that only a confirming Size
clause need be supported for an aliased elementary object.

43/2
   * <This paragraph was deleted.>

                          _Static Semantics_

44
For every subtype S:

45
S'Size
               If S is definite, denotes the size (in bits) that the
               implementation would choose for the following objects of
               subtype S:

46
                  * A record component of subtype S when the record type
                    is packed.

47
                  * The formal parameter of an instance of
                    Unchecked_Conversion that converts from subtype S to
                    some other subtype.

48
               If S is indefinite, the meaning is implementation
               defined.  The value of this attribute is of the type
               <universal_integer>.  The Size of an object is at least
               as large as that of its subtype, unless the object's Size
               is determined by a Size clause, a component_clause, or a
               Component_Size clause.  Size may be specified for first
               subtypes via an attribute_definition_clause (*note 13.3:
               S0310.); the expression of such a clause shall be static
               and its value nonnegative.

                     _Implementation Requirements_

49
In an implementation, Boolean'Size shall be 1.

                        _Implementation Advice_

50/2
If the Size of a subtype allows for efficient independent addressability
(see *note 9.10::) on the target architecture, then the Size of the
following objects of the subtype should equal the Size of the subtype:

51
   * Aliased objects (including components).

52
   * Unaliased components, unless the Size of the component is
     determined by a component_clause or Component_Size clause.

53
A Size clause on a composite subtype should not affect the internal
layout of components.

54
The recommended level of support for the Size attribute of subtypes is:

55
   * The Size (if not specified) of a static discrete or fixed point
     subtype should be the number of bits needed to represent each value
     belonging to the subtype using an unbiased representation, leaving
     space for a sign bit only if the subtype contains negative values.
     If such a subtype is a first subtype, then an implementation should
     support a specified Size for it that reflects this representation.

56
   * For a subtype implemented with levels of indirection, the Size
     should include the size of the pointers, but not the size of what
     they point at.

56.1/2
   * An implementation should support a Size clause for a discrete type,
     fixed point type, record type, or array type, subject to the
     following:

56.2/2
             * An implementation need not support a Size clause for a
               signed integer type specifying a Size greater than that
               of the largest signed integer type supported by the
               implementation in the absence of a size clause (that is,
               when the size is chosen by default).  A corresponding
               limitation may be imposed for modular integer types,
               fixed point types, enumeration types, record types, and
               array types.

56.3/2
             * A nonconfirming size clause for the first subtype of a
               derived untagged by-reference type need not be supported.

     NOTES

57
     6  Size is a subtype-specific attribute.

58/3
     7  A component_clause or Component_Size clause can override a
     specified Size.  Aspect Pack cannot.

                          _Static Semantics_

59/1
For a prefix T that denotes a task object (after any implicit
dereference):

60/3
T'Storage_Size
               Denotes the number of storage elements reserved for the
               task.  The value of this attribute is of the type
               <universal_integer>.  The Storage_Size includes the size
               of the task's stack, if any.  The language does not
               specify whether or not it includes other storage
               associated with the task (such as the "task control
               block" used by some implementations.)  If the aspect
               Storage_Size is specified for the type of the object, the
               value of the Storage_Size attribute is at least the value
               determined by the aspect.

61/3
Aspect Storage_Size specifies the amount of storage to be reserved for
the execution of a task.

<Paragraphs 62 through 65 were moved to *note Annex J::, "*note Annex
J:: Obsolescent Features".>

                          _Static Semantics_

65.1/3
For a task type (including the anonymous type of a
single_task_declaration), the following language-defined representation
aspect may be specified:

65.2/3
Storage_Size
               The Storage_Size aspect is an expression, which shall be
               of any integer type.

                           _Legality Rules_

65.3/3
The Storage_Size aspect shall not be specified for a task interface
type.

                          _Dynamic Semantics_

66/3
When a task object is created, the expression (if any) associated with
the Storage_Size aspect of its type is evaluated; the Storage_Size
attribute of the newly created task object is at least the value of the
expression.

67
At the point of task object creation, or upon task activation,
Storage_Error is raised if there is insufficient free storage to
accommodate the requested Storage_Size.

                          _Static Semantics_

68/1
For a prefix X that denotes an array subtype or array object (after any
implicit dereference):

69
X'Component_Size
               Denotes the size in bits of components of the type of X.
               The value of this attribute is of type
               <universal_integer>.

70
               Component_Size may be specified for array types via an
               attribute_definition_clause (*note 13.3: S0310.); the
               expression of such a clause shall be static, and its
               value nonnegative.

                        _Implementation Advice_

71
The recommended level of support for the Component_Size attribute is:

72
   * An implementation need not support specified Component_Sizes that
     are less than the Size of the component subtype.

73/3
   * An implementation should support specified Component_Sizes that are
     factors and multiples of the word size.  For such Component_Sizes,
     the array should contain no gaps between components.  For other
     Component_Sizes (if supported), the array should contain no gaps
     between components when Pack is also specified; the implementation
     should forbid this combination in cases where it cannot support a
     no-gaps representation.

                          _Static Semantics_

73.1/3
For a prefix X that denotes an object:

73.2/4
X'Has_Same_Storage
               X'Has_Same_Storage denotes a function with the following
               specification:

73.3/3
                    function X'Has_Same_Storage (<Arg> : <any_type>)
                      return Boolean

73.4/4
               The actual parameter shall be a name that denotes an
               object.  The object denoted by the actual parameter can
               be of any type.  This function evaluates the names of the
               objects involved.  It returns True if the representation
               of the object denoted by the actual parameter occupies
               exactly the same bits as the representation of the object
               denoted by X and the objects occupy at least one bit;
               otherwise, it returns False.

73.5/3
For a prefix X that denotes an object:

73.6/3
X'Overlaps_Storage
               X'Overlaps_Storage denotes a function with the following
               specification:

73.7/3
                    function X'Overlaps_Storage (<Arg> : <any_type>)
                      return Boolean

73.8/3
               The actual parameter shall be a name that denotes an
               object.  The object denoted by the actual parameter can
               be of any type.  This function evaluates the names of the
               objects involved and returns True if the representation
               of the object denoted by the actual parameter shares at
               least one bit with the representation of the object
               denoted by X; otherwise, it returns False.

     NOTES

73.9/3
     8  X'Has_Same_Storage(Y) implies X'Overlaps_Storage(Y).

73.10/3
     9  X'Has_Same_Storage(Y) and X'Overlaps_Storage(Y) are not
     considered to be reads of X and Y.

                          _Static Semantics_

73.11/3
The following type-related operational attribute is defined:
External_Tag.

74/1
For every subtype S of a tagged type <T> (specific or class-wide):

75/3
S'External_Tag
               S'External_Tag denotes an external string representation
               for S'Tag; it is of the predefined type String.
               External_Tag may be specified for a specific tagged type
               via an attribute_definition_clause; the expression of
               such a clause shall be static.  The default external tag
               representation is implementation defined.  See *note
               13.13.2::.  The value of External_Tag is never inherited;
               the default value is always used unless a new value is
               directly specified for a type.

                          _Dynamic Semantics_

75.1/3
If a user-specified external tag S'External_Tag is the same as
T'External_Tag for some other tagged type declared by a different
declaration in the partition, Program_Error is raised by the elaboration
of the attribute_definition_clause.

                     _Implementation Requirements_

76
In an implementation, the default external tag for each specific tagged
type declared in a partition shall be distinct, so long as the type is
declared outside an instance of a generic body.  If the compilation unit
in which a given tagged type is declared, and all compilation units on
which it semantically depends, are the same in two different partitions,
then the external tag for the type shall be the same in the two
partitions.  What it means for a compilation unit to be the same in two
different partitions is implementation defined.  At a minimum, if the
compilation unit is not recompiled between building the two different
partitions that include it, the compilation unit is considered the same
in the two partitions.

                     _Implementation Permissions_

76.1/3
If a user-specified external tag S'External_Tag is the same as
T'External_Tag for some other tagged type declared by a different
declaration in the partition, the partition may be rejected.

     NOTES

77/2
     10  The following language-defined attributes are specifiable, at
     least for some of the kinds of entities to which they apply:
     Address, Alignment, Bit_Order, Component_Size, External_Tag, Input,
     Machine_Radix, Output, Read, Size, Small, Storage_Pool,
     Storage_Size, Stream_Size, and Write.

78
     11  It follows from the general rules in *note 13.1:: that if one
     writes "for X'Size use Y;" then the X'Size attribute_reference will
     return Y (assuming the implementation allows the Size clause).  The
     same is true for all of the specifiable attributes except
     Storage_Size.

                              _Examples_

79
<Examples of attribute definition clauses:>

80
     Byte : constant := 8;
     Page : constant := 2**12;

81
     type Medium is range 0 .. 65_000;
     for Medium'Size use 2*Byte;
     for Medium'Alignment use 2;
     Device_Register : Medium;
     for Device_Register'Size use Medium'Size;
     for Device_Register'Address use System.Storage_Elements.To_Address(16#FFFF_0020#);

82
     type Short is delta 0.01 range -100.0 .. 100.0;
     for Short'Size use 15;

83
     for Car_Name'Storage_Size use --< specify access type's storage pool size>
             2000*((Car'Size/System.Storage_Unit) +1); --< approximately 2000 cars>

84/2
     function My_Input(Stream : not null access Ada.Streams.Root_Stream_Type'Class)
       return T;
     for T'Input use My_Input; --< see *note 13.13.2::>

     NOTES

85
     12  <Notes on the examples:> In the Size clause for Short, fifteen
     bits is the minimum necessary, since the type definition requires
     Short'Small <= 2**(-7).


File: arm2012.info,  Node: 13.4,  Next: 13.5,  Prev: 13.3,  Up: 13

13.4 Enumeration Representation Clauses
=======================================

1
An enumeration_representation_clause specifies the internal codes for
enumeration literals.

                               _Syntax_

2
     enumeration_representation_clause ::=
         for <first_subtype_>local_name use enumeration_aggregate;

3
     enumeration_aggregate ::= array_aggregate

                        _Name Resolution Rules_

4
The enumeration_aggregate shall be written as a one-dimensional
array_aggregate, for which the index subtype is the unconstrained
subtype of the enumeration type, and each component expression is
expected to be of any integer type.

                           _Legality Rules_

5
The <first_subtype_>local_name of an enumeration_representation_clause
shall denote an enumeration subtype.

6/2
Each component of the array_aggregate shall be given by an expression
rather than a <>.  The expressions given in the array_aggregate shall be
static, and shall specify distinct integer codes for each value of the
enumeration type; the associated integer codes shall satisfy the
predefined ordering relation of the type.

                          _Static Semantics_

7
An enumeration_representation_clause specifies the <coding> aspect of
representation.  The coding consists of the <internal code> for each
enumeration literal, that is, the integral value used internally to
represent each literal.

                     _Implementation Requirements_

8
For nonboolean enumeration types, if the coding is not specified for the
type, then for each value of the type, the internal code shall be equal
to its position number.

                        _Implementation Advice_

9
The recommended level of support for enumeration_representation_clauses
is:

10
   * An implementation should support at least the internal codes in the
     range System.Min_Int..System.Max_Int.  An implementation need not
     support enumeration_representation_clause (*note 13.4: S0311.)s for
     boolean types.

     NOTES

11/3
     13  Unchecked_Conversion may be used to query the internal codes
     used for an enumeration type.  The attributes of the type, such as
     Succ, Pred, and Pos, are unaffected by the
     enumeration_representation_clause.  For example, Pos always returns
     the position number, <not> the internal integer code that might
     have been specified in an enumeration_representation_clause.

                              _Examples_

12
<Example of an enumeration representation clause:>

13
     type Mix_Code is (ADD, SUB, MUL, LDA, STA, STZ);

14
     for Mix_Code use
        (ADD => 1, SUB => 2, MUL => 3, LDA => 8, STA => 24, STZ =>33);


File: arm2012.info,  Node: 13.5,  Next: 13.6,  Prev: 13.4,  Up: 13

13.5 Record Layout
==================

1
The <(record) layout> aspect of representation consists of the <storage
places> for some or all components, that is, storage place attributes of
the components.  The layout can be specified with a
record_representation_clause (*note 13.5.1: S0313.).

* Menu:

* 13.5.1 ::   Record Representation Clauses
* 13.5.2 ::   Storage Place Attributes
* 13.5.3 ::   Bit Ordering


File: arm2012.info,  Node: 13.5.1,  Next: 13.5.2,  Up: 13.5

13.5.1 Record Representation Clauses
------------------------------------

1
A record_representation_clause specifies the storage representation of
records and record extensions, that is, the order, position, and size of
components (including discriminants, if any).  

                               _Syntax_

2
     record_representation_clause ::=
         for <first_subtype_>local_name use
           record [mod_clause]
             {component_clause}
           end record;

3
     component_clause ::=
         <component_>local_name at position range first_bit .. last_bit;

4
     position ::= <static_>expression

5
     first_bit ::= <static_>simple_expression

6
     last_bit ::= <static_>simple_expression

                        _Name Resolution Rules_

7
Each position, first_bit, and last_bit is expected to be of any integer
type.

                           _Legality Rules_

8/2
The <first_subtype_>local_name of a record_representation_clause shall
denote a specific record or record extension subtype.

9
If the <component_>local_name is a direct_name, the local_name shall
denote a component of the type.  For a record extension, the component
shall not be inherited, and shall not be a discriminant that corresponds
to a discriminant of the parent type.  If the <component_>local_name
(*note 13.1: S0306.) has an attribute_designator (*note 4.1.4: S0101.),
the direct_name (*note 4.1: S0092.) of the local_name (*note 13.1:
S0306.) shall denote either the declaration of the type or a component
of the type, and the attribute_designator (*note 4.1.4: S0101.) shall
denote an implementation-defined implicit component of the type.

10
The position, first_bit, and last_bit shall be static expressions.  The
value of position and first_bit shall be nonnegative.  The value of
last_bit shall be no less than first_bit - 1.

10.1/2
If the nondefault bit ordering applies to the type, then either:

10.2/2
   * the value of last_bit shall be less than the size of the largest
     machine scalar; or

10.3/2
   * the value of first_bit shall be zero and the value of last_bit + 1
     shall be a multiple of System.Storage_Unit.

11
At most one component_clause is allowed for each component of the type,
including for each discriminant (component_clauses may be given for
some, all, or none of the components).  Storage places within a
component_list shall not overlap, unless they are for components in
distinct variants of the same variant_part.

12
A name that denotes a component of a type is not allowed within a
record_representation_clause for the type, except as the
<component_>local_name of a component_clause.

                          _Static Semantics_

13/2
A record_representation_clause (without the mod_clause) specifies the
layout.

13.1/2
If the default bit ordering applies to the type, the position,
first_bit, and last_bit of each component_clause directly specify the
position and size of the corresponding component.

13.2/3
If the nondefault bit ordering applies to the type, then the layout is
determined as follows:

13.3/2
   * the component_clauses for which the value of last_bit is greater
     than or equal to the size of the largest machine scalar directly
     specify the position and size of the corresponding component;

13.4/2
   * for other component_clauses, all of the components having the same
     value of position are considered to be part of a single machine
     scalar, located at that position; this machine scalar has a size
     which is the smallest machine scalar size larger than the largest
     last_bit for all component_clauses at that position; the first_bit
     and last_bit of each component_clause are then interpreted as bit
     offsets in this machine scalar.

14
A record_representation_clause for a record extension does not override
the layout of the parent part; if the layout was specified for the
parent type, it is inherited by the record extension.

                     _Implementation Permissions_

15
An implementation may generate implementation-defined components (for
example, one containing the offset of another component).  An
implementation may generate names that denote such
implementation-defined components; such names shall be
implementation-defined attribute_references.  An implementation may
allow such implementation-defined names to be used in
record_representation_clause (*note 13.5.1: S0313.)s.  An implementation
can restrict such component_clause (*note 13.5.1: S0314.)s in any manner
it sees fit.

16
If a record_representation_clause is given for an untagged derived type,
the storage place attributes for all of the components of the derived
type may differ from those of the corresponding components of the parent
type, even for components whose storage place is not specified
explicitly in the record_representation_clause (*note 13.5.1: S0313.).

                        _Implementation Advice_

17
The recommended level of support for record_representation_clauses is:

17.1/2
   * An implementation should support machine scalars that correspond to
     all of the integer, floating point, and address formats supported
     by the machine.

18
   * An implementation should support storage places that can be
     extracted with a load, mask, shift sequence of machine code, and
     set with a load, shift, mask, store sequence, given the available
     machine instructions and run-time model.

19
   * A storage place should be supported if its size is equal to the
     Size of the component subtype, and it starts and ends on a boundary
     that obeys the Alignment of the component subtype.

20/2
   * For a component with a subtype whose Size is less than the word
     size, any storage place that does not cross an aligned word
     boundary should be supported.

21
   * An implementation may reserve a storage place for the tag field of
     a tagged type, and disallow other components from overlapping that
     place.

22
   * An implementation need not support a component_clause for a
     component of an extension part if the storage place is not after
     the storage places of all components of the parent type, whether or
     not those storage places had been specified.

     NOTES

23
     14  If no component_clause is given for a component, then the
     choice of the storage place for the component is left to the
     implementation.  If component_clauses are given for all components,
     the record_representation_clause completely specifies the
     representation of the type and will be obeyed exactly by the
     implementation.

                              _Examples_

24
<Example of specifying the layout of a record type:>

25
     Word : constant := 4;  --<  storage element is byte, 4 bytes per word>

26
     type State         is (A,M,W,P);
     type Mode          is (Fix, Dec, Exp, Signif);

27
     type Byte_Mask     is array (0..7)  of Boolean;
     type State_Mask    is array (State) of Boolean;
     type Mode_Mask     is array (Mode)  of Boolean;

28
     type Program_Status_Word is
       record
           System_Mask        : Byte_Mask;
           Protection_Key     : Integer range 0 .. 3;
           Machine_State      : State_Mask;
           Interrupt_Cause    : Interruption_Code;
           Ilc                : Integer range 0 .. 3;
           Cc                 : Integer range 0 .. 3;
           Program_Mask       : Mode_Mask;
           Inst_Address       : Address;
     end record;

29
     for Program_Status_Word use
       record
           System_Mask      at 0*Word range 0  .. 7;
           Protection_Key   at 0*Word range 10 .. 11; --< bits 8,9 unused>
           Machine_State    at 0*Word range 12 .. 15;
           Interrupt_Cause  at 0*Word range 16 .. 31;
           Ilc              at 1*Word range 0  .. 1;  --< second word>
           Cc               at 1*Word range 2  .. 3;
           Program_Mask     at 1*Word range 4  .. 7;
           Inst_Address     at 1*Word range 8  .. 31;
       end record;

30
     for Program_Status_Word'Size use 8*System.Storage_Unit;
     for Program_Status_Word'Alignment use 8;

     NOTES

31
     15  <Note on the example:> The record_representation_clause defines
     the record layout.  The Size clause guarantees that (at least)
     eight storage elements are used for objects of the type.  The
     Alignment clause guarantees that aliased, imported, or exported
     objects of the type will have addresses divisible by eight.


File: arm2012.info,  Node: 13.5.2,  Next: 13.5.3,  Prev: 13.5.1,  Up: 13.5

13.5.2 Storage Place Attributes
-------------------------------

                          _Static Semantics_

1
For a component C of a composite, non-array object R, the <storage place
attributes> are defined:

2/2
R.C'Position
               If the nondefault bit ordering applies to the composite
               type, and if a component_clause specifies the placement
               of C, denotes the value given for the position of the
               component_clause; otherwise, denotes the same value as
               R.C'Address - R'Address.  The value of this attribute is
               of the type <universal_integer>.

3/2
R.C'First_Bit
               If the nondefault bit ordering applies to the composite
               type, and if a component_clause specifies the placement
               of C, denotes the value given for the first_bit of the
               component_clause; otherwise, denotes the offset, from the
               start of the first of the storage elements occupied by C,
               of the first bit occupied by C. This offset is measured
               in bits.  The first bit of a storage element is numbered
               zero.  The value of this attribute is of the type
               <universal_integer>.

4/2
R.C'Last_Bit
               If the nondefault bit ordering applies to the composite
               type, and if a component_clause specifies the placement
               of C, denotes the value given for the last_bit of the
               component_clause; otherwise, denotes the offset, from the
               start of the first of the storage elements occupied by C,
               of the last bit occupied by C. This offset is measured in
               bits.  The value of this attribute is of the type
               <universal_integer>.

                        _Implementation Advice_

5
If a component is represented using some form of pointer (such as an
offset) to the actual data of the component, and this data is contiguous
with the rest of the object, then the storage place attributes should
reflect the place of the actual data, not the pointer.  If a component
is allocated discontiguously from the rest of the object, then a warning
should be generated upon reference to one of its storage place
attributes.


File: arm2012.info,  Node: 13.5.3,  Prev: 13.5.2,  Up: 13.5

13.5.3 Bit Ordering
-------------------

1
The Bit_Order attribute specifies the interpretation of the storage
place attributes.

                          _Static Semantics_

2
A bit ordering is a method of interpreting the meaning of the storage
place attributes.  High_Order_First (known in the vernacular as "big
endian") means that the first bit of a storage element (bit 0) is the
most significant bit (interpreting the sequence of bits that represent a
component as an unsigned integer value).  Low_Order_First (known in the
vernacular as "little endian") means the opposite: the first bit is the
least significant.

3
For every specific record subtype S, the following attribute is defined:

4
S'Bit_Order
               Denotes the bit ordering for the type of S. The value of
               this attribute is of type System.Bit_Order.  Bit_Order
               may be specified for specific record types via an
               attribute_definition_clause; the expression of such a
               clause shall be static.

5
If Word_Size = Storage_Unit, the default bit ordering is implementation
defined.  If Word_Size > Storage_Unit, the default bit ordering is the
same as the ordering of storage elements in a word, when interpreted as
an integer.  

6
The storage place attributes of a component of a type are interpreted
according to the bit ordering of the type.

                        _Implementation Advice_

7
The recommended level of support for the nondefault bit ordering is:

8/2
   * The implementation should support the nondefault bit ordering in
     addition to the default bit ordering.

     NOTES

9/2
     16  Bit_Order clauses make it possible to write
     record_representation_clauses that can be ported between machines
     having different bit ordering.  They do not guarantee transparent
     exchange of data between such machines.


File: arm2012.info,  Node: 13.6,  Next: 13.7,  Prev: 13.5,  Up: 13

13.6 Change of Representation
=============================

1/3
A type_conversion (see *note 4.6::) can be used to convert between two
different representations of the same array or record.  To convert an
array from one representation to another, two array types need to be
declared with matching component subtypes, and convertible index types.
If one type has Pack specified and the other does not, then explicit
conversion can be used to pack or unpack an array.

2
To convert a record from one representation to another, two record types
with a common ancestor type need to be declared, with no inherited
subprograms.  Distinct representations can then be specified for the
record types, and explicit conversion between the types can be used to
effect a change in representation.

                              _Examples_

3
<Example of change of representation:>

4
     --< Packed_Descriptor and Descriptor are two different types>
     --< with identical characteristics, apart from their>
     --< representation>

5
     type Descriptor is
         record
           --< components of a descriptor>
         end record;

6
     type Packed_Descriptor is new Descriptor;

7
     for Packed_Descriptor use
         record
           --< component clauses for some or for all components>
         end record;

8
     <-- Change of representation can now be accomplished by explicit type conversions:>

9
     D : Descriptor;
     P : Packed_Descriptor;

10
     P := Packed_Descriptor(D);  --< pack D>
     D := Descriptor(P);         --< unpack P>


File: arm2012.info,  Node: 13.7,  Next: 13.8,  Prev: 13.6,  Up: 13

13.7 The Package System
=======================

1
For each implementation there is a library package called System which
includes the definitions of certain configuration-dependent
characteristics.

                          _Static Semantics_

2
The following language-defined library package exists:

3/2
     package System is
        pragma Pure(System);

4
        type Name is <implementation-defined-enumeration-type>;
        System_Name : constant Name := <implementation-defined>;

5
        --< System-Dependent Named Numbers:>

6
        Min_Int               : constant := <root_integer>'First;
        Max_Int               : constant := <root_integer>'Last;

7
        Max_Binary_Modulus    : constant := <implementation-defined>;
        Max_Nonbinary_Modulus : constant := <implementation-defined>;

8
        Max_Base_Digits       : constant := <root_real>'Digits;
        Max_Digits            : constant := <implementation-defined>;

9
        Max_Mantissa          : constant := <implementation-defined>;
        Fine_Delta            : constant := <implementation-defined>;

10
        Tick                  : constant := <implementation-defined>;

11
        --< Storage-related Declarations:>

12
        type Address is <implementation-defined>;
        Null_Address : constant Address;

13
        Storage_Unit : constant := <implementation-defined>;
        Word_Size    : constant := <implementation-defined> * Storage_Unit;
        Memory_Size  : constant := <implementation-defined>;

14/3
        --< Address Comparison:>
        function "<" (Left, Right : Address) return Boolean
           with Convention => Intrinsic;
        function "<="(Left, Right : Address) return Boolean
           with Convention => Intrinsic;
        function ">" (Left, Right : Address) return Boolean
           with Convention => Intrinsic;
        function ">="(Left, Right : Address) return Boolean
           with Convention => Intrinsic;
        function "=" (Left, Right : Address) return Boolean
           with Convention => Intrinsic;
     -- function "/=" (Left, Right : Address) return Boolean;
        --< "/=" is implicitly defined>

15/2
        --< Other System-Dependent Declarations:>
        type Bit_Order is (High_Order_First, Low_Order_First);
        Default_Bit_Order : constant Bit_Order := <implementation-defined>;

16
        --< Priority-related declarations (see *note D.1::):>
        subtype Any_Priority is Integer range <implementation-defined>;
        subtype Priority is Any_Priority range Any_Priority'First ..
                  <implementation-defined>;
        subtype Interrupt_Priority is Any_Priority range Priority'Last+1 ..
                  Any_Priority'Last;

17
        Default_Priority : constant Priority :=
                  (Priority'First + Priority'Last)/2;

18
     private
        ... -- <not specified by the language>
     end System;

19
Name is an enumeration subtype.  Values of type Name are the names of
alternative machine configurations handled by the implementation.
System_Name represents the current machine configuration.

20
The named numbers Fine_Delta and Tick are of the type <universal_real>;
the others are of the type <universal_integer>.

21
The meanings of the named numbers are:

22
Min_Int
               The smallest (most negative) value allowed for the
               expressions of a signed_integer_type_definition (*note
               3.5.4: S0042.).

23
Max_Int
               The largest (most positive) value allowed for the
               expressions of a signed_integer_type_definition (*note
               3.5.4: S0042.).

24
Max_Binary_Modulus
               A power of two such that it, and all lesser positive
               powers of two, are allowed as the modulus of a
               modular_type_definition.

25
Max_Nonbinary_Modulus
               A value such that it, and all lesser positive integers,
               are allowed as the modulus of a modular_type_definition.

26
Max_Base_Digits
               The largest value allowed for the requested decimal
               precision in a floating_point_definition (*note 3.5.7:
               S0045.).

27
Max_Digits
               The largest value allowed for the requested decimal
               precision in a floating_point_definition (*note 3.5.7:
               S0045.) that has no real_range_specification (*note
               3.5.7: S0046.).  Max_Digits is less than or equal to
               Max_Base_Digits.

28
Max_Mantissa
               The largest possible number of binary digits in the
               mantissa of machine numbers of a user-defined ordinary
               fixed point type.  (The mantissa is defined in *note
               Annex G::.)

29
Fine_Delta
               The smallest delta allowed in an
               ordinary_fixed_point_definition that has the
               real_range_specification (*note 3.5.7: S0046.) range -1.0
               ..  1.0.

30
Tick
               A period in seconds approximating the real time interval
               during which the value of Calendar.Clock remains
               constant.

31
Storage_Unit
               The number of bits per storage element.

32
Word_Size
               The number of bits per word.

33
Memory_Size
               An implementation-defined value that is intended to
               reflect the memory size of the configuration in storage
               elements.

34/2
Address is a definite, nonlimited type with preelaborable initialization
(see *note 10.2.1::).  Address represents machine addresses capable of
addressing individual storage elements.  Null_Address is an address that
is distinct from the address of any object or program unit.  

35/2
Default_Bit_Order shall be a static constant.  See *note 13.5.3:: for an
explanation of Bit_Order and Default_Bit_Order.

                     _Implementation Permissions_

36/2
An implementation may add additional implementation-defined declarations
to package System and its children.  However, it is usually better for
the implementation to provide additional functionality via
implementation-defined children of System.

                        _Implementation Advice_

37
Address should be a private type.

     NOTES

38
     17  There are also some language-defined child packages of System
     defined elsewhere.

* Menu:

* 13.7.1 ::   The Package System.Storage_Elements
* 13.7.2 ::   The Package System.Address_To_Access_Conversions


File: arm2012.info,  Node: 13.7.1,  Next: 13.7.2,  Up: 13.7

13.7.1 The Package System.Storage_Elements
------------------------------------------

                          _Static Semantics_

1
The following language-defined library package exists:

2/2
     package System.Storage_Elements is
        pragma Pure(Storage_Elements);

3
        type Storage_Offset is range <implementation-defined>;

4
        subtype Storage_Count is Storage_Offset range 0..Storage_Offset'Last;

5
        type Storage_Element is mod <implementation-defined>;
        for Storage_Element'Size use Storage_Unit;
        type Storage_Array is array
          (Storage_Offset range <>) of aliased Storage_Element;
        for Storage_Array'Component_Size use Storage_Unit;

6
        --< Address Arithmetic:>

7/3
        function "+"(Left : Address; Right : Storage_Offset) return Address
           with Convention => Intrinsic;
        function "+"(Left : Storage_Offset; Right : Address) return Address
           with Convention => Intrinsic;
        function "-"(Left : Address; Right : Storage_Offset) return Address
           with Convention => Intrinsic;
        function "-"(Left, Right : Address) return Storage_Offset
           with Convention => Intrinsic;

8/3
        function "mod"(Left : Address; Right : Storage_Offset)
           return Storage_Offset
              with Convention => Intrinsic;

9
        --< Conversion to/from integers:>

10/3
        type Integer_Address is <implementation-defined>;
        function To_Address(Value : Integer_Address) return Address
           with Convention => Intrinsic;
        function To_Integer(Value : Address) return Integer_Address
           with Convention => Intrinsic;

11/3
     end System.Storage_Elements;

12
Storage_Element represents a storage element.  Storage_Offset represents
an offset in storage elements.  Storage_Count represents a number of
storage elements.  Storage_Array represents a contiguous sequence of
storage elements.

13
Integer_Address is a (signed or modular) integer subtype.  To_Address
and To_Integer convert back and forth between this type and Address.

                     _Implementation Requirements_

14
Storage_Offset'Last shall be greater than or equal to Integer'Last or
the largest possible storage offset, whichever is smaller.
Storage_Offset'First shall be <= (-Storage_Offset'Last).

<Paragraph 15 was deleted.>

                        _Implementation Advice_

16
Operations in System and its children should reflect the target
environment semantics as closely as is reasonable.  For example, on most
machines, it makes sense for address arithmetic to "wrap around."
Operations that do not make sense should raise Program_Error.


File: arm2012.info,  Node: 13.7.2,  Prev: 13.7.1,  Up: 13.7

13.7.2 The Package System.Address_To_Access_Conversions
-------------------------------------------------------

                          _Static Semantics_

1
The following language-defined generic library package exists:

2
     generic
         type Object(<>) is limited private;
     package System.Address_To_Access_Conversions is
        pragma Preelaborate(Address_To_Access_Conversions);

3/3
        type Object_Pointer is access all Object;
        function To_Pointer(Value : Address) return Object_Pointer
           with Convention => Intrinsic;
        function To_Address(Value : Object_Pointer) return Address
           with Convention => Intrinsic;

4/3
     end System.Address_To_Access_Conversions;

5/2
The To_Pointer and To_Address subprograms convert back and forth between
values of types Object_Pointer and Address.  To_Pointer(X'Address) is
equal to X'Unchecked_Access for any X that allows Unchecked_Access.
To_Pointer(Null_Address) returns null.  For other addresses, the
behavior is unspecified.  To_Address(null) returns Null_Address.
To_Address(Y), where Y /= null, returns Y.all'Address.

                     _Implementation Permissions_

6
An implementation may place restrictions on instantiations of
Address_To_Access_Conversions.


File: arm2012.info,  Node: 13.8,  Next: 13.9,  Prev: 13.7,  Up: 13

13.8 Machine Code Insertions
============================

1
A machine code insertion can be achieved by a call to a subprogram whose
sequence_of_statements contains code_statements.

                               _Syntax_

2
     code_statement ::= qualified_expression;

3
     A code_statement is only allowed in the
     handled_sequence_of_statements (*note 11.2: S0265.) of a
     subprogram_body (*note 6.3: S0177.).  If a subprogram_body (*note
     6.3: S0177.) contains any code_statement (*note 13.8: S0318.)s,
     then within this subprogram_body (*note 6.3: S0177.) the only
     allowed form of statement is a code_statement (*note 13.8: S0318.)
     (labeled or not), the only allowed declarative_item (*note 3.11:
     S0087.)s are use_clause (*note 8.4: S0196.)s, and no
     exception_handler (*note 11.2: S0266.) is allowed (comments and
     pragmas are allowed as usual).

                        _Name Resolution Rules_

4
The qualified_expression is expected to be of any type.

                           _Legality Rules_

5
The qualified_expression shall be of a type declared in package
System.Machine_Code.

6
A code_statement shall appear only within the scope of a with_clause
that mentions package System.Machine_Code.

                          _Static Semantics_

7
The contents of the library package System.Machine_Code (if provided)
are implementation defined.  The meaning of code_statements is
implementation defined.  Typically, each qualified_expression represents
a machine instruction or assembly directive.

                     _Implementation Permissions_

8
An implementation may place restrictions on code_statements.  An
implementation is not required to provide package System.Machine_Code.

     NOTES

9
     18  An implementation may provide implementation-defined pragmas
     specifying register conventions and calling conventions.

10/2
     19  Machine code functions are exempt from the rule that a return
     statement is required.  In fact, return statements are forbidden,
     since only code_statements are allowed.

11
     20  Intrinsic subprograms (see *note 6.3.1::, "*note 6.3.1::
     Conformance Rules") can also be used to achieve machine code
     insertions.  Interface to assembly language can be achieved using
     the features in *note Annex B::, "*note Annex B:: Interface to
     Other Languages".

                              _Examples_

12
<Example of a code statement:>

13/3
     M : Mask;
     procedure Set_Mask
       with Inline;

14
     procedure Set_Mask is
       use System.Machine_Code; --< assume "with System.Machine_Code;" appears somewhere above>
     begin
       SI_Format'(Code => SSM, B => M'Base_Reg, D => M'Disp);
       --<  Base_Reg and Disp are implementation-defined attributes>
     end Set_Mask;


File: arm2012.info,  Node: 13.9,  Next: 13.10,  Prev: 13.8,  Up: 13

13.9 Unchecked Type Conversions
===============================

1
An unchecked type conversion can be achieved by a call to an instance of
the generic function Unchecked_Conversion.

                          _Static Semantics_

2
The following language-defined generic library function exists:

3/3
     generic
        type Source(<>) is limited private;
        type Target(<>) is limited private;
     function Ada.Unchecked_Conversion(S : Source) return Target
        with Convention => Intrinsic;
     pragma Pure(Ada.Unchecked_Conversion);

                          _Dynamic Semantics_

4
The size of the formal parameter S in an instance of
Unchecked_Conversion is that of its subtype.  This is the actual subtype
passed to Source, except when the actual is an unconstrained composite
subtype, in which case the subtype is constrained by the bounds or
discriminants of the value of the actual expression passed to S.

5
If all of the following are true, the effect of an unchecked conversion
is to return the value of an object of the target subtype whose
representation is the same as that of the source object S:

6
   * S'Size = Target'Size.

7/3
   * S'Alignment is a multiple of Target'Alignment or Target'Alignment
     is zero.

8
   * The target subtype is not an unconstrained composite subtype.

9
   * S and the target subtype both have a contiguous representation.

10
   * The representation of S is a representation of an object of the
     target subtype.

11/2
Otherwise, if the result type is scalar, the result of the function is
implementation defined, and can have an invalid representation (see
*note 13.9.1::).  If the result type is nonscalar, the effect is
implementation defined; in particular, the result can be abnormal (see
*note 13.9.1::).

                     _Implementation Permissions_

12
An implementation may return the result of an unchecked conversion by
reference, if the Source type is not a by-copy type.  In this case, the
result of the unchecked conversion represents simply a different
(read-only) view of the operand of the conversion.

13
An implementation may place restrictions on Unchecked_Conversion.

                        _Implementation Advice_

14/2
Since the Size of an array object generally does not include its bounds,
the bounds should not be part of the converted data.

15
The implementation should not generate unnecessary run-time checks to
ensure that the representation of S is a representation of the target
type.  It should take advantage of the permission to return by reference
when possible.  Restrictions on unchecked conversions should be avoided
unless required by the target environment.

16
The recommended level of support for unchecked conversions is:

17/3
   * Unchecked conversions should be supported and should be reversible
     in the cases where this subclause defines the result.  To enable
     meaningful use of unchecked conversion, a contiguous representation
     should be used for elementary subtypes, for statically constrained
     array subtypes whose component subtype is one of the subtypes
     described in this paragraph, and for record subtypes without
     discriminants whose component subtypes are described in this
     paragraph.

* Menu:

* 13.9.1 ::   Data Validity
* 13.9.2 ::   The Valid Attribute


File: arm2012.info,  Node: 13.9.1,  Next: 13.9.2,  Up: 13.9

13.9.1 Data Validity
--------------------

1
Certain actions that can potentially lead to erroneous execution are not
directly erroneous, but instead can cause objects to become <abnormal>.
Subsequent uses of abnormal objects can be erroneous.

2
A scalar object can have an <invalid representation>, which means that
the object's representation does not represent any value of the object's
subtype.  The primary cause of invalid representations is uninitialized
variables.

3
Abnormal objects and invalid representations are explained in this
subclause.

                          _Dynamic Semantics_

4
When an object is first created, and any explicit or default
initializations have been performed, the object and all of its parts are
in the <normal> state.  Subsequent operations generally leave them
normal.  However, an object or part of an object can become <abnormal>
in the following ways:

5
   * An assignment to the object is disrupted due to an abort (see *note
     9.8::) or due to the failure of a language-defined check (see *note
     11.6::).

6/2
   * The object is not scalar, and is passed to an in out or out
     parameter of an imported procedure, the Read procedure of an
     instance of Sequential_IO, Direct_IO, or Storage_IO, or the stream
     attribute T'Read, if after return from the procedure the
     representation of the parameter does not represent a value of the
     parameter's subtype.

6.1/2
   * The object is the return object of a function call of a nonscalar
     type, and the function is an imported function, an instance of
     Unchecked_Conversion, or the stream attribute T'Input, if after
     return from the function the representation of the return object
     does not represent a value of the function's subtype.

6.2/2
For an imported object, it is the programmer's responsibility to ensure
that the object remains in a normal state.

7
Whether or not an object actually becomes abnormal in these cases is not
specified.  An abnormal object becomes normal again upon successful
completion of an assignment to the object as a whole.

                         _Erroneous Execution_

8
It is erroneous to evaluate a primary that is a name denoting an
abnormal object, or to evaluate a prefix that denotes an abnormal
object.

                      _Bounded (Run-Time) Errors_

9
If the representation of a scalar object does not represent a value of
the object's subtype (perhaps because the object was not initialized),
the object is said to have an <invalid representation>.  It is a bounded
error to evaluate the value of such an object.  If the error is
detected, either Constraint_Error or Program_Error is raised.
Otherwise, execution continues using the invalid representation.  The
rules of the language outside this subclause assume that all objects
have valid representations.  The semantics of operations on invalid
representations are as follows:

10
   * If the representation of the object represents a value of the
     object's type, the value of the type is used.

11
   * If the representation of the object does not represent a value of
     the object's type, the semantics of operations on such
     representations is implementation-defined, but does not by itself
     lead to erroneous or unpredictable execution, or to other objects
     becoming abnormal.

                         _Erroneous Execution_

12/3
A call to an imported function or an instance of Unchecked_Conversion is
erroneous if the result is scalar, the result object has an invalid
representation, and the result is used other than as the expression of
an assignment_statement or an object_declaration, as the <object_>name
of an object_renaming_declaration, or as the prefix of a Valid
attribute.  If such a result object is used as the source of an
assignment, and the assigned value is an invalid representation for the
target of the assignment, then any use of the target object prior to a
further assignment to the target object, other than as the prefix of a
Valid attribute reference, is erroneous.

13/3
The dereference of an access value is erroneous if it does not designate
an object of an appropriate type or a subprogram with an appropriate
profile, if it designates a nonexistent object, or if it is an
access-to-variable value that designates a constant object and it did
not originate from an attribute_reference applied to an aliased variable
view of a controlled or immutably limited object.  An access value whose
dereference is erroneous can exist, for example, because of
Unchecked_Deallocation, Unchecked_Access, or Unchecked_Conversion.

     NOTES

14
     21  Objects can become abnormal due to other kinds of actions that
     directly update the object's representation; such actions are
     generally considered directly erroneous, however.


File: arm2012.info,  Node: 13.9.2,  Prev: 13.9.1,  Up: 13.9

13.9.2 The Valid Attribute
--------------------------

1
The Valid attribute can be used to check the validity of data produced
by unchecked conversion, input, interface to foreign languages, and the
like.

                          _Static Semantics_

2
For a prefix X that denotes a scalar object (after any implicit
dereference), the following attribute is defined:

3/4
X'Valid
               Yields True if and only if the object denoted by X is
               normal, has a valid representation, and then, if the
               preceding conditions hold, the value of X also satisfies
               the predicates of the nominal subtype of X. The value of
               this attribute is of the predefined type Boolean.

     NOTES

4
     22  Invalid data can be created in the following cases (not
     counting erroneous or unpredictable execution):

5
        * an uninitialized scalar object,

6
        * the result of an unchecked conversion,

7
        * input,

8
        * interface to another language (including machine code),

9
        * aborting an assignment,

10
        * disrupting an assignment due to the failure of a
          language-defined check (see *note 11.6::), and

11
        * use of an object whose Address has been specified.

12/4
     23  Determining whether X is normal and has a valid representation
     as part of the evaluation of X'Valid is not considered to include
     an evaluation of X; hence, it is not an error to check the validity
     of an object that is invalid or abnormal.  Determining whether X
     satisfies the predicates of its nominal subtype may include an
     evaluation of X, but only after it has been determined that X has a
     valid representation.

13/4
     If X is volatile, the evaluation of X'Valid is considered a read of
     X.

14/2
     24  The Valid attribute may be used to check the result of calling
     an instance of Unchecked_Conversion (or any other operation that
     can return invalid values).  However, an exception handler should
     also be provided because implementations are permitted to raise
     Constraint_Error or Program_Error if they detect the use of an
     invalid representation (see *note 13.9.1::).


File: arm2012.info,  Node: 13.10,  Next: 13.11,  Prev: 13.9,  Up: 13

13.10 Unchecked Access Value Creation
=====================================

1
The attribute Unchecked_Access is used to create access values in an
unsafe manner -- the programmer is responsible for preventing "dangling
references."

                          _Static Semantics_

2
The following attribute is defined for a prefix X that denotes an
aliased view of an object:

3
X'Unchecked_Access
               All rules and semantics that apply to X'Access (see *note
               3.10.2::) apply also to X'Unchecked_Access, except that,
               for the purposes of accessibility rules and checks, it is
               as if X were declared immediately within a library
               package.  

     NOTES

4
     25  This attribute is provided to support the situation where a
     local object is to be inserted into a global linked data structure,
     when the programmer knows that it will always be removed from the
     data structure prior to exiting the object's scope.  The Access
     attribute would be illegal in this case (see *note 3.10.2::, "*note
     3.10.2:: Operations of Access Types").

5
     26  There is no Unchecked_Access attribute for subprograms.


File: arm2012.info,  Node: 13.11,  Next: 13.12,  Prev: 13.10,  Up: 13

13.11 Storage Management
========================

1
Each access-to-object type has an associated storage pool.  The storage
allocated by an allocator comes from the pool; instances of
Unchecked_Deallocation return storage to the pool.  Several access types
can share the same pool.

2/2
A storage pool is a variable of a type in the class rooted at
Root_Storage_Pool, which is an abstract limited controlled type.  By
default, the implementation chooses a <standard storage pool> for each
access-to-object type.  The user may define new pool types, and may
override the choice of pool for an access-to-object type by specifying
Storage_Pool for the type.

                           _Legality Rules_

3
If Storage_Pool is specified for a given access type, Storage_Size shall
not be specified for it.

                          _Static Semantics_

4
The following language-defined library package exists:

5
     with Ada.Finalization;
     with System.Storage_Elements;
     package System.Storage_Pools is
         pragma Preelaborate(System.Storage_Pools);

6/2
         type Root_Storage_Pool is
             abstract new Ada.Finalization.Limited_Controlled with private;
         pragma Preelaborable_Initialization(Root_Storage_Pool);

7
         procedure Allocate(
           Pool : in out Root_Storage_Pool;
           Storage_Address : out Address;
           Size_In_Storage_Elements : in Storage_Elements.Storage_Count;
           Alignment : in Storage_Elements.Storage_Count) is abstract;

8
         procedure Deallocate(
           Pool : in out Root_Storage_Pool;
           Storage_Address : in Address;
           Size_In_Storage_Elements : in Storage_Elements.Storage_Count;
           Alignment : in Storage_Elements.Storage_Count) is abstract;

9
         function Storage_Size(Pool : Root_Storage_Pool)
             return Storage_Elements.Storage_Count is abstract;

10
     private
        ... -- <not specified by the language>
     end System.Storage_Pools;

11
A <storage pool type> (or <pool type>) is a descendant of
Root_Storage_Pool.  The <elements> of a storage pool are the objects
allocated in the pool by allocators.

12/2
For every access-to-object subtype S, the following representation
attributes are defined:

13
S'Storage_Pool
               Denotes the storage pool of the type of S. The type of
               this attribute is Root_Storage_Pool'Class.

14
S'Storage_Size
               Yields the result of calling
               Storage_Size(S'Storage_Pool), which is intended to be a
               measure of the number of storage elements reserved for
               the pool.  The type of this attribute is
               <universal_integer>.

15
Storage_Size or Storage_Pool may be specified for a nonderived
access-to-object type via an attribute_definition_clause (*note 13.3:
S0310.); the name in a Storage_Pool clause shall denote a variable.

16/3
An allocator of a type <T> that does not support subpools allocates
storage from <T>'s storage pool.  If the storage pool is a user-defined
object, then the storage is allocated by calling Allocate as described
below.  Allocators for types that support subpools are described in
*note 13.11.4::.

17
If Storage_Pool is not specified for a type defined by an
access_to_object_definition, then the implementation chooses a standard
storage pool for it in an implementation-defined manner.  In this case,
the exception Storage_Error is raised by an allocator if there is not
enough storage.  It is implementation defined whether or not the
implementation provides user-accessible names for the standard pool
type(s).

18/4
If Storage_Size is specified for an access type <T>, an
implementation-defined pool <P> is used for the type.  The Storage_Size
of <P> is at least that requested, and the storage for <P> is reclaimed
when the master containing the declaration of the access type is left.
If the implementation cannot satisfy the request, Storage_Error is
raised at the freezing point of type <T>.  The storage pool <P> is used
only for allocators returning type <T> or other access types specified
to use <T>'Storage_Pool.  Storage_Error is raised by an allocator
returning such a type if the storage space of <P> is exhausted
(additional memory is not allocated).

18.1/4
If neither Storage_Pool nor Storage_Size are specified, then the meaning
of Storage_Size is implementation defined.

19
If Storage_Pool is specified for an access type, then the specified pool
is used.

20
The effect of calling Allocate and Deallocate for a standard storage
pool directly (rather than implicitly via an allocator or an instance of
Unchecked_Deallocation) is unspecified.

                         _Erroneous Execution_

21
If Storage_Pool is specified for an access type, then if Allocate can
satisfy the request, it should allocate a contiguous block of memory,
and return the address of the first storage element in Storage_Address.
The block should contain Size_In_Storage_Elements storage elements, and
should be aligned according to Alignment.  The allocated storage should
not be used for any other purpose while the pool element remains in
existence.  If the request cannot be satisfied, then Allocate should
propagate an exception (such as Storage_Error).  If Allocate behaves in
any other manner, then the program execution is erroneous.

                     _Implementation Requirements_

21.1/3
The Allocate procedure of a user-defined storage pool object <P> may be
called by the implementation only to allocate storage for a type <T>
whose pool is <P>, only at the following points:

21.2/3
   * During the execution of an allocator of type <T>;

21.3/3
   * During the execution of a return statement for a function whose
     result is built-in-place in the result of an allocator of type <T>;

21.4/3
   * During the execution of an assignment operation with a target of an
     allocated object of type <T> with a part that has an unconstrained
     discriminated subtype with defaults.

21.5/3
For each of the calls of Allocate described above, <P> (equivalent to
<T>'Storage_Pool) is passed as the Pool parameter.  The
Size_In_Storage_Elements parameter indicates the number of storage
elements to be allocated, and is no more than
<D>'Max_Size_In_Storage_Elements, where <D> is the designated subtype of
<T>.  The Alignment parameter is a nonzero integral multiple of
<D>'Alignment if <D> is a specific type, and otherwise is a nonzero
integral multiple of the alignment of the specific type identified by
the tag of the object being created; it is unspecified if there is no
such value.  The Alignment parameter is no more than
<D>'Max_Alignment_For_Allocation.  The result returned in the
Storage_Address parameter is used as the address of the allocated
storage, which is a contiguous block of memory of
Size_In_Storage_Elements storage elements.  Any exception propagated by
Allocate is propagated by the construct that contained the call.

21.6/3
The number of calls to Allocate needed to implement an allocator for any
particular type is unspecified.  The number of calls to Deallocate
needed to implement an instance of Unchecked_Deallocation (see *note
13.11.2::) for any particular object is the same as the number of
Allocate calls for that object.

21.7/3
The Deallocate procedure of a user-defined storage pool object <P> may
be called by the implementation to deallocate storage for a type <T>
whose pool is <P> only at the places when an Allocate call is allowed
for <P>, during the execution of an instance of Unchecked_Deallocation
for <T>, or as part of the finalization of the collection of <T>.  For
such a call of Deallocate, <P> (equivalent to <T>'Storage_Pool) is
passed as the Pool parameter.  The value of the Storage_Address
parameter for a call to Deallocate is the value returned in the
Storage_Address parameter of the corresponding successful call to
Allocate.  The values of the Size_In_Storage_Elements and Alignment
parameters are the same values passed to the corresponding Allocate
call.  Any exception propagated by Deallocate is propagated by the
construct that contained the call.

                     _Documentation Requirements_

22
An implementation shall document the set of values that a user-defined
Allocate procedure needs to accept for the Alignment parameter.  An
implementation shall document how the standard storage pool is chosen,
and how storage is allocated by standard storage pools.

                        _Implementation Advice_

23
An implementation should document any cases in which it dynamically
allocates heap storage for a purpose other than the evaluation of an
allocator.

24
A default (implementation-provided) storage pool for an
access-to-constant type should not have overhead to support deallocation
of individual objects.

25/2
The storage pool used for an allocator of an anonymous access type
should be determined as follows:

25.1/2
   * If the allocator is defining a coextension (see *note 3.10.2::) of
     an object being created by an outer allocator, then the storage
     pool used for the outer allocator should also be used for the
     coextension;

25.2/2
   * For other access discriminants and access parameters, the storage
     pool should be created at the point of the allocator, and be
     reclaimed when the allocated object becomes inaccessible;

25.3/3
   * If the allocator defines the result of a function with an access
     result, the storage pool is determined as though the allocator were
     in place of the call of the function.  If the call is the operand
     of a type conversion, the storage pool is that of the target access
     type of the conversion.  If the call is itself defining the result
     of a function with an access result, this rule is applied
     recursively;

25.4/2
   * Otherwise, a default storage pool should be created at the point
     where the anonymous access type is elaborated; such a storage pool
     need not support deallocation of individual objects.

     NOTES

26
     27  A user-defined storage pool type can be obtained by extending
     the Root_Storage_Pool type, and overriding the primitive
     subprograms Allocate, Deallocate, and Storage_Size.  A user-defined
     storage pool can then be obtained by declaring an object of the
     type extension.  The user can override Initialize and Finalize if
     there is any need for nontrivial initialization and finalization
     for a user-defined pool type.  For example, Finalize might reclaim
     blocks of storage that are allocated separately from the pool
     object itself.

27
     28  The writer of the user-defined allocation and deallocation
     procedures, and users of allocators for the associated access type,
     are responsible for dealing with any interactions with tasking.  In
     particular:

28
        * If the allocators are used in different tasks, they require
          mutual exclusion.

29
        * If they are used inside protected objects, they cannot block.

30
        * If they are used by interrupt handlers (see *note C.3::,
          "*note C.3:: Interrupt Support"), the mutual exclusion
          mechanism has to work properly in that context.

31
     29  The primitives Allocate, Deallocate, and Storage_Size are
     declared as abstract (see *note 3.9.3::), and therefore they have
     to be overridden when a new (nonabstract) storage pool type is
     declared.

                              _Examples_

32
To associate an access type with a storage pool object, the user first
declares a pool object of some type derived from Root_Storage_Pool.
Then, the user defines its Storage_Pool attribute, as follows:

33
     Pool_Object : Some_Storage_Pool_Type;

34
     type T is access Designated;
     for T'Storage_Pool use Pool_Object;

35
Another access type may be added to an existing storage pool, via:

36
     for T2'Storage_Pool use T'Storage_Pool;

37
The semantics of this is implementation defined for a standard storage
pool.

38/3
As usual, a derivative of Root_Storage_Pool may define additional
operations.  For example, consider the Mark_Release_Pool_Type defined in
*note 13.11.6::, that has two additional operations, Mark and Release,
the following is a possible use:

39/3
     type Mark_Release_Pool_Type
        (Pool_Size : Storage_Elements.Storage_Count)
             is new Subpools.Root_Storage_Pool_With_Subpools with private;
                -- <As defined in package MR_Pool, see *note 13.11.6::>

40
     ...

41/3
     Our_Pool : Mark_Release_Pool_Type (Pool_Size => 2000);
     My_Mark : MR_Pool.Subpool_Handle; -- <See *note 13.11.6::>

42/3
     type Acc is access ...;
     for Acc'Storage_Pool use Our_Pool;
     ...

43/3
     My_Mark := Mark(Our_Pool);
     ... --< Allocate objects using "new (My_Mark) Designated(...)".>
     Release(My_Mark); --< Finalize objects and reclaim storage.>

* Menu:

* 13.11.1 ::  Storage Allocation Attributes
* 13.11.2 ::  Unchecked Storage Deallocation
* 13.11.3 ::  Default Storage Pools
* 13.11.4 ::  Storage Subpools
* 13.11.5 ::  Subpool Reclamation
* 13.11.6 ::  Storage Subpool Example


File: arm2012.info,  Node: 13.11.1,  Next: 13.11.2,  Up: 13.11

13.11.1 Storage Allocation Attributes
-------------------------------------

1/3
The Max_Size_In_Storage_Elements and Max_Alignment_For_Allocation
attributes may be useful in writing user-defined pool types.

                          _Static Semantics_

2/3
For every subtype S, the following attributes are defined:

3/3
S'Max_Size_In_Storage_Elements
               Denotes the maximum value for Size_In_Storage_Elements
               that could be requested by the implementation via
               Allocate for an access type whose designated subtype is
               S. The value of this attribute is of type
               <universal_integer>.

4/3
S'Max_Alignment_For_Allocation
               Denotes the maximum value for Alignment that could be
               requested by the implementation via Allocate for an
               access type whose designated subtype is S. The value of
               this attribute is of type <universal_integer>.

5/3
For a type with access discriminants, if the implementation allocates
space for a coextension in the same pool as that of the object having
the access discriminant, then these attributes account for any calls on
Allocate that could be performed to provide space for such coextensions.


File: arm2012.info,  Node: 13.11.2,  Next: 13.11.3,  Prev: 13.11.1,  Up: 13.11

13.11.2 Unchecked Storage Deallocation
--------------------------------------

1
Unchecked storage deallocation of an object designated by a value of an
access type is achieved by a call to an instance of the generic
procedure Unchecked_Deallocation.

                          _Static Semantics_

2
The following language-defined generic library procedure exists:

3/3
     generic
        type Object(<>) is limited private;
        type Name   is access  Object;
     procedure Ada.Unchecked_Deallocation(X : in out Name)
        with Convention => Intrinsic;
     pragma Preelaborate(Ada.Unchecked_Deallocation);

                           _Legality Rules_

3.1/3
A call on an instance of Unchecked_Deallocation is illegal if the actual
access type of the instance is a type for which the Storage_Size has
been specified by a static expression with value zero or is defined by
the language to be zero.  In addition to the places where Legality Rules
normally apply (see *note 12.3::), this rule applies also in the private
part of an instance of a generic unit.

                          _Dynamic Semantics_

4
Given an instance of Unchecked_Deallocation declared as follows:

5
     procedure Free is
         new Ada.Unchecked_Deallocation(
             <object_subtype_name>, <access_to_variable_subtype_name>);

6
Procedure Free has the following effect:

7
     1.  After executing Free(X), the value of X is null.

8
     2.  Free(X), when X is already equal to null, has no effect.

9/3
     3.  Free(X), when X is not equal to null first performs
     finalization of the object designated by X (and any coextensions of
     the object -- see *note 3.10.2::), as described in *note 7.6.1::.
     It then deallocates the storage occupied by the object designated
     by X (and any coextensions).  If the storage pool is a user-defined
     object, then the storage is deallocated by calling Deallocate as
     described in *note 13.11::.  There is one exception: if the object
     being freed contains tasks, the object might not be deallocated.

10/4
After the finalization step of Free(X), the object designated by X, and
any subcomponents (and coextensions) thereof, no longer exist; their
storage can be reused for other purposes.

                      _Bounded (Run-Time) Errors_

11
It is a bounded error to free a discriminated, unterminated task object.
The possible consequences are:

12
   * No exception is raised.

13
   * Program_Error or Tasking_Error is raised at the point of the
     deallocation.

14
   * Program_Error or Tasking_Error is raised in the task the next time
     it references any of the discriminants.

15
In the first two cases, the storage for the discriminants (and for any
enclosing object if it is designated by an access discriminant of the
task) is not reclaimed prior to task termination.

15.1/4
An access value that designates a nonexistent object is called a
<dangling reference>.

15.2/4
If a dangling reference is dereferenced (implicitly or explicitly),
execution is erroneous (see below).  If there is no explicit or implicit
dereference, then it is a bounded error to evaluate an expression whose
result is a dangling reference.  If the error is detected, either
Constraint_Error or Program_Error is raised.  Otherwise, execution
proceeds normally, but with the possibility that the access value
designates some other existing object.

                         _Erroneous Execution_

16/3
Evaluating a name that denotes a nonexistent object, or a protected
subprogram or subprogram renaming whose associated object (if any) is
nonexistent, is erroneous.  The execution of a call to an instance of
Unchecked_Deallocation is erroneous if the object was created other than
by an allocator for an access type whose pool is Name'Storage_Pool.

                        _Implementation Advice_

17
For a standard storage pool, Free should actually reclaim the storage.

17.1/3
A call on an instance of Unchecked_Deallocation with a nonnull access
value should raise Program_Error if the actual access type of the
instance is a type for which the Storage_Size has been specified to be
zero or is defined by the language to be zero.

     NOTES

18
     30  The rules here that refer to Free apply to any instance of
     Unchecked_Deallocation.

19
     31  Unchecked_Deallocation cannot be instantiated for an
     access-to-constant type.  This is implied by the rules of *note
     12.5.4::.


File: arm2012.info,  Node: 13.11.3,  Next: 13.11.4,  Prev: 13.11.2,  Up: 13.11

13.11.3 Default Storage Pools
-----------------------------

1/4
Pragma and aspect Default_Storage_Pool specify the storage pool that
will be used in the absence of an explicit specification of a storage
pool or storage size for an access type.

                               _Syntax_

2/3
     The form of a pragma Default_Storage_Pool is as follows:

3/3
       pragma Default_Storage_Pool (storage_pool_indicator);

3.1/4
     storage_pool_indicator ::= <storage_pool_>name | null | Standard

3.2/3
     A pragma Default_Storage_Pool is allowed immediately within the
     visible part of a package_specification, immediately within a
     declarative_part, or as a configuration pragma.

                        _Name Resolution Rules_

3.3/3
The <storage_pool_>name is expected to be of type
Root_Storage_Pool'Class.

                           _Legality Rules_

4/3
The <storage_pool_>name shall denote a variable.

4.1/4
The Standard storage_pool_indicator is an identifier specific to a
pragma (see *note 2.8::) and does not denote any declaration.  If the
storage_pool_indicator is Standard, then there shall not be a
declaration with defining_identifier Standard that is immediately
visible at the point of the pragma, other than package Standard itself.

4.2/4
If the pragma is used as a configuration pragma, the
storage_pool_indicator shall be either null or Standard, and it defines
the <default pool> to be the given storage_pool_indicator within all
applicable compilation units (see *note 10.1.5::), except within the
immediate scope of another pragma Default_Storage_Pool.  Otherwise, the
pragma occurs immediately within a sequence of declarations, and it
defines the default pool within the immediate scope of the pragma to be
the given storage_pool_indicator, except within the immediate scope of a
later pragma Default_Storage_Pool.  Thus, an inner pragma overrides an
outer one.

4.3/4
A pragma Default_Storage_Pool shall not be used as a configuration
pragma that applies to a compilation unit that is within the immediate
scope of another pragma Default_Storage_Pool.

                          _Static Semantics_

5/4
The language-defined aspect Default_Storage_Pool may be specified for a
generic instance; it defines the default pool for access types within an
instance.  .

5.1/4
The Default_Storage_Pool aspect may be specified as Standard, which is
an identifier specific to an aspect (see *note 13.1.1::) and defines the
default pool to be Standard.  In this case, there shall not be a
declaration with defining_identifier Standard that is immediately
visible at the point of the aspect specification, other than package
Standard itself.

5.2/4
Otherwise, the expected type for the Default_Storage_Pool aspect is
Root_Storage_Pool'Class and the aspect_definition shall be a name that
denotes a variable.  This aspect overrides any Default_Storage_Pool
pragma that might apply to the generic unit; if the aspect is not
specified, the default pool of the instance is that defined for the
generic unit.

5.3/4
The effect of specifying the aspect Default_Storage_Pool on an instance
of a language-defined generic unit is implementation-defined.

6/3
For nonderived access types declared in places where the default pool is
defined by the pragma or aspect, their Storage_Pool or Storage_Size
attribute is determined as follows, unless Storage_Pool or Storage_Size
is specified for the type:

6.1/3
   * If the default pool is null, the Storage_Size attribute is defined
     by the language to be zero.  Therefore, an allocator for such a
     type is illegal.

6.2/4
   * If the default pool is neither null nor Standard, the Storage_Pool
     attribute is that pool.

6.3/4
Otherwise (including when the default pool is specified as Standard),
the standard storage pool is used for the type as described in *note
13.11::.

7/3
<This paragraph was deleted.>

                     _Implementation Permissions_

8/3
An object created by an allocator that is passed as the actual parameter
to an access parameter may be allocated on the stack, and automatically
reclaimed, regardless of the default pool.

     NOTES

9/3
     32  Default_Storage_Pool may be used with restrictions
     No_Coextensions and No_Access_Parameter_Allocators (see *note
     H.4::) to ensure that all allocators use the default pool.


File: arm2012.info,  Node: 13.11.4,  Next: 13.11.5,  Prev: 13.11.3,  Up: 13.11

13.11.4 Storage Subpools
------------------------

1/3
This subclause defines a package to support the partitioning of a
storage pool into subpools.  A subpool may be specified as the default
to be used for allocation from the associated storage pool, or a
particular subpool may be specified as part of an allocator (see *note
4.8::).

                          _Static Semantics_

2/3
The following language-defined library package exists:

3/3
     package System.Storage_Pools.Subpools is
        pragma Preelaborate (Subpools);

4/3
        type Root_Storage_Pool_With_Subpools is
           abstract new Root_Storage_Pool with private;

5/3
        type Root_Subpool is abstract tagged limited private;

6/3
        type Subpool_Handle is access all Root_Subpool'Class;
        for Subpool_Handle'Storage_Size use 0;

7/3
        function Create_Subpool (Pool : in out Root_Storage_Pool_With_Subpools)
           return not null Subpool_Handle is abstract;

8/3
        -- <The following operations are intended for pool implementers:>

9/3
        function Pool_of_Subpool (Subpool : not null Subpool_Handle)
           return access Root_Storage_Pool_With_Subpools'Class;

10/3
        procedure Set_Pool_of_Subpool (
           Subpool : in not null Subpool_Handle;
           To : in out Root_Storage_Pool_With_Subpools'Class);

11/3
        procedure Allocate_From_Subpool (
           Pool : in out Root_Storage_Pool_With_Subpools;
           Storage_Address : out Address;
           Size_In_Storage_Elements : in Storage_Elements.Storage_Count;
           Alignment : in Storage_Elements.Storage_Count;
           Subpool : in not null Subpool_Handle) is abstract
              with Pre'Class => Pool_of_Subpool(Subpool) = Pool'Access;

12/3
        procedure Deallocate_Subpool (
           Pool : in out Root_Storage_Pool_With_Subpools;
           Subpool : in out Subpool_Handle) is abstract
              with Pre'Class => Pool_of_Subpool(Subpool) = Pool'Access;

13/3
        function Default_Subpool_for_Pool (
           Pool : in out Root_Storage_Pool_With_Subpools)
              return not null Subpool_Handle;

14/3
        overriding
        procedure Allocate (
           Pool : in out Root_Storage_Pool_With_Subpools;
           Storage_Address : out Address;
           Size_In_Storage_Elements : in Storage_Elements.Storage_Count;
           Alignment : in Storage_Elements.Storage_Count);

15/3
        overriding
        procedure Deallocate (
           Pool : in out Root_Storage_Pool_With_Subpools;
           Storage_Address : in Address;
           Size_In_Storage_Elements : in Storage_Elements.Storage_Count;
           Alignment : in Storage_Elements.Storage_Count) is null;

16/3
        overriding
        function Storage_Size (Pool : Root_Storage_Pool_With_Subpools)
           return Storage_Elements.Storage_Count
               is (Storage_Elements.Storage_Count'Last);

17/3
     private
        ... -- <not specified by the language>
     end System.Storage_Pools.Subpools;

18/3
A <subpool> is a separately reclaimable portion of a storage pool,
identified by an object of type Subpool_Handle (a <subpool handle>).  A
subpool handle also identifies the enclosing storage pool, a <storage
pool that supports subpools>, which is a storage pool whose type is
descended from Root_Storage_Pool_With_Subpools.  A subpool is created by
calling Create_Subpool or a similar constructor; the constructor returns
the subpool handle.

19/3
A <subpool object> is an object of a type descended from Root_Subpool.
Typically, subpool objects are managed by the containing storage pool;
only the handles need be exposed to clients of the storage pool.
Subpool objects are designated by subpool handles, and are the run-time
representation of a subpool.

20/4
Each subpool <belongs> to a single storage pool (which will always be a
pool that supports subpools).  An access to the pool that a subpool
belongs to can be obtained by calling Pool_of_Subpool with the subpool
handle.  Set_Pool_of_Subpool causes the subpool of the subpool handle to
belong to the given pool; this is intended to be called from subpool
constructors like Create_Subpool.  Set_Pool_of_Subpool propagates
Program_Error if the subpool already belongs to a pool.  If
Set_Pool_of_Subpool has not yet been called for a subpool,
Pool_of_Subpool returns null.

21/3
When an allocator for a type whose storage pool supports subpools is
evaluated, a call is made on Allocate_From_Subpool passing in a
Subpool_Handle, in addition to the parameters as defined for calls on
Allocate (see *note 13.11::).  The subpool designated by the
<subpool_handle_>name is used, if specified in an allocator.  Otherwise,
Default_Subpool_for_Pool of the Pool is used to provide a subpool
handle.  All requirements on the Allocate procedure also apply to
Allocate_from_Subpool.

                           _Legality Rules_

22/3
If a storage pool that supports subpools is specified as the
Storage_Pool for an access type, the access type is called a <subpool
access type>.  A subpool access type shall be a pool-specific access
type.

23/3
The accessibility level of a subpool access type shall not be statically
deeper than that of the storage pool object.  If the specified storage
pool object is a storage pool that supports subpools, then the name that
denotes the object shall not denote part of a formal parameter, nor
shall it denote part of a dereference of a value of a non-library-level
general access type.  In addition to the places where Legality Rules
normally apply (see *note 12.3::), these rules also apply in the private
part of an instance of a generic unit.

                          _Dynamic Semantics_

24/3
When an access type with a specified storage pool is frozen (see *note
13.14::), if the tag of the storage pool object identifies a storage
pool that supports subpools, the following checks are made:

25/3
   * the name used to specify the storage pool object does not denote
     part of a formal parameter nor part of a dereference of a value of
     a non-library-level general access type; and

26/3
   * the accessibility level of the access type is not deeper than that
     of the storage pool object.

27/3
Program_Error is raised if either of these checks fail.

28/3
A call to Subpools.Allocate(P, Addr, Size, Align) does the following:

29/3
     Allocate_From_Subpool
       (Root_Storage_Pool_With_Subpools'Class(P),
        Addr, Size, Align,
        Subpool => Default_Subpool_for_Pool
                     (Root_Storage_Pool_With_Subpools'Class(P)));

30/3
An allocator that allocates in a subpool raises Program_Error if the
allocated object has task parts.

31/3
Unless overridden, Default_Subpool_for_Pool propagates Program_Error.

                         _Erroneous Execution_

31.1/4
If Allocate_From_Subpool does not meet one or more of the requirements
on the Allocate procedure as given in the Erroneous Execution rules of
*note 13.11::, then the program execution is erroneous.

                     _Implementation Permissions_

32/3
When an allocator for a type whose storage pool is of type
Root_Storage_Pool'Class is evaluated, but supports subpools, the
implementation may call Allocate rather than Allocate_From_Subpool.
This will have the same effect, so long as Allocate has not been
overridden.

     NOTES

33/3
     33  A user-defined storage pool type that supports subpools can be
     implemented by extending the Root_Storage_Pool_With_Subpools type,
     and overriding the primitive subprograms Create_Subpool,
     Allocate_From_Subpool, and Deallocate_Subpool.  Create_Subpool
     should call Set_Pool_Of_Subpool before returning the subpool
     handle.  To make use of such a pool, a user would declare an object
     of the type extension, use it to define the Storage_Pool attribute
     of one or more access types, and then call Create_Subpool to obtain
     subpool handles associated with the pool.

34/3
     34  A user-defined storage pool type that supports subpools may
     define additional subpool constructors similar to Create_Subpool
     (these typically will have additional parameters).

35/3
     35  The pool implementor should override Default_Subpool_For_Pool
     if the pool is to support a default subpool for the pool.  The
     implementor can override Deallocate if individual object
     reclamation is to be supported, and can override Storage_Size if
     there is some limit on the total size of the storage pool.  The
     implementor can override Initialize and Finalize if there is any
     need for nontrivial initialization and finalization for the pool as
     a whole.  For example, Finalize might reclaim blocks of storage
     that are allocated over and above the space occupied by the pool
     object itself.  The pool implementor may extend the Root_Subpool
     type as necessary to carry additional information with each subpool
     provided by Create_Subpool.


File: arm2012.info,  Node: 13.11.5,  Next: 13.11.6,  Prev: 13.11.4,  Up: 13.11

13.11.5 Subpool Reclamation
---------------------------

1/3
A subpool may be explicitly deallocated using
Unchecked_Deallocate_Subpool.

                          _Static Semantics_

2/3
The following language-defined library procedure exists:

3/3
     with System.Storage_Pools.Subpools;
     procedure Ada.Unchecked_Deallocate_Subpool
        (Subpool : in out System.Storage_Pools.Subpools.Subpool_Handle);

4/3
If Subpool is null, a call on Unchecked_Deallocate_Subpool has no
effect.  Otherwise, the subpool is finalized, and Subpool is set to
null.

5/3
Finalization of a subpool has the following effects:

6/3
   * The subpool no longer belongs to any pool;

7/3
   * Any of the objects allocated from the subpool that still exist are
     finalized in an arbitrary order;

7.1/4
   * All of the objects allocated from the subpool cease to exist;

8/3
   * The following dispatching call is then made:

9/3
        Deallocate_Subpool(Pool_of_Subpool(Subpool).all, Subpool);

10/3
Finalization of a Root_Storage_Pool_With_Subpools object finalizes all
subpools that belong to that pool that have not yet been finalized.


File: arm2012.info,  Node: 13.11.6,  Prev: 13.11.5,  Up: 13.11

13.11.6 Storage Subpool Example
-------------------------------

                              _Examples_

1/3
The following example is a simple but complete implementation of the
classic Mark/Release pool using subpools:

2/3
     with System.Storage_Pools.Subpools;
     with System.Storage_Elements;
     with Ada.Unchecked_Deallocate_Subpool;
     package MR_Pool is

3/3
        use System.Storage_Pools;
           -- <For uses of Subpools.>
        use System.Storage_Elements;
           -- <For uses of Storage_Count and Storage_Array.>

4/3
        -- <Mark and Release work in a stack fashion, and allocations are not allowed>
        -- <from a subpool other than the one at the top of the stack. This is also>
        -- <the default pool.>

5/3
        subtype Subpool_Handle is Subpools.Subpool_Handle;

6/3
        type Mark_Release_Pool_Type (Pool_Size : Storage_Count) is new
           Subpools.Root_Storage_Pool_With_Subpools with private;

7/3
        function Mark (Pool : in out Mark_Release_Pool_Type)
           return not null Subpool_Handle;

8/3
        procedure Release (Subpool : in out Subpool_Handle) renames
           Ada.Unchecked_Deallocate_Subpool;

9/3
     private

10/3
        type MR_Subpool is new Subpools.Root_Subpool with record
           Start : Storage_Count;
        end record;
        subtype Subpool_Indexes is Positive range 1 .. 10;
        type Subpool_Array is array (Subpool_Indexes) of aliased MR_Subpool;

11/4
        type Mark_Release_Pool_Type (Pool_Size : Storage_Count) is new
           Subpools.Root_Storage_Pool_With_Subpools with record
           Storage         : Storage_Array (0 .. Pool_Size);
           Next_Allocation : Storage_Count := 0;
           Markers         : Subpool_Array;
           Current_Pool    : Subpool_Indexes := 1;
        end record;

12/3
        overriding
        function Create_Subpool (Pool : in out Mark_Release_Pool_Type)
           return not null Subpool_Handle;

13/3
        function Mark (Pool : in out Mark_Release_Pool_Type)
           return not null Subpool_Handle renames Create_Subpool;

14/3
        overriding
        procedure Allocate_From_Subpool (
           Pool : in out Mark_Release_Pool_Type;
           Storage_Address : out System.Address;
           Size_In_Storage_Elements : in Storage_Count;
           Alignment : in Storage_Count;
           Subpool : not null Subpool_Handle);

15/3
        overriding
        procedure Deallocate_Subpool (
           Pool : in out Mark_Release_Pool_Type;
           Subpool : in out Subpool_Handle);

16/3
        overriding
        function Default_Subpool_for_Pool (Pool : in out Mark_Release_Pool_Type)
           return not null Subpool_Handle;

17/3
        overriding
        procedure Initialize (Pool : in out Mark_Release_Pool_Type);

18/3
        -- <We don't need Finalize.>

19/3
     end MR_Pool;

20/3
     package body MR_Pool is

21/3
        use type Subpool_Handle;

22/3
        procedure Initialize (Pool : in out Mark_Release_Pool_Type) is
           -- <Initialize the first default subpool.>
        begin
           Pool.Markers(1).Start := 1;
           Subpools.Set_Pool_of_Subpool
              (Pool.Markers(1)'Unchecked_Access, Pool);
        end Initialize;

23/3
        function Create_Subpool (Pool : in out Mark_Release_Pool_Type)
           return not null Subpool_Handle is
           -- <Mark the current allocation location.>
        begin
           if Pool.Current_Pool = Subpool_Indexes'Last then
              raise Storage_Error; -- <No more subpools.>
           end if;
           Pool.Current_Pool := Pool.Current_Pool + 1; -- <Move to the next subpool>

24/3
           return Result : constant not null Subpool_Handle :=
              Pool.Markers(Pool.Current_Pool)'Unchecked_Access
           do
              Pool.Markers(Pool.Current_Pool).Start := Pool.Next_Allocation;
              Subpools.Set_Pool_of_Subpool (Result, Pool);
           end return;
        end Create_Subpool;

25/3
        procedure Deallocate_Subpool (
           Pool : in out Mark_Release_Pool_Type;
           Subpool : in out Subpool_Handle) is
        begin
           if Subpool /= Pool.Markers(Pool.Current_Pool)'Unchecked_Access then
              raise Program_Error; -- <Only the last marked subpool can be released.>
           end if;
           if Pool.Current_Pool /= 1 then
              Pool.Next_Allocation := Pool.Markers(Pool.Current_Pool).Start;
              Pool.Current_Pool := Pool.Current_Pool - 1; -- <Move to the previous subpool>
           else -- <Reinitialize the default subpool:>
              Pool.Next_Allocation := 1;
              Subpools.Set_Pool_of_Subpool
                 (Pool.Markers(1)'Unchecked_Access, Pool);
           end if;
        end Deallocate_Subpool;

26/3
        function Default_Subpool_for_Pool (Pool : in out Mark_Release_Pool_Type)
           return not null Subpool_Handle is
        begin
           return Pool.Markers(Pool.Current_Pool)'Unchecked_Access;
        end Default_Subpool_for_Pool;

27/3
        procedure Allocate_From_Subpool (
           Pool : in out Mark_Release_Pool_Type;
           Storage_Address : out System.Address;
           Size_In_Storage_Elements : in Storage_Count;
           Alignment : in Storage_Count;
           Subpool : not null Subpool_Handle) is
        begin
           if Subpool /= Pool.Markers(Pool.Current_Pool)'Unchecked_Access then
              raise Program_Error; -- <Only the last marked subpool can be used for allocations.>
           end if;

28/4
           -- <Check for the maximum supported alignment, which is the alignment of the storage area:>
           if Alignment > Pool.Storage'Alignment then
              raise Program_Error;
           end if;
           -- <Correct the alignment if necessary:>
           Pool.Next_Allocation := Pool.Next_Allocation +
              ((-Pool.Next_Allocation) mod Alignment);
           if Pool.Next_Allocation + Size_In_Storage_Elements >
              Pool.Pool_Size then
              raise Storage_Error; -- <Out of space.>
           end if;
           Storage_Address := Pool.Storage (Pool.Next_Allocation)'Address;
           Pool.Next_Allocation :=
              Pool.Next_Allocation + Size_In_Storage_Elements;
        end Allocate_From_Subpool;

29/3
     end MR_Pool;


File: arm2012.info,  Node: 13.12,  Next: 13.13,  Prev: 13.11,  Up: 13

13.12 Pragma Restrictions and Pragma Profile
============================================

1/3
A pragma Restrictions expresses the user's intent to abide by certain
restrictions.  A pragma Profile expresses the user's intent to abide by
a set of Restrictions or other specified run-time policies.  These may
facilitate the construction of simpler run-time environments.

                               _Syntax_

2
     The form of a pragma Restrictions is as follows:

3
       pragma Restrictions(restriction{, restriction});

4/2
     restriction ::= <restriction_>identifier
         | <restriction_parameter_>identifier => 
     restriction_parameter_argument

4.1/2
     restriction_parameter_argument ::= name | expression

                        _Name Resolution Rules_

5
Unless otherwise specified for a particular restriction, the expression
is expected to be of any integer type.

                           _Legality Rules_

6
Unless otherwise specified for a particular restriction, the expression
shall be static, and its value shall be nonnegative.

<Paragraph 7 was deleted.>

                       _Post-Compilation Rules_

8/3
A pragma Restrictions is a configuration pragma.  If a pragma
Restrictions applies to any compilation unit included in the partition,
this may impose either (or both) of two kinds of requirements, as
specified for the particular restriction:

8.1/3
   * A restriction may impose requirements on some or all of the units
     comprising the partition.  Unless otherwise specified for a
     particular restriction, such a requirement applies to all of the
     units comprising the partition and is enforced via a
     post-compilation check.

8.2/3
   * A restriction may impose requirements on the run-time behavior of
     the program, as indicated by the specification of run-time behavior
     associated with a violation of the requirement.

8.3/1
For the purpose of checking whether a partition contains constructs that
violate any restriction (unless specified otherwise for a particular
restriction):

8.4/1
   * Generic instances are logically expanded at the point of
     instantiation;

8.5/1
   * If an object of a type is declared or allocated and not explicitly
     initialized, then all expressions appearing in the definition for
     the type and any of its ancestors are presumed to be used;

8.6/1
   * A default_expression for a formal parameter or a generic formal
     object is considered to be used if and only if the corresponding
     actual parameter is not provided in a given call or instantiation.

                     _Implementation Permissions_

8.7/3
An implementation may provide implementation-defined restrictions; the
identifier for an implementation-defined restriction shall differ from
those of the language-defined restrictions.

9
An implementation may place limitations on the values of the expression
that are supported, and limitations on the supported combinations of
restrictions.  The consequences of violating such limitations are
implementation defined.

9.1/1
An implementation is permitted to omit restriction checks for code that
is recognized at compile time to be unreachable and for which no code is
generated.

9.2/1
Whenever enforcement of a restriction is not required prior to
execution, an implementation may nevertheless enforce the restriction
prior to execution of a partition to which the restriction applies,
provided that every execution of the partition would violate the
restriction.

                               _Syntax_

10/3
     The form of a pragma Profile is as follows:

11/3
       pragma Profile (<profile_>identifier {, <profile_>
     pragma_argument_association});

                           _Legality Rules_

12/3
The <profile_>identifier shall be the name of a usage profile.  The
semantics of any <profile_>pragma_argument_association (*note 2.8:
S0020.)s are defined by the usage profile specified by the
<profile_>identifier.

                          _Static Semantics_

13/3
A profile is equivalent to the set of configuration pragmas that is
defined for each usage profile.

                       _Post-Compilation Rules_

14/3
A pragma Profile is a configuration pragma.  There may be more than one
pragma Profile for a partition.

                     _Implementation Permissions_

15/3
An implementation may provide implementation-defined usage profiles; the
identifier for an implementation-defined usage profile shall differ from
those of the language-defined usage profiles.

     NOTES

16/2
     36  Restrictions intended to facilitate the construction of
     efficient tasking run-time systems are defined in *note D.7::.
     Restrictions intended for use when constructing high integrity
     systems are defined in *note H.4::.

17
     37  An implementation has to enforce the restrictions in cases
     where enforcement is required, even if it chooses not to take
     advantage of the restrictions in terms of efficiency.

* Menu:

* 13.12.1 ::  Language-Defined Restrictions and Profiles


File: arm2012.info,  Node: 13.12.1,  Up: 13.12

13.12.1 Language-Defined Restrictions and Profiles
--------------------------------------------------

                          _Static Semantics_

1/2
The following <restriction_>identifiers are language defined (additional
restrictions are defined in the Specialized Needs Annexes):

1.1/3
No_Implementation_Aspect_Specifications
               There are no implementation-defined aspects specified by
               an aspect_specification.  This restriction applies only
               to the current compilation or environment, not the entire
               partition.

2/2
No_Implementation_Attributes
               There are no implementation-defined attributes.  This
               restriction applies only to the current compilation or
               environment, not the entire partition.

2.1/3
No_Implementation_Identifiers
               There are no usage names that denote declarations with
               implementation-defined identifiers that occur within
               language-defined packages or instances of
               language-defined generic packages.  Such identifiers can
               arise as follows:

2.2/3
                  * The following language-defined packages and generic
                    packages allow implementation-defined identifiers:

2.3/3
                            * package System (see *note 13.7::);

2.4/3
                            * package Standard (see *note A.1::);

2.5/3
                            * package Ada.Command_Line (see *note
                              A.15::);

2.6/3
                            * package Interfaces.C (see *note B.3::);

2.7/3
                            * package Interfaces.C.Strings (see *note
                              B.3.1::);

2.8/3
                            * package Interfaces.C.Pointers (see *note
                              B.3.2::);

2.9/3
                            * package Interfaces.COBOL (see *note
                              B.4::);

2.10/3
                            * package Interfaces.Fortran (see *note
                              B.5::);

2.11/3
                  * The following language-defined packages contain only
                    implementation-defined identifiers:

2.12/3
                            * package System.Machine_Code (see *note
                              13.8::);

2.13/3
                            * package Ada.Directories.Information (see
                              *note A.16::);

2.14/3
                            * nested Implementation packages of the
                              Queue containers (see *note A.18.28::-31);

2.15/3
                            * package Interfaces (see *note B.2::);

2.16/3
                            * package Ada.Interrupts.Names (see *note
                              C.3.2::).

2.17/3
               For package Standard, Standard.Long_Integer and
               Standard.Long_Float are considered language-defined
               identifiers, but identifiers such as
               Standard.Short_Short_Integer are considered
               implementation-defined.

2.18/3
               This restriction applies only to the current compilation
               or environment, not the entire partition.

3/2
No_Implementation_Pragmas
               There are no implementation-defined pragmas or pragma
               arguments.  This restriction applies only to the current
               compilation or environment, not the entire partition.

3.1/3
No_Implementation_Units
               There is no mention in the context_clause of any
               implementation-defined descendants of packages Ada,
               Interfaces, or System.  This restriction applies only to
               the current compilation or environment, not the entire
               partition.

4/3
No_Obsolescent_Features
               There is no use of language features defined in Annex J.
               It is implementation defined whether uses of the
               renamings of *note J.1:: and of the pragmas of *note
               J.15:: are detected by this restriction.  This
               restriction applies only to the current compilation or
               environment, not the entire partition.

5/3
The following <restriction_parameter_>identifiers are language defined:

6/2
No_Dependence
               Specifies a library unit on which there are no semantic
               dependences.

6.1/3
No_Specification_of_Aspect
               Identifies an aspect for which no aspect_specification,
               attribute_definition_clause, or pragma is given.

6.2/3
No_Use_Of_Attribute
               Identifies an attribute for which no attribute_reference
               or attribute_definition_clause is given.

6.3/3
No_Use_Of_Pragma
               Identifies a pragma which is not to be used.

                           _Legality Rules_

7/2
The restriction_parameter_argument of a No_Dependence restriction shall
be a name; the name shall have the form of a full expanded name of a
library unit, but need not denote a unit present in the environment.

7.1/3
The restriction_parameter_argument of a No_Specification_of_Aspect
restriction shall be an identifier; this is an identifier specific to a
pragma (see *note 2.8::) and does not denote any declaration.

7.2/3
The restriction_parameter_argument of a No_Use_Of_Attribute restriction
shall be an identifier or one of the reserved words Access, Delta,
Digits, Mod, or Range; this is an identifier specific to a pragma.

7.3/3
The restriction_parameter_argument of a No_Use_Of_Pragma restriction
shall be an identifier or the reserved word Interface; this is an
identifier specific to a pragma.

                       _Post-Compilation Rules_

8/3
No compilation unit included in the partition shall depend semantically
on the library unit identified by the name of a No_Dependence
restriction.

                          _Static Semantics_

9/3
The following <profile_>identifier is language defined:

10/3
No_Implementation_Extensions

11/3
For usage profile No_Implementation_Extensions, there shall be no
<profile_>pragma_argument_associations.

12/3
The No_Implementation_Extensions usage profile is equivalent to the
following restrictions:

13/3
     No_Implementation_Aspect_Specifications,
     No_Implementation_Attributes,
     No_Implementation_Identifiers,
     No_Implementation_Pragmas,
     No_Implementation_Units.


File: arm2012.info,  Node: 13.13,  Next: 13.14,  Prev: 13.12,  Up: 13

13.13 Streams
=============

1
A <stream> is a sequence of elements comprising values from possibly
different types and allowing sequential access to these values.  A
<stream type> is a type in the class whose root type is
Streams.Root_Stream_Type.  A stream type may be implemented in various
ways, such as an external sequential file, an internal buffer, or a
network channel.

* Menu:

* 13.13.1 ::  The Package Streams
* 13.13.2 ::  Stream-Oriented Attributes


File: arm2012.info,  Node: 13.13.1,  Next: 13.13.2,  Up: 13.13

13.13.1 The Package Streams
---------------------------

                          _Static Semantics_

1
The abstract type Root_Stream_Type is the root type of the class of
stream types.  The types in this class represent different kinds of
streams.  A new stream type is defined by extending the root type (or
some other stream type), overriding the Read and Write operations, and
optionally defining additional primitive subprograms, according to the
requirements of the particular kind of stream.  The predefined
stream-oriented attributes like T'Read and T'Write make dispatching
calls on the Read and Write procedures of the Root_Stream_Type.
(User-defined T'Read and T'Write attributes can also make such calls, or
can call the Read and Write attributes of other types.)

2
     package Ada.Streams is
         pragma Pure(Streams);

3/2
         type Root_Stream_Type is abstract tagged limited private;
         pragma Preelaborable_Initialization(Root_Stream_Type);

4/1
         type Stream_Element is mod <implementation-defined>;
         type Stream_Element_Offset is range <implementation-defined>;
         subtype Stream_Element_Count is
             Stream_Element_Offset range 0..Stream_Element_Offset'Last;
         type Stream_Element_Array is
             array(Stream_Element_Offset range <>) of aliased Stream_Element;

5
         procedure Read(
           Stream : in out Root_Stream_Type;
           Item   : out Stream_Element_Array;
           Last   : out Stream_Element_Offset) is abstract;

6
         procedure Write(
           Stream : in out Root_Stream_Type;
           Item   : in Stream_Element_Array) is abstract;

7
     private
        ... -- <not specified by the language>
     end Ada.Streams;

8/2
The Read operation transfers stream elements from the specified stream
to fill the array Item.  Elements are transferred until Item'Length
elements have been transferred, or until the end of the stream is
reached.  If any elements are transferred, the index of the last stream
element transferred is returned in Last.  Otherwise, Item'First - 1 is
returned in Last.  Last is less than Item'Last only if the end of the
stream is reached.

9
The Write operation appends Item to the specified stream.

                     _Implementation Permissions_

9.1/1
If Stream_Element'Size is not a multiple of System.Storage_Unit, then
the components of Stream_Element_Array need not be aliased.

     NOTES

10
     38  See *note A.12.1::, "*note A.12.1:: The Package
     Streams.Stream_IO" for an example of extending type
     Root_Stream_Type.

11/2
     39  If the end of stream has been reached, and Item'First is
     Stream_Element_Offset'First, Read will raise Constraint_Error.


File: arm2012.info,  Node: 13.13.2,  Prev: 13.13.1,  Up: 13.13

13.13.2 Stream-Oriented Attributes
----------------------------------

1/3
The type-related operational attributes Write, Read, Output, and Input
convert values to a stream of elements and reconstruct values from a
stream.

                          _Static Semantics_

1.1/2
For every subtype S of an elementary type <T>, the following
representation attribute is defined:

1.2/3
S'Stream_Size
               Denotes the number of bits read from or written to a
               stream by the default implementations of S'Read and
               S'Write.  Hence, the number of stream elements required
               per item of elementary type <T> is:

1.3/2
                    <T>'Stream_Size / Ada.Streams.Stream_Element'Size

1.4/2
               The value of this attribute is of type
               <universal_integer> and is a multiple of
               Stream_Element'Size.

1.5/2
               Stream_Size may be specified for first subtypes via an
               attribute_definition_clause; the expression of such a
               clause shall be static, nonnegative, and a multiple of
               Stream_Element'Size.

                        _Implementation Advice_

1.6/2
If not specified, the value of Stream_Size for an elementary type should
be the number of bits that corresponds to the minimum number of stream
elements required by the first subtype of the type, rounded up to the
nearest factor or multiple of the word size that is also a multiple of
the stream element size.

1.7/2
The recommended level of support for the Stream_Size attribute is:

1.8/2
   * A Stream_Size clause should be supported for a discrete or fixed
     point type <T> if the specified Stream_Size is a multiple of
     Stream_Element'Size and is no less than the size of the first
     subtype of <T>, and no greater than the size of the largest type of
     the same elementary class (signed integer, modular integer,
     enumeration, ordinary fixed point, or decimal fixed point).

                          _Static Semantics_

2
For every subtype S of a specific type <T>, the following attributes are
defined.

3
S'Write
               S'Write denotes a procedure with the following
               specification:

4/2
                    procedure S'Write(
                       <Stream> : not null access Ada.Streams.Root_Stream_Type'Class;
                       <Item> : in <T>)

5
               S'Write writes the value of <Item> to <Stream>.

6
S'Read
               S'Read denotes a procedure with the following
               specification:

7/2
                    procedure S'Read(
                       <Stream> : not null access Ada.Streams.Root_Stream_Type'Class;
                       <Item> : out <T>)

8
               S'Read reads the value of <Item> from <Stream>.

8.1/3
For an untagged derived type, the Write (resp.  Read) attribute is
inherited according to the rules given in *note 13.1:: if the attribute
is specified and available for the parent type at the point where <T> is
declared.  For a tagged derived type, these attributes are not
inherited, but rather the default implementations are used.

8.2/2
The default implementations of the Write and Read attributes, where
available, execute as follows:

9/3
For elementary types, Read reads (and Write writes) the number of stream
elements implied by the Stream_Size for the type <T>; the representation
of those stream elements is implementation defined.  For composite
types, the Write or Read attribute for each component is called in
canonical order, which is last dimension varying fastest for an array
(unless the convention of the array is Fortran, in which case it is
first dimension varying fastest), and positional aggregate order for a
record.  Bounds are not included in the stream if <T> is an array type.
If <T> is a discriminated type, discriminants are included only if they
have defaults.  If <T> is a tagged type, the tag is not included.  For
type extensions, the Write or Read attribute for the parent type is
called, followed by the Write or Read attribute of each component of the
extension part, in canonical order.  For a limited type extension, if
the attribute of the parent type or any progenitor type of <T> is
available anywhere within the immediate scope of <T>, and the attribute
of the parent type or the type of any of the extension components is not
available at the freezing point of <T>, then the attribute of <T> shall
be directly specified.

9.1/3
If <T> is a discriminated type and its discriminants have defaults, then
S'Read first reads the discriminants from the stream without modifying
<Item>.  S'Read then creates an object of type <T> constrained by these
discriminants.  The value of this object is then converted to the
subtype of <Item> and is assigned to <Item>.  Finally, the Read
attribute for each nondiscriminant component of <Item> is called in
canonical order as described above.  Normal default initialization and
finalization take place for the created object.

9.2/3
Constraint_Error is raised by the predefined Write attribute if the
value of the elementary item is outside the range of values
representable using Stream_Size bits.  For a signed integer type, an
enumeration type, or a fixed point type, the range is unsigned only if
the integer code for the lower bound of the first subtype is
nonnegative, and a (symmetric) signed range that covers all values of
the first subtype would require more than Stream_Size bits; otherwise,
the range is signed.

10
For every subtype S'Class of a class-wide type <T>'Class:

11
S'Class'Write
               S'Class'Write denotes a procedure with the following
               specification:

12/2
                    procedure S'Class'Write(
                       <Stream> : not null access Ada.Streams.Root_Stream_Type'Class;
                       <Item>   : in <T>'Class)

13
               Dispatches to the subprogram denoted by the Write
               attribute of the specific type identified by the tag of
               Item.

14
S'Class'Read
               S'Class'Read denotes a procedure with the following
               specification:

15/2
                    procedure S'Class'Read(
                       <Stream> : not null access Ada.Streams.Root_Stream_Type'Class;
                       <Item> : out <T>'Class)

16
               Dispatches to the subprogram denoted by the Read
               attribute of the specific type identified by the tag of
               Item.

<Paragraph 17 was deleted.>

                          _Static Semantics_

18
For every subtype S of a specific type <T>, the following attributes are
defined.

19
S'Output
               S'Output denotes a procedure with the following
               specification:

20/2
                    procedure S'Output(
                       <Stream> : not null access Ada.Streams.Root_Stream_Type'Class;
                       <Item> : in <T>)

21
               S'Output writes the value of <Item> to <Stream>,
               including any bounds or discriminants.

22
S'Input
               S'Input denotes a function with the following
               specification:

23/2
                    function S'Input(
                       <Stream> : not null access Ada.Streams.Root_Stream_Type'Class)
                       return <T>

24
               S'Input reads and returns one value from <Stream>, using
               any bounds or discriminants written by a corresponding
               S'Output to determine how much to read.

25/3
For an untagged derived type, the Output (resp.  Input) attribute is
inherited according to the rules given in *note 13.1:: if the attribute
is specified and available for the parent type at the point where <T> is
declared.  For a tagged derived type, these attributes are not
inherited, but rather the default implementations are used.

25.1/2
The default implementations of the Output and Input attributes, where
available, execute as follows:

26/3
   * If <T> is an array type, S'Output first writes the bounds, and
     S'Input first reads the bounds.  If <T> has discriminants without
     defaults, S'Output first writes the discriminants (using the Write
     attribute of the discriminant type for each), and S'Input first
     reads the discriminants (using the Read attribute of the
     discriminant type for each).

27/3
   * S'Output then calls S'Write to write the value of <Item> to the
     stream.  S'Input then creates an object of type <T>, with the
     bounds or (when without defaults) the discriminants, if any, taken
     from the stream, passes it to S'Read, and returns the value of the
     object.  If <T> has discriminants, then this object is
     unconstrained if and only the discriminants have defaults.  Normal
     default initialization and finalization take place for this object
     (see *note 3.3.1::, *note 7.6::, and *note 7.6.1::).

27.1/2
If <T> is an abstract type, then S'Input is an abstract function.

28
For every subtype S'Class of a class-wide type <T>'Class:

29
S'Class'Output
               S'Class'Output denotes a procedure with the following
               specification:

30/2
                    procedure S'Class'Output(
                       <Stream> : not null access Ada.Streams.Root_Stream_Type'Class;
                       <Item>   : in <T>'Class)

31/2
               First writes the external tag of <Item> to <Stream> (by
               calling String'Output(<Stream>,
               Tags.External_Tag(<Item>'Tag)) -- see *note 3.9::) and
               then dispatches to the subprogram denoted by the Output
               attribute of the specific type identified by the tag.
               Tag_Error is raised if the tag of Item identifies a type
               declared at an accessibility level deeper than that of S.

32
S'Class'Input
               S'Class'Input denotes a function with the following
               specification:

33/2
                    function S'Class'Input(
                       <Stream> : not null access Ada.Streams.Root_Stream_Type'Class)
                       return <T>'Class

34/3
               First reads the external tag from <Stream> and determines
               the corresponding internal tag (by calling
               Tags.Descendant_Tag(String'Input(<Stream>), S'Tag) which
               might raise Tag_Error -- see *note 3.9::) and then
               dispatches to the subprogram denoted by the Input
               attribute of the specific type identified by the internal
               tag; returns that result.  If the specific type
               identified by the internal tag is abstract,
               Constraint_Error is raised.

35/3
In the default implementation of Read and Input for a composite type,
for each scalar component that is a discriminant or that has an implicit
initial value, a check is made that the value returned by Read for the
component belongs to its subtype.  Constraint_Error is raised if this
check fails.  For other scalar components, no check is made.  For each
component that is of an access type, if the implementation can detect
that the value returned by Read for the component is not a value of its
subtype, Constraint_Error is raised.  If the value is not a value of its
subtype and this error is not detected, the component has an abnormal
value, and erroneous execution can result (see *note 13.9.1::).  In the
default implementation of Read for a composite type with defaulted
discriminants, if the actual parameter of Read is constrained, a check
is made that the discriminants read from the stream are equal to those
of the actual parameter.  Constraint_Error is raised if this check
fails.

36/2
It is unspecified at which point and in which order these checks are
performed.  In particular, if Constraint_Error is raised due to the
failure of one of these checks, it is unspecified how many stream
elements have been read from the stream.

37/1
In the default implementation of Read and Input for a type, End_Error is
raised if the end of the stream is reached before the reading of a value
of the type is completed.

38/4
The stream-oriented attributes may be specified for any type via an
attribute_definition_clause.  Alternatively, each of the specific
stream-oriented attributes may be specified using an
aspect_specification on any type_declaration, with the aspect name being
the corresponding attribute name.  Each of the class-wide
stream-oriented attributes may be specified using an
aspect_specification for a tagged type <T> using the name of the
stream-oriented attribute followed by 'Class; such class-wide aspects do
not apply to other descendants of <T>.  

38.1/4
The subprogram name given in such an attribute_definition_clause (*note
13.3: S0310.) or aspect_specification (*note 13.1.1: S0307.) shall
statically denote a subprogram that is not an abstract subprogram.
Furthermore, if a specific stream-oriented attribute is specified for an
interface type, the subprogram name given in the
attribute_definition_clause or aspect_specification shall statically
denote a null procedure.

39/2
A stream-oriented attribute for a subtype of a specific type <T> is
<available> at places where one of the following conditions is true: 

40/2
   * <T> is nonlimited.

41/2
   * The attribute_designator is Read (resp.  Write) and <T> is a
     limited record extension, and the attribute Read (resp.  Write) is
     available for the parent type of <T> and for the types of all of
     the extension components.

42/2
   * <T> is a limited untagged derived type, and the attribute was
     inherited for the type.

43/2
   * The attribute_designator is Input (resp.  Output), and <T> is a
     limited type, and the attribute Read (resp.  Write) is available
     for <T>.

44/2
   * The attribute has been specified via an
     attribute_definition_clause, and the attribute_definition_clause is
     visible.

45/2
A stream-oriented attribute for a subtype of a class-wide type <T>'Class
is available at places where one of the following conditions is true:

46/2
   * <T> is nonlimited;

47/2
   * the attribute has been specified via an
     attribute_definition_clause, and the attribute_definition_clause is
     visible; or

48/2
   * the corresponding attribute of <T> is available, provided that if
     <T> has a partial view, the corresponding attribute is available at
     the end of the visible part where <T> is declared.

49/4
An attribute_reference for one of the stream-oriented attributes is
illegal unless the attribute is available at the place of the
attribute_reference.  Furthermore, an attribute_reference for <T>'Input
is illegal if <T> is an abstract type.  In addition to the places where
Legality Rules normally apply (see *note 12.3::), these rules also apply
in the private part of an instance of a generic unit.

49.1/4
Unless inherited from a parent type, if any, for an untagged type having
a task, protected, or explicitly limited record part, the default
implementation of each of the Read, Write, Input, and Output attributes
raises Program_Error and performs no other action.

50/3
In the parameter_and_result_profiles for the default implementations of
the stream-oriented attributes, the subtype of the Item parameter is the
base subtype of <T> if <T> is a scalar type, and the first subtype
otherwise.  The same rule applies to the result of the Input attribute.

51/3
For an attribute_definition_clause specifying one of these attributes,
the subtype of the <Item> parameter shall be the first subtype or the
base subtype if scalar, and the first subtype if not scalar.  The same
rule applies to the result of the Input function.

52/3
A type is said to <support external streaming> if Read and Write
attributes are provided for sending values of such a type between active
partitions, with Write marshalling the representation, and Read
unmarshalling the representation.  A limited type supports external
streaming only if it has available Read and Write attributes.  A type
with a part that is of a nonremote access type supports external
streaming only if that access type or the type of some part that
includes the access type component, has Read and Write attributes that
have been specified via an attribute_definition_clause, and that
attribute_definition_clause is visible.  An anonymous access type does
not support external streaming.  All other types (including remote
access types, see *note E.2.2::) support external streaming.

                         _Erroneous Execution_

53/2
If the internal tag returned by Descendant_Tag to T'Class'Input
identifies a type that is not library-level and whose tag has not been
created, or does not exist in the partition at the time of the call,
execution is erroneous.

                     _Implementation Requirements_

54/1
For every subtype <S> of a language-defined nonlimited specific type
<T>, the output generated by S'Output or S'Write shall be readable by
S'Input or S'Read, respectively.  This rule applies across partitions if
the implementation conforms to the Distributed Systems Annex.

55/3
If Constraint_Error is raised during a call to Read because of failure
of one the above checks, the implementation shall ensure that the
discriminants of the actual parameter of Read are not modified.

                     _Implementation Permissions_

56/3
The number of calls performed by the predefined implementation of the
stream-oriented attributes on the Read and Write operations of the
stream type is unspecified.  An implementation may take advantage of
this permission to perform internal buffering.  However, all the calls
on the Read and Write operations of the stream type needed to implement
an explicit invocation of a stream-oriented attribute shall take place
before this invocation returns.  An explicit invocation is one appearing
explicitly in the program text, possibly through a generic instantiation
(see *note 12.3::).

56.1/3
If <T> is a discriminated type and its discriminants have defaults, then
in two cases an execution of the default implementation of S'Read is not
required to create an anonymous object of type <T>: If the discriminant
values that are read in are equal to the corresponding discriminant
values of <Item>, then no object of type <T> need be created and <Item>
may be used instead.  If they are not equal and <Item> is a constrained
variable, then Constraint_Error may be raised at that point, before any
further values are read from the stream and before the object of type
<T> is created.

56.2/3
A default implementation of S'Input that calls the default
implementation of S'Read may create a constrained anonymous object with
discriminants that match those in the stream.

     NOTES

57
     40  For a definite subtype S of a type <T>, only <T>'Write and
     <T>'Read are needed to pass an arbitrary value of the subtype
     through a stream.  For an indefinite subtype S of a type <T>,
     <T>'Output and <T>'Input will normally be needed, since <T>'Write
     and <T>'Read do not pass bounds, discriminants, or tags.

58
     41  User-specified attributes of S'Class are not inherited by other
     class-wide types descended from S.

                              _Examples_

59
<Example of user-defined Write attribute:>

60/2
     procedure My_Write(
       Stream : not null access Ada.Streams.Root_Stream_Type'Class;
       Item   : My_Integer'Base);
     for My_Integer'Write use My_Write;


File: arm2012.info,  Node: 13.14,  Prev: 13.13,  Up: 13

13.14 Freezing Rules
====================

1/3
This subclause defines a place in the program text where each declared
entity becomes "frozen."  A use of an entity, such as a reference to it
by name, or (for a type) an expression of the type, causes freezing of
the entity in some contexts, as described below.  The Legality Rules
forbid certain kinds of uses of an entity in the region of text where it
is frozen.

2
The <freezing> of an entity occurs at one or more places (<freezing
points>) in the program text where the representation for the entity has
to be fully determined.  Each entity is frozen from its first freezing
point to the end of the program text (given the ordering of compilation
units defined in *note 10.1.4::).

2.1/3
This subclause also defines a place in the program text where the
profile of each declared callable entity becomes <frozen>.  A use of a
callable entity causes freezing of its profile in some contexts, as
described below.  At the place where the profile of a callable entity
becomes frozen, the entity itself becomes frozen.

3/4
The end of a declarative_part, protected_body, or a declaration of a
library package or generic library package, causes <freezing> of each
entity and profile declared within it, except for incomplete types.  A
proper_body, body_stub, or entry_body causes freezing of each entity and
profile declared before it within the same declarative_part that is not
an incomplete type; it only causes freezing of an incomplete type if the
body is within the immediate scope of the incomplete type.

4/1
A construct that (explicitly or implicitly) references an entity can
cause the <freezing> of the entity, as defined by subsequent paragraphs.
At the place where a construct causes freezing, each name, expression,
implicit_dereference, or range within the construct causes freezing:

5/3
   * The occurrence of a generic_instantiation causes freezing, except
     that a name which is a generic actual parameter whose corresponding
     generic formal parameter is a formal incomplete type (see *note
     12.5.1::) does not cause freezing.  In addition, if a parameter of
     the instantiation is defaulted, the default_expression or
     default_name for that parameter causes freezing.

5.1/4
   * At the occurrence of an expression_function_declaration that is a
     completion, the return expression of the expression function causes
     freezing.

5.2/4
   * At the occurrence of a renames-as-body whose <callable_entity_>name
     denotes an expression function, the return expression of the
     expression function causes freezing.

6
   * The occurrence of an object_declaration that has no corresponding
     completion causes freezing.

7
   * The declaration of a record extension causes freezing of the parent
     subtype.

7.1/2
   * The declaration of a record extension, interface type, task unit,
     or protected unit causes freezing of any progenitor types specified
     in the declaration.

7.2/3
   * At the freezing point of the entity associated with an
     aspect_specification, any expressions or names within the
     aspect_specification cause freezing.  Any static expressions within
     an aspect_specification also cause freezing at the end of the
     immediately enclosing declaration list.

8/4
A static expression (other than within an aspect_specification) causes
freezing where it occurs.  An object name or nonstatic expression causes
freezing where it occurs, unless the name or expression is part of a
default_expression, a default_name, the return expression of an
expression function, an aspect_specification, or a per-object expression
of a component's constraint, in which case, the freezing occurs later as
part of another construct or at the freezing point of an associated
entity.

8.1/3
An implicit call freezes the same entities and profiles that would be
frozen by an explicit call.  This is true even if the implicit call is
removed via implementation permissions.

8.2/1
If an expression is implicitly converted to a type or subtype <T>, then
at the place where the expression causes freezing, <T> is frozen.

9
The following rules define which entities are frozen at the place where
a construct causes freezing:

10
   * At the place where an expression causes freezing, the type of the
     expression is frozen, unless the expression is an enumeration
     literal used as a discrete_choice of the array_aggregate (*note
     4.3.3: S0113.) of an enumeration_representation_clause (*note 13.4:
     S0311.).

10.1/4
   * At the place where a function call causes freezing, the profile of
     the function is frozen.  Furthermore, if a parameter of the call is
     defaulted, the default_expression for that parameter causes
     freezing.  If the function call is to an expression function, the
     return expression of the expression function causes freezing.

10.2/4
   * At the place where a generic_instantiation causes freezing of a
     callable entity, the profile of that entity is frozen unless the
     formal subprogram corresponding to the callable entity has a
     parameter or result of a formal untagged incomplete type; if the
     callable entity is an expression function, the return expression of
     the expression function causes freezing.

10.3/4
   * At the place where a use of the Access or Unchecked_Access
     attribute whose prefix denotes an expression function causes
     freezing, the return expression of the expression function causes
     freezing.

11
   * At the place where a name causes freezing, the entity denoted by
     the name is frozen, unless the name is a prefix of an expanded
     name; at the place where an object name causes freezing, the
     nominal subtype associated with the name is frozen.

11.1/1
   * At the place where an implicit_dereference causes freezing, the
     nominal subtype associated with the implicit_dereference is frozen.

12
   * At the place where a range causes freezing, the type of the range
     is frozen.

13
   * At the place where an allocator causes freezing, the designated
     subtype of its type is frozen.  If the type of the allocator is a
     derived type, then all ancestor types are also frozen.

14/3
   * At the place where a profile is frozen, each subtype of the profile
     is frozen.  If the corresponding callable entity is a member of an
     entry family, the index subtype of the family is frozen.

15
   * At the place where a subtype is frozen, its type is frozen.  At the
     place where a type is frozen, any expressions or names within the
     full type definition cause freezing; the first subtype, and any
     component subtypes, index subtypes, and parent subtype of the type
     are frozen as well.  For a specific tagged type, the corresponding
     class-wide type is frozen as well.  For a class-wide type, the
     corresponding specific type is frozen as well.

15.1/3
   * At the place where a specific tagged type is frozen, the primitive
     subprograms of the type are frozen.  At the place where a type is
     frozen, any subprogram named in an attribute_definition_clause for
     the type is frozen.

                           _Legality Rules_

16
The explicit declaration of a primitive subprogram of a tagged type
shall occur before the type is frozen (see *note 3.9.2::).

17
A type shall be completely defined before it is frozen (see *note
3.11.1:: and *note 7.3::).

18
The completion of a deferred constant declaration shall occur before the
constant is frozen (see *note 7.4::).

19/1
An operational or representation item that directly specifies an aspect
of an entity shall appear before the entity is frozen (see *note
13.1::).

                          _Dynamic Semantics_

20/2
The tag (see *note 3.9::) of a tagged type T is created at the point
where T is frozen.


File: arm2012.info,  Node: Annex A,  Next: Annex B,  Prev: 13,  Up: Top

Annex A Predefined Language Environment
***************************************

1
This Annex contains the specifications of library units that shall be
provided by every implementation.  There are three root library units:
Ada, Interfaces, and System; other library units are children of these:

2/3
 
 

     Standard -- *note A.1::
        Ada -- *note A.2::
           Assertions -- *note 11.4.2::
           Asynchronous_Task_Control -- *note D.11::
           Calendar -- *note 9.6::
              Arithmetic -- *note 9.6.1::
              Formatting -- *note 9.6.1::
              Time_Zones -- *note 9.6.1::
           Characters -- *note A.3.1::
              Conversions -- *note A.3.4::
              Handling -- *note A.3.2::
              Latin_1 -- *note A.3.3::
           Command_Line -- *note A.15::
           Complex_Text_IO -- *note G.1.3::
           Containers -- *note A.18.1::
              Bounded_Doubly_Linked_Lists
                       -- *note A.18.20::
              Bounded_Hashed_Maps -- *note A.18.21::
              Bounded_Hashed_Sets -- *note A.18.23::
              Bounded_Multiway_Trees -- *note A.18.25::
              Bounded_Ordered_Maps -- *note A.18.22::
              Bounded_Ordered_Sets -- *note A.18.24::
              Bounded_Priority_Queues -- *note A.18.31::
              Bounded_Synchronized_Queues
                        -- *note A.18.29::
              Bounded_Vectors -- *note A.18.19::
              Doubly_Linked_Lists -- *note A.18.3::
              Generic_Array_Sort -- *note A.18.26::
              Generic_Constrained_Array_Sort
                       -- *note A.18.26::
              Generic_Sort -- *note A.18.26::
              Hashed_Maps -- *note A.18.5::
              Hashed_Sets -- *note A.18.8::
              Indefinite_Doubly_Linked_Lists
                       -- *note A.18.12::
              Indefinite_Hashed_Maps -- *note A.18.13::
              Indefinite_Hashed_Sets -- *note A.18.15::
              Indefinite_Holders -- *note A.18.18::
              Indefinite_Multiway_Trees -- *note A.18.17::
              Indefinite_Ordered_Maps -- *note A.18.14::
              Indefinite_Ordered_Sets -- *note A.18.16::
              Indefinite_Vectors -- *note
     A.18.11::Standard (<...continued>)
        Ada (<...continued>)
           Containers (<...continued>)
              Multiway_Trees -- *note A.18.10::
              Ordered_Maps -- *note A.18.6::
              Ordered_Sets -- *note A.18.9::
              Synchronized_Queue_Interfaces
                       -- *note A.18.27::
              Unbounded_Priority_Queues
                       -- *note A.18.30::
              Unbounded_Synchronized_Queues
                       -- *note A.18.28::
              Vectors -- *note A.18.2::
           Decimal -- *note F.2::
           Direct_IO -- *note A.8.4::
           Directories -- *note A.16::
              Hierarchical_File_Names -- *note A.16.1::
              Information -- *note A.16::
           Dispatching -- *note D.2.1::
              EDF -- *note D.2.6::
              Non_Preemptive -- *note D.2.4::
              Round_Robin -- *note D.2.5::
           Dynamic_Priorities -- *note D.5.1::
           Environment_Variables -- *note A.17::
           Exceptions -- *note 11.4.1::
           Execution_Time -- *note D.14::
              Group_Budgets -- *note D.14.2::
              Interrupts -- *note D.14.3::
              Timers -- *note D.14.1::
           Finalization -- *note 7.6::
           Float_Text_IO -- *note A.10.9::
           Float_Wide_Text_IO -- *note A.11::
           Float_Wide_Wide_Text_IO -- *note A.11::
           Integer_Text_IO -- *note A.10.8::
           Integer_Wide_Text_IO -- *note A.11::
           Integer_Wide_Wide_Text_IO -- *note A.11::
           Interrupts -- *note C.3.2::
              Names -- *note C.3.2::
           IO_Exceptions -- *note A.13::
           Iterator_Interfaces -- *note 5.5.1::
           Locales -- *note A.19::
     Standard (<...continued>)
        Ada (<...continued>)
           Numerics -- *note A.5::
              Complex_Arrays -- *note G.3.2::
              Complex_Elementary_Functions -- *note G.1.2::
              Complex_Types -- *note G.1.1::
              Discrete_Random -- *note A.5.2::
              Elementary_Functions -- *note A.5.1::
              Float_Random -- *note A.5.2::
              Generic_Complex_Arrays -- *note G.3.2::
              Generic_Complex_Elementary_Functions
                       -- *note G.1.2::
              Generic_Complex_Types -- *note G.1.1::
              Generic_Elementary_Functions -- *note A.5.1::
              Generic_Real_Arrays -- *note G.3.1::
              Real_Arrays -- *note G.3.1::
           Real_Time -- *note D.8::
              Timing_Events -- *note D.15::
           Sequential_IO -- *note A.8.1::
           Storage_IO -- *note A.9::
           Streams -- *note 13.13.1::
              Stream_IO -- *note A.12.1::
           Strings -- *note A.4.1::
              Bounded -- *note A.4.4::
                 Equal_Case_Insensitive -- *note A.4.10::
                 Hash -- *note A.4.9::
                 Hash_Case_Insensitive -- *note A.4.9::
                 Less_Case_Insensitive -- *note A.4.10::
              Fixed -- *note A.4.3::
                 Equal_Case_Insensitive -- *note A.4.10::
                 Hash -- *note A.4.9::
                 Hash_Case_Insensitive -- *note A.4.9::
                 Less_Case_Insensitive -- *note A.4.10::
              Equal_Case_Insensitive -- *note A.4.10::
              Hash -- *note A.4.9::
              Hash_Case_Insensitive -- *note A.4.9::
              Less_Case_Insensitive -- *note A.4.10::
              Maps -- *note A.4.2::
                 Constants -- *note A.4.6::
              Unbounded -- *note A.4.5::
                 Equal_Case_Insensitive -- *note A.4.10::
                 Hash -- *note A.4.9::
                 Hash_Case_Insensitive -- *note A.4.9::
                 Less_Case_Insensitive -- *note A.4.10::
              UTF_Encoding -- *note A.4.11::
                 Conversions -- *note A.4.11::
                 Strings -- *note A.4.11::
                 Wide_Strings -- *note A.4.11::
                 Wide_Wide_Strings -- *note A.4.11::
     Standard (<...continued>)
        Ada (<...continued>)
           Strings (<...continued>)
              Wide_Bounded -- *note A.4.7::
                 Wide_Equal_Case_Insensitive
                          -- *note A.4.7::
                 Wide_Hash -- *note A.4.7::
                 Wide_Hash_Case_Insensitive -- *note A.4.7::
              Wide_Equal_Case_Insensitive -- *note A.4.7::
              Wide_Fixed -- *note A.4.7::
                 Wide_Equal_Case_Insensitive
                          -- *note A.4.7::
                 Wide_Hash -- *note A.4.7::
                 Wide_Hash_Case_Insensitive -- *note A.4.7::
              Wide_Hash -- *note A.4.7::
              Wide_Hash_Case_Insensitive -- *note A.4.7::
              Wide_Maps -- *note A.4.7::
                 Wide_Constants -- *note A.4.7::
              Wide_Unbounded -- *note A.4.7::
                 Wide_Equal_Case_Insensitive
                          -- *note A.4.7::
                 Wide_Hash -- *note A.4.7::
                 Wide_Hash_Case_Insensitive -- *note A.4.7::
              Wide_Wide_Bounded -- *note A.4.8::
                 Wide_Wide_Equal_Case_Insensitive
                          -- *note A.4.8::
                 Wide_Wide_Hash -- *note A.4.8::
                 Wide_Wide_Hash_Case_Insensitive
                          -- *note A.4.8::
              Wide_Wide_Equal_Case_Insensitive
                       -- *note A.4.8::
              Wide_Wide_Fixed -- *note A.4.8::
                 Wide_Wide_Equal_Case_Insensitive
                          -- *note A.4.8::
                 Wide_Wide_Hash -- *note A.4.8::
                 Wide_Wide_Hash_Case_Insensitive
                          -- *note A.4.8::
              Wide_Wide_Hash -- *note A.4.8::
              Wide_Wide_Hash_Case_Insensitive
                          -- *note A.4.8::
              Wide_Wide_Maps -- *note A.4.8::
                 Wide_Wide_Constants -- *note A.4.8::
              Wide_Wide_Unbounded -- *note A.4.8::
                 Wide_Wide_Equal_Case_Insensitive
                          -- *note A.4.8::
                 Wide_Wide_Hash -- *note A.4.8::
                 Wide_Wide_Hash_Case_Insensitive
                          -- *note A.4.8::
           Synchronous_Barriers -- *note D.10.1::
           Synchronous_Task_Control -- *note D.10::
              EDF -- *note D.10::
     Standard (<...continued>)
        Ada (<...continued>)
           Tags -- *note 3.9::
              Generic_Dispatching_Constructor -- *note 3.9::
           Task_Attributes -- *note C.7.2::
           Task_Identification -- *note C.7.1::
           Task_Termination -- *note C.7.3::
           Text_IO -- *note A.10.1::
              Bounded_IO -- *note A.10.11::
              Complex_IO -- *note G.1.3::
              Editing -- *note F.3.3::
              Text_Streams -- *note A.12.2::
              Unbounded_IO -- *note A.10.12::
           Unchecked_Conversion -- *note 13.9::
           Unchecked_Deallocate_Subpool -- *note 13.11.5::
           Unchecked_Deallocation -- *note 13.11.2::
           Wide_Characters -- *note A.3.1::
              Handling -- *note A.3.5::
           Wide_Text_IO -- *note A.11::
              Complex_IO -- *note G.1.4::
              Editing -- *note F.3.4::
              Text_Streams -- *note A.12.3::
              Wide_Bounded_IO -- *note A.11::
              Wide_Unbounded_IO -- *note A.11::
           Wide_Wide_Characters -- *note A.3.1::
              Handling -- *note A.3.6::
           Wide_Wide_Text_IO -- *note A.11::
              Complex_IO -- *note G.1.5::
              Editing -- *note F.3.5::
              Text_Streams -- *note A.12.4::
              Wide_Wide_Bounded_IO -- *note A.11::
              Wide_Wide_Unbounded_IO -- *note A.11::

        Interfaces -- *note B.2::
           C -- *note B.3::
              Pointers -- *note B.3.2::
              Strings -- *note B.3.1::
           COBOL -- *note B.4::
           Fortran -- *note B.5::

        System -- *note 13.7::
           Address_To_Access_Conversions -- *note 13.7.2::
           Machine_Code -- *note 13.8::
           Multiprocessors -- *note D.16::
              Dispatching_Domains -- *note D.16.1::
           RPC -- *note E.5::
           Storage_Elements -- *note 13.7.1::
           Storage_Pools -- *note 13.11::
              Subpools -- *note 13.11.4::

                     _Implementation Requirements_

3/4
The implementation shall ensure that each language-defined subprogram is
reentrant in the sense that concurrent calls on any language-defined
subprogram perform as specified, so long as all objects that are denoted
by parameters that could be passed by reference or designated by
parameters of an access type are nonoverlapping.

3.1/4
For the purpose of determining whether concurrent calls on text
input-output subprograms are required to perform as specified above,
when calling a subprogram within Text_IO or its children that implicitly
operates on one of the default input-output files, the subprogram is
considered to have a parameter of Current_Input or Current_Output (as
appropriate).

3.2/3
If a descendant of a language-defined tagged type is declared, the
implementation shall ensure that each inherited language-defined
subprogram behaves as described in this International Standard.  In
particular, overriding a language-defined subprogram shall not alter the
effect of any inherited language-defined subprogram.

                     _Implementation Permissions_

4
The implementation may restrict the replacement of language-defined
compilation units.  The implementation may restrict children of
language-defined library units (other than Standard).

* Menu:

* A.1 ::      The Package Standard
* A.2 ::      The Package Ada
* A.3 ::      Character Handling
* A.4 ::      String Handling
* A.5 ::      The Numerics Packages
* A.6 ::      Input-Output
* A.7 ::      External Files and File Objects
* A.8 ::      Sequential and Direct Files
* A.9 ::      The Generic Package Storage_IO
* A.10 ::     Text Input-Output
* A.11 ::     Wide Text Input-Output and Wide Wide Text Input-Output
* A.12 ::     Stream Input-Output
* A.13 ::     Exceptions in Input-Output
* A.14 ::     File Sharing
* A.15 ::     The Package Command_Line
* A.16 ::     The Package Directories
* A.17 ::     The Package Environment_Variables
* A.18 ::     Containers
* A.19 ::     The Package Locales


File: arm2012.info,  Node: A.1,  Next: A.2,  Up: Annex A

A.1 The Package Standard
========================

1/3
This subclause outlines the specification of the package Standard
containing all predefined identifiers in the language.  The
corresponding package body is not specified by the language.

2
The operators that are predefined for the types declared in the package
Standard are given in comments since they are implicitly declared.
Italics are used for pseudo-names of anonymous types (such as
<root_real>) and for undefined information (such as
<implementation-defined>).

                          _Static Semantics_

3
The library package Standard has the following declaration:

4
     package Standard is
        pragma Pure(Standard);

5
        type Boolean is (False, True);

6
        --< The predefined relational operators for this type are as follows:>

7/1
        -- function "="   (Left, Right : Boolean'Base) return Boolean;
        -- function "/="  (Left, Right : Boolean'Base) return Boolean;
        -- function "<"   (Left, Right : Boolean'Base) return Boolean;
        -- function "<="  (Left, Right : Boolean'Base) return Boolean;
        -- function ">"   (Left, Right : Boolean'Base) return Boolean;
        -- function ">="  (Left, Right : Boolean'Base) return Boolean;

8
        --< The predefined logical operators and the predefined logical>
        --< negation operator are as follows:>

9/1
        -- function "and" (Left, Right : Boolean'Base) return Boolean'Base;
        -- function "or"  (Left, Right : Boolean'Base) return Boolean'Base;
        -- function "xor" (Left, Right : Boolean'Base) return Boolean'Base;

10/1
        -- function "not" (Right : Boolean'Base) return Boolean'Base;

11/2
        --< The integer type root_integer and the>
        --< corresponding universal type universal_integer are predefined.>

12
        type Integer is range <implementation-defined>;

13
        subtype Natural  is Integer range 0 .. Integer'Last;
        subtype Positive is Integer range 1 .. Integer'Last;

14
        --< The predefined operators for type Integer are as follows:>

15
        -- function "="  (Left, Right : Integer'Base) return Boolean;
        -- function "/=" (Left, Right : Integer'Base) return Boolean;
        -- function "<"  (Left, Right : Integer'Base) return Boolean;
        -- function "<=" (Left, Right : Integer'Base) return Boolean;
        -- function ">"  (Left, Right : Integer'Base) return Boolean;
        -- function ">=" (Left, Right : Integer'Base) return Boolean;

16
        -- function "+"   (Right : Integer'Base) return Integer'Base;
        -- function "-"   (Right : Integer'Base) return Integer'Base;
        -- function "abs" (Right : Integer'Base) return Integer'Base;

17
        -- function "+"   (Left, Right : Integer'Base) return Integer'Base;
        -- function "-"   (Left, Right : Integer'Base) return Integer'Base;
        -- function "*"   (Left, Right : Integer'Base) return Integer'Base;
        -- function "/"   (Left, Right : Integer'Base) return Integer'Base;
        -- function "rem" (Left, Right : Integer'Base) return Integer'Base;
        -- function "mod" (Left, Right : Integer'Base) return Integer'Base;

18
        -- function "**"  (Left : Integer'Base; Right : Natural)
        --                  return Integer'Base;

19
        --< The specification of each operator for the type>
        --< root_integer, or for any additional predefined integer>
        --< type, is obtained by replacing Integer by the name of the type>
        --< in the specification of the corresponding operator of the type>
        --< Integer. The right operand of the exponentiation operator>
        --< remains as subtype Natural.>

20/2
        --< The floating point type root_real and the>
        --< corresponding universal type universal_real are predefined.>

21
        type Float is digits <implementation-defined>;

22
        --< The predefined operators for this type are as follows:>

23
        -- function "="   (Left, Right : Float) return Boolean;
        -- function "/="  (Left, Right : Float) return Boolean;
        -- function "<"   (Left, Right : Float) return Boolean;
        -- function "<="  (Left, Right : Float) return Boolean;
        -- function ">"   (Left, Right : Float) return Boolean;
        -- function ">="  (Left, Right : Float) return Boolean;

24
        -- function "+"   (Right : Float) return Float;
        -- function "-"   (Right : Float) return Float;
        -- function "abs" (Right : Float) return Float;

25
        -- function "+"   (Left, Right : Float) return Float;
        -- function "-"   (Left, Right : Float) return Float;
        -- function "*"   (Left, Right : Float) return Float;
        -- function "/"   (Left, Right : Float) return Float;

26
        -- function "**"  (Left : Float; Right : Integer'Base) return Float;

27
        --< The specification of each operator for the type root_real, or for>
        --< any additional predefined floating point type, is obtained by>
        --< replacing Float by the name of the type in the specification of the>
        --< corresponding operator of the type Float.>

28
        --< In addition, the following operators are predefined for the root>
        --< numeric types:>

29
        function "*" (Left : <root_integer>; Right : <root_real>)
          return <root_real>;

30
        function "*" (Left : <root_real>;    Right : <root_integer>)
          return <root_real>;

31
        function "/" (Left : <root_real>;    Right : <root_integer>)
          return <root_real>;

32
        --< The type universal_fixed is predefined.>
        --< The only multiplying operators defined between>
        --< fixed point types are>

33
        function "*" (Left : <universal_fixed>; Right : <universal_fixed>)
          return <universal_fixed>;

34
        function "/" (Left : <universal_fixed>; Right : <universal_fixed>)
          return <universal_fixed>;

34.1/2
        --< The type universal_access is predefined.>
        --< The following equality operators are predefined:>

34.2/2
        function "="  (Left, Right: <universal_access>) return Boolean;
        function "/=" (Left, Right: <universal_access>) return Boolean;

35/3
           --< The declaration of type Character is based on the standard ISO 8859-1 character set.>

           --< There are no character literals corresponding to the positions for control characters.>
           --< They are indicated in italics in this definition. See *note 3.5.2::.>

        type Character is
          (<nul>,   <soh>,   <stx>,   <etx>,   <eot>,   <enq>,   <ack>,   <bel>,   --<0 (16#00#) .. 7 (16#07#)>
           <bs>,   <ht>,   <lf>,   <vt>,   <ff>,   <cr>,   <so>,   <si>,   --<8 (16#08#) .. 15 (16#0F#)>

           <dle>,   <dc1>,   <dc2>,   <dc3>,   <dc4>,   <nak>,   <syn>,   <etb>,   --<16 (16#10#) .. 23 (16#17#)>
           <can>,   <em>,   <sub>,   <esc>,   <fs>,   <gs>,   <rs>,   <us>,   --<24 (16#18#) .. 31 (16#1F#)>

           ' ',   '!',   '"',   '#',   '$',   '%',   '&',   ''',   --<32 (16#20#) .. 39 (16#27#)>
           '(',   ')',   '*',   '+',   ',',   '-',   '.',   '/',   --<40 (16#28#) .. 47 (16#2F#)>

           '0',   '1',   '2',   '3',   '4',   '5',   '6',   '7',   --<48 (16#30#) .. 55 (16#37#)>
           '8',   '9',   ':',   ';',   '<',   '=',   '>',   '?',   --<56 (16#38#) .. 63 (16#3F#)>

           '@',   'A',   'B',   'C',   'D',   'E',   'F',   'G',   --<64 (16#40#) .. 71 (16#47#)>
           'H',   'I',   'J',   'K',   'L',   'M',   'N',   'O',   --<72 (16#48#) .. 79 (16#4F#)>

           'P',   'Q',   'R',   'S',   'T',   'U',   'V',   'W',   --<80 (16#50#) .. 87 (16#57#)>
           'X',   'Y',   'Z',   '[',   '\',   ']',   '^',   '_',   --<88 (16#58#) .. 95 (16#5F#)>

           '`',   'a',   'b',   'c',   'd',   'e',   'f',   'g',   --<96 (16#60#) .. 103 (16#67#)>
           'h',   'i',   'j',   'k',   'l',   'm',   'n',   'o',   --<104 (16#68#) .. 111 (16#6F#)>

           'p',   'q',   'r',   's',   't',   'u',   'v',   'w',   --<112 (16#70#) .. 119 (16#77#)>
           'x',   'y',   'z',   '{',   '|',   '}',   '~',   <del>,   --<120 (16#78#) .. 127 (16#7F#)>

           <reserved_128>,   <reserved_129>,   <bph>,   <nbh>,         --<128 (16#80#) .. 131 (16#83#)>
           <reserved_132>,   <nel>,   <ssa>,   <esa>,            --<132 (16#84#) .. 135 (16#87#)>
           <hts>,   <htj>,   <vts>,   <pld>,   <plu>,   <ri>,   <ss2>,   <ss3>,   --<136 (16#88#) .. 143 (16#8F#)>

           <dcs>,   <pu1>,   <pu2>,   <sts>,   <cch>,   <mw>,   <spa>,   <epa>,   --<144 (16#90#) .. 151 (16#97#)>
           <sos>,   <reserved_153>,   <sci>,   <csi>,            --<152 (16#98#) .. 155 (16#9B#)>
           <st>,   <osc>,   <pm>,   <apc>,               --<156 (16#9C#) .. 159 (16#9F#)>

           ' ',   '¡',   '¢',   '£',   '¤',   '¥',   '¦',   '§',   --<160 (16#A0#) .. 167 (16#A7#)>
           '¨',   '©',   'ª',   '«',               --<168 (16#A8#) .. 171 (16#AB#)>
           ¬',   <soft_hyphen>,   '®',   '¯',            --<172 (16#AC#) .. 175 (16#AF#)>

           '°',   '±',   '²',   '³',   '´',   'µ',   '¶',   '·',   --<176 (16#B0#) .. 183 (16#B7#)>
           '¸',   '¹',   'º',   '»',   '¼',   '½',   '¾',   '¿',   --<184 (16#B8#) .. 191 (16#BF#)>

           'À',   'Á',   'Â',   'Ã',   'Ä',   'Å',   'Æ',   'Ç',   --<192 (16#C0#) .. 199 (16#C7#)>
           'È',   'É',   'Ê',   'Ë',   'Ì',   'Í',   'Î',   'Ï',   --<200 (16#C8#) .. 207 (16#CF#)>

           'Ð',   'Ñ',   'Ò',   'Ó',   'Ô',   'Õ',   'Ö',   '×',   --<208 (16#D0#) .. 215 (16#D7#)>
           'Ø',   'Ù',   'Ú',   'Û',   'Ü',   'Ý',   'Þ',   'ß',   --<216 (16#D8#) .. 223 (16#DF#)>

           'à',   'á',   'â',   'ã',   'ä',   'å',   'æ',   'ç',   --<224 (16#E0#) .. 231 (16#E7#)>
           'è',   'é',   'ê',   'ë',   'ì',   'í',   'î',   'ï',   --<232 (16#E8#) .. 239 (16#EF#)>

           'ð',   'ñ',   'ò',   'ó',   'ô',   'õ',   'ö',   '÷',   --<240 (16#F0#) .. 247 (16#F7#)>
           'ø',   'ù',   'ú',   'û',   'ü',   'ý',   'þ',   'ÿ');--<248 (16#F8#) .. 255 (16#FF#)>

36
        --< The predefined operators for the type Character are the same as for>
        --< any enumeration type.>


36.1/3
        --< The declaration of type Wide_Character is based on the standard ISO/IEC 10646:2011 BMP character>
        --< set. The first 256 positions have the same contents as type Character. See *note 3.5.2::.>

        type Wide_Character is (<nul>, <soh> ... <Hex_0000FFFE>, <Hex_0000FFFF>);

36.2/3
        --< The declaration of type Wide_Wide_Character is based on the full>
        --< ISO/IEC 10646:2011 character set. The first 65536 positions have the>
        --< same contents as type Wide_Character. See *note 3.5.2::.>

        type Wide_Wide_Character is (<nul>, <soh> ... <Hex_7FFFFFFE>, <Hex_7FFFFFFF>);
        for Wide_Wide_Character'Size use 32;

36.3/2
        package ASCII is ... end ASCII;  --<Obsolescent; see *note J.5::>



37/3
        --< Predefined string types:>

        type String is array(Positive range <>) of Character
           with Pack;

38
        --< The predefined operators for this type are as follows:>

39
        --     function "="  (Left, Right: String) return Boolean;
        --     function "/=" (Left, Right: String) return Boolean;
        --     function "<"  (Left, Right: String) return Boolean;
        --     function "<=" (Left, Right: String) return Boolean;
        --     function ">"  (Left, Right: String) return Boolean;
        --     function ">=" (Left, Right: String) return Boolean;

40
        --     function "&" (Left: String;    Right: String)    return String;
        --     function "&" (Left: Character; Right: String)    return String;
        --     function "&" (Left: String;    Right: Character) return String;
        --     function "&" (Left: Character; Right: Character) return String;

41/3
        type Wide_String is array(Positive range <>) of Wide_Character
           with Pack;

42
        --< The predefined operators for this type correspond to those for String.>

42.1/3
        type Wide_Wide_String is array (Positive range <>)
           of Wide_Wide_Character
              with Pack;

42.2/2
        --< The predefined operators for this type correspond to those for String.>

43
        type Duration is delta <implementation-defined> range <implementation-defined>;

44
           --< The predefined operators for the type Duration are the same as for>
           --< any fixed point type.>

45
        --< The predefined exceptions:>

46
        Constraint_Error: exception;
        Program_Error   : exception;
        Storage_Error   : exception;
        Tasking_Error   : exception;

47
     end Standard;

48
Standard has no private part.

49/2
In each of the types Character, Wide_Character, and Wide_Wide_Character,
the character literals for the space character (position 32) and the
non-breaking space character (position 160) correspond to different
values.  Unless indicated otherwise, each occurrence of the character
literal ' ' in this International Standard refers to the space
character.  Similarly, the character literals for hyphen (position 45)
and soft hyphen (position 173) correspond to different values.  Unless
indicated otherwise, each occurrence of the character literal '-' in
this International Standard refers to the hyphen character.

                          _Dynamic Semantics_

50
Elaboration of the body of Standard has no effect.

                     _Implementation Permissions_

51
An implementation may provide additional predefined integer types and
additional predefined floating point types.  Not all of these types need
have names.

                        _Implementation Advice_

52
If an implementation provides additional named predefined integer types,
then the names should end with "Integer" as in "Long_Integer".  If an
implementation provides additional named predefined floating point
types, then the names should end with "Float" as in "Long_Float".

     NOTES

53
     1  Certain aspects of the predefined entities cannot be completely
     described in the language itself.  For example, although the
     enumeration type Boolean can be written showing the two enumeration
     literals False and True, the short-circuit control forms cannot be
     expressed in the language.

54
     2  As explained in *note 8.1::, "*note 8.1:: Declarative Region"
     and *note 10.1.4::, "*note 10.1.4:: The Compilation Process", the
     declarative region of the package Standard encloses every library
     unit and consequently the main subprogram; the declaration of every
     library unit is assumed to occur within this declarative region.
     Library_items are assumed to be ordered in such a way that there
     are no forward semantic dependences.  However, as explained in
     *note 8.3::, "*note 8.3:: Visibility", the only library units that
     are visible within a given compilation unit are the library units
     named by all with_clauses that apply to the given unit, and
     moreover, within the declarative region of a given library unit,
     that library unit itself.

55
     3  If all block_statements of a program are named, then the name of
     each program unit can always be written as an expanded name
     starting with Standard (unless Standard is itself hidden).  The
     name of a library unit cannot be a homograph of a name (such as
     Integer) that is already declared in Standard.

56
     4  The exception Standard.Numeric_Error is defined in *note J.6::.


File: arm2012.info,  Node: A.2,  Next: A.3,  Prev: A.1,  Up: Annex A

A.2 The Package Ada
===================

                          _Static Semantics_

1
The following language-defined library package exists:

2
     package Ada is
         pragma Pure(Ada);
     end Ada;

3
Ada serves as the parent of most of the other language-defined library
units; its declaration is empty (except for the pragma Pure).

                           _Legality Rules_

4
In the standard mode, it is illegal to compile a child of package Ada.


File: arm2012.info,  Node: A.3,  Next: A.4,  Prev: A.2,  Up: Annex A

A.3 Character Handling
======================

1/3
This subclause presents the packages related to character processing: an
empty declared pure package Characters and child packages
Characters.Handling and Characters.Latin_1.  The package
Characters.Handling provides classification and conversion functions for
Character data, and some simple functions for dealing with
Wide_Character and Wide_Wide_Character data.  The child package
Characters.Latin_1 declares a set of constants initialized to values of
type Character.

* Menu:

* A.3.1 ::    The Packages Characters, Wide_Characters, and Wide_Wide_Characters
* A.3.2 ::    The Package Characters.Handling
* A.3.3 ::    The Package Characters.Latin_1
* A.3.4 ::    The Package Characters.Conversions
* A.3.5 ::    The Package Wide_Characters.Handling
* A.3.6 ::    The Package Wide_Wide_Characters.Handling


File: arm2012.info,  Node: A.3.1,  Next: A.3.2,  Up: A.3

A.3.1 The Packages Characters, Wide_Characters, and Wide_Wide_Characters
------------------------------------------------------------------------

                          _Static Semantics_

1
The library package Characters has the following declaration:

2
     package Ada.Characters is
       pragma Pure(Characters);
     end Ada.Characters;

3/2
The library package Wide_Characters has the following declaration:

4/2
     package Ada.Wide_Characters is
       pragma Pure(Wide_Characters);
     end Ada.Wide_Characters;

5/2
The library package Wide_Wide_Characters has the following declaration:

6/2
     package Ada.Wide_Wide_Characters is
       pragma Pure(Wide_Wide_Characters);
     end Ada.Wide_Wide_Characters;

                        _Implementation Advice_

7/3
If an implementation chooses to provide implementation-defined
operations on Wide_Character or Wide_String (such as collating and
sorting, etc.)  it should do so by providing child units of
Wide_Characters.  Similarly if it chooses to provide
implementation-defined operations on Wide_Wide_Character or
Wide_Wide_String it should do so by providing child units of
Wide_Wide_Characters.


File: arm2012.info,  Node: A.3.2,  Next: A.3.3,  Prev: A.3.1,  Up: A.3

A.3.2 The Package Characters.Handling
-------------------------------------

                          _Static Semantics_

1
The library package Characters.Handling has the following declaration:

2/2
     with Ada.Characters.Conversions;
     package Ada.Characters.Handling is
       pragma Pure(Handling);

3
     --<Character classification functions>

4/3
       function Is_Control           (Item : in Character) return Boolean;
       function Is_Graphic           (Item : in Character) return Boolean;
       function Is_Letter            (Item : in Character) return Boolean;
       function Is_Lower             (Item : in Character) return Boolean;
       function Is_Upper             (Item : in Character) return Boolean;
       function Is_Basic             (Item : in Character) return Boolean;
       function Is_Digit             (Item : in Character) return Boolean;
       function Is_Decimal_Digit     (Item : in Character) return Boolean
                          renames Is_Digit;
       function Is_Hexadecimal_Digit (Item : in Character) return Boolean;
       function Is_Alphanumeric      (Item : in Character) return Boolean;
       function Is_Special           (Item : in Character) return Boolean;
       function Is_Line_Terminator   (Item : in Character) return Boolean;
       function Is_Mark              (Item : in Character) return Boolean;
       function Is_Other_Format      (Item : in Character) return Boolean;
       function Is_Punctuation_Connector (Item : in Character) return Boolean;
       function Is_Space             (Item : in Character) return Boolean;

5
     --<Conversion functions for Character and String>

6
       function To_Lower (Item : in Character) return Character;
       function To_Upper (Item : in Character) return Character;
       function To_Basic (Item : in Character) return Character;

7
       function To_Lower (Item : in String) return String;
       function To_Upper (Item : in String) return String;
       function To_Basic (Item : in String) return String;

8
     --<Classifications of and conversions between Character and ISO 646>

9
       subtype ISO_646 is
         Character range Character'Val(0) .. Character'Val(127);

10
       function Is_ISO_646 (Item : in Character) return Boolean;
       function Is_ISO_646 (Item : in String)    return Boolean;

11
       function To_ISO_646 (Item       : in Character;
                            Substitute : in ISO_646 := ' ')
         return ISO_646;

12
       function To_ISO_646 (Item       : in String;
                            Substitute : in ISO_646 := ' ')
         return String;

13/2
     --< The functions Is_Character, Is_String, To_Character, To_String, To_Wide_Character,>
     --< and To_Wide_String are obsolescent; see *note J.14::.>

     <Paragraphs 14 through 18 were deleted.>

19
     end Ada.Characters.Handling;

20
In the description below for each function that returns a Boolean
result, the effect is described in terms of the conditions under which
the value True is returned.  If these conditions are not met, then the
function returns False.

21
Each of the following classification functions has a formal Character
parameter, Item, and returns a Boolean result.

22
Is_Control
               True if Item is a control character.  A <control
               character> is a character whose position is in one of the
               ranges 0..31 or 127..159.

23
Is_Graphic
               True if Item is a graphic character.  A <graphic
               character> is a character whose position is in one of the
               ranges 32..126 or 160..255.

24
Is_Letter
               True if Item is a letter.  A <letter> is a character that
               is in one of the ranges 'A'..'Z' or 'a'..'z', or whose
               position is in one of the ranges 192..214, 216..246, or
               248..255.

25
Is_Lower
               True if Item is a lower-case letter.  A <lower-case
               letter> is a character that is in the range 'a'..'z', or
               whose position is in one of the ranges 223..246 or
               248..255.

26
Is_Upper
               True if Item is an upper-case letter.  An <upper-case
               letter> is a character that is in the range 'A'..'Z' or
               whose position is in one of the ranges 192..214 or 216..
               222.

27
Is_Basic
               True if Item is a basic letter.  A <basic letter> is a
               character that is in one of the ranges 'A'..'Z' and
               'a'..'z', or that is one of the following: 'Æ', 'æ', 'Ð',
               'ð', 'Þ', 'þ', or 'ß'.

28
Is_Digit
               True if Item is a decimal digit.  A <decimal digit> is a
               character in the range '0'..'9'.

29
Is_Decimal_Digit
               A renaming of Is_Digit.

30
Is_Hexadecimal_Digit
               True if Item is a hexadecimal digit.  A <hexadecimal
               digit> is a character that is either a decimal digit or
               that is in one of the ranges 'A' ..  'F' or 'a' ..  'f'.

31
Is_Alphanumeric
               True if Item is an alphanumeric character.  An
               <alphanumeric character> is a character that is either a
               letter or a decimal digit.

32
Is_Special
               True if Item is a special graphic character.  A <special
               graphic character> is a graphic character that is not
               alphanumeric.

32.1/3
Is_Line_Terminator
               True if Item is a character with position 10 ..  13
               (Line_Feed, Line_Tabulation, Form_Feed, Carriage_Return)
               or 133 (Next_Line).

32.2/3
Is_Mark
               Never True (no value of type Character has categories
               Mark, Non-Spacing or Mark, Spacing Combining).

32.3/3
Is_Other_Format
               True if Item is a character with position 173
               (Soft_Hyphen).

32.4/3
Is_Punctuation_Connector
               True if Item is a character with position 95 ('_', known
               as Low_Line or Underscore).

32.5/3
Is_Space
               True if Item is a character with position 32 (' ') or 160
               (No_Break_Space).

33
Each of the names To_Lower, To_Upper, and To_Basic refers to two
functions: one that converts from Character to Character, and the other
that converts from String to String.  The result of each
Character-to-Character function is described below, in terms of the
conversion applied to Item, its formal Character parameter.  The result
of each String-to-String conversion is obtained by applying to each
element of the function's String parameter the corresponding
Character-to-Character conversion; the result is the null String if the
value of the formal parameter is the null String.  The lower bound of
the result String is 1.

34
To_Lower
               Returns the corresponding lower-case value for Item if
               Is_Upper(Item), and returns Item otherwise.

35
To_Upper
               Returns the corresponding upper-case value for Item if
               Is_Lower(Item) and Item has an upper-case form, and
               returns Item otherwise.  The lower case letters 'ß' and
               'ÿ' do not have upper case forms.

36
To_Basic
               Returns the letter corresponding to Item but with no
               diacritical mark, if Item is a letter but not a basic
               letter; returns Item otherwise.

37
The following set of functions test for membership in the ISO 646
character range, or convert between ISO 646 and Character.

38
Is_ISO_646
               The function whose formal parameter, Item, is of type
               Character returns True if Item is in the subtype ISO_646.

39
Is_ISO_646
               The function whose formal parameter, Item, is of type
               String returns True if Is_ISO_646(Item(I)) is True for
               each I in Item'Range.

40
To_ISO_646
               The function whose first formal parameter, Item, is of
               type Character returns Item if Is_ISO_646(Item), and
               returns the Substitute ISO_646 character otherwise.

41
To_ISO_646
               The function whose first formal parameter, Item, is of
               type String returns the String whose Range is
               1..Item'Length and each of whose elements is given by
               To_ISO_646 of the corresponding element in Item.

<Paragraphs 42 through 49 were deleted.>

     NOTES

50
     5  A basic letter is a letter without a diacritical mark.

51
     6  Except for the hexadecimal digits, basic letters, and ISO_646
     characters, the categories identified in the classification
     functions form a strict hierarchy:

52
          -- Control characters

53
          -- Graphic characters

54
             -- Alphanumeric characters

55
                -- Letters

56
                   -- Upper-case letters

57
                   -- Lower-case letters

58
                -- Decimal digits

59
             -- Special graphic characters

60/3
     7  There are certain characters which are defined to be lower case
     letters by ISO 10646 and are therefore allowed in identifiers, but
     are not considered lower case letters by Ada.Characters.Handling.


File: arm2012.info,  Node: A.3.3,  Next: A.3.4,  Prev: A.3.2,  Up: A.3

A.3.3 The Package Characters.Latin_1
------------------------------------

1
The package Characters.Latin_1 declares constants for characters in ISO
8859-1.

                          _Static Semantics_

2
The library package Characters.Latin_1 has the following declaration:

3
     package Ada.Characters.Latin_1 is
         pragma Pure(Latin_1);

4
     --< Control characters:>

5
         NUL                  : constant Character := Character'Val(0);
         SOH                  : constant Character := Character'Val(1);
         STX                  : constant Character := Character'Val(2);
         ETX                  : constant Character := Character'Val(3);
         EOT                  : constant Character := Character'Val(4);
         ENQ                  : constant Character := Character'Val(5);
         ACK                  : constant Character := Character'Val(6);
         BEL                  : constant Character := Character'Val(7);
         BS                   : constant Character := Character'Val(8);
         HT                   : constant Character := Character'Val(9);
         LF                   : constant Character := Character'Val(10);
         VT                   : constant Character := Character'Val(11);
         FF                   : constant Character := Character'Val(12);
         CR                   : constant Character := Character'Val(13);
         SO                   : constant Character := Character'Val(14);
         SI                   : constant Character := Character'Val(15);

6
         DLE                  : constant Character := Character'Val(16);
         DC1                  : constant Character := Character'Val(17);
         DC2                  : constant Character := Character'Val(18);
         DC3                  : constant Character := Character'Val(19);
         DC4                  : constant Character := Character'Val(20);
         NAK                  : constant Character := Character'Val(21);
         SYN                  : constant Character := Character'Val(22);
         ETB                  : constant Character := Character'Val(23);
         CAN                  : constant Character := Character'Val(24);
         EM                   : constant Character := Character'Val(25);
         SUB                  : constant Character := Character'Val(26);
         ESC                  : constant Character := Character'Val(27);
         FS                   : constant Character := Character'Val(28);
         GS                   : constant Character := Character'Val(29);
         RS                   : constant Character := Character'Val(30);
         US                   : constant Character := Character'Val(31);

7
     --< ISO 646 graphic characters:>

8
         Space                : constant Character := ' ';  --< Character'Val(32)>
         Exclamation          : constant Character := '!';  --< Character'Val(33)>
         Quotation            : constant Character := '"';  --< Character'Val(34)>
         Number_Sign          : constant Character := '#';  --< Character'Val(35)>
         Dollar_Sign          : constant Character := '$';  --< Character'Val(36)>
         Percent_Sign         : constant Character := '%';  --< Character'Val(37)>
         Ampersand            : constant Character := '&';  --< Character'Val(38)>
         Apostrophe           : constant Character := ''';  --< Character'Val(39)>
         Left_Parenthesis     : constant Character := '(';  --< Character'Val(40)>
         Right_Parenthesis    : constant Character := ')';  --< Character'Val(41)>
         Asterisk             : constant Character := '*';  --< Character'Val(42)>
         Plus_Sign            : constant Character := '+';  --< Character'Val(43)>
         Comma                : constant Character := ',';  --< Character'Val(44)>
         Hyphen               : constant Character := '-';  --< Character'Val(45)>
         Minus_Sign           : Character renames Hyphen;
         Full_Stop            : constant Character := '.';  --< Character'Val(46)>
         Solidus              : constant Character := '/';  --< Character'Val(47)>

9
         --< Decimal digits '0' though '9' are at positions 48 through 57>

10
         Colon                : constant Character := ':';  --< Character'Val(58)>
         Semicolon            : constant Character := ';';  --< Character'Val(59)>
         Less_Than_Sign       : constant Character := '<';  --< Character'Val(60)>
         Equals_Sign          : constant Character := '=';  --< Character'Val(61)>
         Greater_Than_Sign    : constant Character := '>';  --< Character'Val(62)>
         Question             : constant Character := '?';  --< Character'Val(63)>
         Commercial_At        : constant Character := '@';  --< Character'Val(64)>

11
         --< Letters 'A' through 'Z' are at positions 65 through 90>

12
         Left_Square_Bracket  : constant Character := '[';  --< Character'Val(91)>
         Reverse_Solidus      : constant Character := '\';  --< Character'Val(92)>
         Right_Square_Bracket : constant Character := ']';  --< Character'Val(93)>
         Circumflex           : constant Character := '^';  --< Character'Val(94)>
         Low_Line             : constant Character := '_';  --< Character'Val(95)>

13
         Grave                : constant Character := '`';  --< Character'Val(96)>
         LC_A                 : constant Character := 'a';  --< Character'Val(97)>
         LC_B                 : constant Character := 'b';  --< Character'Val(98)>
         LC_C                 : constant Character := 'c';  --< Character'Val(99)>
         LC_D                 : constant Character := 'd';  --< Character'Val(100)>
         LC_E                 : constant Character := 'e';  --< Character'Val(101)>
         LC_F                 : constant Character := 'f';  --< Character'Val(102)>
         LC_G                 : constant Character := 'g';  --< Character'Val(103)>
         LC_H                 : constant Character := 'h';  --< Character'Val(104)>
         LC_I                 : constant Character := 'i';  --< Character'Val(105)>
         LC_J                 : constant Character := 'j';  --< Character'Val(106)>
         LC_K                 : constant Character := 'k';  --< Character'Val(107)>
         LC_L                 : constant Character := 'l';  --< Character'Val(108)>
         LC_M                 : constant Character := 'm';  --< Character'Val(109)>
         LC_N                 : constant Character := 'n';  --< Character'Val(110)>
         LC_O                 : constant Character := 'o';  --< Character'Val(111)>

14
         LC_P                 : constant Character := 'p';  --< Character'Val(112)>
         LC_Q                 : constant Character := 'q';  --< Character'Val(113)>
         LC_R                 : constant Character := 'r';  --< Character'Val(114)>
         LC_S                 : constant Character := 's';  --< Character'Val(115)>
         LC_T                 : constant Character := 't';  --< Character'Val(116)>
         LC_U                 : constant Character := 'u';  --< Character'Val(117)>
         LC_V                 : constant Character := 'v';  --< Character'Val(118)>
         LC_W                 : constant Character := 'w';  --< Character'Val(119)>
         LC_X                 : constant Character := 'x';  --< Character'Val(120)>
         LC_Y                 : constant Character := 'y';  --< Character'Val(121)>
         LC_Z                 : constant Character := 'z';  --< Character'Val(122)>
         Left_Curly_Bracket   : constant Character := '{';  --< Character'Val(123)>
         Vertical_Line        : constant Character := '|';  --< Character'Val(124)>
         Right_Curly_Bracket  : constant Character := '}';  --< Character'Val(125)>
         Tilde                : constant Character := '~';  --< Character'Val(126)>
         DEL                  : constant Character := Character'Val(127);

15
     --< ISO 6429 control characters:>

16
         IS4                  : Character renames FS;
         IS3                  : Character renames GS;
         IS2                  : Character renames RS;
         IS1                  : Character renames US;

17
         Reserved_128         : constant Character := Character'Val(128);
         Reserved_129         : constant Character := Character'Val(129);
         BPH                  : constant Character := Character'Val(130);
         NBH                  : constant Character := Character'Val(131);
         Reserved_132         : constant Character := Character'Val(132);
         NEL                  : constant Character := Character'Val(133);
         SSA                  : constant Character := Character'Val(134);
         ESA                  : constant Character := Character'Val(135);
         HTS                  : constant Character := Character'Val(136);
         HTJ                  : constant Character := Character'Val(137);
         VTS                  : constant Character := Character'Val(138);
         PLD                  : constant Character := Character'Val(139);
         PLU                  : constant Character := Character'Val(140);
         RI                   : constant Character := Character'Val(141);
         SS2                  : constant Character := Character'Val(142);
         SS3                  : constant Character := Character'Val(143);

18
         DCS                  : constant Character := Character'Val(144);
         PU1                  : constant Character := Character'Val(145);
         PU2                  : constant Character := Character'Val(146);
         STS                  : constant Character := Character'Val(147);
         CCH                  : constant Character := Character'Val(148);
         MW                   : constant Character := Character'Val(149);
         SPA                  : constant Character := Character'Val(150);
         EPA                  : constant Character := Character'Val(151);

19
         SOS                  : constant Character := Character'Val(152);
         Reserved_153         : constant Character := Character'Val(153);
         SCI                  : constant Character := Character'Val(154);
         CSI                  : constant Character := Character'Val(155);
         ST                   : constant Character := Character'Val(156);
         OSC                  : constant Character := Character'Val(157);
         PM                   : constant Character := Character'Val(158);
         APC                  : constant Character := Character'Val(159);

20
     --< Other graphic characters:>

21/3
     --< Character positions 160 (16#A0#) .. 175 (16#AF#):>
         No_Break_Space             : constant Character := ' '; --<Character'Val(160)>
         NBSP                       : Character renames No_Break_Space;
         Inverted_Exclamation       : constant Character := '¡'; --<Character'Val(161)>
         Cent_Sign                  : constant Character := '¢'; --<Character'Val(162)>
         Pound_Sign                 : constant Character := '£'; --<Character'Val(163)>
         Currency_Sign              : constant Character := '¤'; --<Character'Val(164)>
         Yen_Sign                   : constant Character := '¥'; --<Character'Val(165)>
         Broken_Bar                 : constant Character := '¦'; --<Character'Val(166)>
         Section_Sign               : constant Character := '§'; --<Character'Val(167)>
         Diaeresis                  : constant Character := '¨'; --<Character'Val(168)>
         Copyright_Sign             : constant Character := '©'; --<Character'Val(169)>
         Feminine_Ordinal_Indicator : constant Character := 'ª'; --<Character'Val(170)>
         Left_Angle_Quotation       : constant Character := '«'; --<Character'Val(171)>
         Not_Sign                   : constant Character := '¬'; --<Character'Val(172)>
         Soft_Hyphen                : constant Character := Character'Val(173);
         Registered_Trade_Mark_Sign : constant Character := '®'; --<Character'Val(174)>
         Macron                     : constant Character := '¯'; --<Character'Val(175)>

22
     --< Character positions 176 (16#B0#) .. 191 (16#BF#):>
         Degree_Sign                : constant Character := '°'; --<Character'Val(176)>
         Ring_Above                 : Character renames Degree_Sign;
         Plus_Minus_Sign            : constant Character := '±'; --<Character'Val(177)>
         Superscript_Two            : constant Character := '²'; --<Character'Val(178)>
         Superscript_Three          : constant Character := '³'; --<Character'Val(179)>
         Acute                      : constant Character := '´'; --<Character'Val(180)>
         Micro_Sign                 : constant Character := 'µ'; --<Character'Val(181)>
         Pilcrow_Sign               : constant Character := '¶'; --<Character'Val(182)>
         Paragraph_Sign             : Character renames Pilcrow_Sign;
         Middle_Dot                 : constant Character := '·'; --<Character'Val(183)>
         Cedilla                    : constant Character := '¸'; --<Character'Val(184)>
         Superscript_One            : constant Character := '¹'; --<Character'Val(185)>
         Masculine_Ordinal_Indicator: constant Character := 'º'; --<Character'Val(186)>
         Right_Angle_Quotation      : constant Character := '»'; --<Character'Val(187)>
         Fraction_One_Quarter       : constant Character := '¼'; --<Character'Val(188)>
         Fraction_One_Half          : constant Character := '½'; --<Character'Val(189)>
         Fraction_Three_Quarters    : constant Character := '¾'; --<Character'Val(190)>
         Inverted_Question          : constant Character := '¿'; --<Character'Val(191)>

23
     --< Character positions 192 (16#C0#) .. 207 (16#CF#):>
         UC_A_Grave                 : constant Character := 'À'; --<Character'Val(192)>
         UC_A_Acute                 : constant Character := 'Á'; --<Character'Val(193)>
         UC_A_Circumflex            : constant Character := 'Â'; --<Character'Val(194)>
         UC_A_Tilde                 : constant Character := 'Ã'; --<Character'Val(195)>
         UC_A_Diaeresis             : constant Character := 'Ä'; --<Character'Val(196)>
         UC_A_Ring                  : constant Character := 'Å'; --<Character'Val(197)>
         UC_AE_Diphthong            : constant Character := 'Æ'; --<Character'Val(198)>
         UC_C_Cedilla               : constant Character := 'Ç'; --<Character'Val(199)>
         UC_E_Grave                 : constant Character := 'È'; --<Character'Val(200)>
         UC_E_Acute                 : constant Character := 'É'; --<Character'Val(201)>
         UC_E_Circumflex            : constant Character := 'Ê'; --<Character'Val(202)>
         UC_E_Diaeresis             : constant Character := 'Ë'; --<Character'Val(203)>
         UC_I_Grave                 : constant Character := 'Ì'; --<Character'Val(204)>
         UC_I_Acute                 : constant Character := 'Í'; --<Character'Val(205)>
         UC_I_Circumflex            : constant Character := 'Î'; --<Character'Val(206)>
         UC_I_Diaeresis             : constant Character := 'Ï'; --<Character'Val(207)>

24
     --< Character positions 208 (16#D0#) .. 223 (16#DF#):>
         UC_Icelandic_Eth           : constant Character := 'Ð'; --<Character'Val(208)>
         UC_N_Tilde                 : constant Character := 'Ñ'; --<Character'Val(209)>
         UC_O_Grave                 : constant Character := 'Ò'; --<Character'Val(210)>
         UC_O_Acute                 : constant Character := 'Ó'; --<Character'Val(211)>
         UC_O_Circumflex            : constant Character := 'Ô'; --<Character'Val(212)>
         UC_O_Tilde                 : constant Character := 'Õ'; --<Character'Val(213)>
         UC_O_Diaeresis             : constant Character := 'Ö'; --<Character'Val(214)>
         Multiplication_Sign        : constant Character := '×'; --<Character'Val(215)>
         UC_O_Oblique_Stroke        : constant Character := 'Ø'; --<Character'Val(216)>
         UC_U_Grave                 : constant Character := 'Ù'; --<Character'Val(217)>
         UC_U_Acute                 : constant Character := 'Ú'; --<Character'Val(218)>
         UC_U_Circumflex            : constant Character := 'Û'; --<Character'Val(219)>
         UC_U_Diaeresis             : constant Character := 'Ü'; --<Character'Val(220)>
         UC_Y_Acute                 : constant Character := 'Ý'; --<Character'Val(221)>
         UC_Icelandic_Thorn         : constant Character := 'Þ'; --<Character'Val(222)>
         LC_German_Sharp_S          : constant Character := 'ß'; --<Character'Val(223)>

25
     --< Character positions 224 (16#E0#) .. 239 (16#EF#):>
         LC_A_Grave                 : constant Character := 'à'; --<Character'Val(224)>
         LC_A_Acute                 : constant Character := 'á'; --<Character'Val(225)>
         LC_A_Circumflex            : constant Character := 'â'; --<Character'Val(226)>
         LC_A_Tilde                 : constant Character := 'ã'; --<Character'Val(227)>
         LC_A_Diaeresis             : constant Character := 'ä'; --<Character'Val(228)>
         LC_A_Ring                  : constant Character := 'å'; --<Character'Val(229)>
         LC_AE_Diphthong            : constant Character := 'æ'; --<Character'Val(230)>
         LC_C_Cedilla               : constant Character := 'ç'; --<Character'Val(231)>
         LC_E_Grave                 : constant Character := 'è'; --<Character'Val(232)>
         LC_E_Acute                 : constant Character := 'é'; --<Character'Val(233)>
         LC_E_Circumflex            : constant Character := 'ê'; --<Character'Val(234)>
         LC_E_Diaeresis             : constant Character := 'ë'; --<Character'Val(235)>
         LC_I_Grave                 : constant Character := 'ì'; --<Character'Val(236)>
         LC_I_Acute                 : constant Character := 'í'; --<Character'Val(237)>
         LC_I_Circumflex            : constant Character := 'î'; --<Character'Val(238)>
         LC_I_Diaeresis             : constant Character := 'ï'; --<Character'Val(239)>

26
     --< Character positions 240 (16#F0#) .. 255 (16#FF#):>
         LC_Icelandic_Eth           : constant Character := 'ð'; --<Character'Val(240)>
         LC_N_Tilde                 : constant Character := 'ñ'; --<Character'Val(241)>
         LC_O_Grave                 : constant Character := 'ò'; --<Character'Val(242)>
         LC_O_Acute                 : constant Character := 'ó'; --<Character'Val(243)>
         LC_O_Circumflex            : constant Character := 'ô'; --<Character'Val(244)>
         LC_O_Tilde                 : constant Character := 'õ'; --<Character'Val(245)>
         LC_O_Diaeresis             : constant Character := 'ö'; --<Character'Val(246)>
         Division_Sign              : constant Character := '÷'; --<Character'Val(247)>
         LC_O_Oblique_Stroke        : constant Character := 'ø'; --<Character'Val(248)>
         LC_U_Grave                 : constant Character := 'ù'; --<Character'Val(249)>
         LC_U_Acute                 : constant Character := 'ú'; --<Character'Val(250)>
         LC_U_Circumflex            : constant Character := 'û'; --<Character'Val(251)>
         LC_U_Diaeresis             : constant Character := 'ü'; --<Character'Val(252)>
         LC_Y_Acute                 : constant Character := 'ý'; --<Character'Val(253)>
         LC_Icelandic_Thorn         : constant Character := 'þ'; --<Character'Val(254)>
         LC_Y_Diaeresis             : constant Character := 'ÿ'; --<Character'Val(255)>
     end Ada.Characters.Latin_1;

                     _Implementation Permissions_

27
An implementation may provide additional packages as children of
Ada.Characters, to declare names for the symbols of the local character
set or other character sets.


File: arm2012.info,  Node: A.3.4,  Next: A.3.5,  Prev: A.3.3,  Up: A.3

A.3.4 The Package Characters.Conversions
----------------------------------------

                          _Static Semantics_

1/2
The library package Characters.Conversions has the following
declaration:

2/2
     package Ada.Characters.Conversions is
        pragma Pure(Conversions);

3/2
        function Is_Character (Item : in Wide_Character)      return Boolean;
        function Is_String    (Item : in Wide_String)         return Boolean;
        function Is_Character (Item : in Wide_Wide_Character) return Boolean;
        function Is_String    (Item : in Wide_Wide_String)    return Boolean;
        function Is_Wide_Character (Item : in Wide_Wide_Character)
           return Boolean;
        function Is_Wide_String    (Item : in Wide_Wide_String)
           return Boolean;

4/2
        function To_Wide_Character (Item : in Character) return Wide_Character;
        function To_Wide_String    (Item : in String)    return Wide_String;
        function To_Wide_Wide_Character (Item : in Character)
           return Wide_Wide_Character;
        function To_Wide_Wide_String    (Item : in String)
           return Wide_Wide_String;
        function To_Wide_Wide_Character (Item : in Wide_Character)
           return Wide_Wide_Character;
        function To_Wide_Wide_String    (Item : in Wide_String)
           return Wide_Wide_String;

5/2
        function To_Character (Item       : in Wide_Character;
                              Substitute : in Character := ' ')
           return Character;
        function To_String    (Item       : in Wide_String;
                               Substitute : in Character := ' ')
           return String;
        function To_Character (Item :       in Wide_Wide_Character;
                               Substitute : in Character := ' ')
           return Character;
        function To_String    (Item :       in Wide_Wide_String;
                               Substitute : in Character := ' ')
           return String;
        function To_Wide_Character (Item :       in Wide_Wide_Character;
                                    Substitute : in Wide_Character := ' ')
           return Wide_Character;
        function To_Wide_String    (Item :       in Wide_Wide_String;
                                    Substitute : in Wide_Character := ' ')
           return Wide_String;

6/2
     end Ada.Characters.Conversions;

7/2
The functions in package Characters.Conversions test Wide_Wide_Character
or Wide_Character values for membership in Wide_Character or Character,
or convert between corresponding characters of Wide_Wide_Character,
Wide_Character, and Character.

8/2
     function Is_Character (Item : in Wide_Character) return Boolean;

9/2
          Returns True if Wide_Character'Pos(Item) <=
          Character'Pos(Character'Last).

10/2
     function Is_Character (Item : in Wide_Wide_Character) return Boolean;

11/2
          Returns True if Wide_Wide_Character'Pos(Item) <=
          Character'Pos(Character'Last).

12/2
     function Is_Wide_Character (Item : in Wide_Wide_Character) return Boolean;

13/2
          Returns True if Wide_Wide_Character'Pos(Item) <=
          Wide_Character'Pos(Wide_Character'Last).

14/2
     function Is_String (Item : in Wide_String)      return Boolean;
     function Is_String (Item : in Wide_Wide_String) return Boolean;

15/2
          Returns True if Is_Character(Item(I)) is True for each I in
          Item'Range.

16/2
     function Is_Wide_String (Item : in Wide_Wide_String) return Boolean;

17/2
          Returns True if Is_Wide_Character(Item(I)) is True for each I
          in Item'Range.

18/2
     function To_Character (Item :       in Wide_Character;
                            Substitute : in Character := ' ') return Character;
     function To_Character (Item :       in Wide_Wide_Character;
                            Substitute : in Character := ' ') return Character;

19/2
          Returns the Character corresponding to Item if
          Is_Character(Item), and returns the Substitute Character
          otherwise.

20/2
     function To_Wide_Character (Item : in Character) return Wide_Character;

21/2
          Returns the Wide_Character X such that Character'Pos(Item) =
          Wide_Character'Pos (X).

22/2
     function To_Wide_Character (Item :       in Wide_Wide_Character;
                                 Substitute : in Wide_Character := ' ')
        return Wide_Character;

23/2
          Returns the Wide_Character corresponding to Item if
          Is_Wide_Character(Item), and returns the Substitute
          Wide_Character otherwise.

24/2
     function To_Wide_Wide_Character (Item : in Character)
        return Wide_Wide_Character;

25/2
          Returns the Wide_Wide_Character X such that
          Character'Pos(Item) = Wide_Wide_Character'Pos (X).

26/2
     function To_Wide_Wide_Character (Item : in Wide_Character)
        return Wide_Wide_Character;

27/2
          Returns the Wide_Wide_Character X such that
          Wide_Character'Pos(Item) = Wide_Wide_Character'Pos (X).

28/2
     function To_String (Item :       in Wide_String;
                         Substitute : in Character := ' ') return String;
     function To_String (Item :       in Wide_Wide_String;
                         Substitute : in Character := ' ') return String;

29/2
          Returns the String whose range is 1..Item'Length and each of
          whose elements is given by To_Character of the corresponding
          element in Item.

30/2
     function To_Wide_String (Item : in String) return Wide_String;

31/2
          Returns the Wide_String whose range is 1..Item'Length and each
          of whose elements is given by To_Wide_Character of the
          corresponding element in Item.

32/2
     function To_Wide_String (Item :       in Wide_Wide_String;
                              Substitute : in Wide_Character := ' ')
        return Wide_String;

33/2
          Returns the Wide_String whose range is 1..Item'Length and each
          of whose elements is given by To_Wide_Character of the
          corresponding element in Item with the given Substitute
          Wide_Character.

34/2
     function To_Wide_Wide_String (Item : in String) return Wide_Wide_String;
     function To_Wide_Wide_String (Item : in Wide_String)
        return Wide_Wide_String;

35/2
          Returns the Wide_Wide_String whose range is 1..Item'Length and
          each of whose elements is given by To_Wide_Wide_Character of
          the corresponding element in Item.


File: arm2012.info,  Node: A.3.5,  Next: A.3.6,  Prev: A.3.4,  Up: A.3

A.3.5 The Package Wide_Characters.Handling
------------------------------------------

1/3
The package Wide_Characters.Handling provides operations for classifying
Wide_Characters and case folding for Wide_Characters.

                          _Static Semantics_

2/3
The library package Wide_Characters.Handling has the following
declaration:

3/3
     package Ada.Wide_Characters.Handling is
        pragma Pure(Handling);

4/3
        function Character_Set_Version return String;

5/3
        function Is_Control (Item : Wide_Character) return Boolean;

6/3
        function Is_Letter (Item : Wide_Character) return Boolean;

7/3
        function Is_Lower (Item : Wide_Character) return Boolean;

8/3
        function Is_Upper (Item : Wide_Character) return Boolean;

9/3
        function Is_Digit (Item : Wide_Character) return Boolean;

10/3
        function Is_Decimal_Digit (Item : Wide_Character) return Boolean
           renames Is_Digit;

11/3
        function Is_Hexadecimal_Digit (Item : Wide_Character) return Boolean;

12/3
        function Is_Alphanumeric (Item : Wide_Character) return Boolean;

13/3
        function Is_Special (Item : Wide_Character) return Boolean;

14/3
        function Is_Line_Terminator (Item : Wide_Character) return Boolean;

15/3
        function Is_Mark (Item : Wide_Character) return Boolean;

16/3
        function Is_Other_Format (Item : Wide_Character) return Boolean;

17/3
        function Is_Punctuation_Connector (Item : Wide_Character) return Boolean;

18/3
        function Is_Space (Item : Wide_Character) return Boolean;

19/3
        function Is_Graphic (Item : Wide_Character) return Boolean;

20/3
        function To_Lower (Item : Wide_Character) return Wide_Character;
        function To_Upper (Item : Wide_Character) return Wide_Character;

21/3
        function To_Lower (Item : Wide_String) return Wide_String;
        function To_Upper (Item : Wide_String) return Wide_String;

22/3
     end Ada.Wide_Characters.Handling;

23/3
The subprograms defined in Wide_Characters.Handling are locale
independent.

24/3
     function Character_Set_Version return String;

25/3
          Returns an implementation-defined identifier that identifies
          the version of the character set standard that is used for
          categorizing characters by the implementation.

26/3
     function Is_Control (Item : Wide_Character) return Boolean;

27/3
          Returns True if the Wide_Character designated by Item is
          categorized as other_control; otherwise returns False.

28/3
     function Is_Letter (Item : Wide_Character) return Boolean;

29/3
          Returns True if the Wide_Character designated by Item is
          categorized as letter_uppercase, letter_lowercase,
          letter_titlecase, letter_modifier, letter_other, or
          number_letter; otherwise returns False.

30/3
     function Is_Lower (Item : Wide_Character) return Boolean;

31/3
          Returns True if the Wide_Character designated by Item is
          categorized as letter_lowercase; otherwise returns False.

32/3
     function Is_Upper (Item : Wide_Character) return Boolean;

33/3
          Returns True if the Wide_Character designated by Item is
          categorized as letter_uppercase; otherwise returns False.

34/3
     function Is_Digit (Item : Wide_Character) return Boolean;

35/3
          Returns True if the Wide_Character designated by Item is
          categorized as number_decimal; otherwise returns False.

36/3
     function Is_Hexadecimal_Digit (Item : Wide_Character) return Boolean;

37/3
          Returns True if the Wide_Character designated by Item is
          categorized as number_decimal, or is in the range 'A' ..  'F'
          or 'a' ..  'f'; otherwise returns False.

38/3
     function Is_Alphanumeric (Item : Wide_Character) return Boolean;

39/3
          Returns True if the Wide_Character designated by Item is
          categorized as letter_uppercase, letter_lowercase,
          letter_titlecase, letter_modifier, letter_other,
          number_letter, or number_decimal; otherwise returns False.

40/3
     function Is_Special (Item : Wide_Character) return Boolean;

41/3
          Returns True if the Wide_Character designated by Item is
          categorized as graphic_character, but not categorized as
          letter_uppercase, letter_lowercase, letter_titlecase,
          letter_modifier, letter_other, number_letter, or
          number_decimal; otherwise returns False.

42/3
     function Is_Line_Terminator (Item : Wide_Character) return Boolean;

43/3
          Returns True if the Wide_Character designated by Item is
          categorized as separator_line or separator_paragraph, or if
          Item is a conventional line terminator character (Line_Feed,
          Line_Tabulation, Form_Feed, Carriage_Return, Next_Line);
          otherwise returns False.

44/3
     function Is_Mark (Item : Wide_Character) return Boolean;

45/3
          Returns True if the Wide_Character designated by Item is
          categorized as mark_non_spacing or mark_spacing_combining;
          otherwise returns False.

46/3
     function Is_Other_Format (Item : Wide_Character) return Boolean;

47/3
          Returns True if the Wide_Character designated by Item is
          categorized as other_format; otherwise returns False.

48/3
     function Is_Punctuation_Connector (Item : Wide_Character) return Boolean;

49/3
          Returns True if the Wide_Character designated by Item is
          categorized as punctuation_connector; otherwise returns False.

50/3
     function Is_Space (Item : Wide_Character) return Boolean;

51/3
          Returns True if the Wide_Character designated by Item is
          categorized as separator_space; otherwise returns False.

52/3
     function Is_Graphic (Item : Wide_Character) return Boolean;

53/3
          Returns True if the Wide_Character designated by Item is
          categorized as graphic_character; otherwise returns False.

54/3
     function To_Lower (Item : Wide_Character) return Wide_Character;

55/3
          Returns the Simple Lowercase Mapping as defined by documents
          referenced in the note in Clause 1 of ISO/IEC 10646:2011 of
          the Wide_Character designated by Item.  If the Simple
          Lowercase Mapping does not exist for the Wide_Character
          designated by Item, then the value of Item is returned.

56/3
     function To_Lower (Item : Wide_String) return Wide_String;

57/3
          Returns the result of applying the To_Lower conversion to each
          Wide_Character element of the Wide_String designated by Item.
          The result is the null Wide_String if the value of the formal
          parameter is the null Wide_String.  The lower bound of the
          result Wide_String is 1.

58/3
     function To_Upper (Item : Wide_Character) return Wide_Character;

59/3
          Returns the Simple Uppercase Mapping as defined by documents
          referenced in the note in Clause 1 of ISO/IEC 10646:2011 of
          the Wide_Character designated by Item.  If the Simple
          Uppercase Mapping does not exist for the Wide_Character
          designated by Item, then the value of Item is returned.

60/3
     function To_Upper (Item : Wide_String) return Wide_String;

61/3
          Returns the result of applying the To_Upper conversion to each
          Wide_Character element of the Wide_String designated by Item.
          The result is the null Wide_String if the value of the formal
          parameter is the null Wide_String.  The lower bound of the
          result Wide_String is 1.

                        _Implementation Advice_

62/3
The string returned by Character_Set_Version should include either
"10646:" or "Unicode".

     NOTES

63/3
     8  The results returned by these functions may depend on which
     particular version of the 10646 standard is supported by the
     implementation (see *note 2.1::).

64/3
     9  The case insensitive equality comparison routines provided in
     *note A.4.10::, "*note A.4.10:: String Comparison" are also
     available for wide strings (see *note A.4.7::).


File: arm2012.info,  Node: A.3.6,  Prev: A.3.5,  Up: A.3

A.3.6 The Package Wide_Wide_Characters.Handling
-----------------------------------------------

1/3
The package Wide_Wide_Characters.Handling has the same contents as
Wide_Characters.Handling except that each occurrence of Wide_Character
is replaced by Wide_Wide_Character, and each occurrence of Wide_String
is replaced by Wide_Wide_String.


File: arm2012.info,  Node: A.4,  Next: A.5,  Prev: A.3,  Up: Annex A

A.4 String Handling
===================

1/3
This subclause presents the specifications of the package Strings and
several child packages, which provide facilities for dealing with string
data.  Fixed-length, bounded-length, and unbounded-length strings are
supported, for String, Wide_String, and Wide_Wide_String.  The
string-handling subprograms include searches for pattern strings and for
characters in program-specified sets, translation (via a
character-to-character mapping), and transformation (replacing,
inserting, overwriting, and deleting of substrings).

* Menu:

* A.4.1 ::    The Package Strings
* A.4.2 ::    The Package Strings.Maps
* A.4.3 ::    Fixed-Length String Handling
* A.4.4 ::    Bounded-Length String Handling
* A.4.5 ::    Unbounded-Length String Handling
* A.4.6 ::    String-Handling Sets and Mappings
* A.4.7 ::    Wide_String Handling
* A.4.8 ::    Wide_Wide_String Handling
* A.4.9 ::    String Hashing
* A.4.10 ::   String Comparison
* A.4.11 ::   String Encoding


File: arm2012.info,  Node: A.4.1,  Next: A.4.2,  Up: A.4

A.4.1 The Package Strings
-------------------------

1
The package Strings provides declarations common to the string handling
packages.

                          _Static Semantics_

2
The library package Strings has the following declaration:

3
     package Ada.Strings is
        pragma Pure(Strings);

4/2
        Space      : constant Character      := ' ';
        Wide_Space : constant Wide_Character := ' ';
        Wide_Wide_Space : constant Wide_Wide_Character := ' ';

5
        Length_Error, Pattern_Error, Index_Error, Translation_Error : exception;

6
        type Alignment  is (Left, Right, Center);
        type Truncation is (Left, Right, Error);
        type Membership is (Inside, Outside);
        type Direction  is (Forward, Backward);
        type Trim_End   is (Left, Right, Both);
     end Ada.Strings;


File: arm2012.info,  Node: A.4.2,  Next: A.4.3,  Prev: A.4.1,  Up: A.4

A.4.2 The Package Strings.Maps
------------------------------

1
The package Strings.Maps defines the types, operations, and other
entities needed for character sets and character-to-character mappings.

                          _Static Semantics_

2
The library package Strings.Maps has the following declaration:

3/2
     package Ada.Strings.Maps is
        pragma Pure(Maps);

4/2
        --< Representation for a set of character values:>
        type Character_Set is private;
        pragma Preelaborable_Initialization(Character_Set);

5
        Null_Set : constant Character_Set;

6
        type Character_Range is
          record
             Low  : Character;
             High : Character;
          end record;
        -- <Represents Character range Low..High>

7
        type Character_Ranges is array (Positive range <>) of Character_Range;

8
        function To_Set    (Ranges : in Character_Ranges)return Character_Set;

9
        function To_Set    (Span   : in Character_Range)return Character_Set;

10
        function To_Ranges (Set    : in Character_Set)  return Character_Ranges;

11
        function "="   (Left, Right : in Character_Set) return Boolean;

12
        function "not" (Right : in Character_Set)       return Character_Set;
        function "and" (Left, Right : in Character_Set) return Character_Set;
        function "or"  (Left, Right : in Character_Set) return Character_Set;
        function "xor" (Left, Right : in Character_Set) return Character_Set;
        function "-"   (Left, Right : in Character_Set) return Character_Set;

13
        function Is_In (Element : in Character;
                        Set     : in Character_Set)
           return Boolean;

14
        function Is_Subset (Elements : in Character_Set;
                            Set      : in Character_Set)
           return Boolean;

15
        function "<=" (Left  : in Character_Set;
                       Right : in Character_Set)
           return Boolean renames Is_Subset;

16
        --< Alternative representation for a set of character values:>
        subtype Character_Sequence is String;

17
        function To_Set (Sequence  : in Character_Sequence)return Character_Set;

18
        function To_Set (Singleton : in Character)     return Character_Set;

19
        function To_Sequence (Set  : in Character_Set) return Character_Sequence;

20/2
        --< Representation for a character to character mapping:>
        type Character_Mapping is private;
        pragma Preelaborable_Initialization(Character_Mapping);

21
        function Value (Map     : in Character_Mapping;
                        Element : in Character)
           return Character;

22
        Identity : constant Character_Mapping;

23
        function To_Mapping (From, To : in Character_Sequence)
           return Character_Mapping;

24
        function To_Domain (Map : in Character_Mapping)
           return Character_Sequence;
        function To_Range  (Map : in Character_Mapping)
           return Character_Sequence;

25
        type Character_Mapping_Function is
           access function (From : in Character) return Character;

26
     private
        ... -- <not specified by the language>
     end Ada.Strings.Maps;

27
An object of type Character_Set represents a set of characters.

28
Null_Set represents the set containing no characters.

29
An object Obj of type Character_Range represents the set of characters
in the range Obj.Low ..  Obj.High.

30
An object Obj of type Character_Ranges represents the union of the sets
corresponding to Obj(I) for I in Obj'Range.

31
     function To_Set (Ranges : in Character_Ranges) return Character_Set;

32/3
          If Ranges'Length=0 then Null_Set is returned; otherwise, the
          returned value represents the set corresponding to Ranges.

33
     function To_Set (Span : in Character_Range) return Character_Set;

34
          The returned value represents the set containing each
          character in Span.

35
     function To_Ranges (Set : in Character_Set) return Character_Ranges;

36/3
          If Set = Null_Set, then an empty Character_Ranges array is
          returned; otherwise, the shortest array of contiguous ranges
          of Character values in Set, in increasing order of Low, is
          returned.

37
     function "=" (Left, Right : in Character_Set) return Boolean;

38
          The function "=" returns True if Left and Right represent
          identical sets, and False otherwise.

39
Each of the logical operators "not", "and", "or", and "xor" returns a
Character_Set value that represents the set obtained by applying the
corresponding operation to the set(s) represented by the parameter(s) of
the operator.  "-"(Left, Right) is equivalent to "and"(Left,
"not"(Right)).

40
     function Is_In (Element : in Character;
                     Set     : in Character_Set);
        return Boolean;

41
          Is_In returns True if Element is in Set, and False otherwise.

42
     function Is_Subset (Elements : in Character_Set;
                         Set      : in Character_Set)
        return Boolean;

43
          Is_Subset returns True if Elements is a subset of Set, and
          False otherwise.

44
     subtype Character_Sequence is String;

45
          The Character_Sequence subtype is used to portray a set of
          character values and also to identify the domain and range of
          a character mapping.

46
     function To_Set (Sequence  : in Character_Sequence) return Character_Set;

     function To_Set (Singleton : in Character)          return Character_Set;

47
          Sequence portrays the set of character values that it
          explicitly contains (ignoring duplicates).  Singleton portrays
          the set comprising a single Character.  Each of the To_Set
          functions returns a Character_Set value that represents the
          set portrayed by Sequence or Singleton.

48
     function To_Sequence (Set : in Character_Set) return Character_Sequence;

49
          The function To_Sequence returns a Character_Sequence value
          containing each of the characters in the set represented by
          Set, in ascending order with no duplicates.

50
     type Character_Mapping is private;

51
          An object of type Character_Mapping represents a
          Character-to-Character mapping.

52
     function Value (Map     : in Character_Mapping;
                     Element : in Character)
        return Character;

53
          The function Value returns the Character value to which
          Element maps with respect to the mapping represented by Map.

54
A character C <matches> a pattern character P with respect to a given
Character_Mapping value Map if Value(Map, C) = P. A string S <matches> a
pattern string P with respect to a given Character_Mapping if their
lengths are the same and if each character in S matches its
corresponding character in the pattern string P.

55
String handling subprograms that deal with character mappings have
parameters whose type is Character_Mapping.

56
     Identity : constant Character_Mapping;

57
          Identity maps each Character to itself.

58
     function To_Mapping (From, To : in Character_Sequence)
         return Character_Mapping;

59
          To_Mapping produces a Character_Mapping such that each element
          of From maps to the corresponding element of To, and each
          other character maps to itself.  If From'Length /= To'Length,
          or if some character is repeated in From, then
          Translation_Error is propagated.

60
     function To_Domain (Map : in Character_Mapping) return Character_Sequence;

61
          To_Domain returns the shortest Character_Sequence value D such
          that each character not in D maps to itself, and such that the
          characters in D are in ascending order.  The lower bound of D
          is 1.

62
     function To_Range  (Map : in Character_Mapping) return Character_Sequence;

63/1
          To_Range returns the Character_Sequence value R, such that if
          D = To_Domain(Map), then R has the same bounds as D, and D(I)
          maps to R(I) for each I in D'Range.

64
An object F of type Character_Mapping_Function maps a Character value C
to the Character value F.all(C), which is said to <match> C with respect
to mapping function F. 

     NOTES

65
     10  Character_Mapping and Character_Mapping_Function are used both
     for character equivalence mappings in the search subprograms (such
     as for case insensitivity) and as transformational mappings in the
     Translate subprograms.

66
     11  To_Domain(Identity) and To_Range(Identity) each returns the
     null string.

                              _Examples_

67
To_Mapping("ABCD", "ZZAB") returns a Character_Mapping that maps 'A' and
'B' to 'Z', 'C' to 'A', 'D' to 'B', and each other Character to itself.


File: arm2012.info,  Node: A.4.3,  Next: A.4.4,  Prev: A.4.2,  Up: A.4

A.4.3 Fixed-Length String Handling
----------------------------------

1
The language-defined package Strings.Fixed provides string-handling
subprograms for fixed-length strings; that is, for values of type
Standard.String.  Several of these subprograms are procedures that
modify the contents of a String that is passed as an out or an in out
parameter; each has additional parameters to control the effect when the
logical length of the result differs from the parameter's length.

2
For each function that returns a String, the lower bound of the returned
value is 1.

3
The basic model embodied in the package is that a fixed-length string
comprises significant characters and possibly padding (with space
characters) on either or both ends.  When a shorter string is copied to
a longer string, padding is inserted, and when a longer string is copied
to a shorter one, padding is stripped.  The Move procedure in
Strings.Fixed, which takes a String as an out parameter, allows the
programmer to control these effects.  Similar control is provided by the
string transformation procedures.

                          _Static Semantics_

4
The library package Strings.Fixed has the following declaration:

5
     with Ada.Strings.Maps;
     package Ada.Strings.Fixed is
        pragma Preelaborate(Fixed);

6
     --< "Copy" procedure for strings of possibly different lengths>

7
        procedure Move (Source  : in  String;
                        Target  : out String;
                        Drop    : in  Truncation := Error;
                        Justify : in  Alignment  := Left;
                        Pad     : in  Character  := Space);

8
     --< Search subprograms>

8.1/2
        function Index (Source  : in String;
                        Pattern : in String;
                        From    : in Positive;
                        Going   : in Direction := Forward;
                        Mapping : in Maps.Character_Mapping := Maps.Identity)
           return Natural;

8.2/2
        function Index (Source  : in String;
                        Pattern : in String;
                        From    : in Positive;
                        Going   : in Direction := Forward;
                        Mapping : in Maps.Character_Mapping_Function)
           return Natural;

9
        function Index (Source   : in String;
                        Pattern  : in String;
                        Going    : in Direction := Forward;
                        Mapping  : in Maps.Character_Mapping
                                     := Maps.Identity)
           return Natural;

10
        function Index (Source   : in String;
                        Pattern  : in String;
                        Going    : in Direction := Forward;
                        Mapping  : in Maps.Character_Mapping_Function)
           return Natural;

10.1/2
        function Index (Source  : in String;
                        Set     : in Maps.Character_Set;
                        From    : in Positive;
                        Test    : in Membership := Inside;
                        Going   : in Direction := Forward)
           return Natural;

11
        function Index (Source : in String;
                        Set    : in Maps.Character_Set;
                        Test   : in Membership := Inside;
                        Going  : in Direction  := Forward)
           return Natural;

11.1/2
        function Index_Non_Blank (Source : in String;
                                  From   : in Positive;
                                  Going  : in Direction := Forward)
           return Natural;

12
        function Index_Non_Blank (Source : in String;
                                  Going  : in Direction := Forward)
           return Natural;

13
        function Count (Source   : in String;
                        Pattern  : in String;
                        Mapping  : in Maps.Character_Mapping
                                      := Maps.Identity)
           return Natural;

14
        function Count (Source   : in String;
                        Pattern  : in String;
                        Mapping  : in Maps.Character_Mapping_Function)
           return Natural;

15
        function Count (Source   : in String;
                        Set      : in Maps.Character_Set)
           return Natural;

15.1/3
        procedure Find_Token (Source : in String;
                              Set    : in Maps.Character_Set;
                              From   : in Positive;
                              Test   : in Membership;
                              First  : out Positive;
                              Last   : out Natural);

16
        procedure Find_Token (Source : in String;
                              Set    : in Maps.Character_Set;
                              Test   : in Membership;
                              First  : out Positive;
                              Last   : out Natural);

17
     --< String translation subprograms>

18
        function Translate (Source  : in String;
                            Mapping : in Maps.Character_Mapping)
           return String;

19
        procedure Translate (Source  : in out String;
                             Mapping : in Maps.Character_Mapping);

20
        function Translate (Source  : in String;
                            Mapping : in Maps.Character_Mapping_Function)
           return String;

21
        procedure Translate (Source  : in out String;
                             Mapping : in Maps.Character_Mapping_Function);

22
     --< String transformation subprograms>

23
        function Replace_Slice (Source   : in String;
                                Low      : in Positive;
                                High     : in Natural;
                                By       : in String)
           return String;

24
        procedure Replace_Slice (Source   : in out String;
                                 Low      : in Positive;
                                 High     : in Natural;
                                 By       : in String;
                                 Drop     : in Truncation := Error;
                                 Justify  : in Alignment  := Left;
                                 Pad      : in Character  := Space);

25
        function Insert (Source   : in String;
                         Before   : in Positive;
                         New_Item : in String)
           return String;

26
        procedure Insert (Source   : in out String;
                          Before   : in Positive;
                          New_Item : in String;
                          Drop     : in Truncation := Error);

27
        function Overwrite (Source   : in String;
                            Position : in Positive;
                            New_Item : in String)
           return String;

28
        procedure Overwrite (Source   : in out String;
                             Position : in Positive;
                             New_Item : in String;
                             Drop     : in Truncation := Right);

29
        function Delete (Source  : in String;
                         From    : in Positive;
                         Through : in Natural)
           return String;

30
        procedure Delete (Source  : in out String;
                          From    : in Positive;
                          Through : in Natural;
                          Justify : in Alignment := Left;
                          Pad     : in Character := Space);

31
      --<String selector subprograms>
        function Trim (Source : in String;
                       Side   : in Trim_End)
           return String;

32
        procedure Trim (Source  : in out String;
                        Side    : in Trim_End;
                        Justify : in Alignment := Left;
                        Pad     : in Character := Space);

33
        function Trim (Source : in String;
                       Left   : in Maps.Character_Set;
                       Right  : in Maps.Character_Set)
           return String;

34
        procedure Trim (Source  : in out String;
                        Left    : in Maps.Character_Set;
                        Right   : in Maps.Character_Set;
                        Justify : in Alignment := Strings.Left;
                        Pad     : in Character := Space);

35
        function Head (Source : in String;
                       Count  : in Natural;
                       Pad    : in Character := Space)
           return String;

36
        procedure Head (Source  : in out String;
                        Count   : in Natural;
                        Justify : in Alignment := Left;
                        Pad     : in Character := Space);

37
        function Tail (Source : in String;
                       Count  : in Natural;
                       Pad    : in Character := Space)
           return String;

38
        procedure Tail (Source  : in out String;
                        Count   : in Natural;
                        Justify : in Alignment := Left;
                        Pad     : in Character := Space);

39
     --<String constructor functions>

40
        function "*" (Left  : in Natural;
                      Right : in Character) return String;

41
        function "*" (Left  : in Natural;
                      Right : in String) return String;

42
     end Ada.Strings.Fixed;

43
The effects of the above subprograms are as follows.

44
     procedure Move (Source  : in  String;
                     Target  : out String;
                     Drop    : in  Truncation := Error;
                     Justify : in  Alignment  := Left;
                     Pad     : in  Character  := Space);

45/3
          The Move procedure copies characters from Source to Target.
          If Source has the same length as Target, then the effect is to
          assign Source to Target.  If Source is shorter than Target,
          then:

46
             * If Justify=Left, then Source is copied into the first
               Source'Length characters of Target.

47
             * If Justify=Right, then Source is copied into the last
               Source'Length characters of Target.

48
             * If Justify=Center, then Source is copied into the middle
               Source'Length characters of Target.  In this case, if the
               difference in length between Target and Source is odd,
               then the extra Pad character is on the right.

49
             * Pad is copied to each Target character not otherwise
               assigned.

50
          If Source is longer than Target, then the effect is based on
          Drop.

51
             * If Drop=Left, then the rightmost Target'Length characters
               of Source are copied into Target.

52
             * If Drop=Right, then the leftmost Target'Length characters
               of Source are copied into Target.

53
             * If Drop=Error, then the effect depends on the value of
               the Justify parameter and also on whether any characters
               in Source other than Pad would fail to be copied:

54
                       * If Justify=Left, and if each of the rightmost
                         Source'Length-Target'Length characters in
                         Source is Pad, then the leftmost Target'Length
                         characters of Source are copied to Target.

55
                       * If Justify=Right, and if each of the leftmost
                         Source'Length-Target'Length characters in
                         Source is Pad, then the rightmost Target'Length
                         characters of Source are copied to Target.

56
                       * Otherwise, Length_Error is propagated.

56.1/2
     function Index (Source  : in String;
                     Pattern : in String;
                     From    : in Positive;
                     Going   : in Direction := Forward;
                     Mapping : in Maps.Character_Mapping := Maps.Identity)
        return Natural;

     function Index (Source  : in String;
                     Pattern : in String;
                     From    : in Positive;
                     Going   : in Direction := Forward;
                     Mapping : in Maps.Character_Mapping_Function)
        return Natural;

56.2/3
          Each Index function searches, starting from From, for a slice
          of Source, with length Pattern'Length, that matches Pattern
          with respect to Mapping; the parameter Going indicates the
          direction of the lookup.  If Source is the null string, Index
          returns 0; otherwise, if From is not in Source'Range, then
          Index_Error is propagated.  If Going = Forward, then Index
          returns the smallest index I which is greater than or equal to
          From such that the slice of Source starting at I matches
          Pattern.  If Going = Backward, then Index returns the largest
          index I such that the slice of Source starting at I matches
          Pattern and has an upper bound less than or equal to From.  If
          there is no such slice, then 0 is returned.  If Pattern is the
          null string, then Pattern_Error is propagated.

57
     function Index (Source   : in String;
                     Pattern  : in String;
                     Going    : in Direction := Forward;
                     Mapping  : in Maps.Character_Mapping
                                   := Maps.Identity)
        return Natural;

     function Index (Source   : in String;
                     Pattern  : in String;
                     Going    : in Direction := Forward;
                     Mapping  : in Maps.Character_Mapping_Function)
        return Natural;

58/2
          If Going = Forward, returns

58.1/2
           Index (Source, Pattern, Source'First, Forward, Mapping);

58.2/3
          otherwise, returns

58.3/2
           Index (Source, Pattern, Source'Last, Backward, Mapping);

58.4/2
     function Index (Source  : in String;
                     Set     : in Maps.Character_Set;
                     From    : in Positive;
                     Test    : in Membership := Inside;
                     Going   : in Direction := Forward)
        return Natural;

58.5/3
          Index searches for the first or last occurrence of any of a
          set of characters (when Test=Inside), or any of the complement
          of a set of characters (when Test=Outside).  If Source is the
          null string, Index returns 0; otherwise, if From is not in
          Source'Range, then Index_Error is propagated.  Otherwise, it
          returns the smallest index I >= From (if Going=Forward) or the
          largest index I <= From (if Going=Backward) such that
          Source(I) satisfies the Test condition with respect to Set; it
          returns 0 if there is no such Character in Source.

59
     function Index (Source : in String;
                     Set    : in Maps.Character_Set;
                     Test   : in Membership := Inside;
                     Going  : in Direction  := Forward)
        return Natural;

60/2
          If Going = Forward, returns

60.1/2
           Index (Source, Set, Source'First, Test, Forward);

60.2/3
          otherwise, returns

60.3/2
           Index (Source, Set, Source'Last, Test, Backward);

60.4/2
     function Index_Non_Blank (Source : in String;
                               From   : in Positive;
                               Going  : in Direction := Forward)
        return Natural;

60.5/2
          Returns Index (Source, Maps.To_Set(Space), From, Outside,
          Going);

61
     function Index_Non_Blank (Source : in String;
                               Going  : in Direction := Forward)
        return Natural;

62
          Returns Index(Source, Maps.To_Set(Space), Outside, Going)

63
     function Count (Source   : in String;
                     Pattern  : in String;
                     Mapping  : in Maps.Character_Mapping
                                  := Maps.Identity)
        return Natural;

     function Count (Source   : in String;
                     Pattern  : in String;
                     Mapping  : in Maps.Character_Mapping_Function)
        return Natural;

64
          Returns the maximum number of nonoverlapping slices of Source
          that match Pattern with respect to Mapping.  If Pattern is the
          null string then Pattern_Error is propagated.

65
     function Count (Source   : in String;
                     Set      : in Maps.Character_Set)
        return Natural;

66
          Returns the number of occurrences in Source of characters that
          are in Set.

66.1/3
     procedure Find_Token (Source : in String;
                           Set    : in Maps.Character_Set;
                           From   : in Positive;
                           Test   : in Membership;
                           First  : out Positive;
                           Last   : out Natural);

66.2/3
          If Source is not the null string and From is not in
          Source'Range, then Index_Error is raised.  Otherwise, First is
          set to the index of the first character in Source(From ..
          Source'Last) that satisfies the Test condition.  Last is set
          to the largest index such that all characters in Source(First
          ..  Last) satisfy the Test condition.  If no characters in
          Source(From ..  Source'Last) satisfy the Test condition, First
          is set to From, and Last is set to 0.

67
     procedure Find_Token (Source : in String;
                           Set    : in Maps.Character_Set;
                           Test   : in Membership;
                           First  : out Positive;
                           Last   : out Natural);

68/3
          Equivalent to Find_Token (Source, Set, Source'First, Test,
          First, Last).

69
     function Translate (Source  : in String;
                         Mapping : in Maps.Character_Mapping)
        return String;

     function Translate (Source  : in String;
                         Mapping : in Maps.Character_Mapping_Function)
        return String;

70
          Returns the string S whose length is Source'Length and such
          that S(I) is the character to which Mapping maps the
          corresponding element of Source, for I in 1..Source'Length.

71
     procedure Translate (Source  : in out String;
                          Mapping : in Maps.Character_Mapping);

     procedure Translate (Source  : in out String;
                          Mapping : in Maps.Character_Mapping_Function);

72
          Equivalent to Source := Translate(Source, Mapping).

73
     function Replace_Slice (Source   : in String;
                             Low      : in Positive;
                             High     : in Natural;
                             By       : in String)
        return String;

74/1
          If Low > Source'Last+1, or High < Source'First-1, then
          Index_Error is propagated.  Otherwise:

74.1/1
             * If High >= Low, then the returned string comprises
               Source(Source'First..Low-1) & By &
               Source(High+1..Source'Last), but with lower bound 1.

74.2/1
             * If High < Low, then the returned string is Insert(Source,
               Before=>Low, New_Item=>By).

75
     procedure Replace_Slice (Source   : in out String;
                              Low      : in Positive;
                              High     : in Natural;
                              By       : in String;
                              Drop     : in Truncation := Error;
                              Justify  : in Alignment  := Left;
                              Pad      : in Character  := Space);

76
          Equivalent to Move(Replace_Slice(Source, Low, High, By),
          Source, Drop, Justify, Pad).

77
     function Insert (Source   : in String;
                      Before   : in Positive;
                      New_Item : in String)
        return String;

78/3
          Propagates Index_Error if Before is not in Source'First ..
          Source'Last+1; otherwise, returns
          Source(Source'First..Before-1) & New_Item &
          Source(Before..Source'Last), but with lower bound 1.

79
     procedure Insert (Source   : in out String;
                       Before   : in Positive;
                       New_Item : in String;
                       Drop     : in Truncation := Error);

80
          Equivalent to Move(Insert(Source, Before, New_Item), Source,
          Drop).

81
     function Overwrite (Source   : in String;
                         Position : in Positive;
                         New_Item : in String)
        return String;

82/3
          Propagates Index_Error if Position is not in Source'First ..
          Source'Last+1; otherwise, returns the string obtained from
          Source by consecutively replacing characters starting at
          Position with corresponding characters from New_Item.  If the
          end of Source is reached before the characters in New_Item are
          exhausted, the remaining characters from New_Item are appended
          to the string.

83
     procedure Overwrite (Source   : in out String;
                          Position : in Positive;
                          New_Item : in String;
                          Drop     : in Truncation := Right);

84
          Equivalent to Move(Overwrite(Source, Position, New_Item),
          Source, Drop).

85
     function Delete (Source  : in String;
                      From    : in Positive;
                      Through : in Natural)
        return String;

86/3
          If From <= Through, the returned string is
          Replace_Slice(Source, From, Through, ""); otherwise, it is
          Source with lower bound 1.

87
     procedure Delete (Source  : in out String;
                       From    : in Positive;
                       Through : in Natural;
                       Justify : in Alignment := Left;
                       Pad     : in Character := Space);

88
          Equivalent to Move(Delete(Source, From, Through), Source,
          Justify => Justify, Pad => Pad).

89
     function Trim (Source : in String;
                    Side   : in Trim_End)
       return String;

90
          Returns the string obtained by removing from Source all
          leading Space characters (if Side = Left), all trailing Space
          characters (if Side = Right), or all leading and trailing
          Space characters (if Side = Both).

91
     procedure Trim (Source  : in out String;
                     Side    : in Trim_End;
                     Justify : in Alignment := Left;
                     Pad     : in Character := Space);

92
          Equivalent to Move(Trim(Source, Side), Source,
          Justify=>Justify, Pad=>Pad).

93
     function Trim (Source : in String;
                    Left   : in Maps.Character_Set;
                    Right  : in Maps.Character_Set)
        return String;

94
          Returns the string obtained by removing from Source all
          leading characters in Left and all trailing characters in
          Right.

95
     procedure Trim (Source  : in out String;
                     Left    : in Maps.Character_Set;
                     Right   : in Maps.Character_Set;
                     Justify : in Alignment := Strings.Left;
                     Pad     : in Character := Space);

96
          Equivalent to Move(Trim(Source, Left, Right), Source, Justify
          => Justify, Pad=>Pad).

97
     function Head (Source : in String;
                    Count  : in Natural;
                    Pad    : in Character := Space)
        return String;

98/3
          Returns a string of length Count.  If Count <= Source'Length,
          the string comprises the first Count characters of Source.
          Otherwise, its contents are Source concatenated with
          Count-Source'Length Pad characters.

99
     procedure Head (Source  : in out String;
                     Count   : in Natural;
                     Justify : in Alignment := Left;
                     Pad     : in Character := Space);

100
          Equivalent to Move(Head(Source, Count, Pad), Source,
          Drop=>Error, Justify=>Justify, Pad=>Pad).

101
     function Tail (Source : in String;
                    Count  : in Natural;
                    Pad    : in Character := Space)
        return String;

102/3
          Returns a string of length Count.  If Count <= Source'Length,
          the string comprises the last Count characters of Source.
          Otherwise, its contents are Count-Source'Length Pad characters
          concatenated with Source.

103
     procedure Tail (Source  : in out String;
                     Count   : in Natural;
                     Justify : in Alignment := Left;
                     Pad     : in Character := Space);

104
          Equivalent to Move(Tail(Source, Count, Pad), Source,
          Drop=>Error, Justify=>Justify, Pad=>Pad).

105
     function "*" (Left  : in Natural;
                   Right : in Character) return String;

     function "*" (Left  : in Natural;
                   Right : in String) return String;

106/1
          These functions replicate a character or string a specified
          number of times.  The first function returns a string whose
          length is Left and each of whose elements is Right.  The
          second function returns a string whose length is
          Left*Right'Length and whose value is the null string if Left =
          0 and otherwise is (Left-1)*Right & Right with lower bound 1.

     NOTES

107/3
     12  In the Index and Count functions taking Pattern and Mapping
     parameters, the actual String parameter passed to Pattern should
     comprise characters occurring as target characters of the mapping.
     Otherwise, the pattern will not match.

108
     13  In the Insert subprograms, inserting at the end of a string is
     obtained by passing Source'Last+1 as the Before parameter.

109
     14  If a null Character_Mapping_Function is passed to any of the
     string handling subprograms, Constraint_Error is propagated.


File: arm2012.info,  Node: A.4.4,  Next: A.4.5,  Prev: A.4.3,  Up: A.4

A.4.4 Bounded-Length String Handling
------------------------------------

1
The language-defined package Strings.Bounded provides a generic package
each of whose instances yields a private type Bounded_String and a set
of operations.  An object of a particular Bounded_String type represents
a String whose low bound is 1 and whose length can vary conceptually
between 0 and a maximum size established at the generic instantiation.
The subprograms for fixed-length string handling are either overloaded
directly for Bounded_String, or are modified as needed to reflect the
variability in length.  Additionally, since the Bounded_String type is
private, appropriate constructor and selector operations are provided.

                          _Static Semantics_

2
The library package Strings.Bounded has the following declaration:

3
     with Ada.Strings.Maps;
     package Ada.Strings.Bounded is
        pragma Preelaborate(Bounded);

4
        generic
           Max   : Positive;    --< Maximum length of a Bounded_String>
        package Generic_Bounded_Length is

5
           Max_Length : constant Positive := Max;

6
           type Bounded_String is private;

7
           Null_Bounded_String : constant Bounded_String;

8
           subtype Length_Range is Natural range 0 .. Max_Length;

9
           function Length (Source : in Bounded_String) return Length_Range;

10
        --< Conversion, Concatenation, and Selection functions>

11
           function To_Bounded_String (Source : in String;
                                       Drop   : in Truncation := Error)
              return Bounded_String;

12
           function To_String (Source : in Bounded_String) return String;

12.1/2
           procedure Set_Bounded_String
              (Target :    out Bounded_String;
               Source : in     String;
               Drop   : in     Truncation := Error);

13
           function Append (Left, Right : in Bounded_String;
                            Drop        : in Truncation  := Error)
              return Bounded_String;

14
           function Append (Left  : in Bounded_String;
                            Right : in String;
                            Drop  : in Truncation := Error)
              return Bounded_String;

15
           function Append (Left  : in String;
                            Right : in Bounded_String;
                            Drop  : in Truncation := Error)
              return Bounded_String;

16
           function Append (Left  : in Bounded_String;
                            Right : in Character;
                            Drop  : in Truncation := Error)
              return Bounded_String;

17
           function Append (Left  : in Character;
                            Right : in Bounded_String;
                            Drop  : in Truncation := Error)
              return Bounded_String;

18
           procedure Append (Source   : in out Bounded_String;
                             New_Item : in Bounded_String;
                             Drop     : in Truncation  := Error);

19
           procedure Append (Source   : in out Bounded_String;
                             New_Item : in String;
                             Drop     : in Truncation  := Error);

20
           procedure Append (Source   : in out Bounded_String;
                             New_Item : in Character;
                             Drop     : in Truncation  := Error);

21
           function "&" (Left, Right : in Bounded_String)
              return Bounded_String;

22
           function "&" (Left : in Bounded_String; Right : in String)
              return Bounded_String;

23
           function "&" (Left : in String; Right : in Bounded_String)
              return Bounded_String;

24
           function "&" (Left : in Bounded_String; Right : in Character)
              return Bounded_String;

25
           function "&" (Left : in Character; Right : in Bounded_String)
              return Bounded_String;

26
           function Element (Source : in Bounded_String;
                             Index  : in Positive)
              return Character;

27
           procedure Replace_Element (Source : in out Bounded_String;
                                      Index  : in Positive;
                                      By     : in Character);

28
           function Slice (Source : in Bounded_String;
                           Low    : in Positive;
                           High   : in Natural)
              return String;

28.1/2
           function Bounded_Slice
              (Source : in Bounded_String;
               Low    : in Positive;
               High   : in Natural)
                  return Bounded_String;

28.2/2
           procedure Bounded_Slice
              (Source : in     Bounded_String;
               Target :    out Bounded_String;
               Low    : in     Positive;
               High   : in     Natural);

29
           function "="  (Left, Right : in Bounded_String) return Boolean;
           function "="  (Left : in Bounded_String; Right : in String)
             return Boolean;

30
           function "="  (Left : in String; Right : in Bounded_String)
             return Boolean;

31
           function "<"  (Left, Right : in Bounded_String) return Boolean;

32
           function "<"  (Left : in Bounded_String; Right : in String)
             return Boolean;

33
           function "<"  (Left : in String; Right : in Bounded_String)
             return Boolean;

34
           function "<=" (Left, Right : in Bounded_String) return Boolean;

35
           function "<="  (Left : in Bounded_String; Right : in String)
             return Boolean;

36
           function "<="  (Left : in String; Right : in Bounded_String)
             return Boolean;

37
           function ">"  (Left, Right : in Bounded_String) return Boolean;

38
           function ">"  (Left : in Bounded_String; Right : in String)
             return Boolean;

39
           function ">"  (Left : in String; Right : in Bounded_String)
             return Boolean;

40
           function ">=" (Left, Right : in Bounded_String) return Boolean;

41
           function ">="  (Left : in Bounded_String; Right : in String)
             return Boolean;

42
           function ">="  (Left : in String; Right : in Bounded_String)
             return Boolean;

43/2
        --< Search subprograms>

43.1/2
           function Index (Source  : in Bounded_String;
                           Pattern : in String;
                           From    : in Positive;
                           Going   : in Direction := Forward;
                           Mapping : in Maps.Character_Mapping := Maps.Identity)
              return Natural;

43.2/2
           function Index (Source  : in Bounded_String;
                           Pattern : in String;
                           From    : in Positive;
                           Going   : in Direction := Forward;
                           Mapping : in Maps.Character_Mapping_Function)
              return Natural;

44
           function Index (Source   : in Bounded_String;
                           Pattern  : in String;
                           Going    : in Direction := Forward;
                           Mapping  : in Maps.Character_Mapping
                                      := Maps.Identity)
              return Natural;

45
           function Index (Source   : in Bounded_String;
                           Pattern  : in String;
                           Going    : in Direction := Forward;
                           Mapping  : in Maps.Character_Mapping_Function)
              return Natural;

45.1/2
           function Index (Source  : in Bounded_String;
                           Set     : in Maps.Character_Set;
                           From    : in Positive;
                           Test    : in Membership := Inside;
                           Going   : in Direction := Forward)
              return Natural;

46
           function Index (Source : in Bounded_String;
                           Set    : in Maps.Character_Set;
                           Test   : in Membership := Inside;
                           Going  : in Direction  := Forward)
              return Natural;

46.1/2
           function Index_Non_Blank (Source : in Bounded_String;
                                     From   : in Positive;
                                     Going  : in Direction := Forward)
              return Natural;

47
           function Index_Non_Blank (Source : in Bounded_String;
                                     Going  : in Direction := Forward)
              return Natural;

48
           function Count (Source   : in Bounded_String;
                           Pattern  : in String;
                           Mapping  : in Maps.Character_Mapping
                                        := Maps.Identity)
              return Natural;

49
           function Count (Source   : in Bounded_String;
                           Pattern  : in String;
                           Mapping  : in Maps.Character_Mapping_Function)
              return Natural;

50
           function Count (Source   : in Bounded_String;
                           Set      : in Maps.Character_Set)
              return Natural;

50.1/3
           procedure Find_Token (Source : in Bounded_String;
                                 Set    : in Maps.Character_Set;
                                 From   : in Positive;
                                 Test   : in Membership;
                                 First  : out Positive;
                                 Last   : out Natural);

51
           procedure Find_Token (Source : in Bounded_String;
                                 Set    : in Maps.Character_Set;
                                 Test   : in Membership;
                                 First  : out Positive;
                                 Last   : out Natural);

52
        --< String translation subprograms>

53
           function Translate (Source  : in Bounded_String;
                               Mapping : in Maps.Character_Mapping)
              return Bounded_String;

54
           procedure Translate (Source  : in out Bounded_String;
                                Mapping : in Maps.Character_Mapping);

55
           function Translate (Source  : in Bounded_String;
                               Mapping : in Maps.Character_Mapping_Function)
              return Bounded_String;

56
           procedure Translate (Source  : in out Bounded_String;
                                Mapping : in Maps.Character_Mapping_Function);

57
        --< String transformation subprograms>

58
           function Replace_Slice (Source   : in Bounded_String;
                                   Low      : in Positive;
                                   High     : in Natural;
                                   By       : in String;
                                   Drop     : in Truncation := Error)
              return Bounded_String;

59
           procedure Replace_Slice (Source   : in out Bounded_String;
                                    Low      : in Positive;
                                    High     : in Natural;
                                    By       : in String;
                                    Drop     : in Truncation := Error);

60
           function Insert (Source   : in Bounded_String;
                            Before   : in Positive;
                            New_Item : in String;
                            Drop     : in Truncation := Error)
              return Bounded_String;

61
           procedure Insert (Source   : in out Bounded_String;
                             Before   : in Positive;
                             New_Item : in String;
                             Drop     : in Truncation := Error);

62
           function Overwrite (Source    : in Bounded_String;
                               Position  : in Positive;
                               New_Item  : in String;
                               Drop      : in Truncation := Error)
              return Bounded_String;

63
           procedure Overwrite (Source    : in out Bounded_String;
                                Position  : in Positive;
                                New_Item  : in String;
                                Drop      : in Truncation := Error);

64
           function Delete (Source  : in Bounded_String;
                            From    : in Positive;
                            Through : in Natural)
              return Bounded_String;

65
           procedure Delete (Source  : in out Bounded_String;
                             From    : in Positive;
                             Through : in Natural);

66
        --<String selector subprograms>

67
           function Trim (Source : in Bounded_String;
                          Side   : in Trim_End)
              return Bounded_String;
           procedure Trim (Source : in out Bounded_String;
                           Side   : in Trim_End);

68
           function Trim (Source : in Bounded_String;
                          Left   : in Maps.Character_Set;
                          Right  : in Maps.Character_Set)
              return Bounded_String;

69
           procedure Trim (Source : in out Bounded_String;
                           Left   : in Maps.Character_Set;
                           Right  : in Maps.Character_Set);

70
           function Head (Source : in Bounded_String;
                          Count  : in Natural;
                          Pad    : in Character  := Space;
                          Drop   : in Truncation := Error)
              return Bounded_String;

71
           procedure Head (Source : in out Bounded_String;
                           Count  : in Natural;
                           Pad    : in Character  := Space;
                           Drop   : in Truncation := Error);

72
           function Tail (Source : in Bounded_String;
                          Count  : in Natural;
                          Pad    : in Character  := Space;
                          Drop   : in Truncation := Error)
              return Bounded_String;

73
           procedure Tail (Source : in out Bounded_String;
                           Count  : in Natural;
                           Pad    : in Character  := Space;
                           Drop   : in Truncation := Error);

74
        --<String constructor subprograms>

75
           function "*" (Left  : in Natural;
                         Right : in Character)
              return Bounded_String;

76
           function "*" (Left  : in Natural;
                         Right : in String)
              return Bounded_String;

77
           function "*" (Left  : in Natural;
                         Right : in Bounded_String)
              return Bounded_String;

78
           function Replicate (Count : in Natural;
                               Item  : in Character;
                               Drop  : in Truncation := Error)
              return Bounded_String;

79
           function Replicate (Count : in Natural;
                               Item  : in String;
                               Drop  : in Truncation := Error)
              return Bounded_String;

80
           function Replicate (Count : in Natural;
                               Item  : in Bounded_String;
                               Drop  : in Truncation := Error)
              return Bounded_String;

81
        private
            ... -- <not specified by the language>
        end Generic_Bounded_Length;

82
     end Ada.Strings.Bounded;

83
Null_Bounded_String represents the null string.  If an object of type
Bounded_String is not otherwise initialized, it will be initialized to
the same value as Null_Bounded_String.

84
     function Length (Source : in Bounded_String) return Length_Range;

85
          The Length function returns the length of the string
          represented by Source.

86
     function To_Bounded_String (Source : in String;
                                 Drop   : in Truncation := Error)
        return Bounded_String;

87/3
          If Source'Length <= Max_Length, then this function returns a
          Bounded_String that represents Source.  Otherwise, the effect
          depends on the value of Drop:

88
             * If Drop=Left, then the result is a Bounded_String that
               represents the string comprising the rightmost Max_Length
               characters of Source.

89
             * If Drop=Right, then the result is a Bounded_String that
               represents the string comprising the leftmost Max_Length
               characters of Source.

90
             * If Drop=Error, then Strings.Length_Error is propagated.

91
     function To_String (Source : in Bounded_String) return String;

92
          To_String returns the String value with lower bound 1
          represented by Source.  If B is a Bounded_String, then B =
          To_Bounded_String(To_String(B)).

92.1/2
     procedure Set_Bounded_String
        (Target :    out Bounded_String;
         Source : in     String;
         Drop   : in     Truncation := Error);

92.2/2
          Equivalent to Target := To_Bounded_String (Source, Drop);

93
Each of the Append functions returns a Bounded_String obtained by
concatenating the string or character given or represented by one of the
parameters, with the string or character given or represented by the
other parameter, and applying To_Bounded_String to the concatenation
result string, with Drop as provided to the Append function.

94
Each of the procedures Append(Source, New_Item, Drop) has the same
effect as the corresponding assignment Source := Append(Source,
New_Item, Drop).

95
Each of the "&" functions has the same effect as the corresponding
Append function, with Error as the Drop parameter.

96
     function Element (Source : in Bounded_String;
                       Index  : in Positive)
        return Character;

97
          Returns the character at position Index in the string
          represented by Source; propagates Index_Error if Index >
          Length(Source).

98
     procedure Replace_Element (Source : in out Bounded_String;
                                Index  : in Positive;
                                By     : in Character);

99
          Updates Source such that the character at position Index in
          the string represented by Source is By; propagates Index_Error
          if Index > Length(Source).

100
     function Slice (Source : in Bounded_String;
                     Low    : in Positive;
                     High   : in Natural)
        return String;

101/1
          Returns the slice at positions Low through High in the string
          represented by Source; propagates Index_Error if Low >
          Length(Source)+1 or High > Length(Source).  The bounds of the
          returned string are Low and High..

101.1/2
     function Bounded_Slice
        (Source : in Bounded_String;
         Low    : in Positive;
         High   : in Natural)
            return Bounded_String;

101.2/2
          Returns the slice at positions Low through High in the string
          represented by Source as a bounded string; propagates
          Index_Error if Low > Length(Source)+1 or High >
          Length(Source).

101.3/2
     procedure Bounded_Slice
        (Source : in     Bounded_String;
         Target :    out Bounded_String;
         Low    : in     Positive;
         High   : in     Natural);

101.4/2
          Equivalent to Target := Bounded_Slice (Source, Low, High);

102
Each of the functions "=", "<", ">", "<=", and ">=" returns the same
result as the corresponding String operation applied to the String
values given or represented by the two parameters.

103
Each of the search subprograms (Index, Index_Non_Blank, Count,
Find_Token) has the same effect as the corresponding subprogram in
Strings.Fixed applied to the string represented by the Bounded_String
parameter.

104
Each of the Translate subprograms, when applied to a Bounded_String, has
an analogous effect to the corresponding subprogram in Strings.Fixed.
For the Translate function, the translation is applied to the string
represented by the Bounded_String parameter, and the result is converted
(via To_Bounded_String) to a Bounded_String.  For the Translate
procedure, the string represented by the Bounded_String parameter after
the translation is given by the Translate function for fixed-length
strings applied to the string represented by the original value of the
parameter.

105/1
Each of the transformation subprograms (Replace_Slice, Insert,
Overwrite, Delete), selector subprograms (Trim, Head, Tail), and
constructor functions ("*") has an effect based on its corresponding
subprogram in Strings.Fixed, and Replicate is based on Fixed."*".  In
the case of a function, the corresponding fixed-length string subprogram
is applied to the string represented by the Bounded_String parameter.
To_Bounded_String is applied the result string, with Drop (or Error in
the case of Generic_Bounded_Length."*") determining the effect when the
string length exceeds Max_Length.  In the case of a procedure, the
corresponding function in Strings.Bounded.Generic_Bounded_Length is
applied, with the result assigned into the Source parameter.

                        _Implementation Advice_

106
Bounded string objects should not be implemented by implicit pointers
and dynamic allocation.


File: arm2012.info,  Node: A.4.5,  Next: A.4.6,  Prev: A.4.4,  Up: A.4

A.4.5 Unbounded-Length String Handling
--------------------------------------

1
The language-defined package Strings.Unbounded provides a private type
Unbounded_String and a set of operations.  An object of type
Unbounded_String represents a String whose low bound is 1 and whose
length can vary conceptually between 0 and Natural'Last.  The
subprograms for fixed-length string handling are either overloaded
directly for Unbounded_String, or are modified as needed to reflect the
flexibility in length.  Since the Unbounded_String type is private,
relevant constructor and selector operations are provided.

                          _Static Semantics_

2
The library package Strings.Unbounded has the following declaration:

3
     with Ada.Strings.Maps;
     package Ada.Strings.Unbounded is
        pragma Preelaborate(Unbounded);

4/2
        type Unbounded_String is private;
        pragma Preelaborable_Initialization(Unbounded_String);

5
        Null_Unbounded_String : constant Unbounded_String;

6
        function Length (Source : in Unbounded_String) return Natural;

7
        type String_Access is access all String;
        procedure Free (X : in out String_Access);

8
     --< Conversion, Concatenation, and Selection functions>

9
        function To_Unbounded_String (Source : in String)
           return Unbounded_String;

10
        function To_Unbounded_String (Length : in Natural)
           return Unbounded_String;

11
        function To_String (Source : in Unbounded_String) return String;

11.1/2
        procedure Set_Unbounded_String
          (Target :    out Unbounded_String;
           Source : in     String);

12
        procedure Append (Source   : in out Unbounded_String;
                          New_Item : in Unbounded_String);

13
        procedure Append (Source   : in out Unbounded_String;
                          New_Item : in String);

14
        procedure Append (Source   : in out Unbounded_String;
                          New_Item : in Character);

15
        function "&" (Left, Right : in Unbounded_String)
           return Unbounded_String;

16
        function "&" (Left : in Unbounded_String; Right : in String)
           return Unbounded_String;

17
        function "&" (Left : in String; Right : in Unbounded_String)
           return Unbounded_String;

18
        function "&" (Left : in Unbounded_String; Right : in Character)
           return Unbounded_String;

19
        function "&" (Left : in Character; Right : in Unbounded_String)
           return Unbounded_String;

20
        function Element (Source : in Unbounded_String;
                          Index  : in Positive)
           return Character;

21
        procedure Replace_Element (Source : in out Unbounded_String;
                                   Index  : in Positive;
                                   By     : in Character);

22
        function Slice (Source : in Unbounded_String;
                        Low    : in Positive;
                        High   : in Natural)
           return String;

22.1/2
        function Unbounded_Slice
           (Source : in Unbounded_String;
            Low    : in Positive;
            High   : in Natural)
               return Unbounded_String;

22.2/2
        procedure Unbounded_Slice
           (Source : in     Unbounded_String;
            Target :    out Unbounded_String;
            Low    : in     Positive;
            High   : in     Natural);

23
        function "="  (Left, Right : in Unbounded_String) return Boolean;

24
        function "="  (Left : in Unbounded_String; Right : in String)
          return Boolean;

25
        function "="  (Left : in String; Right : in Unbounded_String)
          return Boolean;

26
        function "<"  (Left, Right : in Unbounded_String) return Boolean;

27
        function "<"  (Left : in Unbounded_String; Right : in String)
          return Boolean;

28
        function "<"  (Left : in String; Right : in Unbounded_String)
          return Boolean;

29
        function "<=" (Left, Right : in Unbounded_String) return Boolean;

30
        function "<="  (Left : in Unbounded_String; Right : in String)
          return Boolean;

31
        function "<="  (Left : in String; Right : in Unbounded_String)
          return Boolean;

32
        function ">"  (Left, Right : in Unbounded_String) return Boolean;

33
        function ">"  (Left : in Unbounded_String; Right : in String)
          return Boolean;

34
        function ">"  (Left : in String; Right : in Unbounded_String)
          return Boolean;

35
        function ">=" (Left, Right : in Unbounded_String) return Boolean;

36
        function ">="  (Left : in Unbounded_String; Right : in String)
          return Boolean;

37
        function ">="  (Left : in String; Right : in Unbounded_String)
          return Boolean;

38
     --< Search subprograms>

38.1/2
        function Index (Source  : in Unbounded_String;
                        Pattern : in String;
                        From    : in Positive;
                        Going   : in Direction := Forward;
                        Mapping : in Maps.Character_Mapping := Maps.Identity)
           return Natural;

38.2/2
        function Index (Source  : in Unbounded_String;
                        Pattern : in String;
                        From    : in Positive;
                        Going   : in Direction := Forward;
                        Mapping : in Maps.Character_Mapping_Function)
           return Natural;

39
        function Index (Source   : in Unbounded_String;
                        Pattern  : in String;
                        Going    : in Direction := Forward;
                        Mapping  : in Maps.Character_Mapping
                                     := Maps.Identity)
           return Natural;

40
        function Index (Source   : in Unbounded_String;
                        Pattern  : in String;
                        Going    : in Direction := Forward;
                        Mapping  : in Maps.Character_Mapping_Function)
           return Natural;

40.1/2
        function Index (Source  : in Unbounded_String;
                        Set     : in Maps.Character_Set;
                        From    : in Positive;
                        Test    : in Membership := Inside;
                        Going    : in Direction := Forward)
           return Natural;

41
        function Index (Source : in Unbounded_String;
                        Set    : in Maps.Character_Set;
                        Test   : in Membership := Inside;
                        Going  : in Direction  := Forward) return Natural;

41.1/2
        function Index_Non_Blank (Source : in Unbounded_String;
                                  From   : in Positive;
                                  Going  : in Direction := Forward)
           return Natural;

42
        function Index_Non_Blank (Source : in Unbounded_String;
                                  Going  : in Direction := Forward)
           return Natural;

43
        function Count (Source   : in Unbounded_String;
                        Pattern  : in String;
                        Mapping  : in Maps.Character_Mapping
                                     := Maps.Identity)
           return Natural;

44
        function Count (Source   : in Unbounded_String;
                        Pattern  : in String;
                        Mapping  : in Maps.Character_Mapping_Function)
           return Natural;

45
        function Count (Source   : in Unbounded_String;
                        Set      : in Maps.Character_Set)
           return Natural;

45.1/3
        procedure Find_Token (Source : in Unbounded_String;
                              Set    : in Maps.Character_Set;
                              From   : in Positive;
                              Test   : in Membership;
                              First  : out Positive;
                              Last   : out Natural);

46
        procedure Find_Token (Source : in Unbounded_String;
                              Set    : in Maps.Character_Set;
                              Test   : in Membership;
                              First  : out Positive;
                              Last   : out Natural);

47
     --< String translation subprograms>

48
        function Translate (Source  : in Unbounded_String;
                            Mapping : in Maps.Character_Mapping)
           return Unbounded_String;

49
        procedure Translate (Source  : in out Unbounded_String;
                             Mapping : in Maps.Character_Mapping);

50
        function Translate (Source  : in Unbounded_String;
                            Mapping : in Maps.Character_Mapping_Function)
           return Unbounded_String;

51
        procedure Translate (Source  : in out Unbounded_String;
                             Mapping : in Maps.Character_Mapping_Function);

52
     --< String transformation subprograms>

53
        function Replace_Slice (Source   : in Unbounded_String;
                                Low      : in Positive;
                                High     : in Natural;
                                By       : in String)
           return Unbounded_String;

54
        procedure Replace_Slice (Source   : in out Unbounded_String;
                                 Low      : in Positive;
                                 High     : in Natural;
                                 By       : in String);

55
        function Insert (Source   : in Unbounded_String;
                         Before   : in Positive;
                         New_Item : in String)
           return Unbounded_String;

56
        procedure Insert (Source   : in out Unbounded_String;
                          Before   : in Positive;
                          New_Item : in String);

57
        function Overwrite (Source    : in Unbounded_String;
                            Position  : in Positive;
                            New_Item  : in String)
           return Unbounded_String;

58
        procedure Overwrite (Source    : in out Unbounded_String;
                             Position  : in Positive;
                             New_Item  : in String);

59
        function Delete (Source  : in Unbounded_String;
                         From    : in Positive;
                         Through : in Natural)
           return Unbounded_String;

60
        procedure Delete (Source  : in out Unbounded_String;
                          From    : in Positive;
                          Through : in Natural);

61
        function Trim (Source : in Unbounded_String;
                       Side   : in Trim_End)
           return Unbounded_String;

62
        procedure Trim (Source : in out Unbounded_String;
                        Side   : in Trim_End);

63
        function Trim (Source : in Unbounded_String;
                       Left   : in Maps.Character_Set;
                       Right  : in Maps.Character_Set)
           return Unbounded_String;

64
        procedure Trim (Source : in out Unbounded_String;
                        Left   : in Maps.Character_Set;
                        Right  : in Maps.Character_Set);

65
        function Head (Source : in Unbounded_String;
                       Count  : in Natural;
                       Pad    : in Character := Space)
           return Unbounded_String;

66
        procedure Head (Source : in out Unbounded_String;
                        Count  : in Natural;
                        Pad    : in Character := Space);

67
        function Tail (Source : in Unbounded_String;
                       Count  : in Natural;
                       Pad    : in Character := Space)
           return Unbounded_String;

68
        procedure Tail (Source : in out Unbounded_String;
                        Count  : in Natural;
                        Pad    : in Character := Space);

69
        function "*" (Left  : in Natural;
                      Right : in Character)
           return Unbounded_String;

70
        function "*" (Left  : in Natural;
                      Right : in String)
           return Unbounded_String;

71
        function "*" (Left  : in Natural;
                      Right : in Unbounded_String)
           return Unbounded_String;

72
     private
        ... -- <not specified by the language>
     end Ada.Strings.Unbounded;

72.1/2
The type Unbounded_String needs finalization (see *note 7.6::).

73
Null_Unbounded_String represents the null String.  If an object of type
Unbounded_String is not otherwise initialized, it will be initialized to
the same value as Null_Unbounded_String.

74
The function Length returns the length of the String represented by
Source.

75
The type String_Access provides a (nonprivate) access type for explicit
processing of unbounded-length strings.  The procedure Free performs an
unchecked deallocation of an object of type String_Access.

76
The function To_Unbounded_String(Source : in String) returns an
Unbounded_String that represents Source.  The function
To_Unbounded_String(Length : in Natural) returns an Unbounded_String
that represents an uninitialized String whose length is Length.

77
The function To_String returns the String with lower bound 1 represented
by Source.  To_String and To_Unbounded_String are related as follows:

78
   * If S is a String, then To_String(To_Unbounded_String(S)) = S.

79
   * If U is an Unbounded_String, then To_Unbounded_String(To_String(U))
     = U.

79.1/2
The procedure Set_Unbounded_String sets Target to an Unbounded_String
that represents Source.

80
For each of the Append procedures, the resulting string represented by
the Source parameter is given by the concatenation of the original value
of Source and the value of New_Item.

81
Each of the "&" functions returns an Unbounded_String obtained by
concatenating the string or character given or represented by one of the
parameters, with the string or character given or represented by the
other parameter, and applying To_Unbounded_String to the concatenation
result string.

82
The Element, Replace_Element, and Slice subprograms have the same effect
as the corresponding bounded-length string subprograms.

82.1/3
The function Unbounded_Slice returns the slice at positions Low through
High in the string represented by Source as an Unbounded_String.  The
procedure Unbounded_Slice sets Target to the Unbounded_String
representing the slice at positions Low through High in the string
represented by Source.  Both subprograms propagate Index_Error if Low >
Length(Source)+1 or High > Length(Source).

83
Each of the functions "=", "<", ">", "<=", and ">=" returns the same
result as the corresponding String operation applied to the String
values given or represented by Left and Right.

84
Each of the search subprograms (Index, Index_Non_Blank, Count,
Find_Token) has the same effect as the corresponding subprogram in
Strings.Fixed applied to the string represented by the Unbounded_String
parameter.

85
The Translate function has an analogous effect to the corresponding
subprogram in Strings.Fixed.  The translation is applied to the string
represented by the Unbounded_String parameter, and the result is
converted (via To_Unbounded_String) to an Unbounded_String.

86
Each of the transformation functions (Replace_Slice, Insert, Overwrite,
Delete), selector functions (Trim, Head, Tail), and constructor
functions ("*") is likewise analogous to its corresponding subprogram in
Strings.Fixed.  For each of the subprograms, the corresponding
fixed-length string subprogram is applied to the string represented by
the Unbounded_String parameter, and To_Unbounded_String is applied the
result string.

87
For each of the procedures Translate, Replace_Slice, Insert, Overwrite,
Delete, Trim, Head, and Tail, the resulting string represented by the
Source parameter is given by the corresponding function for fixed-length
strings applied to the string represented by Source's original value.

                     _Implementation Requirements_

88
No storage associated with an Unbounded_String object shall be lost upon
assignment or scope exit.


File: arm2012.info,  Node: A.4.6,  Next: A.4.7,  Prev: A.4.5,  Up: A.4

A.4.6 String-Handling Sets and Mappings
---------------------------------------

1
The language-defined package Strings.Maps.Constants declares
Character_Set and Character_Mapping constants corresponding to
classification and conversion functions in package Characters.Handling.

                          _Static Semantics_

2
The library package Strings.Maps.Constants has the following
declaration:

3/2
     package Ada.Strings.Maps.Constants is
        pragma Pure(Constants);

4
        Control_Set           : constant Character_Set;
        Graphic_Set           : constant Character_Set;
        Letter_Set            : constant Character_Set;
        Lower_Set             : constant Character_Set;
        Upper_Set             : constant Character_Set;
        Basic_Set             : constant Character_Set;
        Decimal_Digit_Set     : constant Character_Set;
        Hexadecimal_Digit_Set : constant Character_Set;
        Alphanumeric_Set      : constant Character_Set;
        Special_Set           : constant Character_Set;
        ISO_646_Set           : constant Character_Set;

5
        Lower_Case_Map        : constant Character_Mapping;
          --<Maps to lower case for letters, else identity>
        Upper_Case_Map        : constant Character_Mapping;
          --<Maps to upper case for letters, else identity>
        Basic_Map             : constant Character_Mapping;
          --<Maps to basic letter for letters, else identity>

6
     private
        ... -- <not specified by the language>
     end Ada.Strings.Maps.Constants;

7
Each of these constants represents a correspondingly named set of
characters or character mapping in Characters.Handling (see *note
A.3.2::).

     NOTES

8/3
     15  There are certain characters which are defined to be lower case
     letters by ISO 10646 and are therefore allowed in identifiers, but
     are not considered lower case letters by
     Ada.Strings.Maps.Constants.


File: arm2012.info,  Node: A.4.7,  Next: A.4.8,  Prev: A.4.6,  Up: A.4

A.4.7 Wide_String Handling
--------------------------

1/3
Facilities for handling strings of Wide_Character elements are found in
the packages Strings.Wide_Maps, Strings.Wide_Fixed,
Strings.Wide_Bounded, Strings.Wide_Unbounded, and
Strings.Wide_Maps.Wide_Constants, and in the library functions
Strings.Wide_Hash, Strings.Wide_Fixed.Wide_Hash,
Strings.Wide_Bounded.Wide_Hash, Strings.Wide_Unbounded.Wide_Hash,
Strings.Wide_Hash_Case_Insensitive,
Strings.Wide_Fixed.Wide_Hash_Case_Insensitive,
Strings.Wide_Bounded.Wide_Hash_Case_Insensitive,
Strings.Wide_Unbounded.Wide_Hash_Case_Insensitive,
Strings.Wide_Equal_Case_Insensitive,
Strings.Wide_Fixed.Wide_Equal_Case_Insensitive,
Strings.Wide_Bounded.Wide_Equal_Case_Insensitive, and
Strings.Wide_Unbounded.Wide_Equal_Case_Insensitive.  They provide the
same string-handling operations as the corresponding packages and
functions for strings of Character elements.  

                          _Static Semantics_

2
The package Strings.Wide_Maps has the following declaration.

3
     package Ada.Strings.Wide_Maps is
        pragma Preelaborate(Wide_Maps);

4/2
        --< Representation for a set of Wide_Character values:>
        type Wide_Character_Set is private;
        pragma Preelaborable_Initialization(Wide_Character_Set);

5
        Null_Set : constant Wide_Character_Set;

6
        type Wide_Character_Range is
          record
              Low  : Wide_Character;
              High : Wide_Character;
          end record;
        -- <Represents Wide_Character range Low..High>

7
        type Wide_Character_Ranges is array (Positive range <>)
           of Wide_Character_Range;

8
        function To_Set    (Ranges : in Wide_Character_Ranges)
           return Wide_Character_Set;

9
        function To_Set    (Span   : in Wide_Character_Range)
           return Wide_Character_Set;

10
        function To_Ranges (Set    : in Wide_Character_Set)
           return Wide_Character_Ranges;

11
        function "="   (Left, Right : in Wide_Character_Set) return Boolean;

12
        function "not" (Right : in Wide_Character_Set)
           return Wide_Character_Set;
        function "and" (Left, Right : in Wide_Character_Set)
           return Wide_Character_Set;
        function "or"  (Left, Right : in Wide_Character_Set)
           return Wide_Character_Set;
        function "xor" (Left, Right : in Wide_Character_Set)
           return Wide_Character_Set;
        function "-"   (Left, Right : in Wide_Character_Set)
           return Wide_Character_Set;

13
        function Is_In (Element : in Wide_Character;
                        Set     : in Wide_Character_Set)
           return Boolean;

14
        function Is_Subset (Elements : in Wide_Character_Set;
                            Set      : in Wide_Character_Set)
           return Boolean;

15
        function "<=" (Left  : in Wide_Character_Set;
                       Right : in Wide_Character_Set)
           return Boolean renames Is_Subset;

16
        --< Alternative representation for a set of Wide_Character values:>
        subtype Wide_Character_Sequence is Wide_String;

17
        function To_Set (Sequence  : in Wide_Character_Sequence)
           return Wide_Character_Set;

18
        function To_Set (Singleton : in Wide_Character)
           return Wide_Character_Set;

19
        function To_Sequence (Set  : in Wide_Character_Set)
           return Wide_Character_Sequence;

20/2
        --< Representation for a Wide_Character to Wide_Character mapping:>
        type Wide_Character_Mapping is private;
        pragma Preelaborable_Initialization(Wide_Character_Mapping);

21
        function Value (Map     : in Wide_Character_Mapping;
                        Element : in Wide_Character)
           return Wide_Character;

22
        Identity : constant Wide_Character_Mapping;

23
        function To_Mapping (From, To : in Wide_Character_Sequence)
           return Wide_Character_Mapping;

24
        function To_Domain (Map : in Wide_Character_Mapping)
           return Wide_Character_Sequence;

25
        function To_Range  (Map : in Wide_Character_Mapping)
           return Wide_Character_Sequence;

26
        type Wide_Character_Mapping_Function is
           access function (From : in Wide_Character) return Wide_Character;

27
     private
        ... -- <not specified by the language>
     end Ada.Strings.Wide_Maps;

28
The context clause for each of the packages Strings.Wide_Fixed,
Strings.Wide_Bounded, and Strings.Wide_Unbounded identifies
Strings.Wide_Maps instead of Strings.Maps.

28.1/3
Types Wide_Character_Set and Wide_Character_Mapping need finalization.

29/3
For each of the packages Strings.Fixed, Strings.Bounded,
Strings.Unbounded, and Strings.Maps.Constants, and for library functions
Strings.Hash, Strings.Fixed.Hash, Strings.Bounded.Hash,
Strings.Unbounded.Hash, Strings.Hash_Case_Insensitive,
Strings.Fixed.Hash_Case_Insensitive,
Strings.Bounded.Hash_Case_Insensitive,
Strings.Unbounded.Hash_Case_Insensitive, Strings.Equal_Case_Insensitive,
Strings.Fixed.Equal_Case_Insensitive,
Strings.Bounded.Equal_Case_Insensitive, and
Strings.Unbounded.Equal_Case_Insensitive, the corresponding wide string
package or function has the same contents except that

30
   * Wide_Space replaces Space

31
   * Wide_Character replaces Character

32
   * Wide_String replaces String

33
   * Wide_Character_Set replaces Character_Set

34
   * Wide_Character_Mapping replaces Character_Mapping

35
   * Wide_Character_Mapping_Function replaces Character_Mapping_Function

36
   * Wide_Maps replaces Maps

37
   * Bounded_Wide_String replaces Bounded_String

38
   * Null_Bounded_Wide_String replaces Null_Bounded_String

39
   * To_Bounded_Wide_String replaces To_Bounded_String

40
   * To_Wide_String replaces To_String

40.1/2
   * Set_Bounded_Wide_String replaces Set_Bounded_String

41
   * Unbounded_Wide_String replaces Unbounded_String

42
   * Null_Unbounded_Wide_String replaces Null_Unbounded_String

43
   * Wide_String_Access replaces String_Access

44
   * To_Unbounded_Wide_String replaces To_Unbounded_String

44.1/2
   * Set_Unbounded_Wide_String replaces Set_Unbounded_String

45
The following additional declaration is present in
Strings.Wide_Maps.Wide_Constants:

46/2
     Character_Set : constant Wide_Maps.Wide_Character_Set;
     --<Contains each Wide_Character value WC such that>
     --<Characters.Conversions.Is_Character(WC) is True>

46.1/2
Each Wide_Character_Set constant in the package
Strings.Wide_Maps.Wide_Constants contains no values outside the
Character portion of Wide_Character.  Similarly, each
Wide_Character_Mapping constant in this package is the identity mapping
when applied to any element outside the Character portion of
Wide_Character.

46.2/2
Pragma Pure is replaced by pragma Preelaborate in
Strings.Wide_Maps.Wide_Constants.

     NOTES

47
     16  If a null Wide_Character_Mapping_Function is passed to any of
     the Wide_String handling subprograms, Constraint_Error is
     propagated.


File: arm2012.info,  Node: A.4.8,  Next: A.4.9,  Prev: A.4.7,  Up: A.4

A.4.8 Wide_Wide_String Handling
-------------------------------

1/3
Facilities for handling strings of Wide_Wide_Character elements are
found in the packages Strings.Wide_Wide_Maps, Strings.Wide_Wide_Fixed,
Strings.Wide_Wide_Bounded, Strings.Wide_Wide_Unbounded, and
Strings.Wide_Wide_Maps.Wide_Wide_Constants, and in the library functions
Strings.Wide_Wide_Hash, Strings.Wide_Wide_Fixed.Wide_Wide_Hash,
Strings.Wide_Wide_Bounded.Wide_Wide_Hash,
Strings.Wide_Wide_Unbounded.Wide_Wide_Hash,
Strings.Wide_Wide_Hash_Case_Insensitive,
Strings.Wide_Wide_Fixed.Wide_Wide_Hash_Case_Insensitive,
Strings.Wide_Wide_Bounded.Wide_Wide_Hash_Case_Insensitive,
Strings.Wide_Wide_Unbounded.Wide_Wide_Hash_Case_Insensitive,
Strings.Wide_Wide_Equal_Case_Insensitive,
Strings.Wide_Wide_Fixed.Wide_Wide_Equal_Case_Insensitive,
Strings.Wide_Wide_Bounded.Wide_Wide_Equal_Case_Insensitive, and
Strings.Wide_Wide_Unbounded.Wide_Wide_Equal_Case_Insensitive.  They
provide the same string-handling operations as the corresponding
packages and functions for strings of Character elements.  

                          _Static Semantics_

2/2
The library package Strings.Wide_Wide_Maps has the following
declaration.

3/2
     package Ada.Strings.Wide_Wide_Maps is
        pragma Preelaborate(Wide_Wide_Maps);

4/2
        -- <Representation for a set of Wide_Wide_Character values:>
        type Wide_Wide_Character_Set is private;
        pragma Preelaborable_Initialization(Wide_Wide_Character_Set);

5/2
        Null_Set : constant Wide_Wide_Character_Set;

6/2
        type Wide_Wide_Character_Range is
           record
              Low  : Wide_Wide_Character;
              High : Wide_Wide_Character;
           end record;
        -- <Represents Wide_Wide_Character range Low..High>

7/2
        type Wide_Wide_Character_Ranges is array (Positive range <>)
              of Wide_Wide_Character_Range;

8/2
        function To_Set (Ranges : in Wide_Wide_Character_Ranges)
              return Wide_Wide_Character_Set;

9/2
        function To_Set (Span : in Wide_Wide_Character_Range)
              return Wide_Wide_Character_Set;

10/2
        function To_Ranges (Set : in Wide_Wide_Character_Set)
              return Wide_Wide_Character_Ranges;

11/2
        function "=" (Left, Right : in Wide_Wide_Character_Set) return Boolean;

12/2
        function "not" (Right : in Wide_Wide_Character_Set)
              return Wide_Wide_Character_Set;
        function "and" (Left, Right : in Wide_Wide_Character_Set)
              return Wide_Wide_Character_Set;
        function "or" (Left, Right : in Wide_Wide_Character_Set)
              return Wide_Wide_Character_Set;
        function "xor" (Left, Right : in Wide_Wide_Character_Set)
              return Wide_Wide_Character_Set;
        function "-" (Left, Right : in Wide_Wide_Character_Set)
              return Wide_Wide_Character_Set;

13/2
        function Is_In (Element : in Wide_Wide_Character;
                        Set     : in Wide_Wide_Character_Set)
              return Boolean;

14/2
        function Is_Subset (Elements : in Wide_Wide_Character_Set;
                            Set      : in Wide_Wide_Character_Set)
              return Boolean;

15/2
        function "<=" (Left  : in Wide_Wide_Character_Set;
                       Right : in Wide_Wide_Character_Set)
              return Boolean renames Is_Subset;

16/2
        -- <Alternative representation for a set of Wide_Wide_Character values:>
        subtype Wide_Wide_Character_Sequence is Wide_Wide_String;

17/2
        function To_Set (Sequence : in Wide_Wide_Character_Sequence)
              return Wide_Wide_Character_Set;

18/2
        function To_Set (Singleton : in Wide_Wide_Character)
              return Wide_Wide_Character_Set;

19/2
        function To_Sequence (Set : in Wide_Wide_Character_Set)
              return Wide_Wide_Character_Sequence;

20/2
        -- <Representation for a Wide_Wide_Character to Wide_Wide_Character>
        -- <mapping:>
        type Wide_Wide_Character_Mapping is private;
        pragma Preelaborable_Initialization(Wide_Wide_Character_Mapping);

21/2
        function Value (Map     : in Wide_Wide_Character_Mapping;
                        Element : in Wide_Wide_Character)
              return Wide_Wide_Character;

22/2
        Identity : constant Wide_Wide_Character_Mapping;

23/2
        function To_Mapping (From, To : in Wide_Wide_Character_Sequence)
              return Wide_Wide_Character_Mapping;

24/2
        function To_Domain (Map : in Wide_Wide_Character_Mapping)
              return Wide_Wide_Character_Sequence;

25/2
        function To_Range (Map : in Wide_Wide_Character_Mapping)
              return Wide_Wide_Character_Sequence;

26/2
        type Wide_Wide_Character_Mapping_Function is
              access function (From : in Wide_Wide_Character)
              return Wide_Wide_Character;

27/2
     private
        ... -- <not specified by the language>
     end Ada.Strings.Wide_Wide_Maps;

28/2
The context clause for each of the packages Strings.Wide_Wide_Fixed,
Strings.Wide_Wide_Bounded, and Strings.Wide_Wide_Unbounded identifies
Strings.Wide_Wide_Maps instead of Strings.Maps.

28.1/3
Types Wide_Wide_Character_Set and Wide_Wide_Character_Mapping need
finalization.

29/3
For each of the packages Strings.Fixed, Strings.Bounded,
Strings.Unbounded, and Strings.Maps.Constants, and for library functions
Strings.Hash, Strings.Fixed.Hash, Strings.Bounded.Hash,
Strings.Unbounded.Hash, Strings.Hash_Case_Insensitive,
Strings.Fixed.Hash_Case_Insensitive,
Strings.Bounded.Hash_Case_Insensitive,
Strings.Unbounded.Hash_Case_Insensitive, Strings.Equal_Case_Insensitive,
Strings.Fixed.Equal_Case_Insensitive,
Strings.Bounded.Equal_Case_Insensitive, and
Strings.Unbounded.Equal_Case_Insensitive, the corresponding wide wide
string package or function has the same contents except that

30/2
   * Wide_Wide_Space replaces Space

31/2
   * Wide_Wide_Character replaces Character

32/2
   * Wide_Wide_String replaces String

33/2
   * Wide_Wide_Character_Set replaces Character_Set

34/2
   * Wide_Wide_Character_Mapping replaces Character_Mapping

35/2
   * Wide_Wide_Character_Mapping_Function replaces
     Character_Mapping_Function

36/2
   * Wide_Wide_Maps replaces Maps

37/2
   * Bounded_Wide_Wide_String replaces Bounded_String

38/2
   * Null_Bounded_Wide_Wide_String replaces Null_Bounded_String

39/2
   * To_Bounded_Wide_Wide_String replaces To_Bounded_String

40/2
   * To_Wide_Wide_String replaces To_String

41/2
   * Set_Bounded_Wide_Wide_String replaces Set_Bounded_String

42/2
   * Unbounded_Wide_Wide_String replaces Unbounded_String

43/2
   * Null_Unbounded_Wide_Wide_String replaces Null_Unbounded_String

44/2
   * Wide_Wide_String_Access replaces String_Access

45/2
   * To_Unbounded_Wide_Wide_String replaces To_Unbounded_String

46/2
   * Set_Unbounded_Wide_Wide_String replaces Set_Unbounded_String

47/2
The following additional declarations are present in
Strings.Wide_Wide_Maps.Wide_Wide_Constants:

48/2
     Character_Set : constant Wide_Wide_Maps.Wide_Wide_Character_Set;
     -- <Contains each Wide_Wide_Character value WWC such that>
     -- <Characters.Conversions.Is_Character(WWC) is True>
     Wide_Character_Set : constant Wide_Wide_Maps.Wide_Wide_Character_Set;
     -- <Contains each Wide_Wide_Character value WWC such that>
     -- <Characters.Conversions.Is_Wide_Character(WWC) is True>

49/2
Each Wide_Wide_Character_Set constant in the package
Strings.Wide_Wide_Maps.Wide_Wide_Constants contains no values outside
the Character portion of Wide_Wide_Character.  Similarly, each
Wide_Wide_Character_Mapping constant in this package is the identity
mapping when applied to any element outside the Character portion of
Wide_Wide_Character.

50/2
Pragma Pure is replaced by pragma Preelaborate in
Strings.Wide_Wide_Maps.Wide_Wide_Constants.

     NOTES

51/2
     17  If a null Wide_Wide_Character_Mapping_Function is passed to any
     of the Wide_Wide_String handling subprograms, Constraint_Error is
     propagated.


File: arm2012.info,  Node: A.4.9,  Next: A.4.10,  Prev: A.4.8,  Up: A.4

A.4.9 String Hashing
--------------------

                          _Static Semantics_

1/2
The library function Strings.Hash has the following declaration:

2/3
     with Ada.Containers;
     function Ada.Strings.Hash (Key : String) return Containers.Hash_Type;
     pragma Pure(Ada.Strings.Hash);

3/2
          Returns an implementation-defined value which is a function of
          the value of Key.  If <A> and <B> are strings such that <A>
          equals <B>, Hash(<A>) equals Hash(<B>).

4/2
The library function Strings.Fixed.Hash has the following declaration:

5/3
     with Ada.Containers, Ada.Strings.Hash;
     function Ada.Strings.Fixed.Hash (Key : String) return Containers.Hash_Type
        renames Ada.Strings.Hash;

6/2
The generic library function Strings.Bounded.Hash has the following
declaration:

7/3
     with Ada.Containers;
     generic
        with package Bounded is
           new Ada.Strings.Bounded.Generic_Bounded_Length (<>);
     function Ada.Strings.Bounded.Hash (Key : Bounded.Bounded_String)
        return Containers.Hash_Type;
     pragma Preelaborate(Ada.Strings.Bounded.Hash);

8/3
          Equivalent to Strings.Hash (Bounded.To_String (Key));

9/2
The library function Strings.Unbounded.Hash has the following
declaration:

10/3
     with Ada.Containers;
     function Ada.Strings.Unbounded.Hash (Key : Unbounded_String)
        return Containers.Hash_Type;
     pragma Preelaborate(Ada.Strings.Unbounded.Hash);

11/3
          Equivalent to Strings.Hash (To_String (Key));

11.1/3
The library function Strings.Hash_Case_Insensitive has the following
declaration:

11.2/3
     with Ada.Containers;
     function Ada.Strings.Hash_Case_Insensitive (Key : String)
        return Containers.Hash_Type;
     pragma Pure(Ada.Strings.Hash_Case_Insensitive);

11.3/3
          Returns an implementation-defined value which is a function of
          the value of Key, converted to lower case.  If A and B are
          strings such that Strings.Equal_Case_Insensitive (A, B) (see
          *note A.4.10::) is True, then Hash_Case_Insensitive(A) equals
          Hash_Case_Insensitive(B).

11.4/3
The library function Strings.Fixed.Hash_Case_Insensitive has the
following declaration:

11.5/3
     with Ada.Containers, Ada.Strings.Hash_Case_Insensitive;
     function Ada.Strings.Fixed.Hash_Case_Insensitive (Key : String)
        return Containers.Hash_Type renames Ada.Strings.Hash_Case_Insensitive;

11.6/3
The generic library function Strings.Bounded.Hash_Case_Insensitive has
the following declaration:

11.7/3
     with Ada.Containers;
     generic
        with package Bounded is
           new Ada.Strings.Bounded.Generic_Bounded_Length (<>);
     function Ada.Strings.Bounded.Hash_Case_Insensitive
        (Key : Bounded.Bounded_String) return Containers.Hash_Type;
     pragma Preelaborate(Ada.Strings.Bounded.Hash_Case_Insensitive);

11.8/3
          Equivalent to Strings.Hash_Case_Insensitive (Bounded.To_String
          (Key));

11.9/3
The library function Strings.Unbounded.Hash_Case_Insensitive has the
following declaration:

11.10/3
     with Ada.Containers;
     function Ada.Strings.Unbounded.Hash_Case_Insensitive
        (Key : Unbounded_String) return Containers.Hash_Type;
     pragma Preelaborate(Ada.Strings.Unbounded.Hash_Case_Insensitive);

11.11/3
          Equivalent to Strings.Hash_Case_Insensitive (To_String (Key));

                        _Implementation Advice_

12/2
The Hash functions should be good hash functions, returning a wide
spread of values for different string values.  It should be unlikely for
similar strings to return the same value.


File: arm2012.info,  Node: A.4.10,  Next: A.4.11,  Prev: A.4.9,  Up: A.4

A.4.10 String Comparison
------------------------

                          _Static Semantics_

1/3
The library function Strings.Equal_Case_Insensitive has the following
declaration:

2/3
     function Ada.Strings.Equal_Case_Insensitive (Left, Right : String)
        return Boolean;
     pragma Pure(Ada.Strings.Equal_Case_Insensitive);

3/3
          Returns True if the strings consist of the same sequence of
          characters after applying locale-independent simple case
          folding, as defined by documents referenced in the note in
          Clause 1 of ISO/IEC 10646:2011.  Otherwise, returns False.
          This function uses the same method as is used to determine
          whether two identifiers are the same.

4/3
The library function Strings.Fixed.Equal_Case_Insensitive has the
following declaration:

5/3
     with Ada.Strings.Equal_Case_Insensitive;
     function Ada.Strings.Fixed.Equal_Case_Insensitive
        (Left, Right : String) return Boolean
           renames Ada.Strings.Equal_Case_Insensitive;

6/3
The generic library function Strings.Bounded.Equal_Case_Insensitive has
the following declaration:

7/3
     generic
        with package Bounded is
           new Ada.Strings.Bounded.Generic_Bounded_Length (<>);
     function Ada.Strings.Bounded.Equal_Case_Insensitive
        (Left, Right : Bounded.Bounded_String) return Boolean;
     pragma Preelaborate(Ada.Strings.Bounded.Equal_Case_Insensitive);

8/3
          Equivalent to Strings.Equal_Case_Insensitive
          (Bounded.To_String (Left), Bounded.To_String (Right));

9/3
The library function Strings.Unbounded.Equal_Case_Insensitive has the
following declaration:

10/3
     function Ada.Strings.Unbounded.Equal_Case_Insensitive
        (Left, Right : Unbounded_String) return Boolean;
     pragma Preelaborate(Ada.Strings.Unbounded.Equal_Case_Insensitive);

11/3
          Equivalent to Strings.Equal_Case_Insensitive (To_String
          (Left), To_String (Right));

12/3
The library function Strings.Less_Case_Insensitive has the following
declaration:

13/3
     function Ada.Strings.Less_Case_Insensitive (Left, Right : String)
        return Boolean;
     pragma Pure(Ada.Strings.Less_Case_Insensitive);

14/3
          Performs a lexicographic comparison of strings Left and Right,
          converted to lower case.

15/3
The library function Strings.Fixed.Less_Case_Insensitive has the
following declaration:

16/3
     with Ada.Strings.Less_Case_Insensitive;
     function Ada.Strings.Fixed.Less_Case_Insensitive
        (Left, Right : String) return Boolean
           renames Ada.Strings.Less_Case_Insensitive;

17/3
The generic library function Strings.Bounded.Less_Case_Insensitive has
the following declaration:

18/3
     generic
        with package Bounded is
           new Ada.Strings.Bounded.Generic_Bounded_Length (<>);
     function Ada.Strings.Bounded.Less_Case_Insensitive
       (Left, Right : Bounded.Bounded_String) return Boolean;
     pragma Preelaborate(Ada.Strings.Bounded.Less_Case_Insensitive);

19/3
          Equivalent to Strings.Less_Case_Insensitive (Bounded.To_String
          (Left), Bounded.To_String (Right));

20/3
The library function Strings.Unbounded.Less_Case_Insensitive has the
following declaration:

21/3
     function Ada.Strings.Unbounded.Less_Case_Insensitive
       (Left, Right : Unbounded_String) return Boolean;
     pragma Preelaborate(Ada.Strings.Unbounded.Less_Case_Insensitive);

22/3
          Equivalent to Strings.Less_Case_Insensitive (To_String (Left),
          To_String (Right));


File: arm2012.info,  Node: A.4.11,  Prev: A.4.10,  Up: A.4

A.4.11 String Encoding
----------------------

1/3
Facilities for encoding, decoding, and converting strings in various
character encoding schemes are provided by packages
Strings.UTF_Encoding, Strings.UTF_Encoding.Conversions,
Strings.UTF_Encoding.Strings, Strings.UTF_Encoding.Wide_Strings, and
Strings.UTF_Encoding.Wide_Wide_Strings.

                          _Static Semantics_

2/3
The encoding library packages have the following declarations:

3/3
     package Ada.Strings.UTF_Encoding is
        pragma Pure (UTF_Encoding);

4/3
        -- <Declarations common to the string encoding packages>
        type Encoding_Scheme is (UTF_8, UTF_16BE, UTF_16LE);

5/3
        subtype UTF_String is String;

6/3
        subtype UTF_8_String is String;

7/3
        subtype UTF_16_Wide_String is Wide_String;

8/3
        Encoding_Error : exception;

9/3
        BOM_8    : constant UTF_8_String :=
                     Character'Val(16#EF#) &
                     Character'Val(16#BB#) &
                     Character'Val(16#BF#);

10/3
        BOM_16BE : constant UTF_String :=
                     Character'Val(16#FE#) &
                     Character'Val(16#FF#);

11/3
        BOM_16LE : constant UTF_String :=
                     Character'Val(16#FF#) &
                     Character'Val(16#FE#);

12/3
        BOM_16   : constant UTF_16_Wide_String :=
                    (1 => Wide_Character'Val(16#FEFF#));

13/3
        function Encoding (Item    : UTF_String;
                           Default : Encoding_Scheme := UTF_8)
           return Encoding_Scheme;

14/3
     end Ada.Strings.UTF_Encoding;

15/3
     package Ada.Strings.UTF_Encoding.Conversions is
        pragma Pure (Conversions);

16/3
        -- <Conversions between various encoding schemes>
        function Convert (Item          : UTF_String;
                          Input_Scheme  : Encoding_Scheme;
                          Output_Scheme : Encoding_Scheme;
                          Output_BOM    : Boolean := False) return UTF_String;

17/3
        function Convert (Item          : UTF_String;
                          Input_Scheme  : Encoding_Scheme;
                          Output_BOM    : Boolean := False)
           return UTF_16_Wide_String;

18/3
        function Convert (Item          : UTF_8_String;
                          Output_BOM    : Boolean := False)
           return UTF_16_Wide_String;

19/3
        function Convert (Item          : UTF_16_Wide_String;
                          Output_Scheme : Encoding_Scheme;
                          Output_BOM    : Boolean := False) return UTF_String;

20/3
        function Convert (Item          : UTF_16_Wide_String;
                          Output_BOM    : Boolean := False) return UTF_8_String;

21/3
     end Ada.Strings.UTF_Encoding.Conversions;

22/3
     package Ada.Strings.UTF_Encoding.Strings is
        pragma Pure (Strings);

23/3
        -- <Encoding / decoding between String and various encoding schemes>
        function Encode (Item          : String;
                         Output_Scheme : Encoding_Scheme;
                         Output_BOM    : Boolean  := False) return UTF_String;

24/3
        function Encode (Item       : String;
                         Output_BOM : Boolean  := False) return UTF_8_String;

25/3
        function Encode (Item       : String;
                         Output_BOM : Boolean  := False)
           return UTF_16_Wide_String;

26/3
        function Decode (Item         : UTF_String;
                         Input_Scheme : Encoding_Scheme) return String;

27/3
        function Decode (Item : UTF_8_String) return String;

28/3
        function Decode (Item : UTF_16_Wide_String) return String;

29/3
     end Ada.Strings.UTF_Encoding.Strings;

30/3
     package Ada.Strings.UTF_Encoding.Wide_Strings is
        pragma Pure (Wide_Strings);

31/3
        -- <Encoding / decoding between Wide_String and various encoding schemes>
        function Encode (Item          : Wide_String;
                         Output_Scheme : Encoding_Scheme;
                         Output_BOM    : Boolean  := False) return UTF_String;

32/3
        function Encode (Item       : Wide_String;
                         Output_BOM : Boolean  := False) return UTF_8_String;

33/3
        function Encode (Item       : Wide_String;
                         Output_BOM : Boolean  := False)
           return UTF_16_Wide_String;

34/3
        function Decode (Item         : UTF_String;
                         Input_Scheme : Encoding_Scheme) return Wide_String;

35/3
        function Decode (Item : UTF_8_String) return Wide_String;

36/3
        function Decode (Item : UTF_16_Wide_String) return Wide_String;

37/3
     end Ada.Strings.UTF_Encoding.Wide_Strings;

38/3
     package Ada.Strings.UTF_Encoding.Wide_Wide_Strings is
        pragma Pure (Wide_Wide_Strings);

39/3
        -- <Encoding / decoding between Wide_Wide_String and various encoding schemes>
        function Encode (Item          : Wide_Wide_String;
                         Output_Scheme : Encoding_Scheme;
                         Output_BOM    : Boolean  := False) return UTF_String;

40/3
        function Encode (Item       : Wide_Wide_String;
                         Output_BOM : Boolean  := False) return UTF_8_String;

41/3
        function Encode (Item       : Wide_Wide_String;
                         Output_BOM : Boolean  := False)
           return UTF_16_Wide_String;

42/3
        function Decode (Item         : UTF_String;
                         Input_Scheme : Encoding_Scheme) return Wide_Wide_String;

43/3
        function Decode (Item : UTF_8_String) return Wide_Wide_String;

44/3
        function Decode (Item : UTF_16_Wide_String) return Wide_Wide_String;

45/3
     end Ada.Strings.UTF_Encoding.Wide_Wide_Strings;

46/3
The type Encoding_Scheme defines encoding schemes.  UTF_8 corresponds to
the UTF-8 encoding scheme defined by Annex D of ISO/IEC 10646.  UTF_16BE
corresponds to the UTF-16 encoding scheme defined by Annex C of ISO/IEC
10646 in 8 bit, big-endian order; and UTF_16LE corresponds to the UTF-16
encoding scheme in 8 bit, little-endian order.

47/3
The subtype UTF_String is used to represent a String of 8-bit values
containing a sequence of values encoded in one of three ways (UTF-8,
UTF-16BE, or UTF-16LE). The subtype UTF_8_String is used to represent a
String of 8-bit values containing a sequence of values encoded in UTF-8.
The subtype UTF_16_Wide_String is used to represent a Wide_String of
16-bit values containing a sequence of values encoded in UTF-16.

48/3
The BOM_8, BOM_16BE, BOM_16LE, and BOM_16 constants correspond to values
used at the start of a string to indicate the encoding.

49/3
Each of the Encode functions takes a String, Wide_String, or
Wide_Wide_String Item parameter that is assumed to be an array of
unencoded characters.  Each of the Convert functions takes a UTF_String,
UTF_8_String, or UTF_16_String Item parameter that is assumed to contain
characters whose position values correspond to a valid encoding sequence
according to the encoding scheme required by the function or specified
by its Input_Scheme parameter.

50/3
Each of the Convert and Encode functions returns a UTF_String,
UTF_8_String, or UTF_16_String value whose characters have position
values that correspond to the encoding of the Item parameter according
to the encoding scheme required by the function or specified by its
Output_Scheme parameter.  For UTF_8, no overlong encoding is returned.
A BOM is included at the start of the returned string if the Output_BOM
parameter is set to True.  The lower bound of the returned string is 1.

51/3
Each of the Decode functions takes a UTF_String, UTF_8_String, or
UTF_16_String Item parameter which is assumed to contain characters
whose position values correspond to a valid encoding sequence according
to the encoding scheme required by the function or specified by its
Input_Scheme parameter, and returns the corresponding String,
Wide_String, or Wide_Wide_String value.  The lower bound of the returned
string is 1.

52/3
For each of the Convert and Decode functions, an initial BOM in the
input that matches the expected encoding scheme is ignored, and a
different initial BOM causes Encoding_Error to be propagated.

53/3
The exception Encoding_Error is also propagated in the following
situations:

54/4
   * By a Convert or Decode function when a UTF encoded string contains
     an invalid encoding sequence.

55/4
   * By a Convert or Decode function when the expected encoding is
     UTF-16BE or UTF-16LE and the input string has an odd length.

56/3
   * By a Decode function yielding a String when the decoding of a
     sequence results in a code point whose value exceeds 16#FF#.

57/3
   * By a Decode function yielding a Wide_String when the decoding of a
     sequence results in a code point whose value exceeds 16#FFFF#.

58/3
   * By an Encode function taking a Wide_String as input when an invalid
     character appears in the input.  In particular, the characters
     whose position is in the range 16#D800# ..  16#DFFF# are invalid
     because they conflict with UTF-16 surrogate encodings, and the
     characters whose position is 16#FFFE# or 16#FFFF# are also invalid
     because they conflict with BOM codes.

59/3
     function Encoding (Item    : UTF_String;
                        Default : Encoding_Scheme := UTF_8)
        return Encoding_Scheme;

60/3
          Inspects a UTF_String value to determine whether it starts
          with a BOM for UTF-8, UTF-16BE, or UTF_16LE. If so, returns
          the scheme corresponding to the BOM; otherwise, returns the
          value of Default.

61/3
     function Convert (Item          : UTF_String;
                       Input_Scheme  : Encoding_Scheme;
                       Output_Scheme : Encoding_Scheme;
                       Output_BOM    : Boolean := False) return UTF_String;

62/3
          Returns the value of Item (originally encoded in UTF-8,
          UTF-16LE, or UTF-16BE as specified by Input_Scheme) encoded in
          one of these three schemes as specified by Output_Scheme.

63/3
     function Convert (Item          : UTF_String;
                       Input_Scheme  : Encoding_Scheme;
                       Output_BOM    : Boolean := False)
        return UTF_16_Wide_String;

64/3
          Returns the value of Item (originally encoded in UTF-8,
          UTF-16LE, or UTF-16BE as specified by Input_Scheme) encoded in
          UTF-16.

65/3
     function Convert (Item          : UTF_8_String;
                       Output_BOM    : Boolean := False)
        return UTF_16_Wide_String;

66/3
          Returns the value of Item (originally encoded in UTF-8)
          encoded in UTF-16.

67/3
     function Convert (Item          : UTF_16_Wide_String;
                       Output_Scheme : Encoding_Scheme;
                       Output_BOM    : Boolean := False) return UTF_String;

68/3
          Returns the value of Item (originally encoded in UTF-16)
          encoded in UTF-8, UTF-16LE, or UTF-16BE as specified by
          Output_Scheme.

69/3
     function Convert (Item          : UTF_16_Wide_String;
                       Output_BOM    : Boolean := False) return UTF_8_String;

70/3
          Returns the value of Item (originally encoded in UTF-16)
          encoded in UTF-8.

71/3
     function Encode (Item          : String;
                      Output_Scheme : Encoding_Scheme;
                      Output_BOM    : Boolean  := False) return UTF_String;

72/3
          Returns the value of Item encoded in UTF-8, UTF-16LE, or
          UTF-16BE as specified by Output_Scheme.

73/3
     function Encode (Item       : String;
                      Output_BOM : Boolean  := False) return UTF_8_String;

74/3
          Returns the value of Item encoded in UTF-8.

75/3
     function Encode (Item       : String;
                      Output_BOM : Boolean  := False) return UTF_16_Wide_String;

76/3
          Returns the value of Item encoded in UTF_16.

77/3
     function Decode (Item         : UTF_String;
                      Input_Scheme : Encoding_Scheme) return String;

78/3
          Returns the result of decoding Item, which is encoded in
          UTF-8, UTF-16LE, or UTF-16BE as specified by Input_Scheme.

79/3
     function Decode (Item : UTF_8_String) return String;

80/3
          Returns the result of decoding Item, which is encoded in
          UTF-8.

81/3
     function Decode (Item : UTF_16_Wide_String) return String;

82/3
          Returns the result of decoding Item, which is encoded in
          UTF-16.

83/3
     function Encode (Item          : Wide_String;
                      Output_Scheme : Encoding_Scheme;
                      Output_BOM    : Boolean  := False) return UTF_String;

84/3
          Returns the value of Item encoded in UTF-8, UTF-16LE, or
          UTF-16BE as specified by Output_Scheme.

85/3
     function Encode (Item       : Wide_String;
                      Output_BOM : Boolean  := False) return UTF_8_String;

86/3
          Returns the value of Item encoded in UTF-8.

87/3
     function Encode (Item       : Wide_String;
                      Output_BOM : Boolean  := False) return UTF_16_Wide_String;

88/3
          Returns the value of Item encoded in UTF_16.

89/3
     function Decode (Item         : UTF_String;
                      Input_Scheme : Encoding_Scheme) return Wide_String;

90/3
          Returns the result of decoding Item, which is encoded in
          UTF-8, UTF-16LE, or UTF-16BE as specified by Input_Scheme.

91/3
     function Decode (Item : UTF_8_String) return Wide_String;

92/3
          Returns the result of decoding Item, which is encoded in
          UTF-8.

93/3
     function Decode (Item : UTF_16_Wide_String) return Wide_String;

94/3
          Returns the result of decoding Item, which is encoded in
          UTF-16.

95/3
     function Encode (Item          : Wide_Wide_String;
                      Output_Scheme : Encoding_Scheme;
                      Output_BOM    : Boolean  := False) return UTF_String;

96/3
          Returns the value of Item encoded in UTF-8, UTF-16LE, or
          UTF-16BE as specified by Output_Scheme.

97/3
     function Encode (Item       : Wide_Wide_String;
                      Output_BOM : Boolean  := False) return UTF_8_String;

98/3
          Returns the value of Item encoded in UTF-8.

99/3
     function Encode (Item       : Wide_Wide_String;
                      Output_BOM : Boolean  := False) return UTF_16_Wide_String;

100/3
          Returns the value of Item encoded in UTF_16.

101/3
     function Decode (Item         : UTF_String;
                      Input_Scheme : Encoding_Scheme) return Wide_Wide_String;

102/3
          Returns the result of decoding Item, which is encoded in
          UTF-8, UTF-16LE, or UTF-16BE as specified by Input_Scheme.

103/3
     function Decode (Item : UTF_8_String) return Wide_Wide_String;

104/3
          Returns the result of decoding Item, which is encoded in
          UTF-8.

105/3
     function Decode (Item : UTF_16_Wide_String) return Wide_Wide_String;

106/3
          Returns the result of decoding Item, which is encoded in
          UTF-16.

                        _Implementation Advice_

107/3
If an implementation supports other encoding schemes, another similar
child of Ada.Strings should be defined.

     NOTES

108/3
     18  A BOM (Byte-Order Mark, code position 16#FEFF#) can be included
     in a file or other entity to indicate the encoding; it is skipped
     when decoding.  Typically, only the first line of a file or other
     entity contains a BOM. When decoding, the Encoding function can be
     called on the first line to determine the encoding; this encoding
     will then be used in subsequent calls to Decode to convert all of
     the lines to an internal format.


File: arm2012.info,  Node: A.5,  Next: A.6,  Prev: A.4,  Up: Annex A

A.5 The Numerics Packages
=========================

1
The library package Numerics is the parent of several child units that
provide facilities for mathematical computation.  One child, the generic
package Generic_Elementary_Functions, is defined in *note A.5.1::,
together with nongeneric equivalents; two others, the package
Float_Random and the generic package Discrete_Random, are defined in
*note A.5.2::.  Additional (optional) children are defined in *note
Annex G::, "*note Annex G:: Numerics".

                          _Static Semantics_

2/1
<This paragraph was deleted.>

3/2
     package Ada.Numerics is
        pragma Pure(Numerics);
        Argument_Error : exception;
        Pi : constant :=
               3.14159_26535_89793_23846_26433_83279_50288_41971_69399_37511;
        PI  : constant := Pi;
        e  : constant :=
               2.71828_18284_59045_23536_02874_71352_66249_77572_47093_69996;
     end Ada.Numerics;

4
The Argument_Error exception is raised by a subprogram in a child unit
of Numerics to signal that one or more of the actual subprogram
parameters are outside the domain of the corresponding mathematical
function.

                     _Implementation Permissions_

5
The implementation may specify the values of Pi and e to a larger number
of significant digits.

* Menu:

* A.5.1 ::    Elementary Functions
* A.5.2 ::    Random Number Generation
* A.5.3 ::    Attributes of Floating Point Types
* A.5.4 ::    Attributes of Fixed Point Types


File: arm2012.info,  Node: A.5.1,  Next: A.5.2,  Up: A.5

A.5.1 Elementary Functions
--------------------------

1
Implementation-defined approximations to the mathematical functions
known as the "elementary functions" are provided by the subprograms in
Numerics.Generic_Elementary_Functions.  Nongeneric equivalents of this
generic package for each of the predefined floating point types are also
provided as children of Numerics.

                          _Static Semantics_

2
The generic library package Numerics.Generic_Elementary_Functions has
the following declaration:

3
     generic
        type Float_Type is digits <>;

     package Ada.Numerics.Generic_Elementary_Functions is
        pragma Pure(Generic_Elementary_Functions);

4
        function Sqrt    (X           : Float_Type'Base) return Float_Type'Base;
        function Log     (X           : Float_Type'Base) return Float_Type'Base;
        function Log     (X, Base     : Float_Type'Base) return Float_Type'Base;
        function Exp     (X           : Float_Type'Base) return Float_Type'Base;
        function "**"    (Left, Right : Float_Type'Base) return Float_Type'Base;

5
        function Sin     (X           : Float_Type'Base) return Float_Type'Base;
        function Sin     (X, Cycle    : Float_Type'Base) return Float_Type'Base;
        function Cos     (X           : Float_Type'Base) return Float_Type'Base;
        function Cos     (X, Cycle    : Float_Type'Base) return Float_Type'Base;
        function Tan     (X           : Float_Type'Base) return Float_Type'Base;
        function Tan     (X, Cycle    : Float_Type'Base) return Float_Type'Base;
        function Cot     (X           : Float_Type'Base) return Float_Type'Base;
        function Cot     (X, Cycle    : Float_Type'Base) return Float_Type'Base;

6
        function Arcsin  (X           : Float_Type'Base) return Float_Type'Base;
        function Arcsin  (X, Cycle    : Float_Type'Base) return Float_Type'Base;
        function Arccos  (X           : Float_Type'Base) return Float_Type'Base;
        function Arccos  (X, Cycle    : Float_Type'Base) return Float_Type'Base;
        function Arctan  (Y           : Float_Type'Base;
                          X           : Float_Type'Base := 1.0)
                                                         return Float_Type'Base;
        function Arctan  (Y           : Float_Type'Base;
                          X           : Float_Type'Base := 1.0;
                          Cycle       : Float_Type'Base) return Float_Type'Base;
        function Arccot  (X           : Float_Type'Base;
                          Y           : Float_Type'Base := 1.0)
                                                         return Float_Type'Base;
        function Arccot  (X           : Float_Type'Base;
                          Y           : Float_Type'Base := 1.0;
                          Cycle       : Float_Type'Base) return Float_Type'Base;

7
        function Sinh    (X           : Float_Type'Base) return Float_Type'Base;
        function Cosh    (X           : Float_Type'Base) return Float_Type'Base;
        function Tanh    (X           : Float_Type'Base) return Float_Type'Base;
        function Coth    (X           : Float_Type'Base) return Float_Type'Base;
        function Arcsinh (X           : Float_Type'Base) return Float_Type'Base;
        function Arccosh (X           : Float_Type'Base) return Float_Type'Base;
        function Arctanh (X           : Float_Type'Base) return Float_Type'Base;
        function Arccoth (X           : Float_Type'Base) return Float_Type'Base;

8
     end Ada.Numerics.Generic_Elementary_Functions;

9/1
The library package Numerics.Elementary_Functions is declared pure and
defines the same subprograms as Numerics.Generic_Elementary_Functions,
except that the predefined type Float is systematically substituted for
Float_Type'Base throughout.  Nongeneric equivalents of
Numerics.Generic_Elementary_Functions for each of the other predefined
floating point types are defined similarly, with the names
Numerics.Short_Elementary_Functions, Numerics.Long_Elementary_Functions,
etc.

10
The functions have their usual mathematical meanings.  When the Base
parameter is specified, the Log function computes the logarithm to the
given base; otherwise, it computes the natural logarithm.  When the
Cycle parameter is specified, the parameter X of the forward
trigonometric functions (Sin, Cos, Tan, and Cot) and the results of the
inverse trigonometric functions (Arcsin, Arccos, Arctan, and Arccot) are
measured in units such that a full cycle of revolution has the given
value; otherwise, they are measured in radians.

11
The computed results of the mathematically multivalued functions are
rendered single-valued by the following conventions, which are meant to
imply the principal branch:

12
   * The results of the Sqrt and Arccosh functions and that of the
     exponentiation operator are nonnegative.

13
   * The result of the Arcsin function is in the quadrant containing the
     point (1.0, <x>), where <x> is the value of the parameter X. This
     quadrant is I or IV; thus, the range of the Arcsin function is
     approximately -PI/2.0 to PI/2.0 (-Cycle/4.0 to Cycle/4.0, if the
     parameter Cycle is specified).

14
   * The result of the Arccos function is in the quadrant containing the
     point (<x>, 1.0), where <x> is the value of the parameter X. This
     quadrant is I or II; thus, the Arccos function ranges from 0.0 to
     approximately PI (Cycle/2.0, if the parameter Cycle is specified).

15
   * The results of the Arctan and Arccot functions are in the quadrant
     containing the point (<x>, <y>), where <x> and <y> are the values
     of the parameters X and Y, respectively.  This may be any quadrant
     (I through IV) when the parameter X (resp., Y) of Arctan (resp.,
     Arccot) is specified, but it is restricted to quadrants I and IV
     (resp., I and II) when that parameter is omitted.  Thus, the range
     when that parameter is specified is approximately -PI to PI
     (-Cycle/2.0 to Cycle/2.0, if the parameter Cycle is specified);
     when omitted, the range of Arctan (resp., Arccot) is that of Arcsin
     (resp., Arccos), as given above.  When the point (<x>, <y>) lies on
     the negative x-axis, the result approximates

16
        * PI (resp., -PI) when the sign of the parameter Y is positive
          (resp., negative), if Float_Type'Signed_Zeros is True;

17
        * PI, if Float_Type'Signed_Zeros is False.

18
(In the case of the inverse trigonometric functions, in which a result
lying on or near one of the axes may not be exactly representable, the
approximation inherent in computing the result may place it in an
adjacent quadrant, close to but on the wrong side of the axis.)

                          _Dynamic Semantics_

19
The exception Numerics.Argument_Error is raised, signaling a parameter
value outside the domain of the corresponding mathematical function, in
the following cases:

20
   * by any forward or inverse trigonometric function with specified
     cycle, when the value of the parameter Cycle is zero or negative;

21
   * by the Log function with specified base, when the value of the
     parameter Base is zero, one, or negative;

22
   * by the Sqrt and Log functions, when the value of the parameter X is
     negative;

23
   * by the exponentiation operator, when the value of the left operand
     is negative or when both operands have the value zero;

24
   * by the Arcsin, Arccos, and Arctanh functions, when the absolute
     value of the parameter X exceeds one;

25
   * by the Arctan and Arccot functions, when the parameters X and Y
     both have the value zero;

26
   * by the Arccosh function, when the value of the parameter X is less
     than one; and

27
   * by the Arccoth function, when the absolute value of the parameter X
     is less than one.

28
The exception Constraint_Error is raised, signaling a pole of the
mathematical function (analogous to dividing by zero), in the following
cases, provided that Float_Type'Machine_Overflows is True:

29
   * by the Log, Cot, and Coth functions, when the value of the
     parameter X is zero;

30
   * by the exponentiation operator, when the value of the left operand
     is zero and the value of the exponent is negative;

31
   * by the Tan function with specified cycle, when the value of the
     parameter X is an odd multiple of the quarter cycle;

32
   * by the Cot function with specified cycle, when the value of the
     parameter X is zero or a multiple of the half cycle; and

33
   * by the Arctanh and Arccoth functions, when the absolute value of
     the parameter X is one.

34
Constraint_Error can also be raised when a finite result overflows (see
*note G.2.4::); this may occur for parameter values sufficiently <near>
poles, and, in the case of some of the functions, for parameter values
with sufficiently large magnitudes.  When Float_Type'Machine_Overflows
is False, the result at poles is unspecified.

35
When one parameter of a function with multiple parameters represents a
pole and another is outside the function's domain, the latter takes
precedence (i.e., Numerics.Argument_Error is raised).

                     _Implementation Requirements_

36
In the implementation of Numerics.Generic_Elementary_Functions, the
range of intermediate values allowed during the calculation of a final
result shall not be affected by any range constraint of the subtype
Float_Type.

37
In the following cases, evaluation of an elementary function shall yield
the <prescribed result>, provided that the preceding rules do not call
for an exception to be raised:

38
   * When the parameter X has the value zero, the Sqrt, Sin, Arcsin,
     Tan, Sinh, Arcsinh, Tanh, and Arctanh functions yield a result of
     zero, and the Exp, Cos, and Cosh functions yield a result of one.

39
   * When the parameter X has the value one, the Sqrt function yields a
     result of one, and the Log, Arccos, and Arccosh functions yield a
     result of zero.

40
   * When the parameter Y has the value zero and the parameter X has a
     positive value, the Arctan and Arccot functions yield a result of
     zero.

41
   * The results of the Sin, Cos, Tan, and Cot functions with specified
     cycle are exact when the mathematical result is zero; those of the
     first two are also exact when the mathematical result is ± 1.0.

42
   * Exponentiation by a zero exponent yields the value one.
     Exponentiation by a unit exponent yields the value of the left
     operand.  Exponentiation of the value one yields the value one.
     Exponentiation of the value zero yields the value zero.

43
Other accuracy requirements for the elementary functions, which apply
only in implementations conforming to the Numerics Annex, and then only
in the "strict" mode defined there (see *note G.2::), are given in *note
G.2.4::.

44
When Float_Type'Signed_Zeros is True, the sign of a zero result shall be
as follows:

45
   * A prescribed zero result delivered <at the origin> by one of the
     odd functions (Sin, Arcsin, Sinh, Arcsinh, Tan, Arctan or Arccot as
     a function of Y when X is fixed and positive, Tanh, and Arctanh)
     has the sign of the parameter X (Y, in the case of Arctan or
     Arccot).

46
   * A prescribed zero result delivered by one of the odd functions
     <away from the origin>, or by some other elementary function, has
     an implementation-defined sign.

47
   * A zero result that is not a prescribed result (i.e., one that
     results from rounding or underflow) has the correct mathematical
     sign.

                     _Implementation Permissions_

48
The nongeneric equivalent packages may, but need not, be actual
instantiations of the generic package for the appropriate predefined
type.


File: arm2012.info,  Node: A.5.2,  Next: A.5.3,  Prev: A.5.1,  Up: A.5

A.5.2 Random Number Generation
------------------------------

1
Facilities for the generation of pseudo-random floating point numbers
are provided in the package Numerics.Float_Random; the generic package
Numerics.Discrete_Random provides similar facilities for the generation
of pseudo-random integers and pseudo-random values of enumeration types.
For brevity, pseudo-random values of any of these types are called
<random numbers>.

2
Some of the facilities provided are basic to all applications of random
numbers.  These include a limited private type each of whose objects
serves as the generator of a (possibly distinct) sequence of random
numbers; a function to obtain the "next" random number from a given
sequence of random numbers (that is, from its generator); and
subprograms to initialize or reinitialize a given generator to a
time-dependent state or a state denoted by a single integer.

3
Other facilities are provided specifically for advanced applications.
These include subprograms to save and restore the state of a given
generator; a private type whose objects can be used to hold the saved
state of a generator; and subprograms to obtain a string representation
of a given generator state, or, given such a string representation, the
corresponding state.

                          _Static Semantics_

4
The library package Numerics.Float_Random has the following declaration:

5
     package Ada.Numerics.Float_Random is

6
        -- <Basic facilities>

7
        type Generator is limited private;

8
        subtype Uniformly_Distributed is Float range 0.0 .. 1.0;
        function Random (Gen : Generator) return Uniformly_Distributed;

9
        procedure Reset (Gen       : in Generator;
                         Initiator : in Integer);
        procedure Reset (Gen       : in Generator);

10
        -- <Advanced facilities>

11
        type State is private;

12
        procedure Save  (Gen        : in  Generator;
                         To_State   : out State);
        procedure Reset (Gen        : in  Generator;
                         From_State : in  State);

13
        Max_Image_Width : constant := <implementation-defined integer value>;

14
        function Image (Of_State    : State)  return String;
        function Value (Coded_State : String) return State;

15
     private
        ... -- <not specified by the language>
     end Ada.Numerics.Float_Random;

15.1/2
The type Generator needs finalization (see *note 7.6::).

16
The generic library package Numerics.Discrete_Random has the following
declaration:

17

     generic
        type Result_Subtype is (<>);
     package Ada.Numerics.Discrete_Random is

18
        -- <Basic facilities>

19
        type Generator is limited private;

20
        function Random (Gen : Generator) return Result_Subtype;

21
        procedure Reset (Gen       : in Generator;
                         Initiator : in Integer);
        procedure Reset (Gen       : in Generator);

22
        -- <Advanced facilities>

23
        type State is private;

24
        procedure Save  (Gen        : in  Generator;
                         To_State   : out State);
        procedure Reset (Gen        : in  Generator;
                         From_State : in  State);

25
        Max_Image_Width : constant := <implementation-defined integer value>;

26
        function Image (Of_State    : State)  return String;
        function Value (Coded_State : String) return State;

27
     private
        ... -- <not specified by the language>
     end Ada.Numerics.Discrete_Random;

27.1/2
The type Generator needs finalization (see *note 7.6::) in every
instantiation of Numerics.Discrete_Random.

28
An object of the limited private type Generator is associated with a
sequence of random numbers.  Each generator has a hidden (internal)
state, which the operations on generators use to determine the position
in the associated sequence.  All generators are implicitly initialized
to an unspecified state that does not vary from one program execution to
another; they may also be explicitly initialized, or reinitialized, to a
time-dependent state, to a previously saved state, or to a state
uniquely denoted by an integer value.

29/3
An object of the private type State can be used to hold the internal
state of a generator.  Such objects are only needed if the application
is designed to save and restore generator states or to examine or
manufacture them.  The implicit initial value of type State corresponds
to the implicit initial value of all generators.

30
The operations on generators affect the state and therefore the future
values of the associated sequence.  The semantics of the operations on
generators and states are defined below.

31
     function Random (Gen : Generator) return Uniformly_Distributed;
     function Random (Gen : Generator) return Result_Subtype;

32
          Obtains the "next" random number from the given generator,
          relative to its current state, according to an
          implementation-defined algorithm.  The result of the function
          in Numerics.Float_Random is delivered as a value of the
          subtype Uniformly_Distributed, which is a subtype of the
          predefined type Float having a range of 0.0 ..  1.0.  The
          result of the function in an instantiation of
          Numerics.Discrete_Random is delivered as a value of the
          generic formal subtype Result_Subtype.

33
     procedure Reset (Gen       : in Generator;
                      Initiator : in Integer);
     procedure Reset (Gen       : in Generator);

34
          Sets the state of the specified generator to one that is an
          unspecified function of the value of the parameter Initiator
          (or to a time-dependent state, if only a generator parameter
          is specified).  The latter form of the procedure is known as
          the <time-dependent Reset procedure>.

35
     procedure Save  (Gen        : in  Generator;
                      To_State   : out State);
     procedure Reset (Gen        : in  Generator;
                      From_State : in  State);

36
          Save obtains the current state of a generator.  Reset gives a
          generator the specified state.  A generator that is reset to a
          state previously obtained by invoking Save is restored to the
          state it had when Save was invoked.

37
     function Image (Of_State    : State)  return String;
     function Value (Coded_State : String) return State;

38
          Image provides a representation of a state coded (in an
          implementation-defined way) as a string whose length is
          bounded by the value of Max_Image_Width.  Value is the inverse
          of Image: Value(Image(S)) = S for each state S that can be
          obtained from a generator by invoking Save.

                          _Dynamic Semantics_

39
Instantiation of Numerics.Discrete_Random with a subtype having a null
range raises Constraint_Error.

40/1
<This paragraph was deleted.>

                      _Bounded (Run-Time) Errors_

40.1/1
It is a bounded error to invoke Value with a string that is not the
image of any generator state.  If the error is detected,
Constraint_Error or Program_Error is raised.  Otherwise, a call to Reset
with the resulting state will produce a generator such that calls to
Random with this generator will produce a sequence of values of the
appropriate subtype, but which might not be random in character.  That
is, the sequence of values might not fulfill the implementation
requirements of this subclause.

                     _Implementation Requirements_

41
A sufficiently long sequence of random numbers obtained by successive
calls to Random is approximately uniformly distributed over the range of
the result subtype.

42
The Random function in an instantiation of Numerics.Discrete_Random is
guaranteed to yield each value in its result subtype in a finite number
of calls, provided that the number of such values does not exceed 2 15.

43
Other performance requirements for the random number generator, which
apply only in implementations conforming to the Numerics Annex, and then
only in the "strict" mode defined there (see *note G.2::), are given in
*note G.2.5::.

                     _Documentation Requirements_

44
No one algorithm for random number generation is best for all
applications.  To enable the user to determine the suitability of the
random number generators for the intended application, the
implementation shall describe the algorithm used and shall give its
period, if known exactly, or a lower bound on the period, if the exact
period is unknown.  Periods that are so long that the periodicity is
unobservable in practice can be described in such terms, without giving
a numerical bound.

45
The implementation also shall document the minimum time interval between
calls to the time-dependent Reset procedure that are guaranteed to
initiate different sequences, and it shall document the nature of the
strings that Value will accept without raising Constraint_Error.

                        _Implementation Advice_

46
Any storage associated with an object of type Generator should be
reclaimed on exit from the scope of the object.

47
If the generator period is sufficiently long in relation to the number
of distinct initiator values, then each possible value of Initiator
passed to Reset should initiate a sequence of random numbers that does
not, in a practical sense, overlap the sequence initiated by any other
value.  If this is not possible, then the mapping between initiator
values and generator states should be a rapidly varying function of the
initiator value.

     NOTES

48
     19  If two or more tasks are to share the same generator, then the
     tasks have to synchronize their access to the generator as for any
     shared variable (see *note 9.10::).

49
     20  Within a given implementation, a repeatable random number
     sequence can be obtained by relying on the implicit initialization
     of generators or by explicitly initializing a generator with a
     repeatable initiator value.  Different sequences of random numbers
     can be obtained from a given generator in different program
     executions by explicitly initializing the generator to a
     time-dependent state.

50
     21  A given implementation of the Random function in
     Numerics.Float_Random may or may not be capable of delivering the
     values 0.0 or 1.0.  Portable applications should assume that these
     values, or values sufficiently close to them to behave
     indistinguishably from them, can occur.  If a sequence of random
     integers from some fixed range is needed, the application should
     use the Random function in an appropriate instantiation of
     Numerics.Discrete_Random, rather than transforming the result of
     the Random function in Numerics.Float_Random.  However, some
     applications with unusual requirements, such as for a sequence of
     random integers each drawn from a different range, will find it
     more convenient to transform the result of the floating point
     Random function.  For M >= 1, the expression

51
             Integer(Float(M) * Random(G)) mod M

52
     transforms the result of Random(G) to an integer uniformly
     distributed over the range 0 ..  M-1; it is valid even if Random
     delivers 0.0 or 1.0.  Each value of the result range is possible,
     provided that M is not too large.  Exponentially distributed
     (floating point) random numbers with mean and standard deviation
     1.0 can be obtained by the transformation

53/2
             -Log(Random(G) + Float'Model_Small)

54
     where Log comes from Numerics.Elementary_Functions (see *note
     A.5.1::); in this expression, the addition of Float'Model_Small
     avoids the exception that would be raised were Log to be given the
     value zero, without affecting the result (in most implementations)
     when Random returns a nonzero value.

                              _Examples_

55
<Example of a program that plays a simulated dice game:>

56
     with Ada.Numerics.Discrete_Random;
     procedure Dice_Game is
        subtype Die is Integer range 1 .. 6;
        subtype Dice is Integer range 2*Die'First .. 2*Die'Last;
        package Random_Die is new Ada.Numerics.Discrete_Random (Die);
        use Random_Die;
        G : Generator;
        D : Dice;
     begin
        Reset (G);  -- <Start the generator in a unique state in each run>
        loop
           -- <Roll a pair of dice; sum and process the results>
           D := Random(G) + Random(G);
           ...
        end loop;
     end Dice_Game;

57
<Example of a program that simulates coin tosses:>

58
     with Ada.Numerics.Discrete_Random;
     procedure Flip_A_Coin is
        type Coin is (Heads, Tails);
        package Random_Coin is new Ada.Numerics.Discrete_Random (Coin);
        use Random_Coin;
        G : Generator;
     begin
        Reset (G);  -- <Start the generator in a unique state in each run>
        loop
           -- <Toss a coin and process the result>
           case Random(G) is
               when Heads =>
                  ...
               when Tails =>
                  ...
           end case;
        ...
        end loop;
     end Flip_A_Coin;

59
<Example of a parallel simulation of a physical system, with a separate
generator of event probabilities in each task:>

60
     with Ada.Numerics.Float_Random;
     procedure Parallel_Simulation is
        use Ada.Numerics.Float_Random;
        task type Worker is
           entry Initialize_Generator (Initiator : in Integer);
           ...
        end Worker;
        W : array (1 .. 10) of Worker;
        task body Worker is
           G : Generator;
           Probability_Of_Event : Uniformly_Distributed;
        begin
           accept Initialize_Generator (Initiator : in Integer) do
              Reset (G, Initiator);
           end Initialize_Generator;
           loop
              ...
              Probability_Of_Event := Random(G);
              ...
           end loop;
        end Worker;
     begin
        -- <Initialize the generators in the Worker tasks to different states>
        for I in W'Range loop
           W(I).Initialize_Generator (I);
        end loop;
        ... -- <Wait for the Worker tasks to terminate>
     end Parallel_Simulation;

     NOTES

61
     22  <Notes on the last example:> Although each Worker task
     initializes its generator to a different state, those states will
     be the same in every execution of the program.  The generator
     states can be initialized uniquely in each program execution by
     instantiating Ada.Numerics.Discrete_Random for the type Integer in
     the main procedure, resetting the generator obtained from that
     instance to a time-dependent state, and then using random integers
     obtained from that generator to initialize the generators in each
     Worker task.


File: arm2012.info,  Node: A.5.3,  Next: A.5.4,  Prev: A.5.2,  Up: A.5

A.5.3 Attributes of Floating Point Types
----------------------------------------

                          _Static Semantics_

1
The following <representation-oriented attributes> are defined for every
subtype S of a floating point type <T>.

2
S'Machine_Radix
               Yields the radix of the hardware representation of the
               type <T>.  The value of this attribute is of the type
               <universal_integer>.

3
The values of other representation-oriented attributes of a floating
point subtype, and of the "primitive function" attributes of a floating
point subtype described later, are defined in terms of a particular
representation of nonzero values called the <canonical form>.  The
canonical form (for the type <T>) is the form
    ± <mantissa> · <T>'Machine_Radix<exponent>
where

4
   * <mantissa> is a fraction in the number base <T>'Machine_Radix, the
     first digit of which is nonzero, and

5
   * <exponent> is an integer.

6
S'Machine_Mantissa
               Yields the largest value of <p> such that every value
               expressible in the canonical form (for the type <T>),
               having a <p>-digit <mantissa> and an <exponent> between
               <T>'Machine_Emin and <T>'Machine_Emax, is a machine
               number (see *note 3.5.7::) of the type <T>.  This
               attribute yields a value of the type <universal_integer>.

7
S'Machine_Emin
               Yields the smallest (most negative) value of <exponent>
               such that every value expressible in the canonical form
               (for the type <T>), having a <mantissa> of
               <T>'Machine_Mantissa digits, is a machine number (see
               *note 3.5.7::) of the type <T>.  This attribute yields a
               value of the type <universal_integer>.

8
S'Machine_Emax
               Yields the largest (most positive) value of <exponent>
               such that every value expressible in the canonical form
               (for the type <T>), having a <mantissa> of
               <T>'Machine_Mantissa digits, is a machine number (see
               *note 3.5.7::) of the type <T>.  This attribute yields a
               value of the type <universal_integer>.

9
S'Denorm
               Yields the value True if every value expressible in the
               form
                   ± <mantissa> · <T>'Machine_Radix<T>'Machine_Emin
               where <mantissa> is a nonzero <T>'Machine_Mantissa-digit
               fraction in the number base <T>'Machine_Radix, the first
               digit of which is zero, is a machine number (see *note
               3.5.7::) of the type <T>; yields the value False
               otherwise.  The value of this attribute is of the
               predefined type Boolean.

10
The values described by the formula in the definition of S'Denorm are
called <denormalized numbers>.  A nonzero machine number that is not a
denormalized number is a <normalized number>.  A normalized number <x>
of a given type <T> is said to be <represented in canonical form> when
it is expressed in the canonical form (for the type <T>) with a
<mantissa> having <T>'Machine_Mantissa digits; the resulting form is the
<canonical-form representation> of <x>.

11
S'Machine_Rounds
               Yields the value True if rounding is performed on inexact
               results of every predefined operation that yields a
               result of the type <T>; yields the value False otherwise.
               The value of this attribute is of the predefined type
               Boolean.

12
S'Machine_Overflows
               Yields the value True if overflow and divide-by-zero are
               detected and reported by raising Constraint_Error for
               every predefined operation that yields a result of the
               type <T>; yields the value False otherwise.  The value of
               this attribute is of the predefined type Boolean.

13
S'Signed_Zeros
               Yields the value True if the hardware representation for
               the type <T> has the capability of representing both
               positively and negatively signed zeros, these being
               generated and used by the predefined operations of the
               type <T> as specified in IEC 559:1989; yields the value
               False otherwise.  The value of this attribute is of the
               predefined type Boolean.

14
For every value <x> of a floating point type <T>, the <normalized
exponent> of <x> is defined as follows:

15
   * the normalized exponent of zero is (by convention) zero;

16
   * for nonzero <x>, the normalized exponent of <x> is the unique
     integer <k> such that <T>'Machine_Radix<k>-1 <= |<x>| <
     <T>'Machine_Radix<k>.

17
The following <primitive function attributes> are defined for any
subtype S of a floating point type <T>.

18
S'Exponent
               S'Exponent denotes a function with the following
               specification:

19
                    function S'Exponent (<X> : <T>)
                      return <universal_integer>

20
               The function yields the normalized exponent of <X>.

21
S'Fraction
               S'Fraction denotes a function with the following
               specification:

22
                    function S'Fraction (<X> : <T>)
                      return <T>

23
               The function yields the value <X> ·
               <T>'Machine_Radix-<k>, where <k> is the normalized
               exponent of <X>.  A zero result, which can only occur
               when <X> is zero, has the sign of <X>.

24
S'Compose
               S'Compose denotes a function with the following
               specification:

25
                    function S'Compose (<Fraction> : <T>;
                                        <Exponent> : <universal_integer>)
                      return <T>

26
               Let <v> be the value <Fraction> ·
               <T>'Machine_Radix<Exponent>-<k>, where <k> is the
               normalized exponent of <Fraction>.  If <v> is a machine
               number of the type <T>, or if |<v>| >= <T>'Model_Small,
               the function yields <v>; otherwise, it yields either one
               of the machine numbers of the type <T> adjacent to <v>.  
               Constraint_Error is optionally raised if <v> is outside
               the base range of S. A zero result has the sign of
               <Fraction> when S'Signed_Zeros is True.

27
S'Scaling
               S'Scaling denotes a function with the following
               specification:

28
                    function S'Scaling (<X> : <T>;
                                        <Adjustment> : <universal_integer>)
                      return <T>

29
               Let <v> be the value <X> · <T>'Machine_Radix<Adjustment>.
               If <v> is a machine number of the type <T>, or if |<v>|
               >= <T>'Model_Small, the function yields <v>; otherwise,
               it yields either one of the machine numbers of the type
               <T> adjacent to <v>.  Constraint_Error is optionally
               raised if <v> is outside the base range of S. A zero
               result has the sign of <X> when S'Signed_Zeros is True.

30
S'Floor
               S'Floor denotes a function with the following
               specification:

31
                    function S'Floor (<X> : <T>)
                      return <T>

32
               The function yields the value 'floor(<X>)', i.e., the
               largest (most positive) integral value less than or equal
               to <X>.  When <X> is zero, the result has the sign of
               <X>; a zero result otherwise has a positive sign.

33
S'Ceiling
               S'Ceiling denotes a function with the following
               specification:

34
                    function S'Ceiling (<X> : <T>)
                      return <T>

35
               The function yields the value 'ceiling(<X>)', i.e., the
               smallest (most negative) integral value greater than or
               equal to <X>.  When <X> is zero, the result has the sign
               of <X>; a zero result otherwise has a negative sign when
               S'Signed_Zeros is True.

36
S'Rounding
               S'Rounding denotes a function with the following
               specification:

37
                    function S'Rounding (<X> : <T>)
                      return <T>

38
               The function yields the integral value nearest to <X>,
               rounding away from zero if <X> lies exactly halfway
               between two integers.  A zero result has the sign of <X>
               when S'Signed_Zeros is True.

39
S'Unbiased_Rounding
               S'Unbiased_Rounding denotes a function with the following
               specification:

40
                    function S'Unbiased_Rounding (<X> : <T>)
                      return <T>

41
               The function yields the integral value nearest to <X>,
               rounding toward the even integer if <X> lies exactly
               halfway between two integers.  A zero result has the sign
               of <X> when S'Signed_Zeros is True.

41.1/2
S'Machine_Rounding
               S'Machine_Rounding denotes a function with the following
               specification:

41.2/2
                    function S'Machine_Rounding (<X> : <T>)
                      return <T>

41.3/2
               The function yields the integral value nearest to <X>.
               If <X> lies exactly halfway between two integers, one of
               those integers is returned, but which of them is returned
               is unspecified.  A zero result has the sign of <X> when
               S'Signed_Zeros is True.  This function provides access to
               the rounding behavior which is most efficient on the
               target processor.

42
S'Truncation
               S'Truncation denotes a function with the following
               specification:

43
                    function S'Truncation (<X> : <T>)
                      return <T>

44
               The function yields the value 'ceiling(<X>)' when <X> is
               negative, and 'floor(<X>)' otherwise.  A zero result has
               the sign of <X> when S'Signed_Zeros is True.

45
S'Remainder
               S'Remainder denotes a function with the following
               specification:

46
                    function S'Remainder (<X>, <Y> : <T>)
                      return <T>

47
               For nonzero <Y>, let <v> be the value <X> - <n> · <Y>,
               where <n> is the integer nearest to the exact value of
               <X>/<Y>; if |<n> - <X>/<Y>| = 1/2, then <n> is chosen to
               be even.  If <v> is a machine number of the type <T>, the
               function yields <v>; otherwise, it yields zero.  
               Constraint_Error is raised if <Y> is zero.  A zero result
               has the sign of <X> when S'Signed_Zeros is True.

48
S'Adjacent
               S'Adjacent denotes a function with the following
               specification:

49
                    function S'Adjacent (<X>, <Towards> : <T>)
                      return <T>

50
               If <Towards> = <X>, the function yields <X>; otherwise,
               it yields the machine number of the type <T> adjacent to
               <X> in the direction of <Towards>, if that machine number
               exists.  If the result would be outside the base range of
               S, Constraint_Error is raised.  When <T>'Signed_Zeros is
               True, a zero result has the sign of <X>.  When <Towards>
               is zero, its sign has no bearing on the result.

51
S'Copy_Sign
               S'Copy_Sign denotes a function with the following
               specification:

52
                    function S'Copy_Sign (<Value>, <Sign> : <T>)
                      return <T>

53
               If the value of <Value> is nonzero, the function yields a
               result whose magnitude is that of <Value> and whose sign
               is that of <Sign>; otherwise, it yields the value zero.  
               Constraint_Error is optionally raised if the result is
               outside the base range of S. A zero result has the sign
               of <Sign> when S'Signed_Zeros is True.

54
S'Leading_Part
               S'Leading_Part denotes a function with the following
               specification:

55
                    function S'Leading_Part (<X> : <T>;
                                             <Radix_Digits> : <universal_integer>)
                      return <T>

56
               Let <v> be the value <T>'Machine_Radix<k>-<Radix_Digits>,
               where <k> is the normalized exponent of <X>.  The
               function yields the value

57
                  * 'floor(<X>/<v>)' · <v>, when <X> is nonnegative and
                    <Radix_Digits> is positive;

58
                  * 'ceiling(<X>/<v>)' · <v>, when <X> is negative and
                    <Radix_Digits> is positive.

59
               Constraint_Error is raised when <Radix_Digits> is zero or
               negative.  A zero result, which can only occur when <X>
               is zero, has the sign of <X>.

60
S'Machine
               S'Machine denotes a function with the following
               specification:

61
                    function S'Machine (<X> : <T>)
                      return <T>

62
               If <X> is a machine number of the type <T>, the function
               yields <X>; otherwise, it yields the value obtained by
               rounding or truncating <X> to either one of the adjacent
               machine numbers of the type <T>.  Constraint_Error is
               raised if rounding or truncating <X> to the precision of
               the machine numbers results in a value outside the base
               range of S. A zero result has the sign of <X> when
               S'Signed_Zeros is True.

63
The following <model-oriented attributes> are defined for any subtype S
of a floating point type <T>.

64
S'Model_Mantissa
               If the Numerics Annex is not supported, this attribute
               yields an implementation defined value that is greater
               than or equal to 'ceiling(<d> · log(10) /
               log(<T>'Machine_Radix))' + 1, where <d> is the requested
               decimal precision of <T>, and less than or equal to the
               value of <T>'Machine_Mantissa.  See *note G.2.2:: for
               further requirements that apply to implementations
               supporting the Numerics Annex.  The value of this
               attribute is of the type <universal_integer>.

65
S'Model_Emin
               If the Numerics Annex is not supported, this attribute
               yields an implementation defined value that is greater
               than or equal to the value of <T>'Machine_Emin.  See
               *note G.2.2:: for further requirements that apply to
               implementations supporting the Numerics Annex.  The value
               of this attribute is of the type <universal_integer>.

66
S'Model_Epsilon
               Yields the value <T>'Machine_Radix1 - <T>'Model_Mantissa.
               The value of this attribute is of the type
               <universal_real>.

67
S'Model_Small
               Yields the value <T>'Machine_Radix<T>'Model_Emin - 1.
               The value of this attribute is of the type
               <universal_real>.

68
S'Model
               S'Model denotes a function with the following
               specification:

69
                    function S'Model (<X> : <T>)
                      return <T>

70
               If the Numerics Annex is not supported, the meaning of
               this attribute is implementation defined; see *note
               G.2.2:: for the definition that applies to
               implementations supporting the Numerics Annex.

71
S'Safe_First
               Yields the lower bound of the safe range (see *note
               3.5.7::) of the type <T>.  If the Numerics Annex is not
               supported, the value of this attribute is implementation
               defined; see *note G.2.2:: for the definition that
               applies to implementations supporting the Numerics Annex.
               The value of this attribute is of the type
               <universal_real>.

72
S'Safe_Last
               Yields the upper bound of the safe range (see *note
               3.5.7::) of the type <T>.  If the Numerics Annex is not
               supported, the value of this attribute is implementation
               defined; see *note G.2.2:: for the definition that
               applies to implementations supporting the Numerics Annex.
               The value of this attribute is of the type
               <universal_real>.


File: arm2012.info,  Node: A.5.4,  Prev: A.5.3,  Up: A.5

A.5.4 Attributes of Fixed Point Types
-------------------------------------

                          _Static Semantics_

1
The following <representation-oriented> attributes are defined for every
subtype S of a fixed point type <T>.

2
S'Machine_Radix
               Yields the radix of the hardware representation of the
               type <T>.  The value of this attribute is of the type
               <universal_integer>.

3
S'Machine_Rounds
               Yields the value True if rounding is performed on inexact
               results of every predefined operation that yields a
               result of the type <T>; yields the value False otherwise.
               The value of this attribute is of the predefined type
               Boolean.

4
S'Machine_Overflows
               Yields the value True if overflow and divide-by-zero are
               detected and reported by raising Constraint_Error for
               every predefined operation that yields a result of the
               type <T>; yields the value False otherwise.  The value of
               this attribute is of the predefined type Boolean.


File: arm2012.info,  Node: A.6,  Next: A.7,  Prev: A.5,  Up: Annex A

A.6 Input-Output
================

1/2
Input-output is provided through language-defined packages, each of
which is a child of the root package Ada.  The generic packages
Sequential_IO and Direct_IO define input-output operations applicable to
files containing elements of a given type.  The generic package
Storage_IO supports reading from and writing to an in-memory buffer.
Additional operations for text input-output are supplied in the packages
Text_IO, Wide_Text_IO, and Wide_Wide_Text_IO. Heterogeneous input-output
is provided through the child packages Streams.Stream_IO and
Text_IO.Text_Streams (see also *note 13.13::).  The package
IO_Exceptions defines the exceptions needed by the predefined
input-output packages.


File: arm2012.info,  Node: A.7,  Next: A.8,  Prev: A.6,  Up: Annex A

A.7 External Files and File Objects
===================================

                          _Static Semantics_

1
Values input from the external environment of the program, or output to
the external environment, are considered to occupy <external files>.  An
external file can be anything external to the program that can produce a
value to be read or receive a value to be written.  An external file is
identified by a string (the <name>).  A second string (the <form>) gives
further system-dependent characteristics that may be associated with the
file, such as the physical organization or access rights.  The
conventions governing the interpretation of such strings shall be
documented.

2/3
Input and output operations are expressed as operations on objects of
some <file type>, rather than directly in terms of the external files.
In the remainder of this clause, the term <file> is always used to refer
to a file object; the term <external file> is used otherwise.

3
Input-output for sequential files of values of a single element type is
defined by means of the generic package Sequential_IO. In order to
define sequential input-output for a given element type, an
instantiation of this generic unit, with the given type as actual
parameter, has to be declared.  The resulting package contains the
declaration of a file type (called File_Type) for files of such
elements, as well as the operations applicable to these files, such as
the Open, Read, and Write procedures.

4/2
Input-output for direct access files is likewise defined by a generic
package called Direct_IO. Input-output in human-readable form is defined
by the (nongeneric) packages Text_IO for Character and String data,
Wide_Text_IO for Wide_Character and Wide_String data, and
Wide_Wide_Text_IO for Wide_Wide_Character and Wide_Wide_String data.
Input-output for files containing streams of elements representing
values of possibly different types is defined by means of the
(nongeneric) package Streams.Stream_IO.

5
Before input or output operations can be performed on a file, the file
first has to be associated with an external file.  While such an
association is in effect, the file is said to be <open>, and otherwise
the file is said to be <closed>.

6
The language does not define what happens to external files after the
completion of the main program and all the library tasks (in particular,
if corresponding files have not been closed).  The effect of
input-output for access types is unspecified.

7
An open file has a <current mode>, which is a value of one of the
following enumeration types:

8
     type File_Mode is (In_File, Inout_File, Out_File);  --<  for Direct_IO>

9
          These values correspond respectively to the cases where only
          reading, both reading and writing, or only writing are to be
          performed.

10/2
     type File_Mode is (In_File, Out_File, Append_File);
     --<  for Sequential_IO, Text_IO, Wide_Text_IO, Wide_Wide_Text_IO, and Stream_IO>

11
          These values correspond respectively to the cases where only
          reading, only writing, or only appending are to be performed.

12
          The mode of a file can be changed.

13/2
Several file management operations are common to Sequential_IO,
Direct_IO, Text_IO, Wide_Text_IO, and Wide_Wide_Text_IO. These
operations are described in subclause *note A.8.2:: for sequential and
direct files.  Any additional effects concerning text input-output are
described in subclause *note A.10.2::.

14/3
The exceptions that can be propagated by the execution of an
input-output subprogram are defined in the package IO_Exceptions; the
situations in which they can be propagated are described following the
description of the subprogram (and in subclause *note A.13::).  The
exceptions Storage_Error and Program_Error may be propagated.
(Program_Error can only be propagated due to errors made by the caller
of the subprogram.)  Finally, exceptions can be propagated in certain
implementation-defined situations.

     NOTES

15/2
     23  Each instantiation of the generic packages Sequential_IO and
     Direct_IO declares a different type File_Type.  In the case of
     Text_IO, Wide_Text_IO, Wide_Wide_Text_IO, and Streams.Stream_IO,
     the corresponding type File_Type is unique.

16
     24  A bidirectional device can often be modeled as two sequential
     files associated with the device, one of mode In_File, and one of
     mode Out_File.  An implementation may restrict the number of files
     that may be associated with a given external file.


File: arm2012.info,  Node: A.8,  Next: A.9,  Prev: A.7,  Up: Annex A

A.8 Sequential and Direct Files
===============================

                          _Static Semantics_

1/2
Two kinds of access to external files are defined in this subclause:
<sequential access> and <direct access>.  The corresponding file types
and the associated operations are provided by the generic packages
Sequential_IO and Direct_IO. A file object to be used for sequential
access is called a <sequential file>, and one to be used for direct
access is called a <direct file>.  Access to <stream file>s is described
in *note A.12.1::.

2
For sequential access, the file is viewed as a sequence of values that
are transferred in the order of their appearance (as produced by the
program or by the external environment).  When the file is opened with
mode In_File or Out_File, transfer starts respectively from or to the
beginning of the file.  When the file is opened with mode Append_File,
transfer to the file starts after the last element of the file.

3
For direct access, the file is viewed as a set of elements occupying
consecutive positions in linear order; a value can be transferred to or
from an element of the file at any selected position.  The position of
an element is specified by its <index>, which is a number, greater than
zero, of the implementation-defined integer type Count.  The first
element, if any, has index one; the index of the last element, if any,
is called the <current size>; the current size is zero if there are no
elements.  The current size is a property of the external file.

4
An open direct file has a <current index>, which is the index that will
be used by the next read or write operation.  When a direct file is
opened, the current index is set to one.  The current index of a direct
file is a property of a file object, not of an external file.

* Menu:

* A.8.1 ::    The Generic Package Sequential_IO
* A.8.2 ::    File Management
* A.8.3 ::    Sequential Input-Output Operations
* A.8.4 ::    The Generic Package Direct_IO
* A.8.5 ::    Direct Input-Output Operations


File: arm2012.info,  Node: A.8.1,  Next: A.8.2,  Up: A.8

A.8.1 The Generic Package Sequential_IO
---------------------------------------

                          _Static Semantics_

1
The generic library package Sequential_IO has the following declaration:

2
     with Ada.IO_Exceptions;
     generic
        type Element_Type(<>) is private;
     package Ada.Sequential_IO is

3
        type File_Type is limited private;

4
        type File_Mode is (In_File, Out_File, Append_File);

5
        <-- File management>

6
        procedure Create(File : in out File_Type;
                         Mode : in File_Mode := Out_File;
                         Name : in String := "";
                         Form : in String := "");

7
        procedure Open  (File : in out File_Type;
                         Mode : in File_Mode;
                         Name : in String;
                         Form : in String := "");

8
        procedure Close (File : in out File_Type);
        procedure Delete(File : in out File_Type);
        procedure Reset (File : in out File_Type; Mode : in File_Mode);
        procedure Reset (File : in out File_Type);

9
        function Mode   (File : in File_Type) return File_Mode;
        function Name   (File : in File_Type) return String;
        function Form   (File : in File_Type) return String;

10
        function Is_Open(File : in File_Type) return Boolean;

10.1/4
        procedure Flush (File : in File_Type);

11
        --< Input and output operations>

12
        procedure Read  (File : in File_Type; Item : out Element_Type);
        procedure Write (File : in File_Type; Item : in Element_Type);

13
        function End_Of_File(File : in File_Type) return Boolean;

14
        --< Exceptions>

15
        Status_Error : exception renames IO_Exceptions.Status_Error;
        Mode_Error   : exception renames IO_Exceptions.Mode_Error;
        Name_Error   : exception renames IO_Exceptions.Name_Error;
        Use_Error    : exception renames IO_Exceptions.Use_Error;
        Device_Error : exception renames IO_Exceptions.Device_Error;
        End_Error    : exception renames IO_Exceptions.End_Error;
        Data_Error   : exception renames IO_Exceptions.Data_Error;

16
     private
        ... -- <not specified by the language>
     end Ada.Sequential_IO;

17/2
The type File_Type needs finalization (see *note 7.6::) in every
instantiation of Sequential_IO.


File: arm2012.info,  Node: A.8.2,  Next: A.8.3,  Prev: A.8.1,  Up: A.8

A.8.2 File Management
---------------------

                          _Static Semantics_

1
The procedures and functions described in this subclause provide for the
control of external files; their declarations are repeated in each of
the packages for sequential, direct, text, and stream input-output.  For
text input-output, the procedures Create, Open, and Reset have
additional effects described in subclause *note A.10.2::.

2
     procedure Create(File : in out File_Type;
                      Mode : in File_Mode := <default_mode>;
                      Name : in String := "";
                      Form : in String := "");

3/2
          Establishes a new external file, with the given name and form,
          and associates this external file with the given file.  The
          given file is left open.  The current mode of the given file
          is set to the given access mode.  The default access mode is
          the mode Out_File for sequential, stream, and text
          input-output; it is the mode Inout_File for direct
          input-output.  For direct access, the size of the created file
          is implementation defined.

4
          A null string for Name specifies an external file that is not
          accessible after the completion of the main program (a
          temporary file).  A null string for Form specifies the use of
          the default options of the implementation for the external
          file.

5
          The exception Status_Error is propagated if the given file is
          already open.  The exception Name_Error is propagated if the
          string given as Name does not allow the identification of an
          external file.  The exception Use_Error is propagated if, for
          the specified mode, the external environment does not support
          creation of an external file with the given name (in the
          absence of Name_Error) and form.

6
     procedure Open(File : in out File_Type;
                    Mode : in File_Mode;
                    Name : in String;
                    Form : in String := "");

7
          Associates the given file with an existing external file
          having the given name and form, and sets the current mode of
          the given file to the given mode.  The given file is left
          open.

8
          The exception Status_Error is propagated if the given file is
          already open.  The exception Name_Error is propagated if the
          string given as Name does not allow the identification of an
          external file; in particular, this exception is propagated if
          no external file with the given name exists.  The exception
          Use_Error is propagated if, for the specified mode, the
          external environment does not support opening for an external
          file with the given name (in the absence of Name_Error) and
          form.

9
     procedure Close(File : in out File_Type);

10
          Severs the association between the given file and its
          associated external file.  The given file is left closed.  In
          addition, for sequential files, if the file being closed has
          mode Out_File or Append_File, then the last element written
          since the most recent open or reset is the last element that
          can be read from the file.  If no elements have been written
          and the file mode is Out_File, then the closed file is empty.
          If no elements have been written and the file mode is
          Append_File, then the closed file is unchanged.

11
          The exception Status_Error is propagated if the given file is
          not open.

12
     procedure Delete(File : in out File_Type);

13
          Deletes the external file associated with the given file.  The
          given file is closed, and the external file ceases to exist.

14
          The exception Status_Error is propagated if the given file is
          not open.  The exception Use_Error is propagated if deletion
          of the external file is not supported by the external
          environment.

15
     procedure Reset(File : in out File_Type; Mode : in File_Mode);
     procedure Reset(File : in out File_Type);

16/2
          Resets the given file so that reading from its elements can be
          restarted from the beginning of the external file (for modes
          In_File and Inout_File), and so that writing to its elements
          can be restarted at the beginning of the external file (for
          modes Out_File and Inout_File) or after the last element of
          the external file (for mode Append_File).  In particular, for
          direct access this means that the current index is set to one.
          If a Mode parameter is supplied, the current mode of the given
          file is set to the given mode.  In addition, for sequential
          files, if the given file has mode Out_File or Append_File when
          Reset is called, the last element written since the most
          recent open or reset is the last element that can be read from
          the external file.  If no elements have been written and the
          file mode is Out_File, the reset file is empty.  If no
          elements have been written and the file mode is Append_File,
          then the reset file is unchanged.

17
          The exception Status_Error is propagated if the file is not
          open.  The exception Use_Error is propagated if the external
          environment does not support resetting for the external file
          and, also, if the external environment does not support
          resetting to the specified mode for the external file.

18
     function Mode(File : in File_Type) return File_Mode;

19
          Returns the current mode of the given file.

20
          The exception Status_Error is propagated if the file is not
          open.

21
     function Name(File : in File_Type) return String;

22/2
          Returns a string which uniquely identifies the external file
          currently associated with the given file (and may thus be used
          in an Open operation).

23
          The exception Status_Error is propagated if the given file is
          not open.  The exception Use_Error is propagated if the
          associated external file is a temporary file that cannot be
          opened by any name.

24
     function Form(File : in File_Type) return String;

25
          Returns the form string for the external file currently
          associated with the given file.  If an external environment
          allows alternative specifications of the form (for example,
          abbreviations using default options), the string returned by
          the function should correspond to a full specification (that
          is, it should indicate explicitly all options selected,
          including default options).

26
          The exception Status_Error is propagated if the given file is
          not open.

27
     function Is_Open(File : in File_Type) return Boolean;

28/3
          Returns True if the file is open (that is, if it is associated
          with an external file); otherwise, returns False.

28.1/4
     procedure Flush(File : in File_Type);

28.2/4
          The Flush procedure synchronizes the external file with the
          internal file (by flushing any internal buffers) without
          closing the file.  For a direct file, the current index is
          unchanged; for a stream file (see *note A.12.1::), the current
          position is unchanged.

28.3/4
          The exception Status_Error is propagated if the file is not
          open.  The exception Mode_Error is propagated if the mode of
          the file is In_File.

                     _Implementation Permissions_

29
An implementation may propagate Name_Error or Use_Error if an attempt is
made to use an I/O feature that cannot be supported by the
implementation due to limitations in the external environment.  Any such
restriction should be documented.


File: arm2012.info,  Node: A.8.3,  Next: A.8.4,  Prev: A.8.2,  Up: A.8

A.8.3 Sequential Input-Output Operations
----------------------------------------

                          _Static Semantics_

1
The operations available for sequential input and output are described
in this subclause.  The exception Status_Error is propagated if any of
these operations is attempted for a file that is not open.

2
     procedure Read(File : in File_Type; Item : out Element_Type);

3
          Operates on a file of mode In_File.  Reads an element from the
          given file, and returns the value of this element in the Item
          parameter.

4
          The exception Mode_Error is propagated if the mode is not
          In_File.  The exception End_Error is propagated if no more
          elements can be read from the given file.  The exception
          Data_Error can be propagated if the element read cannot be
          interpreted as a value of the subtype Element_Type (see *note
          A.13::, "*note A.13:: Exceptions in Input-Output").

5
     procedure Write(File : in File_Type; Item : in Element_Type);

6
          Operates on a file of mode Out_File or Append_File.  Writes
          the value of Item to the given file.

7
          The exception Mode_Error is propagated if the mode is not
          Out_File or Append_File.  The exception Use_Error is
          propagated if the capacity of the external file is exceeded.

8
     function End_Of_File(File : in File_Type) return Boolean;

9/3
          Operates on a file of mode In_File.  Returns True if no more
          elements can be read from the given file; otherwise, returns
          False.

10
          The exception Mode_Error is propagated if the mode is not
          In_File.


File: arm2012.info,  Node: A.8.4,  Next: A.8.5,  Prev: A.8.3,  Up: A.8

A.8.4 The Generic Package Direct_IO
-----------------------------------

                          _Static Semantics_

1
The generic library package Direct_IO has the following declaration:

2
     with Ada.IO_Exceptions;
     generic
        type Element_Type is private;
     package Ada.Direct_IO is

3
        type File_Type is limited private;

4
        type File_Mode is (In_File, Inout_File, Out_File);
        type Count     is range 0 .. <implementation-defined>;
        subtype Positive_Count is Count range 1 .. Count'Last;

5
        --< File management>

6
        procedure Create(File : in out File_Type;
                         Mode : in File_Mode := Inout_File;
                         Name : in String := "";
                         Form : in String := "");

7
        procedure Open  (File : in out File_Type;
                         Mode : in File_Mode;
                         Name : in String;
                         Form : in String := "");

8
        procedure Close (File : in out File_Type);
        procedure Delete(File : in out File_Type);
        procedure Reset (File : in out File_Type; Mode : in File_Mode);
        procedure Reset (File : in out File_Type);

9
        function Mode   (File : in File_Type) return File_Mode;
        function Name   (File : in File_Type) return String;
        function Form   (File : in File_Type) return String;

10
        function Is_Open(File : in File_Type) return Boolean;

10.1/4
        procedure Flush (File : in File_Type);

11
        --< Input and output operations>

12
        procedure Read (File : in File_Type; Item : out Element_Type;
                                             From : in Positive_Count);
        procedure Read (File : in File_Type; Item : out Element_Type);

13
        procedure Write(File : in File_Type; Item : in  Element_Type;
                                             To   : in Positive_Count);
        procedure Write(File : in File_Type; Item : in Element_Type);

14
        procedure Set_Index(File : in File_Type; To : in Positive_Count);

15
        function Index(File : in File_Type) return Positive_Count;
        function Size (File : in File_Type) return Count;

16
        function End_Of_File(File : in File_Type) return Boolean;

17
        --< Exceptions>

18
        Status_Error : exception renames IO_Exceptions.Status_Error;
        Mode_Error   : exception renames IO_Exceptions.Mode_Error;
        Name_Error   : exception renames IO_Exceptions.Name_Error;
        Use_Error    : exception renames IO_Exceptions.Use_Error;
        Device_Error : exception renames IO_Exceptions.Device_Error;
        End_Error    : exception renames IO_Exceptions.End_Error;
        Data_Error   : exception renames IO_Exceptions.Data_Error;

19
     private
        ... -- <not specified by the language>
     end Ada.Direct_IO;

20/2
The type File_Type needs finalization (see *note 7.6::) in every
instantiation of Direct_IO.


File: arm2012.info,  Node: A.8.5,  Prev: A.8.4,  Up: A.8

A.8.5 Direct Input-Output Operations
------------------------------------

                          _Static Semantics_

1
The operations available for direct input and output are described in
this subclause.  The exception Status_Error is propagated if any of
these operations is attempted for a file that is not open.

2
     procedure Read(File : in File_Type; Item : out Element_Type;
                                         From : in  Positive_Count);
     procedure Read(File : in File_Type; Item : out Element_Type);

3
          Operates on a file of mode In_File or Inout_File.  In the case
          of the first form, sets the current index of the given file to
          the index value given by the parameter From.  Then (for both
          forms) returns, in the parameter Item, the value of the
          element whose position in the given file is specified by the
          current index of the file; finally, increases the current
          index by one.

4
          The exception Mode_Error is propagated if the mode of the
          given file is Out_File.  The exception End_Error is propagated
          if the index to be used exceeds the size of the external file.
          The exception Data_Error can be propagated if the element read
          cannot be interpreted as a value of the subtype Element_Type
          (see *note A.13::).

5
     procedure Write(File : in File_Type; Item : in Element_Type;
                                          To   : in Positive_Count);
     procedure Write(File : in File_Type; Item : in Element_Type);

6
          Operates on a file of mode Inout_File or Out_File.  In the
          case of the first form, sets the index of the given file to
          the index value given by the parameter To.  Then (for both
          forms) gives the value of the parameter Item to the element
          whose position in the given file is specified by the current
          index of the file; finally, increases the current index by
          one.

7
          The exception Mode_Error is propagated if the mode of the
          given file is In_File.  The exception Use_Error is propagated
          if the capacity of the external file is exceeded.

8
     procedure Set_Index(File : in File_Type; To : in Positive_Count);

9
          Operates on a file of any mode.  Sets the current index of the
          given file to the given index value (which may exceed the
          current size of the file).

10
     function Index(File : in File_Type) return Positive_Count;

11
          Operates on a file of any mode.  Returns the current index of
          the given file.

12
     function Size(File : in File_Type) return Count;

13
          Operates on a file of any mode.  Returns the current size of
          the external file that is associated with the given file.

14
     function End_Of_File(File : in File_Type) return Boolean;

15/3
          Operates on a file of mode In_File or Inout_File.  Returns
          True if the current index exceeds the size of the external
          file; otherwise, returns False.

16
          The exception Mode_Error is propagated if the mode of the
          given file is Out_File.

     NOTES

17
     25  Append_File mode is not supported for the generic package
     Direct_IO.


File: arm2012.info,  Node: A.9,  Next: A.10,  Prev: A.8,  Up: Annex A

A.9 The Generic Package Storage_IO
==================================

1
The generic package Storage_IO provides for reading from and writing to
an in-memory buffer.  This generic package supports the construction of
user-defined input-output packages.

                          _Static Semantics_

2
The generic library package Storage_IO has the following declaration:

3
     with Ada.IO_Exceptions;
     with System.Storage_Elements;
     generic
        type Element_Type is private;
     package Ada.Storage_IO is
        pragma Preelaborate(Storage_IO);

4
        Buffer_Size : constant System.Storage_Elements.Storage_Count :=
           <implementation-defined>;
        subtype Buffer_Type is
           System.Storage_Elements.Storage_Array(1..Buffer_Size);

5
        --< Input and output operations>

6
        procedure Read (Buffer : in  Buffer_Type; Item : out Element_Type);

7
        procedure Write(Buffer : out Buffer_Type; Item : in  Element_Type);

8
        --< Exceptions>

9
        Data_Error   : exception renames IO_Exceptions.Data_Error;
     end Ada.Storage_IO;

10
In each instance, the constant Buffer_Size has a value that is the size
(in storage elements) of the buffer required to represent the content of
an object of subtype Element_Type, including any implicit levels of
indirection used by the implementation.  The Read and Write procedures
of Storage_IO correspond to the Read and Write procedures of Direct_IO
(see *note A.8.4::), but with the content of the Item parameter being
read from or written into the specified Buffer, rather than an external
file.

     NOTES

11
     26  A buffer used for Storage_IO holds only one element at a time;
     an external file used for Direct_IO holds a sequence of elements.


File: arm2012.info,  Node: A.10,  Next: A.11,  Prev: A.9,  Up: Annex A

A.10 Text Input-Output
======================

                          _Static Semantics_

1/3
This subclause describes the package Text_IO, which provides facilities
for input and output in human-readable form.  Each file is read or
written sequentially, as a sequence of characters grouped into lines,
and as a sequence of lines grouped into pages.  The specification of the
package is given below in subclause *note A.10.1::.

2/3
The facilities for file management given above, in subclauses *note
A.8.2:: and *note A.8.3::, are available for text input-output.  In
place of Read and Write, however, there are procedures Get and Put that
input values of suitable types from text files, and output values to
them.  These values are provided to the Put procedures, and returned by
the Get procedures, in a parameter Item.  Several overloaded procedures
of these names exist, for different types of Item.  These Get procedures
analyze the input sequences of characters based on lexical elements (see
Clause *note 2::) and return the corresponding values; the Put
procedures output the given values as appropriate lexical elements.
Procedures Get and Put are also available that input and output
individual characters treated as character values rather than as lexical
elements.  Related to character input are procedures to look ahead at
the next character without reading it, and to read a character
"immediately" without waiting for an end-of-line to signal availability.

3
In addition to the procedures Get and Put for numeric and enumeration
types of Item that operate on text files, analogous procedures are
provided that read from and write to a parameter of type String.  These
procedures perform the same analysis and composition of character
sequences as their counterparts which have a file parameter.

4
For all Get and Put procedures that operate on text files, and for many
other subprograms, there are forms with and without a file parameter.
Each such Get procedure operates on an input file, and each such Put
procedure operates on an output file.  If no file is specified, a
default input file or a default output file is used.

5
At the beginning of program execution the default input and output files
are the so-called standard input file and standard output file.  These
files are open, have respectively the current modes In_File and
Out_File, and are associated with two implementation-defined external
files.  Procedures are provided to change the current default input file
and the current default output file.

6
At the beginning of program execution a default file for
program-dependent error-related text output is the so-called standard
error file.  This file is open, has the current mode Out_File, and is
associated with an implementation-defined external file.  A procedure is
provided to change the current default error file.

7
From a logical point of view, a text file is a sequence of pages, a page
is a sequence of lines, and a line is a sequence of characters; the end
of a line is marked by a <line terminator>; the end of a page is marked
by the combination of a line terminator immediately followed by a <page
terminator>; and the end of a file is marked by the combination of a
line terminator immediately followed by a page terminator and then a
<file terminator>.  Terminators are generated during output; either by
calls of procedures provided expressly for that purpose; or implicitly
as part of other operations, for example, when a bounded line length, a
bounded page length, or both, have been specified for a file.

8
The actual nature of terminators is not defined by the language and
hence depends on the implementation.  Although terminators are
recognized or generated by certain of the procedures that follow, they
are not necessarily implemented as characters or as sequences of
characters.  Whether they are characters (and if so which ones) in any
particular implementation need not concern a user who neither explicitly
outputs nor explicitly inputs control characters.  The effect of input
(Get) or output (Put) of control characters (other than horizontal
tabulation) is not specified by the language.  

9
The characters of a line are numbered, starting from one; the number of
a character is called its <column number>.  For a line terminator, a
column number is also defined: it is one more than the number of
characters in the line.  The lines of a page, and the pages of a file,
are similarly numbered.  The current column number is the column number
of the next character or line terminator to be transferred.  The current
line number is the number of the current line.  The current page number
is the number of the current page.  These numbers are values of the
subtype Positive_Count of the type Count (by convention, the value zero
of the type Count is used to indicate special conditions).

10
     type Count is range 0 .. <implementation-defined>;
     subtype Positive_Count is Count range 1 .. Count'Last;

11
For an output file or an append file, a <maximum line length> can be
specified and a <maximum page length> can be specified.  If a value to
be output cannot fit on the current line, for a specified maximum line
length, then a new line is automatically started before the value is
output; if, further, this new line cannot fit on the current page, for a
specified maximum page length, then a new page is automatically started
before the value is output.  Functions are provided to determine the
maximum line length and the maximum page length.  When a file is opened
with mode Out_File or Append_File, both values are zero: by convention,
this means that the line lengths and page lengths are unbounded.
(Consequently, output consists of a single line if the subprograms for
explicit control of line and page structure are not used.)  The constant
Unbounded is provided for this purpose.

* Menu:

* A.10.1 ::   The Package Text_IO
* A.10.2 ::   Text File Management
* A.10.3 ::   Default Input, Output, and Error Files
* A.10.4 ::   Specification of Line and Page Lengths
* A.10.5 ::   Operations on Columns, Lines, and Pages
* A.10.6 ::   Get and Put Procedures
* A.10.7 ::   Input-Output of Characters and Strings
* A.10.8 ::   Input-Output for Integer Types
* A.10.9 ::   Input-Output for Real Types
* A.10.10 ::  Input-Output for Enumeration Types
* A.10.11 ::  Input-Output for Bounded Strings
* A.10.12 ::  Input-Output for Unbounded Strings


File: arm2012.info,  Node: A.10.1,  Next: A.10.2,  Up: A.10

A.10.1 The Package Text_IO
--------------------------

                          _Static Semantics_

1
The library package Text_IO has the following declaration:

2
     with Ada.IO_Exceptions;
     package Ada.Text_IO is

3
        type File_Type is limited private;

4
        type File_Mode is (In_File, Out_File, Append_File);

5
        type Count is range 0 .. <implementation-defined>;
        subtype Positive_Count is Count range 1 .. Count'Last;
        Unbounded : constant Count := 0; --< line and page length>

6
        subtype Field       is Integer range 0 .. <implementation-defined>;
        subtype Number_Base is Integer range 2 .. 16;

7
        type Type_Set is (Lower_Case, Upper_Case);

8
        --< File Management>

9
        procedure Create (File : in out File_Type;
                          Mode : in File_Mode := Out_File;
                          Name : in String    := "";
                          Form : in String    := "");

10
        procedure Open   (File : in out File_Type;
                          Mode : in File_Mode;
                          Name : in String;
                          Form : in String := "");

11
        procedure Close  (File : in out File_Type);
        procedure Delete (File : in out File_Type);
        procedure Reset  (File : in out File_Type; Mode : in File_Mode);
        procedure Reset  (File : in out File_Type);

12
        function  Mode   (File : in File_Type) return File_Mode;
        function  Name   (File : in File_Type) return String;
        function  Form   (File : in File_Type) return String;

13
        function  Is_Open(File : in File_Type) return Boolean;

14
        --< Control of default input and output files>

15
        procedure Set_Input (File : in File_Type);
        procedure Set_Output(File : in File_Type);
        procedure Set_Error (File : in File_Type);

16
        function Standard_Input  return File_Type;
        function Standard_Output return File_Type;
        function Standard_Error  return File_Type;

17
        function Current_Input   return File_Type;
        function Current_Output  return File_Type;
        function Current_Error   return File_Type;

18
        type File_Access is access constant File_Type;

19
        function Standard_Input  return File_Access;
        function Standard_Output return File_Access;
        function Standard_Error  return File_Access;

20
        function Current_Input   return File_Access;
        function Current_Output  return File_Access;
        function Current_Error   return File_Access;

21/1
     --<Buffer control>
        procedure Flush (File : in File_Type);
        procedure Flush;

22
        --< Specification of line and page lengths>

23
        procedure Set_Line_Length(File : in File_Type; To : in Count);
        procedure Set_Line_Length(To   : in Count);

24
        procedure Set_Page_Length(File : in File_Type; To : in Count);
        procedure Set_Page_Length(To   : in Count);

25
        function  Line_Length(File : in File_Type) return Count;
        function  Line_Length return Count;

26
        function  Page_Length(File : in File_Type) return Count;
        function  Page_Length return Count;

27
        --< Column, Line, and Page Control>

28
        procedure New_Line   (File    : in File_Type;
                              Spacing : in Positive_Count := 1);
        procedure New_Line   (Spacing : in Positive_Count := 1);

29
        procedure Skip_Line  (File    : in File_Type;
                              Spacing : in Positive_Count := 1);
        procedure Skip_Line  (Spacing : in Positive_Count := 1);

30
        function  End_Of_Line(File : in File_Type) return Boolean;
        function  End_Of_Line return Boolean;

31
        procedure New_Page   (File : in File_Type);
        procedure New_Page;

32
        procedure Skip_Page  (File : in File_Type);
        procedure Skip_Page;

33
        function  End_Of_Page(File : in File_Type) return Boolean;
        function  End_Of_Page return Boolean;

34
        function  End_Of_File(File : in File_Type) return Boolean;
        function  End_Of_File return Boolean;

35
        procedure Set_Col (File : in File_Type; To : in Positive_Count);
        procedure Set_Col (To   : in Positive_Count);

36
        procedure Set_Line(File : in File_Type; To : in Positive_Count);
        procedure Set_Line(To   : in Positive_Count);

37
        function Col (File : in File_Type) return Positive_Count;
        function Col  return Positive_Count;

38
        function Line(File : in File_Type) return Positive_Count;
        function Line return Positive_Count;

39
        function Page(File : in File_Type) return Positive_Count;
        function Page return Positive_Count;

40
        --< Character Input-Output>

41
        procedure Get(File : in  File_Type; Item : out Character);
        procedure Get(Item : out Character);

42
        procedure Put(File : in  File_Type; Item : in Character);
        procedure Put(Item : in  Character);

43
        procedure Look_Ahead (File        : in  File_Type;
                              Item        : out Character;
                              End_Of_Line : out Boolean);
        procedure Look_Ahead (Item        : out Character;
                              End_Of_Line : out Boolean);

44
        procedure Get_Immediate(File      : in  File_Type;
                                Item      : out Character);
        procedure Get_Immediate(Item      : out Character);

45
        procedure Get_Immediate(File      : in  File_Type;
                                Item      : out Character;
                                Available : out Boolean);
        procedure Get_Immediate(Item      : out Character;
                                Available : out Boolean);

46
        --< String Input-Output>

47
        procedure Get(File : in  File_Type; Item : out String);
        procedure Get(Item : out String);

48
        procedure Put(File : in  File_Type; Item : in String);
        procedure Put(Item : in  String);

49
        procedure Get_Line(File : in  File_Type;
                           Item : out String;
                           Last : out Natural);
        procedure Get_Line(Item : out String; Last : out Natural);

49.1/2
        function Get_Line(File : in  File_Type) return String;
        function Get_Line return String;

50
        procedure Put_Line(File : in  File_Type; Item : in String);
        procedure Put_Line(Item : in  String);

51
     --< Generic packages for Input-Output of Integer Types>

52
        generic
           type Num is range <>;
        package Integer_IO is

53
           Default_Width : Field := Num'Width;
           Default_Base  : Number_Base := 10;

54
           procedure Get(File  : in  File_Type;
                         Item  : out Num;
                         Width : in Field := 0);
           procedure Get(Item  : out Num;
                         Width : in  Field := 0);

55
           procedure Put(File  : in File_Type;
                         Item  : in Num;
                         Width : in Field := Default_Width;
                         Base  : in Number_Base := Default_Base);
           procedure Put(Item  : in Num;
                         Width : in Field := Default_Width;
                         Base  : in Number_Base := Default_Base);
           procedure Get(From : in  String;
                         Item : out Num;
                         Last : out Positive);
           procedure Put(To   : out String;
                         Item : in Num;
                         Base : in Number_Base := Default_Base);

56
        end Integer_IO;

57
        generic
           type Num is mod <>;
        package Modular_IO is

58
           Default_Width : Field := Num'Width;
           Default_Base  : Number_Base := 10;

59
           procedure Get(File  : in  File_Type;
                         Item  : out Num;
                         Width : in Field := 0);
           procedure Get(Item  : out Num;
                         Width : in  Field := 0);

60
           procedure Put(File  : in File_Type;
                         Item  : in Num;
                         Width : in Field := Default_Width;
                         Base  : in Number_Base := Default_Base);
           procedure Put(Item  : in Num;
                         Width : in Field := Default_Width;
                         Base  : in Number_Base := Default_Base);
           procedure Get(From : in  String;
                         Item : out Num;
                         Last : out Positive);
           procedure Put(To   : out String;
                         Item : in Num;
                         Base : in Number_Base := Default_Base);

61
        end Modular_IO;

62
        --< Generic packages for Input-Output of Real Types>

63
        generic
           type Num is digits <>;
        package Float_IO is

64
           Default_Fore : Field := 2;
           Default_Aft  : Field := Num'Digits-1;
           Default_Exp  : Field := 3;

65
           procedure Get(File  : in  File_Type;
                         Item  : out Num;
                         Width : in  Field := 0);
           procedure Get(Item  : out Num;
                         Width : in  Field := 0);

66
           procedure Put(File : in File_Type;
                         Item : in Num;
                         Fore : in Field := Default_Fore;
                         Aft  : in Field := Default_Aft;
                         Exp  : in Field := Default_Exp);
           procedure Put(Item : in Num;
                         Fore : in Field := Default_Fore;
                         Aft  : in Field := Default_Aft;
                         Exp  : in Field := Default_Exp);

67
           procedure Get(From : in String;
                         Item : out Num;
                         Last : out Positive);
           procedure Put(To   : out String;
                         Item : in Num;
                         Aft  : in Field := Default_Aft;
                         Exp  : in Field := Default_Exp);
        end Float_IO;

68
        generic
           type Num is delta <>;
        package Fixed_IO is

69
           Default_Fore : Field := Num'Fore;
           Default_Aft  : Field := Num'Aft;
           Default_Exp  : Field := 0;

70
           procedure Get(File  : in  File_Type;
                         Item  : out Num;
                         Width : in  Field := 0);
           procedure Get(Item  : out Num;
                         Width : in  Field := 0);

71
           procedure Put(File : in File_Type;
                         Item : in Num;
                         Fore : in Field := Default_Fore;
                         Aft  : in Field := Default_Aft;
                         Exp  : in Field := Default_Exp);
           procedure Put(Item : in Num;
                         Fore : in Field := Default_Fore;
                         Aft  : in Field := Default_Aft;
                         Exp  : in Field := Default_Exp);

72
           procedure Get(From : in  String;
                         Item : out Num;
                         Last : out Positive);
           procedure Put(To   : out String;
                         Item : in Num;
                         Aft  : in Field := Default_Aft;
                         Exp  : in Field := Default_Exp);
        end Fixed_IO;

73
        generic
           type Num is delta <> digits <>;
        package Decimal_IO is

74
           Default_Fore : Field := Num'Fore;
           Default_Aft  : Field := Num'Aft;
           Default_Exp  : Field := 0;

75
           procedure Get(File  : in  File_Type;
                         Item  : out Num;
                         Width : in  Field := 0);
           procedure Get(Item  : out Num;
                         Width : in  Field := 0);

76
           procedure Put(File : in File_Type;
                         Item : in Num;
                         Fore : in Field := Default_Fore;
                         Aft  : in Field := Default_Aft;
                         Exp  : in Field := Default_Exp);
           procedure Put(Item : in Num;
                         Fore : in Field := Default_Fore;
                         Aft  : in Field := Default_Aft;
                         Exp  : in Field := Default_Exp);

77
           procedure Get(From : in  String;
                         Item : out Num;
                         Last : out Positive);
           procedure Put(To   : out String;
                         Item : in Num;
                         Aft  : in Field := Default_Aft;
                         Exp  : in Field := Default_Exp);
        end Decimal_IO;

78
        --< Generic package for Input-Output of Enumeration Types>

79
        generic
           type Enum is (<>);
        package Enumeration_IO is

80
           Default_Width   : Field := 0;
           Default_Setting : Type_Set := Upper_Case;

81
           procedure Get(File : in  File_Type;
                         Item : out Enum);
           procedure Get(Item : out Enum);

82
           procedure Put(File  : in File_Type;
                         Item  : in Enum;
                         Width : in Field    := Default_Width;
                         Set   : in Type_Set := Default_Setting);
           procedure Put(Item  : in Enum;
                         Width : in Field    := Default_Width;
                         Set   : in Type_Set := Default_Setting);

83
           procedure Get(From : in  String;
                         Item : out Enum;
                         Last : out Positive);
           procedure Put(To   : out String;
                         Item : in  Enum;
                         Set  : in  Type_Set := Default_Setting);
        end Enumeration_IO;

84
     --< Exceptions>

85
        Status_Error : exception renames IO_Exceptions.Status_Error;
        Mode_Error   : exception renames IO_Exceptions.Mode_Error;
        Name_Error   : exception renames IO_Exceptions.Name_Error;
        Use_Error    : exception renames IO_Exceptions.Use_Error;
        Device_Error : exception renames IO_Exceptions.Device_Error;
        End_Error    : exception renames IO_Exceptions.End_Error;
        Data_Error   : exception renames IO_Exceptions.Data_Error;
        Layout_Error : exception renames IO_Exceptions.Layout_Error;
     private
        ... -- <not specified by the language>
     end Ada.Text_IO;

86/2
The type File_Type needs finalization (see *note 7.6::).


File: arm2012.info,  Node: A.10.2,  Next: A.10.3,  Prev: A.10.1,  Up: A.10

A.10.2 Text File Management
---------------------------

                          _Static Semantics_

1
The only allowed file modes for text files are the modes In_File,
Out_File, and Append_File.  The subprograms given in subclause *note
A.8.2:: for the control of external files, and the function End_Of_File
given in subclause *note A.8.3:: for sequential input-output, are also
available for text files.  There is also a version of End_Of_File that
refers to the current default input file.  For text files, the
procedures have the following additional effects:

2
   * For the procedures Create and Open: After a file with mode Out_File
     or Append_File is opened, the page length and line length are
     unbounded (both have the conventional value zero).  After a file
     (of any mode) is opened, the current column, current line, and
     current page numbers are set to one.  If the mode is Append_File,
     it is implementation defined whether a page terminator will
     separate preexisting text in the file from the new text to be
     written.

3
   * For the procedure Close: If the file has the current mode Out_File
     or Append_File, has the effect of calling New_Page, unless the
     current page is already terminated; then outputs a file terminator.

4
   * For the procedure Reset: If the file has the current mode Out_File
     or Append_File, has the effect of calling New_Page, unless the
     current page is already terminated; then outputs a file terminator.
     The current column, line, and page numbers are set to one, and the
     line and page lengths to Unbounded.  If the new mode is
     Append_File, it is implementation defined whether a page terminator
     will separate preexisting text in the file from the new text to be
     written.

5
The exception Mode_Error is propagated by the procedure Reset upon an
attempt to change the mode of a file that is the current default input
file, the current default output file, or the current default error
file.

     NOTES

6
     27  An implementation can define the Form parameter of Create and
     Open to control effects including the following:

7
        * the interpretation of line and column numbers for an
          interactive file, and

8
        * the interpretation of text formats in a file created by a
          foreign program.


File: arm2012.info,  Node: A.10.3,  Next: A.10.4,  Prev: A.10.2,  Up: A.10

A.10.3 Default Input, Output, and Error Files
---------------------------------------------

                          _Static Semantics_

1
The following subprograms provide for the control of the particular
default files that are used when a file parameter is omitted from a Get,
Put, or other operation of text input-output described below, or when
application-dependent error-related text is to be output.

2
     procedure Set_Input(File : in File_Type);

3
          Operates on a file of mode In_File.  Sets the current default
          input file to File.

4
          The exception Status_Error is propagated if the given file is
          not open.  The exception Mode_Error is propagated if the mode
          of the given file is not In_File.

5
     procedure Set_Output(File : in File_Type);
     procedure Set_Error (File : in File_Type);

6
          Each operates on a file of mode Out_File or Append_File.
          Set_Output sets the current default output file to File.
          Set_Error sets the current default error file to File.  The
          exception Status_Error is propagated if the given file is not
          open.  The exception Mode_Error is propagated if the mode of
          the given file is not Out_File or Append_File.

7
     function Standard_Input return File_Type;
     function Standard_Input return File_Access;

8
          Returns the standard input file (see *note A.10::), or an
          access value designating the standard input file,
          respectively.

9
     function Standard_Output return File_Type;
     function Standard_Output return File_Access;

10
          Returns the standard output file (see *note A.10::) or an
          access value designating the standard output file,
          respectively.

11
     function Standard_Error return File_Type;
     function Standard_Error return File_Access;

12/1
          Returns the standard error file (see *note A.10::), or an
          access value designating the standard error file,
          respectively.

13
The Form strings implicitly associated with the opening of
Standard_Input, Standard_Output, and Standard_Error at the start of
program execution are implementation defined.

14
     function Current_Input return File_Type;
     function Current_Input return File_Access;

15
          Returns the current default input file, or an access value
          designating the current default input file, respectively.

16
     function Current_Output return File_Type;
     function Current_Output return File_Access;

17
          Returns the current default output file, or an access value
          designating the current default output file, respectively.

18
     function Current_Error return File_Type;
     function Current_Error return File_Access;

19
          Returns the current default error file, or an access value
          designating the current default error file, respectively.

20/1
     procedure Flush (File : in File_Type);
     procedure Flush;

21/4
          The effect of Flush is the same as the corresponding
          subprogram in Sequential_IO (see *note A.8.2::).  If File is
          not explicitly specified, Current_Output is used.

                         _Erroneous Execution_

22/1
The execution of a program is erroneous if it invokes an operation on a
current default input, default output, or default error file, and if the
corresponding file object is closed or no longer exists.

23/1
<This paragraph was deleted.>

     NOTES

24
     28  The standard input, standard output, and standard error files
     cannot be opened, closed, reset, or deleted, because the parameter
     File of the corresponding procedures has the mode in out.

25
     29  The standard input, standard output, and standard error files
     are different file objects, but not necessarily different external
     files.


File: arm2012.info,  Node: A.10.4,  Next: A.10.5,  Prev: A.10.3,  Up: A.10

A.10.4 Specification of Line and Page Lengths
---------------------------------------------

                          _Static Semantics_

1
The subprograms described in this subclause are concerned with the line
and page structure of a file of mode Out_File or Append_File.  They
operate either on the file given as the first parameter, or, in the
absence of such a file parameter, on the current default output file.
They provide for output of text with a specified maximum line length or
page length.  In these cases, line and page terminators are output
implicitly and automatically when needed.  When line and page lengths
are unbounded (that is, when they have the conventional value zero), as
in the case of a newly opened file, new lines and new pages are only
started when explicitly called for.

2
In all cases, the exception Status_Error is propagated if the file to be
used is not open; the exception Mode_Error is propagated if the mode of
the file is not Out_File or Append_File.

3
     procedure Set_Line_Length(File : in File_Type; To : in Count);
     procedure Set_Line_Length(To   : in Count);

4
          Sets the maximum line length of the specified output or append
          file to the number of characters specified by To.  The value
          zero for To specifies an unbounded line length.

5
          The exception Use_Error is propagated if the specified line
          length is inappropriate for the associated external file.

6
     procedure Set_Page_Length(File : in File_Type; To : in Count);
     procedure Set_Page_Length(To   : in Count);

7
          Sets the maximum page length of the specified output or append
          file to the number of lines specified by To.  The value zero
          for To specifies an unbounded page length.

8
          The exception Use_Error is propagated if the specified page
          length is inappropriate for the associated external file.

9
     function Line_Length(File : in File_Type) return Count;
     function Line_Length return Count;

10
          Returns the maximum line length currently set for the
          specified output or append file, or zero if the line length is
          unbounded.

11
     function Page_Length(File : in File_Type) return Count;
     function Page_Length return Count;

12
          Returns the maximum page length currently set for the
          specified output or append file, or zero if the page length is
          unbounded.


File: arm2012.info,  Node: A.10.5,  Next: A.10.6,  Prev: A.10.4,  Up: A.10

A.10.5 Operations on Columns, Lines, and Pages
----------------------------------------------

                          _Static Semantics_

1
The subprograms described in this subclause provide for explicit control
of line and page structure; they operate either on the file given as the
first parameter, or, in the absence of such a file parameter, on the
appropriate (input or output) current default file.  The exception
Status_Error is propagated by any of these subprograms if the file to be
used is not open.

2
     procedure New_Line(File : in File_Type; Spacing : in Positive_Count := 1);
     procedure New_Line(Spacing : in Positive_Count := 1);

3
          Operates on a file of mode Out_File or Append_File.

4
          For a Spacing of one: Outputs a line terminator and sets the
          current column number to one.  Then increments the current
          line number by one, except in the case that the current line
          number is already greater than or equal to the maximum page
          length, for a bounded page length; in that case a page
          terminator is output, the current page number is incremented
          by one, and the current line number is set to one.

5
          For a Spacing greater than one, the above actions are
          performed Spacing times.

6
          The exception Mode_Error is propagated if the mode is not
          Out_File or Append_File.

7
     procedure Skip_Line(File  : in File_Type; Spacing : in Positive_Count := 1);
     procedure Skip_Line(Spacing : in Positive_Count := 1);

8
          Operates on a file of mode In_File.

9
          For a Spacing of one: Reads and discards all characters until
          a line terminator has been read, and then sets the current
          column number to one.  If the line terminator is not
          immediately followed by a page terminator, the current line
          number is incremented by one.  Otherwise, if the line
          terminator is immediately followed by a page terminator, then
          the page terminator is skipped, the current page number is
          incremented by one, and the current line number is set to one.

10
          For a Spacing greater than one, the above actions are
          performed Spacing times.

11
          The exception Mode_Error is propagated if the mode is not
          In_File.  The exception End_Error is propagated if an attempt
          is made to read a file terminator.

12
     function End_Of_Line(File : in File_Type) return Boolean;
     function End_Of_Line return Boolean;

13/3
          Operates on a file of mode In_File.  Returns True if a line
          terminator or a file terminator is next; otherwise, returns
          False.

14
          The exception Mode_Error is propagated if the mode is not
          In_File.

15
     procedure New_Page(File : in File_Type);
     procedure New_Page;

16
          Operates on a file of mode Out_File or Append_File.  Outputs a
          line terminator if the current line is not terminated, or if
          the current page is empty (that is, if the current column and
          line numbers are both equal to one).  Then outputs a page
          terminator, which terminates the current page.  Adds one to
          the current page number and sets the current column and line
          numbers to one.

17
          The exception Mode_Error is propagated if the mode is not
          Out_File or Append_File.

18
     procedure Skip_Page(File : in File_Type);
     procedure Skip_Page;

19
          Operates on a file of mode In_File.  Reads and discards all
          characters and line terminators until a page terminator has
          been read.  Then adds one to the current page number, and sets
          the current column and line numbers to one.

20
          The exception Mode_Error is propagated if the mode is not
          In_File.  The exception End_Error is propagated if an attempt
          is made to read a file terminator.

21
     function End_Of_Page(File : in File_Type) return Boolean;
     function End_Of_Page return Boolean;

22/3
          Operates on a file of mode In_File.  Returns True if the
          combination of a line terminator and a page terminator is
          next, or if a file terminator is next; otherwise, returns
          False.

23
          The exception Mode_Error is propagated if the mode is not
          In_File.

24
     function End_Of_File(File : in File_Type) return Boolean;
     function End_Of_File return Boolean;

25/3
          Operates on a file of mode In_File.  Returns True if a file
          terminator is next, or if the combination of a line, a page,
          and a file terminator is next; otherwise, returns False.

26
          The exception Mode_Error is propagated if the mode is not
          In_File.

27
The following subprograms provide for the control of the current
position of reading or writing in a file.  In all cases, the default
file is the current output file.

28
     procedure Set_Col(File : in File_Type; To : in Positive_Count);
     procedure Set_Col(To   : in Positive_Count);

29
          If the file mode is Out_File or Append_File:

30
             * If the value specified by To is greater than the current
               column number, outputs spaces, adding one to the current
               column number after each space, until the current column
               number equals the specified value.  If the value
               specified by To is equal to the current column number,
               there is no effect.  If the value specified by To is less
               than the current column number, has the effect of calling
               New_Line (with a spacing of one), then outputs (To - 1)
               spaces, and sets the current column number to the
               specified value.

31
             * The exception Layout_Error is propagated if the value
               specified by To exceeds Line_Length when the line length
               is bounded (that is, when it does not have the
               conventional value zero).

32
          If the file mode is In_File:

33
             * Reads (and discards) individual characters, line
               terminators, and page terminators, until the next
               character to be read has a column number that equals the
               value specified by To; there is no effect if the current
               column number already equals this value.  Each transfer
               of a character or terminator maintains the current
               column, line, and page numbers in the same way as a Get
               procedure (see *note A.10.6::).  (Short lines will be
               skipped until a line is reached that has a character at
               the specified column position.)

34
             * The exception End_Error is propagated if an attempt is
               made to read a file terminator.

35
     procedure Set_Line(File : in File_Type; To : in Positive_Count);
     procedure Set_Line(To   : in Positive_Count);

36
          If the file mode is Out_File or Append_File:

37/3
             * If the value specified by To is greater than the current
               line number, has the effect of repeatedly calling
               New_Line (with a spacing of one), until the current line
               number equals the specified value.  If the value
               specified by To is equal to the current line number,
               there is no effect.  If the value specified by To is less
               than the current line number, has the effect of calling
               New_Page followed, if To is greater than 1, by a call of
               New_Line with a spacing equal to (To - 1).

38
             * The exception Layout_Error is propagated if the value
               specified by To exceeds Page_Length when the page length
               is bounded (that is, when it does not have the
               conventional value zero).

39
          If the mode is In_File:

40
             * Has the effect of repeatedly calling Skip_Line (with a
               spacing of one), until the current line number equals the
               value specified by To; there is no effect if the current
               line number already equals this value.  (Short pages will
               be skipped until a page is reached that has a line at the
               specified line position.)

41
             * The exception End_Error is propagated if an attempt is
               made to read a file terminator.

42
     function Col(File : in File_Type) return Positive_Count;
     function Col return Positive_Count;

43
          Returns the current column number.

44
          The exception Layout_Error is propagated if this number
          exceeds Count'Last.

45
     function Line(File : in File_Type) return Positive_Count;
     function Line return Positive_Count;

46
          Returns the current line number.

47
          The exception Layout_Error is propagated if this number
          exceeds Count'Last.

48
     function Page(File : in File_Type) return Positive_Count;
     function Page return Positive_Count;

49
          Returns the current page number.

50
          The exception Layout_Error is propagated if this number
          exceeds Count'Last.

51
The column number, line number, or page number are allowed to exceed
Count'Last (as a consequence of the input or output of sufficiently many
characters, lines, or pages).  These events do not cause any exception
to be propagated.  However, a call of Col, Line, or Page propagates the
exception Layout_Error if the corresponding number exceeds Count'Last.

     NOTES

52
     30  A page terminator is always skipped whenever the preceding line
     terminator is skipped.  An implementation may represent the
     combination of these terminators by a single character, provided
     that it is properly recognized on input.


File: arm2012.info,  Node: A.10.6,  Next: A.10.7,  Prev: A.10.5,  Up: A.10

A.10.6 Get and Put Procedures
-----------------------------

                          _Static Semantics_

1
The procedures Get and Put for items of the type Character, String,
numeric types, and enumeration types are described in subsequent
subclauses.  Features of these procedures that are common to most of
these types are described in this subclause.  The Get and Put procedures
for items of type Character and String deal with individual character
values; the Get and Put procedures for numeric and enumeration types
treat the items as lexical elements.

2
All procedures Get and Put have forms with a file parameter, written
first.  Where this parameter is omitted, the appropriate (input or
output) current default file is understood to be specified.  Each
procedure Get operates on a file of mode In_File.  Each procedure Put
operates on a file of mode Out_File or Append_File.

3
All procedures Get and Put maintain the current column, line, and page
numbers of the specified file: the effect of each of these procedures
upon these numbers is the result of the effects of individual transfers
of characters and of individual output or skipping of terminators.  Each
transfer of a character adds one to the current column number.  Each
output of a line terminator sets the current column number to one and
adds one to the current line number.  Each output of a page terminator
sets the current column and line numbers to one and adds one to the
current page number.  For input, each skipping of a line terminator sets
the current column number to one and adds one to the current line
number; each skipping of a page terminator sets the current column and
line numbers to one and adds one to the current page number.  Similar
considerations apply to the procedures Get_Line, Put_Line, and Set_Col.

4
Several Get and Put procedures, for numeric and enumeration types, have
<format> parameters which specify field lengths; these parameters are of
the nonnegative subtype Field of the type Integer.

5/2
Input-output of enumeration values uses the syntax of the corresponding
lexical elements.  Any Get procedure for an enumeration type begins by
skipping any leading blanks, or line or page terminators.  A <blank> is
defined as a space or a horizontal tabulation character.  Next,
characters are input only so long as the sequence input is an initial
sequence of an identifier or of a character literal (in particular,
input ceases when a line terminator is encountered).  The character or
line terminator that causes input to cease remains available for
subsequent input.

6
For a numeric type, the Get procedures have a format parameter called
Width.  If the value given for this parameter is zero, the Get procedure
proceeds in the same manner as for enumeration types, but using the
syntax of numeric literals instead of that of enumeration literals.  If
a nonzero value is given, then exactly Width characters are input, or
the characters up to a line terminator, whichever comes first; any
skipped leading blanks are included in the count.  The syntax used for
numeric literals is an extended syntax that allows a leading sign (but
no intervening blanks, or line or page terminators) and that also allows
(for real types) an integer literal as well as forms that have digits
only before the point or only after the point.

7
Any Put procedure, for an item of a numeric or an enumeration type,
outputs the value of the item as a numeric literal, identifier, or
character literal, as appropriate.  This is preceded by leading spaces
if required by the format parameters Width or Fore (as described in
later subclauses), and then a minus sign for a negative value; for an
enumeration type, the spaces follow instead of leading.  The format
given for a Put procedure is overridden if it is insufficiently wide, by
using the minimum needed width.

8
Two further cases arise for Put procedures for numeric and enumeration
types, if the line length of the specified output file is bounded (that
is, if it does not have the conventional value zero).  If the number of
characters to be output does not exceed the maximum line length, but is
such that they cannot fit on the current line, starting from the current
column, then (in effect) New_Line is called (with a spacing of one)
before output of the item.  Otherwise, if the number of characters
exceeds the maximum line length, then the exception Layout_Error is
propagated and nothing is output.

9
The exception Status_Error is propagated by any of the procedures Get,
Get_Line, Put, and Put_Line if the file to be used is not open.  The
exception Mode_Error is propagated by the procedures Get and Get_Line if
the mode of the file to be used is not In_File; and by the procedures
Put and Put_Line, if the mode is not Out_File or Append_File.

10
The exception End_Error is propagated by a Get procedure if an attempt
is made to skip a file terminator.  The exception Data_Error is
propagated by a Get procedure if the sequence finally input is not a
lexical element corresponding to the type, in particular if no
characters were input; for this test, leading blanks are ignored; for an
item of a numeric type, when a sign is input, this rule applies to the
succeeding numeric literal.  The exception Layout_Error is propagated by
a Put procedure that outputs to a parameter of type String, if the
length of the actual string is insufficient for the output of the item.

                              _Examples_

11
In the examples, here and in subclauses *note A.10.8:: and *note
A.10.9::, the string quotes and the lower case letter b are not
transferred: they are shown only to reveal the layout and spaces.

12
     N : Integer;
        ...
     Get(N);

13
     <--     Characters at input    Sequence input    Value of N>

     <--     bb-12535b    -12535    -12535>
     <--     bb12_535e1b    12_535e1    125350>
     <--     bb12_535e;    12_535e    (none) Data_Error raised>

14
Example of overridden width parameter:

15
     Put(Item => -23, Width => 2);  --<  "-23">


File: arm2012.info,  Node: A.10.7,  Next: A.10.8,  Prev: A.10.6,  Up: A.10

A.10.7 Input-Output of Characters and Strings
---------------------------------------------

                          _Static Semantics_

1
For an item of type Character the following procedures are provided:

2
     procedure Get(File : in File_Type; Item : out Character);
     procedure Get(Item : out Character);

3
          After skipping any line terminators and any page terminators,
          reads the next character from the specified input file and
          returns the value of this character in the out parameter Item.

4
          The exception End_Error is propagated if an attempt is made to
          skip a file terminator.

5
     procedure Put(File : in File_Type; Item : in Character);
     procedure Put(Item : in Character);

6
          If the line length of the specified output file is bounded
          (that is, does not have the conventional value zero), and the
          current column number exceeds it, has the effect of calling
          New_Line with a spacing of one.  Then, or otherwise, outputs
          the given character to the file.

7
     procedure Look_Ahead (File        : in  File_Type;
                           Item        : out Character;
                           End_Of_Line : out Boolean);
     procedure Look_Ahead (Item        : out Character;
                           End_Of_Line : out Boolean);

8/3
          Status_Error is propagated if the file is not open.
          Mode_Error is propagated if the mode of the file is not
          In_File.  Sets End_Of_Line to True if at end of line,
          including if at end of page or at end of file; in each of
          these cases the value of Item is not specified.  Otherwise,
          End_Of_Line is set to False and Item is set to the next
          character (without consuming it) from the file.

9
     procedure Get_Immediate(File : in  File_Type;
                             Item : out Character);
     procedure Get_Immediate(Item : out Character);

10/3
          Reads the next character, either control or graphic, from the
          specified File or the default input file.  Status_Error is
          propagated if the file is not open.  Mode_Error is propagated
          if the mode of the file is not In_File.  End_Error is
          propagated if at the end of the file.  The current column,
          line and page numbers for the file are not affected.

11
     procedure Get_Immediate(File      : in  File_Type;
                             Item      : out Character;
                             Available : out Boolean);
     procedure Get_Immediate(Item      : out Character;
                             Available : out Boolean);

12/3
          If a character, either control or graphic, is available from
          the specified File or the default input file, then the
          character is read; Available is True and Item contains the
          value of this character.  If a character is not available,
          then Available is False and the value of Item is not
          specified.  Status_Error is propagated if the file is not
          open.  Mode_Error is propagated if the mode of the file is not
          In_File.  End_Error is propagated if at the end of the file.
          The current column, line and page numbers for the file are not
          affected.

13/2
For an item of type String the following subprograms are provided:

14
     procedure Get(File : in File_Type; Item : out String);
     procedure Get(Item : out String);

15
          Determines the length of the given string and attempts that
          number of Get operations for successive characters of the
          string (in particular, no operation is performed if the string
          is null).

16
     procedure Put(File : in File_Type; Item : in String);
     procedure Put(Item : in String);

17
          Determines the length of the given string and attempts that
          number of Put operations for successive characters of the
          string (in particular, no operation is performed if the string
          is null).

17.1/2
     function Get_Line(File : in File_Type) return String;
     function Get_Line return String;

17.2/2
          Returns a result string constructed by reading successive
          characters from the specified input file, and assigning them
          to successive characters of the result string.  The result
          string has a lower bound of 1 and an upper bound of the number
          of characters read.  Reading stops when the end of the line is
          met; Skip_Line is then (in effect) called with a spacing of 1.

17.3/2
          Constraint_Error is raised if the length of the line exceeds
          Positive'Last; in this case, the line number and page number
          are unchanged, and the column number is unspecified but no
          less than it was before the call.  The exception End_Error is
          propagated if an attempt is made to skip a file terminator.

18
     procedure Get_Line(File : in File_Type;
                        Item : out String;
                        Last : out Natural);
     procedure Get_Line(Item : out String;
                        Last : out Natural);

19
          Reads successive characters from the specified input file and
          assigns them to successive characters of the specified string.
          Reading stops if the end of the string is met.  Reading also
          stops if the end of the line is met before meeting the end of
          the string; in this case Skip_Line is (in effect) called with
          a spacing of 1.  The values of characters not assigned are not
          specified.

20
          If characters are read, returns in Last the index value such
          that Item(Last) is the last character assigned (the index of
          the first character assigned is Item'First).  If no characters
          are read, returns in Last an index value that is one less than
          Item'First.  The exception End_Error is propagated if an
          attempt is made to skip a file terminator.

21
     procedure Put_Line(File : in File_Type; Item : in String);
     procedure Put_Line(Item : in String);

22
          Calls the procedure Put for the given string, and then the
          procedure New_Line with a spacing of one.

                        _Implementation Advice_

23
The Get_Immediate procedures should be implemented with unbuffered
input.  For a device such as a keyboard, input should be "available" if
a key has already been typed, whereas for a disk file, input should
always be available except at end of file.  For a file associated with a
keyboard-like device, any line-editing features of the underlying
operating system should be disabled during the execution of
Get_Immediate.

     NOTES

24
     31  Get_Immediate can be used to read a single key from the
     keyboard "immediately"; that is, without waiting for an end of
     line.  In a call of Get_Immediate without the parameter Available,
     the caller will wait until a character is available.

25
     32  In a literal string parameter of Put, the enclosing string
     bracket characters are not output.  Each doubled string bracket
     character in the enclosed string is output as a single string
     bracket character, as a consequence of the rule for string literals
     (see *note 2.6::).

26
     33  A string read by Get or written by Put can extend over several
     lines.  An implementation is allowed to assume that certain
     external files do not contain page terminators, in which case
     Get_Line and Skip_Line can return as soon as a line terminator is
     read.


File: arm2012.info,  Node: A.10.8,  Next: A.10.9,  Prev: A.10.7,  Up: A.10

A.10.8 Input-Output for Integer Types
-------------------------------------

                          _Static Semantics_

1
The following procedures are defined in the generic packages Integer_IO
and Modular_IO, which have to be instantiated for the appropriate signed
integer or modular type respectively (indicated by Num in the
specifications).

2
Values are output as decimal or based literals, without low line
characters or exponent, and, for Integer_IO, preceded by a minus sign if
negative.  The format (which includes any leading spaces and minus sign)
can be specified by an optional field width parameter.  Values of widths
of fields in output formats are of the nonnegative integer subtype
Field.  Values of bases are of the integer subtype Number_Base.

3
     subtype Number_Base is Integer range 2 .. 16;

4
The default field width and base to be used by output procedures are
defined by the following variables that are declared in the generic
packages Integer_IO and Modular_IO:

5
     Default_Width : Field := Num'Width;
     Default_Base  : Number_Base := 10;

6
The following procedures are provided:

7
     procedure Get(File : in File_Type; Item : out Num; Width : in Field := 0);
     procedure Get(Item : out Num; Width : in Field := 0);

8
          If the value of the parameter Width is zero, skips any leading
          blanks, line terminators, or page terminators, then reads a
          plus sign if present or (for a signed type only) a minus sign
          if present, then reads the longest possible sequence of
          characters matching the syntax of a numeric literal without a
          point.  If a nonzero value of Width is supplied, then exactly
          Width characters are input, or the characters (possibly none)
          up to a line terminator, whichever comes first; any skipped
          leading blanks are included in the count.

9
          Returns, in the parameter Item, the value of type Num that
          corresponds to the sequence input.

10/3
          The exception Data_Error is propagated if the sequence of
          characters read does not form a legal integer literal or if
          the value obtained is not of the subtype Num.

11
     procedure Put(File  : in File_Type;
                   Item  : in Num;
                   Width : in Field := Default_Width;
                   Base  : in Number_Base := Default_Base);

     procedure Put(Item  : in Num;
                   Width : in Field := Default_Width;
                   Base  : in Number_Base := Default_Base);

12
          Outputs the value of the parameter Item as an integer literal,
          with no low lines, no exponent, and no leading zeros (but a
          single zero for the value zero), and a preceding minus sign
          for a negative value.

13
          If the resulting sequence of characters to be output has fewer
          than Width characters, then leading spaces are first output to
          make up the difference.

14
          Uses the syntax for decimal literal if the parameter Base has
          the value ten (either explicitly or through Default_Base);
          otherwise, uses the syntax for based literal, with any letters
          in upper case.

15
     procedure Get(From : in String; Item : out Num; Last : out Positive);

16
          Reads an integer value from the beginning of the given string,
          following the same rules as the Get procedure that reads an
          integer value from a file, but treating the end of the string
          as a file terminator.  Returns, in the parameter Item, the
          value of type Num that corresponds to the sequence input.
          Returns in Last the index value such that From(Last) is the
          last character read.

17
          The exception Data_Error is propagated if the sequence input
          does not have the required syntax or if the value obtained is
          not of the subtype Num.

18
     procedure Put(To   : out String;
                   Item : in Num;
                   Base : in Number_Base := Default_Base);

19
          Outputs the value of the parameter Item to the given string,
          following the same rule as for output to a file, using the
          length of the given string as the value for Width.

20
Integer_Text_IO is a library package that is a nongeneric equivalent to
Text_IO.Integer_IO for the predefined type Integer:

21
     with Ada.Text_IO;
     package Ada.Integer_Text_IO is new Ada.Text_IO.Integer_IO(Integer);

22
For each predefined signed integer type, a nongeneric equivalent to
Text_IO.Integer_IO is provided, with names such as
Ada.Long_Integer_Text_IO.

                     _Implementation Permissions_

23
The nongeneric equivalent packages may, but need not, be actual
instantiations of the generic package for the appropriate predefined
type.

<Paragraphs 24 and 25 were deleted.>

                              _Examples_

26/3
     subtype Byte_Int is Integer range -127 .. 127;
     package Int_IO is new Integer_IO(Byte_Int); use Int_IO;
     --< default format used at instantiation,>
     --< Default_Width = 4, Default_Base = 10>

27
     Put(126);                            --< "b126">
     Put(-126, 7);                        --< "bbb-126">
     Put(126, Width => 13, Base => 2);    --< "bbb2#1111110#">


File: arm2012.info,  Node: A.10.9,  Next: A.10.10,  Prev: A.10.8,  Up: A.10

A.10.9 Input-Output for Real Types
----------------------------------

                          _Static Semantics_

1
The following procedures are defined in the generic packages Float_IO,
Fixed_IO, and Decimal_IO, which have to be instantiated for the
appropriate floating point, ordinary fixed point, or decimal fixed point
type respectively (indicated by Num in the specifications).

2
Values are output as decimal literals without low line characters.  The
format of each value output consists of a Fore field, a decimal point,
an Aft field, and (if a nonzero Exp parameter is supplied) the letter E
and an Exp field.  The two possible formats thus correspond to:

3
     Fore  .  Aft

4
and to:

5
     Fore  .  Aft  E  Exp

6
without any spaces between these fields.  The Fore field may include
leading spaces, and a minus sign for negative values.  The Aft field
includes only decimal digits (possibly with trailing zeros).  The Exp
field includes the sign (plus or minus) and the exponent (possibly with
leading zeros).

7
For floating point types, the default lengths of these fields are
defined by the following variables that are declared in the generic
package Float_IO:

8
     Default_Fore : Field := 2;
     Default_Aft  : Field := Num'Digits-1;
     Default_Exp  : Field := 3;

9
For ordinary or decimal fixed point types, the default lengths of these
fields are defined by the following variables that are declared in the
generic packages Fixed_IO and Decimal_IO, respectively:

10
     Default_Fore : Field := Num'Fore;
     Default_Aft  : Field := Num'Aft;
     Default_Exp  : Field := 0;

11
The following procedures are provided:

12
     procedure Get(File : in File_Type; Item : out Num; Width : in Field := 0);
     procedure Get(Item : out Num; Width : in Field := 0);

13
          If the value of the parameter Width is zero, skips any leading
          blanks, line terminators, or page terminators, then reads the
          longest possible sequence of characters matching the syntax of
          any of the following (see *note 2.4::):

14
             * [+|-]numeric_literal

15
             * [+|-]numeral.[exponent]

16
             * [+|-].numeral[exponent]

17
             * [+|-]base#based_numeral.#[exponent]

18
             * [+|-]base#.based_numeral#[exponent]

19
          If a nonzero value of Width is supplied, then exactly Width
          characters are input, or the characters (possibly none) up to
          a line terminator, whichever comes first; any skipped leading
          blanks are included in the count.

20
          Returns in the parameter Item the value of type Num that
          corresponds to the sequence input, preserving the sign
          (positive if none has been specified) of a zero value if Num
          is a floating point type and Num'Signed_Zeros is True.

21
          The exception Data_Error is propagated if the sequence input
          does not have the required syntax or if the value obtained is
          not of the subtype Num.

22
     procedure Put(File : in File_Type;
                   Item : in Num;
                   Fore : in Field := Default_Fore;
                   Aft  : in Field := Default_Aft;
                   Exp  : in Field := Default_Exp);

     procedure Put(Item : in Num;
                   Fore : in Field := Default_Fore;
                   Aft  : in Field := Default_Aft;
                   Exp  : in Field := Default_Exp);

23
          Outputs the value of the parameter Item as a decimal literal
          with the format defined by Fore, Aft and Exp.  If the value is
          negative, or if Num is a floating point type where
          Num'Signed_Zeros is True and the value is a negatively signed
          zero, then a minus sign is included in the integer part.  If
          Exp has the value zero, then the integer part to be output has
          as many digits as are needed to represent the integer part of
          the value of Item, overriding Fore if necessary, or consists
          of the digit zero if the value of Item has no integer part.

24
          If Exp has a value greater than zero, then the integer part to
          be output has a single digit, which is nonzero except for the
          value 0.0 of Item.

25
          In both cases, however, if the integer part to be output has
          fewer than Fore characters, including any minus sign, then
          leading spaces are first output to make up the difference.
          The number of digits of the fractional part is given by Aft,
          or is one if Aft equals zero.  The value is rounded; a value
          of exactly one half in the last place is rounded away from
          zero.

26
          If Exp has the value zero, there is no exponent part.  If Exp
          has a value greater than zero, then the exponent part to be
          output has as many digits as are needed to represent the
          exponent part of the value of Item (for which a single digit
          integer part is used), and includes an initial sign (plus or
          minus).  If the exponent part to be output has fewer than Exp
          characters, including the sign, then leading zeros precede the
          digits, to make up the difference.  For the value 0.0 of Item,
          the exponent has the value zero.

27
     procedure Get(From : in String; Item : out Num; Last : out Positive);

28
          Reads a real value from the beginning of the given string,
          following the same rule as the Get procedure that reads a real
          value from a file, but treating the end of the string as a
          file terminator.  Returns, in the parameter Item, the value of
          type Num that corresponds to the sequence input.  Returns in
          Last the index value such that From(Last) is the last
          character read.

29
          The exception Data_Error is propagated if the sequence input
          does not have the required syntax, or if the value obtained is
          not of the subtype Num.

30
     procedure Put(To   : out String;
                   Item : in Num;
                   Aft  : in Field := Default_Aft;
                   Exp  : in Field := Default_Exp);

31
          Outputs the value of the parameter Item to the given string,
          following the same rule as for output to a file, using a value
          for Fore such that the sequence of characters output exactly
          fills the string, including any leading spaces.

32
Float_Text_IO is a library package that is a nongeneric equivalent to
Text_IO.Float_IO for the predefined type Float:

33
     with Ada.Text_IO;
     package Ada.Float_Text_IO is new Ada.Text_IO.Float_IO(Float);

34
For each predefined floating point type, a nongeneric equivalent to
Text_IO.Float_IO is provided, with names such as Ada.Long_Float_Text_IO.

                     _Implementation Permissions_

35
An implementation may extend Get and Put for floating point types to
support special values such as infinities and NaNs.

36
The implementation of Put need not produce an output value with greater
accuracy than is supported for the base subtype.  The additional
accuracy, if any, of the value produced by Put when the number of
requested digits in the integer and fractional parts exceeds the
required accuracy is implementation defined.

37
The nongeneric equivalent packages may, but need not, be actual
instantiations of the generic package for the appropriate predefined
type.

     NOTES

38
     34  For an item with a positive value, if output to a string
     exactly fills the string without leading spaces, then output of the
     corresponding negative value will propagate Layout_Error.

39
     35  The rules for the Value attribute (see *note 3.5::) and the
     rules for Get are based on the same set of formats.

                              _Examples_

40/1
     <This paragraph was deleted.>

41
     package Real_IO is new Float_IO(Real); use Real_IO;
     --< default format used at instantiation, Default_Exp = 3>

42
     X : Real := -123.4567;  --<  digits 8      (see *note 3.5.7::)>

43
     Put(X);  <-- default format>    <"-1.2345670E+02">
     Put(X, Fore => 5, Aft => 3, Exp => 2);    <-- "bbb-1.235E+2">
     Put(X, 5, 3, 0);                <-- "b-123.457">


File: arm2012.info,  Node: A.10.10,  Next: A.10.11,  Prev: A.10.9,  Up: A.10

A.10.10 Input-Output for Enumeration Types
------------------------------------------

                          _Static Semantics_

1
The following procedures are defined in the generic package
Enumeration_IO, which has to be instantiated for the appropriate
enumeration type (indicated by Enum in the specification).

2
Values are output using either upper or lower case letters for
identifiers.  This is specified by the parameter Set, which is of the
enumeration type Type_Set.

3
     type Type_Set is (Lower_Case, Upper_Case);

4
The format (which includes any trailing spaces) can be specified by an
optional field width parameter.  The default field width and letter case
are defined by the following variables that are declared in the generic
package Enumeration_IO:

5
     Default_Width   : Field := 0;
     Default_Setting : Type_Set := Upper_Case;

6
The following procedures are provided:

7
     procedure Get(File : in File_Type; Item : out Enum);
     procedure Get(Item : out Enum);

8
          After skipping any leading blanks, line terminators, or page
          terminators, reads an identifier according to the syntax of
          this lexical element (lower and upper case being considered
          equivalent), or a character literal according to the syntax of
          this lexical element (including the apostrophes).  Returns, in
          the parameter Item, the value of type Enum that corresponds to
          the sequence input.

9
          The exception Data_Error is propagated if the sequence input
          does not have the required syntax, or if the identifier or
          character literal does not correspond to a value of the
          subtype Enum.

10
     procedure Put(File  : in File_Type;
                   Item  : in Enum;
                   Width : in Field := Default_Width;
                   Set   : in Type_Set := Default_Setting);

     procedure Put(Item  : in Enum;
                   Width : in Field := Default_Width;
                   Set   : in Type_Set := Default_Setting);

11
          Outputs the value of the parameter Item as an enumeration
          literal (either an identifier or a character literal).  The
          optional parameter Set indicates whether lower case or upper
          case is used for identifiers; it has no effect for character
          literals.  If the sequence of characters produced has fewer
          than Width characters, then trailing spaces are finally output
          to make up the difference.  If Enum is a character type, the
          sequence of characters produced is as for Enum'Image(Item), as
          modified by the Width and Set parameters.

12
     procedure Get(From : in String; Item : out Enum; Last : out Positive);

13
          Reads an enumeration value from the beginning of the given
          string, following the same rule as the Get procedure that
          reads an enumeration value from a file, but treating the end
          of the string as a file terminator.  Returns, in the parameter
          Item, the value of type Enum that corresponds to the sequence
          input.  Returns in Last the index value such that From(Last)
          is the last character read.

14
          The exception Data_Error is propagated if the sequence input
          does not have the required syntax, or if the identifier or
          character literal does not correspond to a value of the
          subtype Enum.

15
     procedure Put(To   : out String;
                   Item : in Enum;
                   Set  : in Type_Set := Default_Setting);

16
          Outputs the value of the parameter Item to the given string,
          following the same rule as for output to a file, using the
          length of the given string as the value for Width.

17/1
Although the specification of the generic package Enumeration_IO would
allow instantiation for an integer type, this is not the intended
purpose of this generic package, and the effect of such instantiations
is not defined by the language.

     NOTES

18
     36  There is a difference between Put defined for characters, and
     for enumeration values.  Thus

19
             Ada.Text_IO.Put('A');  --<  outputs the character A>

20
             package Char_IO is new Ada.Text_IO.Enumeration_IO(Character);
             Char_IO.Put('A');  --<  outputs the character 'A', between apostrophes>

21
     37  The type Boolean is an enumeration type, hence Enumeration_IO
     can be instantiated for this type.


File: arm2012.info,  Node: A.10.11,  Next: A.10.12,  Prev: A.10.10,  Up: A.10

A.10.11 Input-Output for Bounded Strings
----------------------------------------

1/2
The package Text_IO.Bounded_IO provides input-output in human-readable
form for Bounded_Strings.

                          _Static Semantics_

2/2
The generic library package Text_IO.Bounded_IO has the following
declaration:

3/2
     with Ada.Strings.Bounded;
     generic
        with package Bounded is
                          new Ada.Strings.Bounded.Generic_Bounded_Length (<>);
     package Ada.Text_IO.Bounded_IO is

4/2
        procedure Put
           (File : in File_Type;
            Item : in Bounded.Bounded_String);

5/2
        procedure Put
           (Item : in Bounded.Bounded_String);

6/2
        procedure Put_Line
           (File : in File_Type;
            Item : in Bounded.Bounded_String);

7/2
        procedure Put_Line
           (Item : in Bounded.Bounded_String);

8/2
        function Get_Line
           (File : in File_Type)
           return Bounded.Bounded_String;

9/2
        function Get_Line
           return Bounded.Bounded_String;

10/2
        procedure Get_Line
           (File : in File_Type; Item : out Bounded.Bounded_String);

11/2
        procedure Get_Line
           (Item : out Bounded.Bounded_String);

12/2
     end Ada.Text_IO.Bounded_IO;

13/2
For an item of type Bounded_String, the following subprograms are
provided:

14/2
     procedure Put
        (File : in File_Type;
         Item : in Bounded.Bounded_String);

15/2
          Equivalent to Text_IO.Put (File, Bounded.To_String(Item));

16/2
     procedure Put
        (Item : in Bounded.Bounded_String);

17/2
          Equivalent to Text_IO.Put (Bounded.To_String(Item));

18/2
     procedure Put_Line
        (File : in File_Type;
         Item : in Bounded.Bounded_String);

19/2
          Equivalent to Text_IO.Put_Line (File,
          Bounded.To_String(Item));

20/2
     procedure Put_Line
        (Item : in Bounded.Bounded_String);

21/2
          Equivalent to Text_IO.Put_Line (Bounded.To_String(Item));

22/2
     function Get_Line
        (File : in File_Type)
        return Bounded.Bounded_String;

23/2
          Returns Bounded.To_Bounded_String(Text_IO.Get_Line(File));

24/2
     function Get_Line
        return Bounded.Bounded_String;

25/2
          Returns Bounded.To_Bounded_String(Text_IO.Get_Line);

26/2
     procedure Get_Line
        (File : in File_Type; Item : out Bounded.Bounded_String);

27/2
          Equivalent to Item := Get_Line (File);

28/2
     procedure Get_Line
        (Item : out Bounded.Bounded_String);

29/2
          Equivalent to Item := Get_Line;


File: arm2012.info,  Node: A.10.12,  Prev: A.10.11,  Up: A.10

A.10.12 Input-Output for Unbounded Strings
------------------------------------------

1/2
The package Text_IO.Unbounded_IO provides input-output in human-readable
form for Unbounded_Strings.

                          _Static Semantics_

2/2
The library package Text_IO.Unbounded_IO has the following declaration:

3/2
     with Ada.Strings.Unbounded;
     package Ada.Text_IO.Unbounded_IO is

4/2
        procedure Put
           (File : in File_Type;
            Item : in Strings.Unbounded.Unbounded_String);

5/2
        procedure Put
           (Item : in Strings.Unbounded.Unbounded_String);

6/2
        procedure Put_Line
           (File : in File_Type;
            Item : in Strings.Unbounded.Unbounded_String);

7/2
        procedure Put_Line
           (Item : in Strings.Unbounded.Unbounded_String);

8/2
        function Get_Line
           (File : in File_Type)
           return Strings.Unbounded.Unbounded_String;

9/2
        function Get_Line
           return Strings.Unbounded.Unbounded_String;

10/2
        procedure Get_Line
           (File : in File_Type; Item : out Strings.Unbounded.Unbounded_String);

11/2
        procedure Get_Line
           (Item : out Strings.Unbounded.Unbounded_String);

12/2
     end Ada.Text_IO.Unbounded_IO;

13/2
For an item of type Unbounded_String, the following subprograms are
provided:

14/2
     procedure Put
        (File : in File_Type;
         Item : in Strings.Unbounded.Unbounded_String);

15/2
          Equivalent to Text_IO.Put (File,
          Strings.Unbounded.To_String(Item));

16/2
     procedure Put
        (Item : in Strings.Unbounded.Unbounded_String);

17/2
          Equivalent to Text_IO.Put (Strings.Unbounded.To_String(Item));

18/2
     procedure Put_Line
        (File : in File_Type;
         Item : in Strings.Unbounded.Unbounded_String);

19/2
          Equivalent to Text_IO.Put_Line (File,
          Strings.Unbounded.To_String(Item));

20/2
     procedure Put_Line
        (Item : in Strings.Unbounded.Unbounded_String);

21/2
          Equivalent to Text_IO.Put_Line
          (Strings.Unbounded.To_String(Item));

22/2
     function Get_Line
        (File : in File_Type)
        return Strings.Unbounded.Unbounded_String;

23/2
          Returns
          Strings.Unbounded.To_Unbounded_String(Text_IO.Get_Line(File));

24/2
     function Get_Line
        return Strings.Unbounded.Unbounded_String;

25/2
          Returns
          Strings.Unbounded.To_Unbounded_String(Text_IO.Get_Line);

26/2
     procedure Get_Line
        (File : in File_Type; Item : out Strings.Unbounded.Unbounded_String);

27/2
          Equivalent to Item := Get_Line (File);

28/2
     procedure Get_Line
        (Item : out Strings.Unbounded.Unbounded_String);

29/2
          Equivalent to Item := Get_Line;


File: arm2012.info,  Node: A.11,  Next: A.12,  Prev: A.10,  Up: Annex A

A.11 Wide Text Input-Output and Wide Wide Text Input-Output
===========================================================

1/2
The packages Wide_Text_IO and Wide_Wide_Text_IO provide facilities for
input and output in human-readable form.  Each file is read or written
sequentially, as a sequence of wide characters (or wide wide characters)
grouped into lines, and as a sequence of lines grouped into pages.

                          _Static Semantics_

2/2
The specification of package Wide_Text_IO is the same as that for
Text_IO, except that in each Get, Look_Ahead, Get_Immediate, Get_Line,
Put, and Put_Line subprogram, any occurrence of Character is replaced by
Wide_Character, and any occurrence of String is replaced by Wide_String.
Nongeneric equivalents of Wide_Text_IO.Integer_IO and
Wide_Text_IO.Float_IO are provided (as for Text_IO) for each predefined
numeric type, with names such as Ada.Integer_Wide_Text_IO,
Ada.Long_Integer_Wide_Text_IO, Ada.Float_Wide_Text_IO,
Ada.Long_Float_Wide_Text_IO.

3/2
The specification of package Wide_Wide_Text_IO is the same as that for
Text_IO, except that in each Get, Look_Ahead, Get_Immediate, Get_Line,
Put, and Put_Line subprogram, any occurrence of Character is replaced by
Wide_Wide_Character, and any occurrence of String is replaced by
Wide_Wide_String.  Nongeneric equivalents of
Wide_Wide_Text_IO.Integer_IO and Wide_Wide_Text_IO.Float_IO are provided
(as for Text_IO) for each predefined numeric type, with names such as
Ada.Integer_Wide_Wide_Text_IO, Ada.Long_Integer_Wide_Wide_Text_IO,
Ada.Float_Wide_Wide_Text_IO, Ada.Long_Float_Wide_Wide_Text_IO.

4/3
The specification of package Wide_Text_IO.Wide_Bounded_IO is the same as
that for Text_IO.Bounded_IO, except that any occurrence of
Bounded_String is replaced by Bounded_Wide_String, and any occurrence of
package Bounded is replaced by Wide_Bounded.  The specification of
package Wide_Wide_Text_IO.Wide_Wide_Bounded_IO is the same as that for
Text_IO.Bounded_IO, except that any occurrence of Bounded_String is
replaced by Bounded_Wide_Wide_String, and any occurrence of package
Bounded is replaced by Wide_Wide_Bounded.

5/3
The specification of package Wide_Text_IO.Wide_Unbounded_IO is the same
as that for Text_IO.Unbounded_IO, except that any occurrence of
Unbounded_String is replaced by Unbounded_Wide_String, and any
occurrence of package Unbounded is replaced by Wide_Unbounded.  The
specification of package Wide_Wide_Text_IO.Wide_Wide_Unbounded_IO is the
same as that for Text_IO.Unbounded_IO, except that any occurrence of
Unbounded_String is replaced by Unbounded_Wide_Wide_String, and any
occurrence of package Unbounded is replaced by Wide_Wide_Unbounded.


File: arm2012.info,  Node: A.12,  Next: A.13,  Prev: A.11,  Up: Annex A

A.12 Stream Input-Output
========================

1/2
The packages Streams.Stream_IO, Text_IO.Text_Streams,
Wide_Text_IO.Text_Streams, and Wide_Wide_Text_IO.Text_Streams provide
stream-oriented operations on files.

* Menu:

* A.12.1 ::   The Package Streams.Stream_IO
* A.12.2 ::   The Package Text_IO.Text_Streams
* A.12.3 ::   The Package Wide_Text_IO.Text_Streams
* A.12.4 ::   The Package Wide_Wide_Text_IO.Text_Streams


File: arm2012.info,  Node: A.12.1,  Next: A.12.2,  Up: A.12

A.12.1 The Package Streams.Stream_IO
------------------------------------

1
The subprograms in the child package Streams.Stream_IO provide control
over stream files.  Access to a stream file is either sequential, via a
call on Read or Write to transfer an array of stream elements, or
positional (if supported by the implementation for the given file), by
specifying a relative index for an element.  Since a stream file can be
converted to a Stream_Access value, calling stream-oriented attribute
subprograms of different element types with the same Stream_Access value
provides heterogeneous input-output.  See *note 13.13:: for a general
discussion of streams.

                          _Static Semantics_

1.1/1
The elements of a stream file are stream elements.  If positioning is
supported for the specified external file, a current index and current
size are maintained for the file as described in *note A.8::.  If
positioning is not supported, a current index is not maintained, and the
current size is implementation defined.

2
The library package Streams.Stream_IO has the following declaration:

3/3
     with Ada.IO_Exceptions;
     package Ada.Streams.Stream_IO is
         pragma Preelaborate(Stream_IO);

4
         type Stream_Access is access all Root_Stream_Type'Class;

5/4
         type File_Type is limited private;
         pragma Preelaborable_Initialization(File_Type);

6
         type File_Mode is (In_File, Out_File, Append_File);

7
         type    Count          is range 0 .. <implementation-defined>;
         subtype Positive_Count is Count range 1 .. Count'Last;
           -- <Index into file, in stream elements.>

8
         procedure Create (File : in out File_Type;
                           Mode : in File_Mode := Out_File;
                           Name : in String    := "";
                           Form : in String    := "");

9
         procedure Open (File : in out File_Type;
                         Mode : in File_Mode;
                         Name : in String;
                         Form : in String := "");

10
         procedure Close  (File : in out File_Type);
         procedure Delete (File : in out File_Type);
         procedure Reset  (File : in out File_Type; Mode : in File_Mode);
         procedure Reset  (File : in out File_Type);

11
         function Mode (File : in File_Type) return File_Mode;
         function Name (File : in File_Type) return String;
         function Form (File : in File_Type) return String;

12
         function Is_Open     (File : in File_Type) return Boolean;
         function End_Of_File (File : in File_Type) return Boolean;

13
         function Stream (File : in File_Type) return Stream_Access;
             -- <Return stream access for use with T'Input and T'Output>

14/1
     <This paragraph was deleted.>

15
         -- <Read array of stream elements from file>
         procedure Read (File : in  File_Type;
                         Item : out Stream_Element_Array;
                         Last : out Stream_Element_Offset;
                         From : in  Positive_Count);

16
         procedure Read (File : in  File_Type;
                         Item : out Stream_Element_Array;
                         Last : out Stream_Element_Offset);

17/1
     <This paragraph was deleted.>

18
         -- <Write array of stream elements into file>
         procedure Write (File : in File_Type;
                          Item : in Stream_Element_Array;
                          To   : in Positive_Count);

19
         procedure Write (File : in File_Type;
                          Item : in Stream_Element_Array);

20/1
     <This paragraph was deleted.>

21
         -- <Operations on position within file>

22
         procedure Set_Index(File : in File_Type; To : in Positive_Count);

23
         function Index(File : in File_Type) return Positive_Count;
         function Size (File : in File_Type) return Count;

24
         procedure Set_Mode(File : in out File_Type; Mode : in File_Mode);

25/1
         procedure Flush(File : in File_Type);

26
         -- <exceptions>
         Status_Error : exception renames IO_Exceptions.Status_Error;
         Mode_Error   : exception renames IO_Exceptions.Mode_Error;
         Name_Error   : exception renames IO_Exceptions.Name_Error;
         Use_Error    : exception renames IO_Exceptions.Use_Error;
         Device_Error : exception renames IO_Exceptions.Device_Error;
         End_Error    : exception renames IO_Exceptions.End_Error;
         Data_Error   : exception renames IO_Exceptions.Data_Error;

27
     private
        ... -- <not specified by the language>
     end Ada.Streams.Stream_IO;

27.1/2
The type File_Type needs finalization (see *note 7.6::).

28/4
The subprograms given in subclause *note A.8.2:: for the control of
external files (Create, Open, Close, Delete, Reset, Mode, Name, Form,
Is_Open, and Flush) are available for stream files.

28.1/2
The End_Of_File function:

28.2/2
   * Propagates Mode_Error if the mode of the file is not In_File;

28.3/3
   * If positioning is supported for the given external file, the
     function returns True if the current index exceeds the size of the
     external file; otherwise, it returns False;

28.4/3
   * If positioning is not supported for the given external file, the
     function returns True if no more elements can be read from the
     given file; otherwise, it returns False.

28.5/2
The Set_Mode procedure sets the mode of the file.  If the new mode is
Append_File, the file is positioned to its end; otherwise, the position
in the file is unchanged.

28.6/4
<This paragraph was deleted.>

29/1
The Stream function returns a Stream_Access result from a File_Type
object, thus allowing the stream-oriented attributes Read, Write, Input,
and Output to be used on the same file for multiple types.  Stream
propagates Status_Error if File is not open.

30/2
The procedures Read and Write are equivalent to the corresponding
operations in the package Streams.  Read propagates Mode_Error if the
mode of File is not In_File.  Write propagates Mode_Error if the mode of
File is not Out_File or Append_File.  The Read procedure with a
Positive_Count parameter starts reading at the specified index.  The
Write procedure with a Positive_Count parameter starts writing at the
specified index.  For a file that supports positioning, Read without a
Positive_Count parameter starts reading at the current index, and Write
without a Positive_Count parameter starts writing at the current index.

30.1/1
The Size function returns the current size of the file.

31/1
The Index function returns the current index.

32
The Set_Index procedure sets the current index to the specified value.

32.1/1
If positioning is supported for the external file, the current index is
maintained as follows:

32.2/1
   * For Open and Create, if the Mode parameter is Append_File, the
     current index is set to the current size of the file plus one;
     otherwise, the current index is set to one.

32.3/1
   * For Reset, if the Mode parameter is Append_File, or no Mode
     parameter is given and the current mode is Append_File, the current
     index is set to the current size of the file plus one; otherwise,
     the current index is set to one.

32.4/1
   * For Set_Mode, if the new mode is Append_File, the current index is
     set to current size plus one; otherwise, the current index is
     unchanged.

32.5/1
   * For Read and Write without a Positive_Count parameter, the current
     index is incremented by the number of stream elements read or
     written.

32.6/1
   * For Read and Write with a Positive_Count parameter, the value of
     the current index is set to the value of the Positive_Count
     parameter plus the number of stream elements read or written.

33
If positioning is not supported for the given file, then a call of Index
or Set_Index propagates Use_Error.  Similarly, a call of Read or Write
with a Positive_Count parameter propagates Use_Error.

<Paragraphs 34 through 36 were deleted.>

                         _Erroneous Execution_

36.1/1
If the File_Type object passed to the Stream function is later closed or
finalized, and the stream-oriented attributes are subsequently called
(explicitly or implicitly) on the Stream_Access value returned by
Stream, execution is erroneous.  This rule applies even if the File_Type
object was opened again after it had been closed.


File: arm2012.info,  Node: A.12.2,  Next: A.12.3,  Prev: A.12.1,  Up: A.12

A.12.2 The Package Text_IO.Text_Streams
---------------------------------------

1
The package Text_IO.Text_Streams provides a function for treating a text
file as a stream.

                          _Static Semantics_

2
The library package Text_IO.Text_Streams has the following declaration:

3
     with Ada.Streams;
     package Ada.Text_IO.Text_Streams is
        type Stream_Access is access all Streams.Root_Stream_Type'Class;

4
        function Stream (File : in File_Type) return Stream_Access;
     end Ada.Text_IO.Text_Streams;

5
The Stream function has the same effect as the corresponding function in
Streams.Stream_IO.

     NOTES

6
     38  The ability to obtain a stream for a text file allows
     Current_Input, Current_Output, and Current_Error to be processed
     with the functionality of streams, including the mixing of text and
     binary input-output, and the mixing of binary input-output for
     different types.

7
     39  Performing operations on the stream associated with a text file
     does not affect the column, line, or page counts.


File: arm2012.info,  Node: A.12.3,  Next: A.12.4,  Prev: A.12.2,  Up: A.12

A.12.3 The Package Wide_Text_IO.Text_Streams
--------------------------------------------

1
The package Wide_Text_IO.Text_Streams provides a function for treating a
wide text file as a stream.

                          _Static Semantics_

2
The library package Wide_Text_IO.Text_Streams has the following
declaration:

3
     with Ada.Streams;
     package Ada.Wide_Text_IO.Text_Streams is
        type Stream_Access is access all Streams.Root_Stream_Type'Class;

4
        function Stream (File : in File_Type) return Stream_Access;
     end Ada.Wide_Text_IO.Text_Streams;

5
The Stream function has the same effect as the corresponding function in
Streams.Stream_IO.


File: arm2012.info,  Node: A.12.4,  Prev: A.12.3,  Up: A.12

A.12.4 The Package Wide_Wide_Text_IO.Text_Streams
-------------------------------------------------

1/2
The package Wide_Wide_Text_IO.Text_Streams provides a function for
treating a wide wide text file as a stream.

                          _Static Semantics_

2/2
The library package Wide_Wide_Text_IO.Text_Streams has the following
declaration:

3/2
     with Ada.Streams;
     package Ada.Wide_Wide_Text_IO.Text_Streams is
        type Stream_Access is access all Streams.Root_Stream_Type'Class;

4/2
        function Stream (File : in File_Type) return Stream_Access;
     end Ada.Wide_Wide_Text_IO.Text_Streams;

5/2
The Stream function has the same effect as the corresponding function in
Streams.Stream_IO.


File: arm2012.info,  Node: A.13,  Next: A.14,  Prev: A.12,  Up: Annex A

A.13 Exceptions in Input-Output
===============================

1
The package IO_Exceptions defines the exceptions needed by the
predefined input-output packages.

                          _Static Semantics_

2
The library package IO_Exceptions has the following declaration:

3
     package Ada.IO_Exceptions is
        pragma Pure(IO_Exceptions);

4
        Status_Error : exception;
        Mode_Error   : exception;
        Name_Error   : exception;
        Use_Error    : exception;
        Device_Error : exception;
        End_Error    : exception;
        Data_Error   : exception;
        Layout_Error : exception;

5
     end Ada.IO_Exceptions;

6
If more than one error condition exists, the corresponding exception
that appears earliest in the following list is the one that is
propagated.

7
The exception Status_Error is propagated by an attempt to operate upon a
file that is not open, and by an attempt to open a file that is already
open.

8
The exception Mode_Error is propagated by an attempt to read from, or
test for the end of, a file whose current mode is Out_File or
Append_File, and also by an attempt to write to a file whose current
mode is In_File.  In the case of Text_IO, the exception Mode_Error is
also propagated by specifying a file whose current mode is Out_File or
Append_File in a call of Set_Input, Skip_Line, End_Of_Line, Skip_Page,
or End_Of_Page; and by specifying a file whose current mode is In_File
in a call of Set_Output, Set_Line_Length, Set_Page_Length, Line_Length,
Page_Length, New_Line, or New_Page.

9
The exception Name_Error is propagated by a call of Create or Open if
the string given for the parameter Name does not allow the
identification of an external file.  For example, this exception is
propagated if the string is improper, or, alternatively, if either none
or more than one external file corresponds to the string.

10
The exception Use_Error is propagated if an operation is attempted that
is not possible for reasons that depend on characteristics of the
external file.  For example, this exception is propagated by the
procedure Create, among other circumstances, if the given mode is
Out_File but the form specifies an input only device, if the parameter
Form specifies invalid access rights, or if an external file with the
given name already exists and overwriting is not allowed.

11
The exception Device_Error is propagated if an input-output operation
cannot be completed because of a malfunction of the underlying system.

12
The exception End_Error is propagated by an attempt to skip (read past)
the end of a file.

13
The exception Data_Error can be propagated by the procedure Read (or by
the Read attribute) if the element read cannot be interpreted as a value
of the required subtype.  This exception is also propagated by a
procedure Get (defined in the package Text_IO) if the input character
sequence fails to satisfy the required syntax, or if the value input
does not belong to the range of the required subtype.

14
The exception Layout_Error is propagated (in text input-output) by Col,
Line, or Page if the value returned exceeds Count'Last.  The exception
Layout_Error is also propagated on output by an attempt to set column or
line numbers in excess of specified maximum line or page lengths,
respectively (excluding the unbounded cases).  It is also propagated by
an attempt to Put too many characters to a string.

14.1/3
These exceptions are also propagated by various other language-defined
packages and operations, see the definition of those entities for other
reasons that these exceptions are propagated.

                     _Documentation Requirements_

15
The implementation shall document the conditions under which Name_Error,
Use_Error and Device_Error are propagated.

                     _Implementation Permissions_

16
If the associated check is too complex, an implementation need not
propagate Data_Error as part of a procedure Read (or the Read attribute)
if the value read cannot be interpreted as a value of the required
subtype.

                         _Erroneous Execution_

17
If the element read by the procedure Read (or by the Read attribute)
cannot be interpreted as a value of the required subtype, but this is
not detected and Data_Error is not propagated, then the resulting value
can be abnormal, and subsequent references to the value can lead to
erroneous execution, as explained in *note 13.9.1::.  


File: arm2012.info,  Node: A.14,  Next: A.15,  Prev: A.13,  Up: Annex A

A.14 File Sharing
=================

                          _Dynamic Semantics_

1
It is not specified by the language whether the same external file can
be associated with more than one file object.  If such sharing is
supported by the implementation, the following effects are defined:

2
   * Operations on one text file object do not affect the column, line,
     and page numbers of any other file object.

3/1
   * <This paragraph was deleted.>

4
   * For direct and stream files, the current index is a property of
     each file object; an operation on one file object does not affect
     the current index of any other file object.

5
   * For direct and stream files, the current size of the file is a
     property of the external file.

6
All other effects are identical.


File: arm2012.info,  Node: A.15,  Next: A.16,  Prev: A.14,  Up: Annex A

A.15 The Package Command_Line
=============================

1
The package Command_Line allows a program to obtain the values of its
arguments and to set the exit status code to be returned on normal
termination.

                          _Static Semantics_

2
The library package Ada.Command_Line has the following declaration:

3
     package Ada.Command_Line is
       pragma Preelaborate(Command_Line);

4
       function Argument_Count return Natural;

5
       function Argument (Number : in Positive) return String;

6
       function Command_Name return String;

7
       type Exit_Status is <implementation-defined integer type>;

8
       Success : constant Exit_Status;
       Failure : constant Exit_Status;

9
       procedure Set_Exit_Status (Code : in Exit_Status);

10
     private
       ... -- <not specified by the language>
     end Ada.Command_Line;


11
     function Argument_Count return Natural;

12/3
          If the external execution environment supports passing
          arguments to a program, then Argument_Count returns the number
          of arguments passed to the program invoking the function.
          Otherwise, it returns 0.  The meaning of "number of arguments"
          is implementation defined.

13
     function Argument (Number : in Positive) return String;

14
          If the external execution environment supports passing
          arguments to a program, then Argument returns an
          implementation-defined value corresponding to the argument at
          relative position Number.  If Number is outside the range
          1..Argument_Count, then Constraint_Error is propagated.

15
     function Command_Name return String;

16/3
          If the external execution environment supports passing
          arguments to a program, then Command_Name returns an
          implementation-defined value corresponding to the name of the
          command invoking the program; otherwise, Command_Name returns
          the null string.

16.1/1
     type Exit_Status is <implementation-defined integer type>;

17
          The type Exit_Status represents the range of exit status
          values supported by the external execution environment.  The
          constants Success and Failure correspond to success and
          failure, respectively.

18
     procedure Set_Exit_Status (Code : in Exit_Status);

19
          If the external execution environment supports returning an
          exit status from a program, then Set_Exit_Status sets Code as
          the status.  Normal termination of a program returns as the
          exit status the value most recently set by Set_Exit_Status,
          or, if no such value has been set, then the value Success.  If
          a program terminates abnormally, the status set by
          Set_Exit_Status is ignored, and an implementation-defined exit
          status value is set.

20
          If the external execution environment does not support
          returning an exit value from a program, then Set_Exit_Status
          does nothing.

                     _Implementation Permissions_

21
An alternative declaration is allowed for package Command_Line if
different functionality is appropriate for the external execution
environment.

     NOTES

22
     40  Argument_Count, Argument, and Command_Name correspond to the C
     language's argc, argv[n] (for n>0) and argv[0], respectively.


File: arm2012.info,  Node: A.16,  Next: A.17,  Prev: A.15,  Up: Annex A

A.16 The Package Directories
============================

1/2
The package Directories provides operations for manipulating files and
directories, and their names.

                          _Static Semantics_

2/2
The library package Directories has the following declaration:

3/2
     with Ada.IO_Exceptions;
     with Ada.Calendar;
     package Ada.Directories is

4/2
        -- <Directory and file operations:>

5/2
        function Current_Directory return String;

6/2
        procedure Set_Directory (Directory : in String);

7/2
        procedure Create_Directory (New_Directory : in String;
                                    Form          : in String := "");

8/2
        procedure Delete_Directory (Directory : in String);

9/2
        procedure Create_Path (New_Directory : in String;
                               Form          : in String := "");

10/2
        procedure Delete_Tree (Directory : in String);

11/2
        procedure Delete_File (Name : in String);

12/2
        procedure Rename (Old_Name, New_Name : in String);

13/2
        procedure Copy_File (Source_Name,
                             Target_Name : in String;
                             Form        : in String := "");

14/2
        -- <File and directory name operations:>

15/2
        function Full_Name (Name : in String) return String;

16/2
        function Simple_Name (Name : in String) return String;

17/2
        function Containing_Directory (Name : in String) return String;

18/2
        function Extension (Name : in String) return String;

19/2
        function Base_Name (Name : in String) return String;

20/2
        function Compose (Containing_Directory : in String := "";
                          Name                 : in String;
                          Extension            : in String := "") return String;

20.1/3
        type Name_Case_Kind is
           (Unknown, Case_Sensitive, Case_Insensitive, Case_Preserving);

20.2/3
        function Name_Case_Equivalence (Name : in String) return Name_Case_Kind;

21/2
        -- <File and directory queries:>

22/2
        type File_Kind is (Directory, Ordinary_File, Special_File);

23/2
        type File_Size is range 0 .. <implementation-defined>;

24/2
        function Exists (Name : in String) return Boolean;

25/2
        function Kind (Name : in String) return File_Kind;

26/2
        function Size (Name : in String) return File_Size;

27/2
        function Modification_Time (Name : in String) return Ada.Calendar.Time;

28/2
        -- <Directory searching:>

29/2
        type Directory_Entry_Type is limited private;

30/2
        type Filter_Type is array (File_Kind) of Boolean;

31/2
        type Search_Type is limited private;

32/2
        procedure Start_Search (Search    : in out Search_Type;
                                Directory : in String;
                                Pattern   : in String;
                                Filter    : in Filter_Type := (others => True));

33/2
        procedure End_Search (Search : in out Search_Type);

34/2
        function More_Entries (Search : in Search_Type) return Boolean;

35/2
        procedure Get_Next_Entry (Search : in out Search_Type;
                                  Directory_Entry : out Directory_Entry_Type);

36/2
        procedure Search (
           Directory : in String;
           Pattern   : in String;
           Filter    : in Filter_Type := (others => True);
           Process   : not null access procedure (
               Directory_Entry : in Directory_Entry_Type));

37/2
        -- <Operations on Directory Entries:>

38/2
        function Simple_Name (Directory_Entry : in Directory_Entry_Type)
            return String;

39/2
        function Full_Name (Directory_Entry : in Directory_Entry_Type)
            return String;

40/2
        function Kind (Directory_Entry : in Directory_Entry_Type)
            return File_Kind;

41/2
        function Size (Directory_Entry : in Directory_Entry_Type)
            return File_Size;

42/2
        function Modification_Time (Directory_Entry : in Directory_Entry_Type)
            return Ada.Calendar.Time;

43/2
        Status_Error : exception renames Ada.IO_Exceptions.Status_Error;
        Name_Error   : exception renames Ada.IO_Exceptions.Name_Error;
        Use_Error    : exception renames Ada.IO_Exceptions.Use_Error;
        Device_Error : exception renames Ada.IO_Exceptions.Device_Error;

44/3
     private
         ... -- <not specified by the language>
     end Ada.Directories;

45/2
External files may be classified as directories, special files, or
ordinary files.  A <directory> is an external file that is a container
for files on the target system.  A <special file> is an external file
that cannot be created or read by a predefined Ada input-output package.
External files that are not special files or directories are called
<ordinary files>.  

46/2
A <file name> is a string identifying an external file.  Similarly, a
<directory name> is a string identifying a directory.  The
interpretation of file names and directory names is
implementation-defined.  

47/2
The <full name> of an external file is a full specification of the name
of the file.  If the external environment allows alternative
specifications of the name (for example, abbreviations), the full name
should not use such alternatives.  A full name typically will include
the names of all of the directories that contain the item.  The <simple
name> of an external file is the name of the item, not including any
containing directory names.  Unless otherwise specified, a file name or
directory name parameter in a call to a predefined Ada input-output
subprogram can be a full name, a simple name, or any other form of name
supported by the implementation.  

48/2
The <default directory> is the directory that is used if a directory or
file name is not a full name (that is, when the name does not fully
identify all of the containing directories).  

49/2
A <directory entry> is a single item in a directory, identifying a
single external file (including directories and special files).  

50/2
For each function that returns a string, the lower bound of the returned
value is 1.

51/2
The following file and directory operations are provided:

52/2
     function Current_Directory return String;

53/2
          Returns the full directory name for the current default
          directory.  The name returned shall be suitable for a future
          call to Set_Directory.  The exception Use_Error is propagated
          if a default directory is not supported by the external
          environment.

54/2
     procedure Set_Directory (Directory : in String);

55/2
          Sets the current default directory.  The exception Name_Error
          is propagated if the string given as Directory does not
          identify an existing directory.  The exception Use_Error is
          propagated if the external environment does not support making
          Directory (in the absence of Name_Error) a default directory.

56/2
     procedure Create_Directory (New_Directory : in String;
                                 Form          : in String := "");

57/2
          Creates a directory with name New_Directory.  The Form
          parameter can be used to give system-dependent characteristics
          of the directory; the interpretation of the Form parameter is
          implementation-defined.  A null string for Form specifies the
          use of the default options of the implementation of the new
          directory.  The exception Name_Error is propagated if the
          string given as New_Directory does not allow the
          identification of a directory.  The exception Use_Error is
          propagated if the external environment does not support the
          creation of a directory with the given name (in the absence of
          Name_Error) and form.

58/2
     procedure Delete_Directory (Directory : in String);

59/3
          Deletes an existing empty directory with name Directory.  The
          exception Name_Error is propagated if the string given as
          Directory does not identify an existing directory.  The
          exception Use_Error is propagated if the directory is not
          empty or the external environment does not support the
          deletion of the directory with the given name (in the absence
          of Name_Error).

60/2
     procedure Create_Path (New_Directory : in String;
                            Form          : in String := "");

61/3
          Creates zero or more directories with name New_Directory.
          Each nonexistent directory named by New_Directory is created.
          For example, on a typical Unix system, Create_Path
          ("/usr/me/my"); would create directory "me" in directory
          "usr", then create directory "my" in directory "me".  The Form
          parameter can be used to give system-dependent characteristics
          of the directory; the interpretation of the Form parameter is
          implementation-defined.  A null string for Form specifies the
          use of the default options of the implementation of the new
          directory.  The exception Name_Error is propagated if the
          string given as New_Directory does not allow the
          identification of any directory.  The exception Use_Error is
          propagated if the external environment does not support the
          creation of any directories with the given name (in the
          absence of Name_Error) and form.  If Use_Error is propagated,
          it is unspecified whether a portion of the directory path is
          created.

62/2
     procedure Delete_Tree (Directory : in String);

63/2
          Deletes an existing directory with name Directory.  The
          directory and all of its contents (possibly including other
          directories) are deleted.  The exception Name_Error is
          propagated if the string given as Directory does not identify
          an existing directory.  The exception Use_Error is propagated
          if the external environment does not support the deletion of
          the directory or some portion of its contents with the given
          name (in the absence of Name_Error).  If Use_Error is
          propagated, it is unspecified whether a portion of the
          contents of the directory is deleted.

64/2
     procedure Delete_File (Name : in String);

65/2
          Deletes an existing ordinary or special file with name Name.
          The exception Name_Error is propagated if the string given as
          Name does not identify an existing ordinary or special
          external file.  The exception Use_Error is propagated if the
          external environment does not support the deletion of the file
          with the given name (in the absence of Name_Error).

66/2
     procedure Rename (Old_Name, New_Name : in String);

67/3
          Renames an existing external file (including directories) with
          name Old_Name to New_Name.  The exception Name_Error is
          propagated if the string given as Old_Name does not identify
          an existing external file or if the string given as New_Name
          does not allow the identification of an external file.  The
          exception Use_Error is propagated if the external environment
          does not support the renaming of the file with the given name
          (in the absence of Name_Error).  In particular, Use_Error is
          propagated if a file or directory already exists with name
          New_Name.

68/3
     procedure Copy_File (Source_Name,
                          Target_Name : in String;
                          Form        : in String := "");

69/3
          Copies the contents of the existing external file with name
          Source_Name to an external file with name Target_Name.  The
          resulting external file is a duplicate of the source external
          file.  The Form parameter can be used to give system-dependent
          characteristics of the resulting external file; the
          interpretation of the Form parameter is
          implementation-defined.  Exception Name_Error is propagated if
          the string given as Source_Name does not identify an existing
          external ordinary or special file, or if the string given as
          Target_Name does not allow the identification of an external
          file.  The exception Use_Error is propagated if the external
          environment does not support creating the file with the name
          given by Target_Name and form given by Form, or copying of the
          file with the name given by Source_Name (in the absence of
          Name_Error).  If Use_Error is propagated, it is unspecified
          whether a portion of the file is copied.

70/2
The following file and directory name operations are provided:

71/2
     function Full_Name (Name : in String) return String;

72/2
          Returns the full name corresponding to the file name specified
          by Name.  The exception Name_Error is propagated if the string
          given as Name does not allow the identification of an external
          file (including directories and special files).

73/2
     function Simple_Name (Name : in String) return String;

74/2
          Returns the simple name portion of the file name specified by
          Name.  The exception Name_Error is propagated if the string
          given as Name does not allow the identification of an external
          file (including directories and special files).

75/2
     function Containing_Directory (Name : in String) return String;

76/2
          Returns the name of the containing directory of the external
          file (including directories) identified by Name.  (If more
          than one directory can contain Name, the directory name
          returned is implementation-defined.)  The exception Name_Error
          is propagated if the string given as Name does not allow the
          identification of an external file.  The exception Use_Error
          is propagated if the external file does not have a containing
          directory.

77/2
     function Extension (Name : in String) return String;

78/2
          Returns the extension name corresponding to Name.  The
          extension name is a portion of a simple name (not including
          any separator characters), typically used to identify the file
          class.  If the external environment does not have extension
          names, then the null string is returned.  The exception
          Name_Error is propagated if the string given as Name does not
          allow the identification of an external file.

79/2
     function Base_Name (Name : in String) return String;

80/2
          Returns the base name corresponding to Name.  The base name is
          the remainder of a simple name after removing any extension
          and extension separators.  The exception Name_Error is
          propagated if the string given as Name does not allow the
          identification of an external file (including directories and
          special files).

81/2
     function Compose (Containing_Directory : in String := "";
                       Name                 : in String;
                       Extension            : in String := "") return String;

82/3
          Returns the name of the external file with the specified
          Containing_Directory, Name, and Extension.  If Extension is
          the null string, then Name is interpreted as a simple name;
          otherwise, Name is interpreted as a base name.  The exception
          Name_Error is propagated if the string given as
          Containing_Directory is not null and does not allow the
          identification of a directory, or if the string given as
          Extension is not null and is not a possible extension, or if
          the string given as Name is not a possible simple name (if
          Extension is null) or base name (if Extension is nonnull).

82.1/3
     function Name_Case_Equivalence (Name : in String) return Name_Case_Kind;

82.2/3
          Returns the file name equivalence rule for the directory
          containing Name.  Raises Name_Error if Name is not a full
          name.  Returns Case_Sensitive if file names that differ only
          in the case of letters are considered different names.  If
          file names that differ only in the case of letters are
          considered the same name, then Case_Preserving is returned if
          names have the case of the file name used when a file is
          created; and Case_Insensitive is returned otherwise.  Returns
          Unknown if the file name equivalence is not known.

83/2
The following file and directory queries and types are provided:

84/2
     type File_Kind is (Directory, Ordinary_File, Special_File);

85/2
          The type File_Kind represents the kind of file represented by
          an external file or directory.

86/2
     type File_Size is range 0 .. <implementation-defined>;

87/2
          The type File_Size represents the size of an external file.

88/2
     function Exists (Name : in String) return Boolean;

89/2
          Returns True if an external file represented by Name exists,
          and False otherwise.  The exception Name_Error is propagated
          if the string given as Name does not allow the identification
          of an external file (including directories and special files).

90/2
     function Kind (Name : in String) return File_Kind;

91/2
          Returns the kind of external file represented by Name.  The
          exception Name_Error is propagated if the string given as Name
          does not allow the identification of an existing external
          file.

92/2
     function Size (Name : in String) return File_Size;

93/2
          Returns the size of the external file represented by Name.
          The size of an external file is the number of stream elements
          contained in the file.  If the external file is not an
          ordinary file, the result is implementation-defined.  The
          exception Name_Error is propagated if the string given as Name
          does not allow the identification of an existing external
          file.  The exception Constraint_Error is propagated if the
          file size is not a value of type File_Size.

94/2
     function Modification_Time (Name : in String) return Ada.Calendar.Time;

95/2
          Returns the time that the external file represented by Name
          was most recently modified.  If the external file is not an
          ordinary file, the result is implementation-defined.  The
          exception Name_Error is propagated if the string given as Name
          does not allow the identification of an existing external
          file.  The exception Use_Error is propagated if the external
          environment does not support reading the modification time of
          the file with the name given by Name (in the absence of
          Name_Error).

96/2
The following directory searching operations and types are provided:

97/2
     type Directory_Entry_Type is limited private;

98/2
          The type Directory_Entry_Type represents a single item in a
          directory.  These items can only be created by the
          Get_Next_Entry procedure in this package.  Information about
          the item can be obtained from the functions declared in this
          package.  A default-initialized object of this type is
          invalid; objects returned from Get_Next_Entry are valid.

99/2
     type Filter_Type is array (File_Kind) of Boolean;

100/2
          The type Filter_Type specifies which directory entries are
          provided from a search operation.  If the Directory component
          is True, directory entries representing directories are
          provided.  If the Ordinary_File component is True, directory
          entries representing ordinary files are provided.  If the
          Special_File component is True, directory entries representing
          special files are provided.

101/2
     type Search_Type is limited private;

102/2
          The type Search_Type contains the state of a directory search.
          A default-initialized Search_Type object has no entries
          available (function More_Entries returns False).  Type
          Search_Type needs finalization (see *note 7.6::).

103/2
     procedure Start_Search (Search    : in out Search_Type;
                             Directory : in String;
                             Pattern   : in String;
                             Filter    : in Filter_Type := (others => True));

104/3
          Starts a search in the directory named by Directory for
          entries matching Pattern and Filter.  Pattern represents a
          pattern for matching file names.  If Pattern is the null
          string, all items in the directory are matched; otherwise, the
          interpretation of Pattern is implementation-defined.  Only
          items that match Filter will be returned.  After a successful
          call on Start_Search, the object Search may have entries
          available, but it may have no entries available if no files or
          directories match Pattern and Filter.  The exception
          Name_Error is propagated if the string given by Directory does
          not identify an existing directory, or if Pattern does not
          allow the identification of any possible external file or
          directory.  The exception Use_Error is propagated if the
          external environment does not support the searching of the
          directory with the given name (in the absence of Name_Error).
          When Start_Search propagates Name_Error or Use_Error, the
          object Search will have no entries available.

105/2
     procedure End_Search (Search : in out Search_Type);

106/2
          Ends the search represented by Search.  After a successful
          call on End_Search, the object Search will have no entries
          available.

107/2
     function More_Entries (Search : in Search_Type) return Boolean;

108/2
          Returns True if more entries are available to be returned by a
          call to Get_Next_Entry for the specified search object, and
          False otherwise.

109/2
     procedure Get_Next_Entry (Search : in out Search_Type;
                               Directory_Entry : out Directory_Entry_Type);

110/3
          Returns the next Directory_Entry for the search described by
          Search that matches the pattern and filter.  If no further
          matches are available, Status_Error is raised.  It is
          implementation-defined as to whether the results returned by
          this subprogram are altered if the contents of the directory
          are altered while the Search object is valid (for example, by
          another program).  The exception Use_Error is propagated if
          the external environment does not support continued searching
          of the directory represented by Search.

111/2
     procedure Search (
         Directory : in String;
         Pattern   : in String;
         Filter    : in Filter_Type := (others => True);
         Process   : not null access procedure (
             Directory_Entry : in Directory_Entry_Type));

112/3
          Searches in the directory named by Directory for entries
          matching Pattern and Filter.  The subprogram designated by
          Process is called with each matching entry in turn.  Pattern
          represents a pattern for matching file names.  If Pattern is
          the null string, all items in the directory are matched;
          otherwise, the interpretation of Pattern is
          implementation-defined.  Only items that match Filter will be
          returned.  The exception Name_Error is propagated if the
          string given by Directory does not identify an existing
          directory, or if Pattern does not allow the identification of
          any possible external file or directory.  The exception
          Use_Error is propagated if the external environment does not
          support the searching of the directory with the given name (in
          the absence of Name_Error).

113/2
     function Simple_Name (Directory_Entry : in Directory_Entry_Type)
          return String;

114/2
          Returns the simple external name of the external file
          (including directories) represented by Directory_Entry.  The
          format of the name returned is implementation-defined.  The
          exception Status_Error is propagated if Directory_Entry is
          invalid.

115/2
     function Full_Name (Directory_Entry : in Directory_Entry_Type)
          return String;

116/2
          Returns the full external name of the external file (including
          directories) represented by Directory_Entry.  The format of
          the name returned is implementation-defined.  The exception
          Status_Error is propagated if Directory_Entry is invalid.

117/2
     function Kind (Directory_Entry : in Directory_Entry_Type)
          return File_Kind;

118/2
          Returns the kind of external file represented by
          Directory_Entry.  The exception Status_Error is propagated if
          Directory_Entry is invalid.

119/2
     function Size (Directory_Entry : in Directory_Entry_Type)
          return File_Size;

120/2
          Returns the size of the external file represented by
          Directory_Entry.  The size of an external file is the number
          of stream elements contained in the file.  If the external
          file represented by Directory_Entry is not an ordinary file,
          the result is implementation-defined.  The exception
          Status_Error is propagated if Directory_Entry is invalid.  The
          exception Constraint_Error is propagated if the file size is
          not a value of type File_Size.

121/2
     function Modification_Time (Directory_Entry : in Directory_Entry_Type)
          return Ada.Calendar.Time;

122/2
          Returns the time that the external file represented by
          Directory_Entry was most recently modified.  If the external
          file represented by Directory_Entry is not an ordinary file,
          the result is implementation-defined.  The exception
          Status_Error is propagated if Directory_Entry is invalid.  The
          exception Use_Error is propagated if the external environment
          does not support reading the modification time of the file
          represented by Directory_Entry.

                     _Implementation Requirements_

123/2
For Copy_File, if Source_Name identifies an existing external ordinary
file created by a predefined Ada input-output package, and Target_Name
and Form can be used in the Create operation of that input-output
package with mode Out_File without raising an exception, then Copy_File
shall not propagate Use_Error.

                        _Implementation Advice_

124/2
If other information about a file (such as the owner or creation date)
is available in a directory entry, the implementation should provide
functions in a child package Directories.Information to retrieve it.

125/3
Start_Search and Search should raise Name_Error if Pattern is malformed,
but not if it could represent a file in the directory but does not
actually do so.

126/2
Rename should be supported at least when both New_Name and Old_Name are
simple names and New_Name does not identify an existing external file.

     NOTES

127/2
     41  The operations Containing_Directory, Full_Name, Simple_Name,
     Base_Name, Extension, and Compose operate on file names, not
     external files.  The files identified by these operations do not
     need to exist.  Name_Error is raised only if the file name is
     malformed and cannot possibly identify a file.  Of these
     operations, only the result of Full_Name depends on the current
     default directory; the result of the others depends only on their
     parameters.

128/2
     42  Using access types, values of Search_Type and
     Directory_Entry_Type can be saved and queried later.  However,
     another task or application can modify or delete the file
     represented by a Directory_Entry_Type value or the directory
     represented by a Search_Type value; such a value can only give the
     information valid at the time it is created.  Therefore, long-term
     storage of these values is not recommended.

129/2
     43  If the target system does not support directories inside of
     directories, then Kind will never return Directory and
     Containing_Directory will always raise Use_Error.

130/2
     44  If the target system does not support creation or deletion of
     directories, then Create_Directory, Create_Path, Delete_Directory,
     and Delete_Tree will always propagate Use_Error.

131/2
     45  To move a file or directory to a different location, use
     Rename.  Most target systems will allow renaming of files from one
     directory to another.  If the target file or directory might
     already exist, it should be deleted first.

* Menu:

* A.16.1 ::   The Package Directories.Hierarchical_File_Names


File: arm2012.info,  Node: A.16.1,  Up: A.16

A.16.1 The Package Directories.Hierarchical_File_Names
------------------------------------------------------

1/3
The library package Directories.Hierarchical_File_Names is an optional
package providing operations for file name construction and
decomposition for targets with hierarchical file naming.

                          _Static Semantics_

2/3
If provided, the library package Directories.Hierarchical_File_Names has
the following declaration:

3/3
     package Ada.Directories.Hierarchical_File_Names is

4/3
        function Is_Simple_Name (Name : in String) return Boolean;

5/3
        function Is_Root_Directory_Name (Name : in String) return Boolean;

6/3
        function Is_Parent_Directory_Name (Name : in String) return Boolean;

7/3
        function Is_Current_Directory_Name (Name : in String) return Boolean;

8/3
        function Is_Full_Name (Name : in String) return Boolean;

9/3
        function Is_Relative_Name (Name : in String) return Boolean;

10/3
        function Simple_Name (Name : in String) return String
           renames Ada.Directories.Simple_Name;

11/3
        function Containing_Directory (Name : in String) return String
           renames Ada.Directories.Containing_Directory;

12/3
        function Initial_Directory (Name : in String) return String;

13/3
        function Relative_Name (Name : in String) return String;

14/3
        function Compose (Directory      : in String := "";
                          Relative_Name  : in String;
                          Extension      : in String := "") return String;

15/3
     end Ada.Directories.Hierarchical_File_Names;

16/3
In addition to the operations provided in package
Directories.Hierarchical_File_Names, the operations in package
Directories can be used with hierarchical file names.  In particular,
functions Full_Name, Base_Name, and Extension provide additional
capabilities for hierarchical file names.

17/3
     function Is_Simple_Name (Name : in String) return Boolean;

18/3
          Returns True if Name is a simple name, and returns False
          otherwise.

19/3
     function Is_Root_Directory_Name (Name : in String) return Boolean;

20/3
          Returns True if Name is syntactically a root (a directory that
          cannot be decomposed further), and returns False otherwise.

21/3
     function Is_Parent_Directory_Name (Name : in String) return Boolean;

22/3
          Returns True if Name can be used to indicate symbolically the
          parent directory of any directory, and returns False
          otherwise.

23/3
     function Is_Current_Directory_Name (Name : in String) return Boolean;

24/3
          Returns True if Name can be used to indicate symbolically the
          directory itself for any directory, and returns False
          otherwise.

25/3
     function Is_Full_Name (Name : in String) return Boolean;

26/3
          Returns True if the leftmost directory part of Name is a root,
          and returns False otherwise.

27/3
     function Is_Relative_Name (Name : in String) return Boolean;

28/3
          Returns True if Name allows the identification of an external
          file (including directories and special files) but is not a
          full name, and returns False otherwise.

29/3
     function Initial_Directory (Name : in String) return String;

30/3
          Returns the leftmost directory part in Name.  That is, it
          returns a root directory name (for a full name), or one of a
          parent directory name, a current directory name, or a simple
          name (for a relative name).  The exception Name_Error is
          propagated if the string given as Name does not allow the
          identification of an external file (including directories and
          special files).

31/3
     function Relative_Name (Name : in String) return String;

32/3
          Returns the entire file name except the Initial_Directory
          portion.  The exception Name_Error is propagated if the string
          given as Name does not allow the identification of an external
          file (including directories and special files), or if Name has
          a single part (this includes if any of Is_Simple_Name,
          Is_Root_Directory_Name, Is_Parent_Directory_Name, or
          Is_Current_Directory_Name are True).

33/3
     function Compose (Directory      : in String := "";
                       Relative_Name  : in String;
                       Extension      : in String := "") return String;

34/3
          Returns the name of the external file with the specified
          Directory, Relative_Name, and Extension.  The exception
          Name_Error is propagated if the string given as Directory is
          not the null string and does not allow the identification of a
          directory, or if Is_Relative_Name (Relative_Name) is False, or
          if the string given as Extension is not the null string and is
          not a possible extension, or if Extension is not the null
          string and Simple_Name (Relative_Name) is not a base name.

35/3
          The result of Compose is a full name if Is_Full_Name
          (Directory) is True; result is a relative name otherwise.

                        _Implementation Advice_

36/3
Directories.Hierarchical_File_Names should be provided for systems with
hierarchical file naming, and should not be provided on other systems.

     NOTES

37/3
     46  These operations operate on file names, not external files.
     The files identified by these operations do not need to exist.
     Name_Error is raised only as specified or if the file name is
     malformed and cannot possibly identify a file.  The result of these
     operations depends only on their parameters.

38/3
     47  Containing_Directory raises Use_Error if Name does not have a
     containing directory, including when any of Is_Simple_Name,
     Is_Root_Directory_Name, Is_Parent_Directory_Name, or
     Is_Current_Directory_Name are True.


File: arm2012.info,  Node: A.17,  Next: A.18,  Prev: A.16,  Up: Annex A

A.17 The Package Environment_Variables
======================================

1/2
The package Environment_Variables allows a program to read or modify
environment variables.  Environment variables are name-value pairs,
where both the name and value are strings.  The definition of what
constitutes an <environment variable>, and the meaning of the name and
value, are implementation defined.

                          _Static Semantics_

2/2
The library package Environment_Variables has the following declaration:

3/2
     package Ada.Environment_Variables is
        pragma Preelaborate(Environment_Variables);

4/2
        function Value (Name : in String) return String;

4.1/3
        function Value (Name : in String; Default : in String) return String;

5/2
        function Exists (Name : in String) return Boolean;

6/2
        procedure Set (Name : in String; Value : in String);

7/2
        procedure Clear (Name : in String);
        procedure Clear;

8/3
        procedure Iterate
           (Process : not null access procedure (Name, Value : in String));

9/2
     end Ada.Environment_Variables;

10/2
     function Value (Name : in String) return String;

11/2
          If the external execution environment supports environment
          variables, then Value returns the value of the environment
          variable with the given name.  If no environment variable with
          the given name exists, then Constraint_Error is propagated.
          If the execution environment does not support environment
          variables, then Program_Error is propagated.

11.1/3
     function Value (Name : in String; Default : in String) return String;

11.2/3
          If the external execution environment supports environment
          variables and an environment variable with the given name
          currently exists, then Value returns its value; otherwise, it
          returns Default.

12/2
     function Exists (Name : in String) return Boolean;

13/3
          If the external execution environment supports environment
          variables and an environment variable with the given name
          currently exists, then Exists returns True; otherwise, it
          returns False.

14/2
     procedure Set (Name : in String; Value : in String);

15/3
          If the external execution environment supports environment
          variables, then Set first clears any existing environment
          variable with the given name, and then defines a single new
          environment variable with the given name and value.
          Otherwise, Program_Error is propagated.

16/2
          If implementation-defined circumstances prohibit the
          definition of an environment variable with the given name and
          value, then Constraint_Error is propagated.

17/2
          It is implementation defined whether there exist values for
          which the call Set(Name, Value) has the same effect as Clear
          (Name).

18/2
     procedure Clear (Name : in String);

19/3
          If the external execution environment supports environment
          variables, then Clear deletes all existing environment
          variables with the given name.  Otherwise, Program_Error is
          propagated.

20/2
     procedure Clear;

21/3
          If the external execution environment supports environment
          variables, then Clear deletes all existing environment
          variables.  Otherwise, Program_Error is propagated.

22/3
     procedure Iterate
        (Process : not null access procedure (Name, Value : in String));

23/3
          If the external execution environment supports environment
          variables, then Iterate calls the subprogram designated by
          Process for each existing environment variable, passing the
          name and value of that environment variable.  Otherwise,
          Program_Error is propagated.

24/2
          If several environment variables exist that have the same
          name, Process is called once for each such variable.

                      _Bounded (Run-Time) Errors_

25/2
It is a bounded error to call Value if more than one environment
variable exists with the given name; the possible outcomes are that:

26/2
   * one of the values is returned, and that same value is returned in
     subsequent calls in the absence of changes to the environment; or

27/2
   * Program_Error is propagated.

                         _Erroneous Execution_

28/2
Making calls to the procedures Set or Clear concurrently with calls to
any subprogram of package Environment_Variables, or to any instantiation
of Iterate, results in erroneous execution.

29/2
Making calls to the procedures Set or Clear in the actual subprogram
corresponding to the Process parameter of Iterate results in erroneous
execution.

                     _Documentation Requirements_

30/2
An implementation shall document how the operations of this package
behave if environment variables are changed by external mechanisms (for
instance, calling operating system services).

                     _Implementation Permissions_

31/2
An implementation running on a system that does not support environment
variables is permitted to define the operations of package
Environment_Variables with the semantics corresponding to the case where
the external execution environment does support environment variables.
In this case, it shall provide a mechanism to initialize a nonempty set
of environment variables prior to the execution of a partition.

                        _Implementation Advice_

32/2
If the execution environment supports subprocesses, the currently
defined environment variables should be used to initialize the
environment variables of a subprocess.

33/2
Changes to the environment variables made outside the control of this
package should be reflected immediately in the effect of the operations
of this package.  Changes to the environment variables made using this
package should be reflected immediately in the external execution
environment.  This package should not perform any buffering of the
environment variables.


File: arm2012.info,  Node: A.18,  Next: A.19,  Prev: A.17,  Up: Annex A

A.18 Containers
===============

1/2
This clause presents the specifications of the package Containers and
several child packages, which provide facilities for storing collections
of elements.

2/2
A variety of sequence and associative containers are provided.  Each
container includes a <cursor> type.  A cursor is a reference to an
element within a container.  Many operations on cursors are common to
all of the containers.  A cursor referencing an element in a container
is considered to be overlapping with the container object itself.  

3/2
Within this clause we provide Implementation Advice for the desired
average or worst case time complexity of certain operations on a
container.  This advice is expressed using the Landau symbol <O>(X).
Presuming f is some function of a length parameter N and t(N) is the
time the operation takes (on average or worst case, as specified) for
the length N, a complexity of <O>(f(N)) means that there exists a finite
A such that for any N, t(N)/f(N) < A. 

4/2
If the advice suggests that the complexity should be less than
<O>(f(N)), then for any arbitrarily small positive real D, there should
exist a positive integer M such that for all N > M, t(N)/f(N) < D.

5/3
When a formal function is used to provide an ordering for a container,
it is generally required to define a strict weak ordering.  A function
"<" defines a <strict weak ordering> if it is irreflexive, asymmetric,
transitive, and in addition, if <x> < <y> for any values <x> and <y>,
then for all other values <z>, (<x> < <z>) or (<z> < <y>).

                          _Static Semantics_

6/4
Certain subprograms declared within instances of some of the generic
packages presented in this clause are said to <perform indefinite
insertion>.  These subprograms are those corresponding (in the sense of
the copying described in subclause *note 12.3::) to subprograms that
have formal parameters of a generic formal indefinite type and that are
identified as performing indefinite insertion in the subclause defining
the generic package.

7/4
If a subprogram performs indefinite insertion, then certain run-time
checks are performed as part of a call to the subprogram; if any of
these checks fail, then the resulting exception is propagated to the
caller and the container is not modified by the call.  These checks are
performed for each parameter corresponding (in the sense of the copying
described in *note 12.3::) to a parameter in the corresponding generic
whose type is a generic formal indefinite type.  The checks performed
for a given parameter are those checks explicitly specified in subclause
*note 4.8:: that would be performed as part of the evaluation of an
initialized allocator whose access type is declared immediately within
the instance, where:

8/4
   * the value of the qualified_expression is that of the parameter; and

9/4
   * the designated subtype of the access type is the subtype of the
     parameter; and

10/4
   * finalization of the collection of the access type has started if
     and only if the finalization of the instance has started.

* Menu:

* A.18.1 ::   The Package Containers
* A.18.2 ::   The Generic Package Containers.Vectors
* A.18.3 ::   The Generic Package Containers.Doubly_Linked_Lists
* A.18.4 ::   Maps
* A.18.5 ::   The Generic Package Containers.Hashed_Maps
* A.18.6 ::   The Generic Package Containers.Ordered_Maps
* A.18.7 ::   Sets
* A.18.8 ::   The Generic Package Containers.Hashed_Sets
* A.18.9 ::   The Generic Package Containers.Ordered_Sets
* A.18.10 ::  The Generic Package Containers.Multiway_Trees
* A.18.11 ::  The Generic Package Containers.Indefinite_Vectors
* A.18.12 ::  The Generic Package Containers.Indefinite_Doubly_Linked_Lists
* A.18.13 ::  The Generic Package Containers.Indefinite_Hashed_Maps
* A.18.14 ::  The Generic Package Containers.Indefinite_Ordered_Maps
* A.18.15 ::  The Generic Package Containers.Indefinite_Hashed_Sets
* A.18.16 ::  The Generic Package Containers.Indefinite_Ordered_Sets
* A.18.17 ::  The Generic Package Containers.Indefinite_Multiway_Trees
* A.18.18 ::  The Generic Package Containers.Indefinite_Holders
* A.18.19 ::  The Generic Package Containers.Bounded_Vectors
* A.18.20 ::  The Generic Package Containers.Bounded_Doubly_Linked_Lists
* A.18.21 ::  The Generic Package Containers.Bounded_Hashed_Maps
* A.18.22 ::  The Generic Package Containers.Bounded_Ordered_Maps
* A.18.23 ::  The Generic Package Containers.Bounded_Hashed_Sets
* A.18.24 ::  The Generic Package Containers.Bounded_Ordered_Sets
* A.18.25 ::  The Generic Package Containers.Bounded_Multiway_Trees
* A.18.26 ::  Array Sorting
* A.18.27 ::  The Generic Package Containers.Synchronized_Queue_Interfaces
* A.18.28 ::  The Generic Package Containers.Unbounded_Synchronized_Queues
* A.18.29 ::  The Generic Package Containers.Bounded_Synchronized_Queues
* A.18.30 ::  The Generic Package Containers.Unbounded_Priority_Queues
* A.18.31 ::  The Generic Package Containers.Bounded_Priority_Queues
* A.18.32 ::  Example of Container Use


File: arm2012.info,  Node: A.18.1,  Next: A.18.2,  Up: A.18

A.18.1 The Package Containers
-----------------------------

1/2
The package Containers is the root of the containers subsystem.

                          _Static Semantics_

2/2
The library package Containers has the following declaration:

3/2
     package Ada.Containers is
        pragma Pure(Containers);

4/2
        type Hash_Type is mod <implementation-defined>;

5/2
        type Count_Type is range 0 .. <implementation-defined>;

5.1/3
        Capacity_Error : exception;

6/2
     end Ada.Containers;

7/2
Hash_Type represents the range of the result of a hash function.
Count_Type represents the (potential or actual) number of elements of a
container.

7.1/3
Capacity_Error is raised when the capacity of a container is exceeded.

                        _Implementation Advice_

8/2
Hash_Type'Modulus should be at least 2**32.  Count_Type'Last should be
at least 2**31-1.


File: arm2012.info,  Node: A.18.2,  Next: A.18.3,  Prev: A.18.1,  Up: A.18

A.18.2 The Generic Package Containers.Vectors
---------------------------------------------

1/2
The language-defined generic package Containers.Vectors provides private
types Vector and Cursor, and a set of operations for each type.  A
vector container allows insertion and deletion at any position, but it
is specifically optimized for insertion and deletion at the high end
(the end with the higher index) of the container.  A vector container
also provides random access to its elements.  

2/2
A vector container behaves conceptually as an array that expands as
necessary as items are inserted.  The <length> of a vector is the number
of elements that the vector contains.  The <capacity> of a vector is the
maximum number of elements that can be inserted into the vector prior to
it being automatically expanded.

3/2
Elements in a vector container can be referred to by an index value of a
generic formal type.  The first element of a vector always has its index
value equal to the lower bound of the formal type.

4/2
A vector container may contain <empty elements>.  Empty elements do not
have a specified value.

                          _Static Semantics_

5/2
The generic library package Containers.Vectors has the following
declaration:

6/3
     with Ada.Iterator_Interfaces;
     generic
        type Index_Type is range <>;
        type Element_Type is private;
        with function "=" (Left, Right : Element_Type)
           return Boolean is <>;
     package Ada.Containers.Vectors is
        pragma Preelaborate(Vectors);
        pragma Remote_Types(Vectors);

7/2
        subtype Extended_Index is
           Index_Type'Base range
              Index_Type'First-1 ..
              Index_Type'Min (Index_Type'Base'Last - 1, Index_Type'Last) + 1;
        No_Index : constant Extended_Index := Extended_Index'First;

8/3
        type Vector is tagged private
           with Constant_Indexing => Constant_Reference,
                Variable_Indexing => Reference,
                Default_Iterator  => Iterate,
                Iterator_Element  => Element_Type;
        pragma Preelaborable_Initialization(Vector);

9/2
        type Cursor is private;
        pragma Preelaborable_Initialization(Cursor);

10/2
        Empty_Vector : constant Vector;

11/2
        No_Element : constant Cursor;

11.1/3
        function Has_Element (Position : Cursor) return Boolean;

11.2/3
        package Vector_Iterator_Interfaces is new
            Ada.Iterator_Interfaces (Cursor, Has_Element);

12/2
        function "=" (Left, Right : Vector) return Boolean;

13/2
        function To_Vector (Length : Count_Type) return Vector;

14/2
        function To_Vector
          (New_Item : Element_Type;
           Length   : Count_Type) return Vector;

15/2
        function "&" (Left, Right : Vector) return Vector;

16/2
        function "&" (Left  : Vector;
                      Right : Element_Type) return Vector;

17/2
        function "&" (Left  : Element_Type;
                      Right : Vector) return Vector;

18/2
        function "&" (Left, Right  : Element_Type) return Vector;

19/2
        function Capacity (Container : Vector) return Count_Type;

20/2
        procedure Reserve_Capacity (Container : in out Vector;
                                    Capacity  : in     Count_Type);

21/2
        function Length (Container : Vector) return Count_Type;

22/2
        procedure Set_Length (Container : in out Vector;
                              Length    : in     Count_Type);

23/2
        function Is_Empty (Container : Vector) return Boolean;

24/2
        procedure Clear (Container : in out Vector);

25/2
        function To_Cursor (Container : Vector;
                            Index     : Extended_Index) return Cursor;

26/2
        function To_Index (Position  : Cursor) return Extended_Index;

27/2
        function Element (Container : Vector;
                          Index     : Index_Type)
           return Element_Type;

28/2
        function Element (Position : Cursor) return Element_Type;

29/2
        procedure Replace_Element (Container : in out Vector;
                                   Index     : in     Index_Type;
                                   New_Item  : in     Element_Type);

30/2
        procedure Replace_Element (Container : in out Vector;
                                   Position  : in     Cursor;
                                   New_item  : in     Element_Type);

31/2
        procedure Query_Element
          (Container : in Vector;
           Index     : in Index_Type;
           Process   : not null access procedure (Element : in Element_Type));

32/2
        procedure Query_Element
          (Position : in Cursor;
           Process  : not null access procedure (Element : in Element_Type));

33/2
        procedure Update_Element
          (Container : in out Vector;
           Index     : in     Index_Type;
           Process   : not null access procedure
                           (Element : in out Element_Type));

34/2
        procedure Update_Element
          (Container : in out Vector;
           Position  : in     Cursor;
           Process   : not null access procedure
                           (Element : in out Element_Type));

34.1/3
        type Constant_Reference_Type
              (Element : not null access constant Element_Type) is private
           with Implicit_Dereference => Element;

34.2/3
        type Reference_Type (Element : not null access Element_Type) is private
           with Implicit_Dereference => Element;

34.3/3
        function Constant_Reference (Container : aliased in Vector;
                                     Index     : in Index_Type)
           return Constant_Reference_Type;

34.4/3
        function Reference (Container : aliased in out Vector;
                            Index     : in Index_Type)
           return Reference_Type;

34.5/3
        function Constant_Reference (Container : aliased in Vector;
                                     Position  : in Cursor)
           return Constant_Reference_Type;

34.6/3
        function Reference (Container : aliased in out Vector;
                            Position  : in Cursor)
           return Reference_Type;

34.7/3
        procedure Assign (Target : in out Vector; Source : in Vector);

34.8/3
        function Copy (Source : Vector; Capacity : Count_Type := 0)
           return Vector;

35/2
        procedure Move (Target : in out Vector;
                        Source : in out Vector);

36/2
        procedure Insert (Container : in out Vector;
                          Before    : in     Extended_Index;
                          New_Item  : in     Vector);

37/2
        procedure Insert (Container : in out Vector;
                          Before    : in     Cursor;
                          New_Item  : in     Vector);

38/2
        procedure Insert (Container : in out Vector;
                          Before    : in     Cursor;
                          New_Item  : in     Vector;
                          Position  :    out Cursor);

39/2
        procedure Insert (Container : in out Vector;
                          Before    : in     Extended_Index;
                          New_Item  : in     Element_Type;
                          Count     : in     Count_Type := 1);

40/2
        procedure Insert (Container : in out Vector;
                          Before    : in     Cursor;
                          New_Item  : in     Element_Type;
                          Count     : in     Count_Type := 1);

41/2
        procedure Insert (Container : in out Vector;
                          Before    : in     Cursor;
                          New_Item  : in     Element_Type;
                          Position  :    out Cursor;
                          Count     : in     Count_Type := 1);

42/2
        procedure Insert (Container : in out Vector;
                          Before    : in     Extended_Index;
                          Count     : in     Count_Type := 1);

43/2
        procedure Insert (Container : in out Vector;
                          Before    : in     Cursor;
                          Position  :    out Cursor;
                          Count     : in     Count_Type := 1);

44/2
        procedure Prepend (Container : in out Vector;
                           New_Item  : in     Vector);

45/2
        procedure Prepend (Container : in out Vector;
                           New_Item  : in     Element_Type;
                           Count     : in     Count_Type := 1);

46/2
        procedure Append (Container : in out Vector;
                          New_Item  : in     Vector);

47/2
        procedure Append (Container : in out Vector;
                          New_Item  : in     Element_Type;
                          Count     : in     Count_Type := 1);

48/2
        procedure Insert_Space (Container : in out Vector;
                                Before    : in     Extended_Index;
                                Count     : in     Count_Type := 1);

49/2
        procedure Insert_Space (Container : in out Vector;
                                Before    : in     Cursor;
                                Position  :    out Cursor;
                                Count     : in     Count_Type := 1);

50/2
        procedure Delete (Container : in out Vector;
                          Index     : in     Extended_Index;
                          Count     : in     Count_Type := 1);

51/2
        procedure Delete (Container : in out Vector;
                          Position  : in out Cursor;
                          Count     : in     Count_Type := 1);

52/2
        procedure Delete_First (Container : in out Vector;
                                Count     : in     Count_Type := 1);

53/2
        procedure Delete_Last (Container : in out Vector;
                               Count     : in     Count_Type := 1);

54/2
        procedure Reverse_Elements (Container : in out Vector);

55/2
        procedure Swap (Container : in out Vector;
                        I, J      : in     Index_Type);

56/2
        procedure Swap (Container : in out Vector;
                        I, J      : in     Cursor);

57/2
        function First_Index (Container : Vector) return Index_Type;

58/2
        function First (Container : Vector) return Cursor;

59/2
        function First_Element (Container : Vector)
           return Element_Type;

60/2
        function Last_Index (Container : Vector) return Extended_Index;

61/2
        function Last (Container : Vector) return Cursor;

62/2
        function Last_Element (Container : Vector)
           return Element_Type;

63/2
        function Next (Position : Cursor) return Cursor;

64/2
        procedure Next (Position : in out Cursor);

65/2
        function Previous (Position : Cursor) return Cursor;

66/2
        procedure Previous (Position : in out Cursor);

67/2
        function Find_Index (Container : Vector;
                             Item      : Element_Type;
                             Index     : Index_Type := Index_Type'First)
           return Extended_Index;

68/2
        function Find (Container : Vector;
                       Item      : Element_Type;
                       Position  : Cursor := No_Element)
           return Cursor;

69/2
        function Reverse_Find_Index (Container : Vector;
                                     Item      : Element_Type;
                                     Index     : Index_Type := Index_Type'Last)
           return Extended_Index;

70/2
        function Reverse_Find (Container : Vector;
                               Item      : Element_Type;
                               Position  : Cursor := No_Element)
           return Cursor;

71/2
        function Contains (Container : Vector;
                           Item      : Element_Type) return Boolean;

72/3
     <This paragraph was deleted.>

73/2
        procedure  Iterate
          (Container : in Vector;
           Process   : not null access procedure (Position : in Cursor));

74/2
        procedure Reverse_Iterate
          (Container : in Vector;
           Process   : not null access procedure (Position : in Cursor));

74.1/3
        function Iterate (Container : in Vector)
           return Vector_Iterator_Interfaces.Reversible_Iterator'Class;

74.2/3
        function Iterate (Container : in Vector; Start : in Cursor)
           return Vector_Iterator_Interfaces.Reversible_Iterator'Class;

75/2
        generic
           with function "<" (Left, Right : Element_Type)
              return Boolean is <>;
        package Generic_Sorting is

76/2
           function Is_Sorted (Container : Vector) return Boolean;

77/2
           procedure Sort (Container : in out Vector);

78/2
           procedure Merge (Target  : in out Vector;
                            Source  : in out Vector);

79/2
        end Generic_Sorting;

80/2
     private

81/2
        ... -- <not specified by the language>

82/2
     end Ada.Containers.Vectors;

83/2
The actual function for the generic formal function "=" on Element_Type
values is expected to define a reflexive and symmetric relationship and
return the same result value each time it is called with a particular
pair of values.  If it behaves in some other manner, the functions
defined to use it return an unspecified value.  The exact arguments and
number of calls of this generic formal function by the functions defined
to use it are unspecified.

84/2
The type Vector is used to represent vectors.  The type Vector needs
finalization (see *note 7.6::).

85/2
Empty_Vector represents the empty vector object.  It has a length of 0.
If an object of type Vector is not otherwise initialized, it is
initialized to the same value as Empty_Vector.

86/2
No_Element represents a cursor that designates no element.  If an object
of type Cursor is not otherwise initialized, it is initialized to the
same value as No_Element.

87/2
The predefined "=" operator for type Cursor returns True if both cursors
are No_Element, or designate the same element in the same container.

88/2
Execution of the default implementation of the Input, Output, Read, or
Write attribute of type Cursor raises Program_Error.

88.1/3
Vector'Write for a Vector object <V> writes Length(<V>) elements of the
vector to the stream.  It also may write additional information about
the vector.

88.2/3
Vector'Read reads the representation of a vector from the stream, and
assigns to <Item> a vector with the same length and elements as was
written by Vector'Write.

89/2
No_Index represents a position that does not correspond to any element.
The subtype Extended_Index includes the indices covered by Index_Type
plus the value No_Index and, if it exists, the successor to the
Index_Type'Last.

89.1/3
If an operation attempts to modify the vector such that the position of
the last element would be greater than Index_Type'Last, then the
operation propagates Constraint_Error.

90/2
Some operations of this generic package have access-to-subprogram
parameters.  To ensure such operations are well-defined, they guard
against certain actions by the designated subprogram.  In particular,
some operations check for "tampering with cursors" of a container
because they depend on the set of elements of the container remaining
constant, and others check for "tampering with elements" of a container
because they depend on elements of the container not being replaced.

91/2
A subprogram is said to <tamper with cursors> of a vector object <V> if:

92/2
   * it inserts or deletes elements of <V>, that is, it calls the
     Insert, Insert_Space, Clear, Delete, or Set_Length procedures with
     <V> as a parameter; or

93/2
   * it finalizes <V>; or

93.1/3
   * it calls the Assign procedure with <V> as the Target parameter; or

94/2
   * it calls the Move procedure with <V> as a parameter.

95/2
A subprogram is said to <tamper with elements> of a vector object <V>
if:

96/2
   * it tampers with cursors of <V>; or

97/2
   * it replaces one or more elements of <V>, that is, it calls the
     Replace_Element, Reverse_Elements, or Swap procedures or the Sort
     or Merge procedures of an instance of Generic_Sorting with <V> as a
     parameter.

97.1/4
When tampering with cursors is <prohibited> for a particular vector
object <V>, Program_Error is propagated by a call of any
language-defined subprogram that is defined to tamper with the cursors
of <V>, leaving <V> unmodified.  Similarly, when tampering with elements
is <prohibited> for a particular vector object <V>, Program_Error is
propagated by a call of any language-defined subprogram that is defined
to tamper with the elements of <V> (or tamper with the cursors of <V>),
leaving <V> unmodified.  These checks are made before any other defined
behavior of the body of the language-defined subprogram.

97.2/3
     function Has_Element (Position : Cursor) return Boolean;

97.3/3
          Returns True if Position designates an element, and returns
          False otherwise.

98/2
     function "=" (Left, Right : Vector) return Boolean;

99/3
          If Left and Right denote the same vector object, then the
          function returns True.  If Left and Right have different
          lengths, then the function returns False.  Otherwise, it
          compares each element in Left to the corresponding element in
          Right using the generic formal equality operator.  If any such
          comparison returns False, the function returns False;
          otherwise, it returns True.  Any exception raised during
          evaluation of element equality is propagated.

100/2
     function To_Vector (Length : Count_Type) return Vector;

101/2
          Returns a vector with a length of Length, filled with empty
          elements.

102/2
     function To_Vector
       (New_Item : Element_Type;
        Length   : Count_Type) return Vector;

103/2
          Returns a vector with a length of Length, filled with elements
          initialized to the value New_Item.

104/2
     function "&" (Left, Right : Vector) return Vector;

105/2
          Returns a vector comprising the elements of Left followed by
          the elements of Right.

106/2
     function "&" (Left  : Vector;
                   Right : Element_Type) return Vector;

107/2
          Returns a vector comprising the elements of Left followed by
          the element Right.

108/2
     function "&" (Left  : Element_Type;
                   Right : Vector) return Vector;

109/2
          Returns a vector comprising the element Left followed by the
          elements of Right.

110/2
     function "&" (Left, Right  : Element_Type) return Vector;

111/2
          Returns a vector comprising the element Left followed by the
          element Right.

112/2
     function Capacity (Container : Vector) return Count_Type;

113/2
          Returns the capacity of Container.

114/2
     procedure Reserve_Capacity (Container : in out Vector;
                                 Capacity  : in     Count_Type);

115/3
          If the capacity of Container is already greater than or equal
          to Capacity, then Reserve_Capacity has no effect.  Otherwise,
          Reserve_Capacity allocates additional storage as necessary to
          ensure that the length of the resulting vector can become at
          least the value Capacity without requiring an additional call
          to Reserve_Capacity, and is large enough to hold the current
          length of Container.  Reserve_Capacity then, as necessary,
          moves elements into the new storage and deallocates any
          storage no longer needed.  Any exception raised during
          allocation is propagated and Container is not modified.

116/2
     function Length (Container : Vector) return Count_Type;

117/2
          Returns the number of elements in Container.

118/2
     procedure Set_Length (Container : in out Vector;
                           Length    : in     Count_Type);

119/3
          If Length is larger than the capacity of Container, Set_Length
          calls Reserve_Capacity (Container, Length), then sets the
          length of the Container to Length.  If Length is greater than
          the original length of Container, empty elements are added to
          Container; otherwise, elements are removed from Container.

120/2
     function Is_Empty (Container : Vector) return Boolean;

121/2
          Equivalent to Length (Container) = 0.

122/2
     procedure Clear (Container : in out Vector);

123/2
          Removes all the elements from Container.  The capacity of
          Container does not change.

124/2
     function To_Cursor (Container : Vector;
                         Index     : Extended_Index) return Cursor;

125/2
          If Index is not in the range First_Index (Container) ..
          Last_Index (Container), then No_Element is returned.
          Otherwise, a cursor designating the element at position Index
          in Container is returned.

126/2
     function To_Index (Position  : Cursor) return Extended_Index;

127/2
          If Position is No_Element, No_Index is returned.  Otherwise,
          the index (within its containing vector) of the element
          designated by Position is returned.

128/2
     function Element (Container : Vector;
                       Index     : Index_Type)
        return Element_Type;

129/2
          If Index is not in the range First_Index (Container) ..
          Last_Index (Container), then Constraint_Error is propagated.
          Otherwise, Element returns the element at position Index.

130/2
     function Element (Position  : Cursor) return Element_Type;

131/2
          If Position equals No_Element, then Constraint_Error is
          propagated.  Otherwise, Element returns the element designated
          by Position.

132/2
     procedure Replace_Element (Container : in out Vector;
                                Index     : in     Index_Type;
                                New_Item  : in     Element_Type);

133/3
          If Index is not in the range First_Index (Container) ..
          Last_Index (Container), then Constraint_Error is propagated.
          Otherwise, Replace_Element assigns the value New_Item to the
          element at position Index.  Any exception raised during the
          assignment is propagated.  The element at position Index is
          not an empty element after successful call to Replace_Element.

134/2
     procedure Replace_Element (Container : in out Vector;
                                Position  : in     Cursor;
                                New_Item  : in     Element_Type);

135/3
          If Position equals No_Element, then Constraint_Error is
          propagated; if Position does not designate an element in
          Container, then Program_Error is propagated.  Otherwise,
          Replace_Element assigns New_Item to the element designated by
          Position.  Any exception raised during the assignment is
          propagated.  The element at Position is not an empty element
          after successful call to Replace_Element.

136/2
     procedure Query_Element
       (Container : in Vector;
        Index     : in Index_Type;
        Process   : not null access procedure (Element : in Element_Type));

137/3
          If Index is not in the range First_Index (Container) ..
          Last_Index (Container), then Constraint_Error is propagated.
          Otherwise, Query_Element calls Process.all with the element at
          position Index as the argument.  Tampering with the elements
          of Container is prohibited during the execution of the call on
          Process.all.  Any exception raised by Process.all is
          propagated.

138/2
     procedure Query_Element
       (Position : in Cursor;
        Process  : not null access procedure (Element : in Element_Type));

139/3
          If Position equals No_Element, then Constraint_Error is
          propagated.  Otherwise, Query_Element calls Process.all with
          the element designated by Position as the argument.  Tampering
          with the elements of the vector that contains the element
          designated by Position is prohibited during the execution of
          the call on Process.all.  Any exception raised by Process.all
          is propagated.

140/2
     procedure Update_Element
       (Container : in out Vector;
        Index     : in     Index_Type;
        Process   : not null access procedure (Element : in out Element_Type));

141/3
          If Index is not in the range First_Index (Container) ..
          Last_Index (Container), then Constraint_Error is propagated.
          Otherwise, Update_Element calls Process.all with the element
          at position Index as the argument.  Tampering with the
          elements of Container is prohibited during the execution of
          the call on Process.all.  Any exception raised by Process.all
          is propagated.

142/2
          If Element_Type is unconstrained and definite, then the actual
          Element parameter of Process.all shall be unconstrained.

143/2
          The element at position Index is not an empty element after
          successful completion of this operation.

144/2
     procedure Update_Element
       (Container : in out Vector;
        Position  : in     Cursor;
        Process   : not null access procedure (Element : in out Element_Type));

145/3
          If Position equals No_Element, then Constraint_Error is
          propagated; if Position does not designate an element in
          Container, then Program_Error is propagated.  Otherwise,
          Update_Element calls Process.all with the element designated
          by Position as the argument.  Tampering with the elements of
          Container is prohibited during the execution of the call on
          Process.all.  Any exception raised by Process.all is
          propagated.

146/2
          If Element_Type is unconstrained and definite, then the actual
          Element parameter of Process.all shall be unconstrained.

147/2
          The element designated by Position is not an empty element
          after successful completion of this operation.

147.1/3
     type Constant_Reference_Type
           (Element : not null access constant Element_Type) is private
        with Implicit_Dereference => Element;

147.2/3
     type Reference_Type (Element : not null access Element_Type) is private
        with Implicit_Dereference => Element;

147.3/3
          The types Constant_Reference_Type and Reference_Type need
          finalization.

147.4/3
          The default initialization of an object of type
          Constant_Reference_Type or Reference_Type propagates
          Program_Error.

147.5/3
     function Constant_Reference (Container : aliased in Vector;
                                  Index     : in Index_Type)
        return Constant_Reference_Type;

147.6/3
          This function (combined with the Constant_Indexing and
          Implicit_Dereference aspects) provides a convenient way to
          gain read access to an individual element of a vector given an
          index value.

147.7/3
          If Index is not in the range First_Index (Container) ..
          Last_Index (Container), then Constraint_Error is propagated.
          Otherwise, Constant_Reference returns an object whose
          discriminant is an access value that designates the element at
          position Index.  Tampering with the elements of Container is
          prohibited while the object returned by Constant_Reference
          exists and has not been finalized.

147.8/3
     function Reference (Container : aliased in out Vector;
                         Index     : in Index_Type)
        return Reference_Type;

147.9/3
          This function (combined with the Variable_Indexing and
          Implicit_Dereference aspects) provides a convenient way to
          gain read and write access to an individual element of a
          vector given an index value.

147.10/3
          If Index is not in the range First_Index (Container) ..
          Last_Index (Container), then Constraint_Error is propagated.
          Otherwise, Reference returns an object whose discriminant is
          an access value that designates the element at position Index.
          Tampering with the elements of Container is prohibited while
          the object returned by Reference exists and has not been
          finalized.

147.11/3
          The element at position Index is not an empty element after
          successful completion of this operation.

147.12/3
     function Constant_Reference (Container : aliased in Vector;
                                  Position  : in Cursor)
        return Constant_Reference_Type;

147.13/3
          This function (combined with the Constant_Indexing and
          Implicit_Dereference aspects) provides a convenient way to
          gain read access to an individual element of a vector given a
          cursor.

147.14/3
          If Position equals No_Element, then Constraint_Error is
          propagated; if Position does not designate an element in
          Container, then Program_Error is propagated.  Otherwise,
          Constant_Reference returns an object whose discriminant is an
          access value that designates the element designated by
          Position.  Tampering with the elements of Container is
          prohibited while the object returned by Constant_Reference
          exists and has not been finalized.

147.15/3
     function Reference (Container : aliased in out Vector;
                         Position  : in Cursor)
        return Reference_Type;

147.16/3
          This function (combined with the Variable_Indexing and
          Implicit_Dereference aspects) provides a convenient way to
          gain read and write access to an individual element of a
          vector given a cursor.

147.17/3
          If Position equals No_Element, then Constraint_Error is
          propagated; if Position does not designate an element in
          Container, then Program_Error is propagated.  Otherwise,
          Reference returns an object whose discriminant is an access
          value that designates the element designated by Position.
          Tampering with the elements of Container is prohibited while
          the object returned by Reference exists and has not been
          finalized.

147.18/3
          The element designated by Position is not an empty element
          after successful completion of this operation.

147.19/3
     procedure Assign (Target : in out Vector; Source : in Vector);

147.20/3
          If Target denotes the same object as Source, the operation has
          no effect.  If the length of Source is greater than the
          capacity of Target, Reserve_Capacity (Target, Length (Source))
          is called.  The elements of Source are then copied to Target
          as for an assignment_statement assigning Source to Target
          (this includes setting the length of Target to be that of
          Source).

147.21/3
     function Copy (Source : Vector; Capacity : Count_Type := 0)
        return Vector;

147.22/3
          Returns a vector whose elements are initialized from the
          corresponding elements of Source.  If Capacity is 0, then the
          vector capacity is the length of Source; if Capacity is equal
          to or greater than the length of Source, the vector capacity
          is at least the specified value.  Otherwise, the operation
          propagates Capacity_Error.

148/2
     procedure Move (Target : in out Vector;
                     Source : in out Vector);

149/3
          If Target denotes the same object as Source, then the
          operation has no effect.  Otherwise, Move first calls
          Reserve_Capacity (Target, Length (Source)) and then Clear
          (Target); then, each element from Source is removed from
          Source and inserted into Target in the original order.  The
          length of Source is 0 after a successful call to Move.

150/2
     procedure Insert (Container : in out Vector;
                       Before    : in     Extended_Index;
                       New_Item  : in     Vector);

151/3
          If Before is not in the range First_Index (Container) ..
          Last_Index (Container) + 1, then Constraint_Error is
          propagated.  If Length(New_Item) is 0, then Insert does
          nothing.  Otherwise, it computes the new length <NL> as the
          sum of the current length and Length (New_Item); if the value
          of Last appropriate for length <NL> would be greater than
          Index_Type'Last, then Constraint_Error is propagated.

152/2
          If the current vector capacity is less than <NL>,
          Reserve_Capacity (Container, <NL>) is called to increase the
          vector capacity.  Then Insert slides the elements in the range
          Before ..  Last_Index (Container) up by Length(New_Item)
          positions, and then copies the elements of New_Item to the
          positions starting at Before.  Any exception raised during the
          copying is propagated.

153/2
     procedure Insert (Container : in out Vector;
                       Before    : in     Cursor;
                       New_Item  : in     Vector);

154/3
          If Before is not No_Element, and does not designate an element
          in Container, then Program_Error is propagated.  Otherwise, if
          Length(New_Item) is 0, then Insert does nothing.  If Before is
          No_Element, then the call is equivalent to Insert (Container,
          Last_Index (Container) + 1, New_Item); otherwise, the call is
          equivalent to Insert (Container, To_Index (Before), New_Item);

155/2
     procedure Insert (Container : in out Vector;
                       Before    : in     Cursor;
                       New_Item  : in     Vector;
                       Position  :    out Cursor);

156/2
          If Before is not No_Element, and does not designate an element
          in Container, then Program_Error is propagated.  If Before
          equals No_Element, then let <T> be Last_Index (Container) + 1;
          otherwise, let <T> be To_Index (Before).  Insert (Container,
          <T>, New_Item) is called, and then Position is set to
          To_Cursor (Container, <T>).

157/2
     procedure Insert (Container : in out Vector;
                       Before    : in     Extended_Index;
                       New_Item  : in     Element_Type;
                       Count     : in     Count_Type := 1);

158/2
          Equivalent to Insert (Container, Before, To_Vector (New_Item,
          Count));

159/2
     procedure Insert (Container : in out Vector;
                       Before    : in     Cursor;
                       New_Item  : in     Element_Type;
                       Count     : in     Count_Type := 1);

160/2
          Equivalent to Insert (Container, Before, To_Vector (New_Item,
          Count));

161/2
     procedure Insert (Container : in out Vector;
                       Before    : in     Cursor;
                       New_Item  : in     Element_Type;
                       Position  :    out Cursor;
                       Count     : in     Count_Type := 1);

162/2
          Equivalent to Insert (Container, Before, To_Vector (New_Item,
          Count), Position);

163/2
     procedure Insert (Container : in out Vector;
                       Before    : in     Extended_Index;
                       Count     : in     Count_Type := 1);

164/3
          If Before is not in the range First_Index (Container) ..
          Last_Index (Container) + 1, then Constraint_Error is
          propagated.  If Count is 0, then Insert does nothing.
          Otherwise, it computes the new length <NL> as the sum of the
          current length and Count; if the value of Last appropriate for
          length <NL> would be greater than Index_Type'Last, then
          Constraint_Error is propagated.

165/2
          If the current vector capacity is less than <NL>,
          Reserve_Capacity (Container, <NL>) is called to increase the
          vector capacity.  Then Insert slides the elements in the range
          Before ..  Last_Index (Container) up by Count positions, and
          then inserts elements that are initialized by default (see
          *note 3.3.1::) in the positions starting at Before.

166/2
     procedure Insert (Container : in out Vector;
                       Before    : in     Cursor;
                       Position  :    out Cursor;
                       Count     : in     Count_Type := 1);

167/2
          If Before is not No_Element, and does not designate an element
          in Container, then Program_Error is propagated.  If Before
          equals No_Element, then let <T> be Last_Index (Container) + 1;
          otherwise, let <T> be To_Index (Before).  Insert (Container,
          <T>, Count) is called, and then Position is set to To_Cursor
          (Container, <T>).

168/4
     procedure Prepend (Container : in out Vector;
                        New_Item  : in     Vector);

169/2
          Equivalent to Insert (Container, First_Index (Container),
          New_Item).

170/2
     procedure Prepend (Container : in out Vector;
                        New_Item  : in     Element_Type;
                        Count     : in     Count_Type := 1);

171/2
          Equivalent to Insert (Container, First_Index (Container),
          New_Item, Count).

172/2
     procedure Append (Container : in out Vector;
                       New_Item  : in     Vector);

173/2
          Equivalent to Insert (Container, Last_Index (Container) + 1,
          New_Item).

174/2
     procedure Append (Container : in out Vector;
                       New_Item  : in     Element_Type;
                       Count     : in     Count_Type := 1);

175/2
          Equivalent to Insert (Container, Last_Index (Container) + 1,
          New_Item, Count).

176/2
     procedure Insert_Space (Container : in out Vector;
                             Before    : in     Extended_Index;
                             Count     : in     Count_Type := 1);

177/3
          If Before is not in the range First_Index (Container) ..
          Last_Index (Container) + 1, then Constraint_Error is
          propagated.  If Count is 0, then Insert_Space does nothing.
          Otherwise, it computes the new length <NL> as the sum of the
          current length and Count; if the value of Last appropriate for
          length <NL> would be greater than Index_Type'Last, then
          Constraint_Error is propagated.

178/2
          If the current vector capacity is less than <NL>,
          Reserve_Capacity (Container, <NL>) is called to increase the
          vector capacity.  Then Insert_Space slides the elements in the
          range Before ..  Last_Index (Container) up by Count positions,
          and then inserts empty elements in the positions starting at
          Before.

179/2
     procedure Insert_Space (Container : in out Vector;
                             Before    : in     Cursor;
                             Position  :    out Cursor;
                             Count     : in     Count_Type := 1);

180/2
          If Before is not No_Element, and does not designate an element
          in Container, then Program_Error is propagated.  If Before
          equals No_Element, then let <T> be Last_Index (Container) + 1;
          otherwise, let <T> be To_Index (Before).  Insert_Space
          (Container, <T>, Count) is called, and then Position is set to
          To_Cursor (Container, <T>).

181/2
     procedure Delete (Container : in out Vector;
                       Index     : in     Extended_Index;
                       Count     : in     Count_Type := 1);

182/3
          If Index is not in the range First_Index (Container) ..
          Last_Index (Container) + 1, then Constraint_Error is
          propagated.  If Count is 0, Delete has no effect.  Otherwise,
          Delete slides the elements (if any) starting at position Index
          + Count down to Index.  Any exception raised during element
          assignment is propagated.

183/2
     procedure Delete (Container : in out Vector;
                       Position  : in out Cursor;
                       Count     : in     Count_Type := 1);

184/2
          If Position equals No_Element, then Constraint_Error is
          propagated.  If Position does not designate an element in
          Container, then Program_Error is propagated.  Otherwise,
          Delete (Container, To_Index (Position), Count) is called, and
          then Position is set to No_Element.

185/2
     procedure Delete_First (Container : in out Vector;
                             Count     : in     Count_Type := 1);

186/2
          Equivalent to Delete (Container, First_Index (Container),
          Count).

187/2
     procedure Delete_Last (Container : in out Vector;
                            Count     : in     Count_Type := 1);

188/3
          If Length (Container) <= Count, then Delete_Last is equivalent
          to Clear (Container).  Otherwise, it is equivalent to Delete
          (Container, Index_Type'Val(Index_Type'Pos(Last_Index
          (Container)) - Count + 1), Count).

189/2
     procedure Reverse_Elements (Container : in out Vector);

190/2
          Reorders the elements of Container in reverse order.

191/2
     procedure Swap (Container : in out Vector;
                     I, J      : in     Index_Type);

192/2
          If either I or J is not in the range First_Index (Container)
          ..  Last_Index (Container), then Constraint_Error is
          propagated.  Otherwise, Swap exchanges the values of the
          elements at positions I and J.

193/2
     procedure Swap (Container : in out Vector;
                     I, J      : in     Cursor);

194/2
          If either I or J is No_Element, then Constraint_Error is
          propagated.  If either I or J do not designate an element in
          Container, then Program_Error is propagated.  Otherwise, Swap
          exchanges the values of the elements designated by I and J.

195/2
     function First_Index (Container : Vector) return Index_Type;

196/2
          Returns the value Index_Type'First.

197/2
     function First (Container : Vector) return Cursor;

198/2
          If Container is empty, First returns No_Element.  Otherwise,
          it returns a cursor that designates the first element in
          Container.

199/2
     function First_Element (Container : Vector) return Element_Type;

200/2
          Equivalent to Element (Container, First_Index (Container)).

201/2
     function Last_Index (Container : Vector) return Extended_Index;

202/2
          If Container is empty, Last_Index returns No_Index.
          Otherwise, it returns the position of the last element in
          Container.

203/2
     function Last (Container : Vector) return Cursor;

204/2
          If Container is empty, Last returns No_Element.  Otherwise, it
          returns a cursor that designates the last element in
          Container.

205/2
     function Last_Element (Container : Vector) return Element_Type;

206/2
          Equivalent to Element (Container, Last_Index (Container)).

207/2
     function Next (Position : Cursor) return Cursor;

208/2
          If Position equals No_Element or designates the last element
          of the container, then Next returns the value No_Element.
          Otherwise, it returns a cursor that designates the element
          with index To_Index (Position) + 1 in the same vector as
          Position.

209/2
     procedure Next (Position : in out Cursor);

210/2
          Equivalent to Position := Next (Position).

211/2
     function Previous (Position : Cursor) return Cursor;

212/2
          If Position equals No_Element or designates the first element
          of the container, then Previous returns the value No_Element.
          Otherwise, it returns a cursor that designates the element
          with index To_Index (Position) - 1 in the same vector as
          Position.

213/2
     procedure Previous (Position : in out Cursor);

214/2
          Equivalent to Position := Previous (Position).

215/2
     function Find_Index (Container : Vector;
                          Item      : Element_Type;
                          Index     : Index_Type := Index_Type'First)
        return Extended_Index;

216/2
          Searches the elements of Container for an element equal to
          Item (using the generic formal equality operator).  The search
          starts at position Index and proceeds towards Last_Index
          (Container).  If no equal element is found, then Find_Index
          returns No_Index.  Otherwise, it returns the index of the
          first equal element encountered.

217/2
     function Find (Container : Vector;
                    Item      : Element_Type;
                    Position  : Cursor := No_Element)
        return Cursor;

218/3
          If Position is not No_Element, and does not designate an
          element in Container, then Program_Error is propagated.
          Otherwise, Find searches the elements of Container for an
          element equal to Item (using the generic formal equality
          operator).  The search starts at the first element if Position
          equals No_Element, and at the element designated by Position
          otherwise.  It proceeds towards the last element of Container.
          If no equal element is found, then Find returns No_Element.
          Otherwise, it returns a cursor designating the first equal
          element encountered.

219/2
     function Reverse_Find_Index (Container : Vector;
                                  Item      : Element_Type;
                                  Index     : Index_Type := Index_Type'Last)
        return Extended_Index;

220/2
          Searches the elements of Container for an element equal to
          Item (using the generic formal equality operator).  The search
          starts at position Index or, if Index is greater than
          Last_Index (Container), at position Last_Index (Container).
          It proceeds towards First_Index (Container).  If no equal
          element is found, then Reverse_Find_Index returns No_Index.
          Otherwise, it returns the index of the first equal element
          encountered.

221/2
     function Reverse_Find (Container : Vector;
                            Item      : Element_Type;
                            Position  : Cursor := No_Element)
        return Cursor;

222/3
          If Position is not No_Element, and does not designate an
          element in Container, then Program_Error is propagated.
          Otherwise, Reverse_Find searches the elements of Container for
          an element equal to Item (using the generic formal equality
          operator).  The search starts at the last element if Position
          equals No_Element, and at the element designated by Position
          otherwise.  It proceeds towards the first element of
          Container.  If no equal element is found, then Reverse_Find
          returns No_Element.  Otherwise, it returns a cursor
          designating the first equal element encountered.

223/2
     function Contains (Container : Vector;
                        Item      : Element_Type) return Boolean;

224/2
          Equivalent to Has_Element (Find (Container, Item)).

          <Paragraphs 225 and 226 were moved above.>

227/2
     procedure Iterate
       (Container : in Vector;
        Process   : not null access procedure (Position : in Cursor));

228/3
          Invokes Process.all with a cursor that designates each element
          in Container, in index order.  Tampering with the cursors of
          Container is prohibited during the execution of a call on
          Process.all.  Any exception raised by Process.all is
          propagated.

229/2
     procedure Reverse_Iterate
       (Container : in Vector;
        Process   : not null access procedure (Position : in Cursor));

230/3
          Iterates over the elements in Container as per procedure
          Iterate, except that elements are traversed in reverse index
          order.

230.1/3
     function Iterate (Container : in Vector)
        return Vector_Iterator_Interfaces.Reversible_Iterator'Class;

230.2/3
          Iterate returns a reversible iterator object (see *note
          5.5.1::) that will generate a value for a loop parameter (see
          *note 5.5.2::) designating each node in Container, starting
          with the first node and moving the cursor as per the Next
          function when used as a forward iterator, and starting with
          the last node and moving the cursor as per the Previous
          function when used as a reverse iterator.  Tampering with the
          cursors of Container is prohibited while the iterator object
          exists (in particular, in the sequence_of_statements of the
          loop_statement whose iterator_specification denotes this
          object).  The iterator object needs finalization.

230.3/3
     function Iterate (Container : in Vector; Start : in Cursor)
        return Vector_Iterator_Interfaces.Reversible_Iterator'Class;

230.4/3
          If Start is not No_Element and does not designate an item in
          Container, then Program_Error is propagated.  If Start is
          No_Element, then Constraint_Error is propagated.  Otherwise,
          Iterate returns a reversible iterator object (see *note
          5.5.1::) that will generate a value for a loop parameter (see
          *note 5.5.2::) designating each node in Container, starting
          with the node designated by Start and moving the cursor as per
          the Next function when used as a forward iterator, or moving
          the cursor as per the Previous function when used as a reverse
          iterator.  Tampering with the cursors of Container is
          prohibited while the iterator object exists (in particular, in
          the sequence_of_statements of the loop_statement whose
          iterator_specification denotes this object).  The iterator
          object needs finalization.

231/3
The actual function for the generic formal function "<" of
Generic_Sorting is expected to return the same value each time it is
called with a particular pair of element values.  It should define a
strict weak ordering relationship (see *note A.18::); it should not
modify Container.  If the actual for "<" behaves in some other manner,
the behavior of the subprograms of Generic_Sorting are unspecified.  The
number of times the subprograms of Generic_Sorting call "<" is
unspecified.

232/2
     function Is_Sorted (Container : Vector) return Boolean;

233/2
          Returns True if the elements are sorted smallest first as
          determined by the generic formal "<" operator; otherwise,
          Is_Sorted returns False.  Any exception raised during
          evaluation of "<" is propagated.

234/2
     procedure Sort (Container : in out Vector);

235/2
          Reorders the elements of Container such that the elements are
          sorted smallest first as determined by the generic formal "<"
          operator provided.  Any exception raised during evaluation of
          "<" is propagated.

236/2
     procedure Merge (Target  : in out Vector;
                      Source  : in out Vector);

237/3
          If Source is empty, then Merge does nothing.  If Source and
          Target are the same nonempty container object, then
          Program_Error is propagated.  Otherwise, Merge removes
          elements from Source and inserts them into Target; afterwards,
          Target contains the union of the elements that were initially
          in Source and Target; Source is left empty.  If Target and
          Source are initially sorted smallest first, then Target is
          ordered smallest first as determined by the generic formal "<"
          operator; otherwise, the order of elements in Target is
          unspecified.  Any exception raised during evaluation of "<" is
          propagated.

                      _Bounded (Run-Time) Errors_

238/3
Reading the value of an empty element by calling Element, Query_Element,
Update_Element, Constant_Reference, Reference, Swap, Is_Sorted, Sort,
Merge, "=", Find, or Reverse_Find is a bounded error.  The
implementation may treat the element as having any normal value (see
*note 13.9.1::) of the element type, or raise Constraint_Error or
Program_Error before modifying the vector.

239/2
Calling Merge in an instance of Generic_Sorting with either Source or
Target not ordered smallest first using the provided generic formal "<"
operator is a bounded error.  Either Program_Error is raised after
Target is updated as described for Merge, or the operation works as
defined.

239.1/3
It is a bounded error for the actual function associated with a generic
formal subprogram, when called as part of an operation of this package,
to tamper with elements of any Vector parameter of the operation.
Either Program_Error is raised, or the operation works as defined on the
value of the Vector either prior to, or subsequent to, some or all of
the modifications to the Vector.

239.2/3
It is a bounded error to call any subprogram declared in the visible
part of Containers.Vectors when the associated container has been
finalized.  If the operation takes Container as an in out parameter,
then it raises Constraint_Error or Program_Error.  Otherwise, the
operation either proceeds as it would for an empty container, or it
raises Constraint_Error or Program_Error.

240/2
A Cursor value is <ambiguous> if any of the following have occurred
since it was created:

241/2
   * Insert, Insert_Space, or Delete has been called on the vector that
     contains the element the cursor designates with an index value (or
     a cursor designating an element at such an index value) less than
     or equal to the index value of the element designated by the
     cursor; or

242/2
   * The vector that contains the element it designates has been passed
     to the Sort or Merge procedures of an instance of Generic_Sorting,
     or to the Reverse_Elements procedure.

243/2
It is a bounded error to call any subprogram other than "=" or
Has_Element declared in Containers.Vectors with an ambiguous (but not
invalid, see below) cursor parameter.  Possible results are:

244/2
   * The cursor may be treated as if it were No_Element;

245/2
   * The cursor may designate some element in the vector (but not
     necessarily the element that it originally designated);

246/2
   * Constraint_Error may be raised; or

247/2
   * Program_Error may be raised.

                         _Erroneous Execution_

248/2
A Cursor value is <invalid> if any of the following have occurred since
it was created: 

249/2
   * The vector that contains the element it designates has been
     finalized;

249.1/3
   * The vector that contains the element it designates has been used as
     the Target of a call to Assign, or as the target of an
     assignment_statement;

250/2
   * The vector that contains the element it designates has been used as
     the Source or Target of a call to Move; or

251/3
   * The element it designates has been deleted or removed from the
     vector that previously contained the element.

252/2
The result of "=" or Has_Element is unspecified if it is called with an
invalid cursor parameter.  Execution is erroneous if any other
subprogram declared in Containers.Vectors is called with an invalid
cursor parameter.

252.1/3
Execution is erroneous if the vector associated with the result of a
call to Reference or Constant_Reference is finalized before the result
object returned by the call to Reference or Constant_Reference is
finalized.

                     _Implementation Requirements_

253/2
No storage associated with a vector object shall be lost upon assignment
or scope exit.

254/3
The execution of an assignment_statement for a vector shall have the
effect of copying the elements from the source vector object to the
target vector object and changing the length of the target object to
that of the source object.

                        _Implementation Advice_

255/2
Containers.Vectors should be implemented similarly to an array.  In
particular, if the length of a vector is <N>, then

256/2
   * the worst-case time complexity of Element should be <O>(log <N>);

257/2
   * the worst-case time complexity of Append with Count=1 when <N> is
     less than the capacity of the vector should be <O>(log <N>); and

258/2
   * the worst-case time complexity of Prepend with Count=1 and
     Delete_First with Count=1 should be <O>(<N> log <N>).

259/2
The worst-case time complexity of a call on procedure Sort of an
instance of Containers.Vectors.Generic_Sorting should be <O>(<N>**2),
and the average time complexity should be better than <O>(<N>**2).

260/2
Containers.Vectors.Generic_Sorting.Sort and
Containers.Vectors.Generic_Sorting.Merge should minimize copying of
elements.

261/2
Move should not copy elements, and should minimize copying of internal
data structures.

262/2
If an exception is propagated from a vector operation, no storage should
be lost, nor any elements removed from a vector unless specified by the
operation.

     NOTES

263/2
     48  All elements of a vector occupy locations in the internal
     array.  If a sparse container is required, a Hashed_Map should be
     used rather than a vector.

264/2
     49  If Index_Type'Base'First = Index_Type'First an instance of
     Ada.Containers.Vectors will raise Constraint_Error.  A value below
     Index_Type'First is required so that an empty vector has a
     meaningful value of Last_Index.


File: arm2012.info,  Node: A.18.3,  Next: A.18.4,  Prev: A.18.2,  Up: A.18

A.18.3 The Generic Package Containers.Doubly_Linked_Lists
---------------------------------------------------------

1/2
The language-defined generic package Containers.Doubly_Linked_Lists
provides private types List and Cursor, and a set of operations for each
type.  A list container is optimized for insertion and deletion at any
position.  

2/2
A doubly-linked list container object manages a linked list of internal
<nodes>, each of which contains an element and pointers to the next
(successor) and previous (predecessor) internal nodes.  A cursor
designates a particular node within a list (and by extension the element
contained in that node).  A cursor keeps designating the same node (and
element) as long as the node is part of the container, even if the node
is moved in the container.

3/2
The <length> of a list is the number of elements it contains.

                          _Static Semantics_

4/2
The generic library package Containers.Doubly_Linked_Lists has the
following declaration:

5/3
     with Ada.Iterator_Interfaces;
     generic
        type Element_Type is private;
        with function "=" (Left, Right : Element_Type)
           return Boolean is <>;
     package Ada.Containers.Doubly_Linked_Lists is
        pragma Preelaborate(Doubly_Linked_Lists);
        pragma Remote_Types(Doubly_Linked_Lists);

6/3
        type List is tagged private
           with Constant_Indexing => Constant_Reference,
                Variable_Indexing => Reference,
                Default_Iterator  => Iterate,
                Iterator_Element  => Element_Type;
        pragma Preelaborable_Initialization(List);

7/2
        type Cursor is private;
        pragma Preelaborable_Initialization(Cursor);

8/2
        Empty_List : constant List;

9/2
        No_Element : constant Cursor;

9.1/3
        function Has_Element (Position : Cursor) return Boolean;

9.2/3
        package List_Iterator_Interfaces is new
            Ada.Iterator_Interfaces (Cursor, Has_Element);

10/2
        function "=" (Left, Right : List) return Boolean;

11/2
        function Length (Container : List) return Count_Type;

12/2
        function Is_Empty (Container : List) return Boolean;

13/2
        procedure Clear (Container : in out List);

14/2
        function Element (Position : Cursor)
           return Element_Type;

15/2
        procedure Replace_Element (Container : in out List;
                                   Position  : in     Cursor;
                                   New_Item  : in     Element_Type);

16/2
        procedure Query_Element
          (Position : in Cursor;
           Process  : not null access procedure (Element : in Element_Type));

17/2
        procedure Update_Element
          (Container : in out List;
           Position  : in     Cursor;
           Process   : not null access procedure
                           (Element : in out Element_Type));

17.1/3
        type Constant_Reference_Type
              (Element : not null access constant Element_Type) is private
           with Implicit_Dereference => Element;

17.2/3
        type Reference_Type (Element : not null access Element_Type) is private
           with Implicit_Dereference => Element;

17.3/3
        function Constant_Reference (Container : aliased in List;
                                     Position  : in Cursor)
           return Constant_Reference_Type;

17.4/3
        function Reference (Container : aliased in out List;
                            Position  : in Cursor)
           return Reference_Type;

17.5/3
        procedure Assign (Target : in out List; Source : in List);

17.6/3
        function Copy (Source : List) return List;

18/2
        procedure Move (Target : in out List;
                        Source : in out List);

19/2
        procedure Insert (Container : in out List;
                          Before    : in     Cursor;
                          New_Item  : in     Element_Type;
                          Count     : in     Count_Type := 1);

20/2
        procedure Insert (Container : in out List;
                          Before    : in     Cursor;
                          New_Item  : in     Element_Type;
                          Position  :    out Cursor;
                          Count     : in     Count_Type := 1);

21/2
        procedure Insert (Container : in out List;
                          Before    : in     Cursor;
                          Position  :    out Cursor;
                          Count     : in     Count_Type := 1);

22/2
        procedure Prepend (Container : in out List;
                           New_Item  : in     Element_Type;
                           Count     : in     Count_Type := 1);

23/2
        procedure Append (Container : in out List;
                          New_Item  : in     Element_Type;
                          Count     : in     Count_Type := 1);

24/2
        procedure Delete (Container : in out List;
                          Position  : in out Cursor;
                          Count     : in     Count_Type := 1);

25/2
        procedure Delete_First (Container : in out List;
                                Count     : in     Count_Type := 1);

26/2
        procedure Delete_Last (Container : in out List;
                               Count     : in     Count_Type := 1);

27/2
        procedure Reverse_Elements (Container : in out List);

28/2
        procedure Swap (Container : in out List;
                        I, J      : in     Cursor);

29/2
        procedure Swap_Links (Container : in out List;
                              I, J      : in     Cursor);

30/2
        procedure Splice (Target   : in out List;
                          Before   : in     Cursor;
                          Source   : in out List);

31/2
        procedure Splice (Target   : in out List;
                          Before   : in     Cursor;
                          Source   : in out List;
                          Position : in out Cursor);

32/2
        procedure Splice (Container: in out List;
                          Before   : in     Cursor;
                          Position : in     Cursor);

33/2
        function First (Container : List) return Cursor;

34/2
        function First_Element (Container : List)
           return Element_Type;

35/2
        function Last (Container : List) return Cursor;

36/2
        function Last_Element (Container : List)
           return Element_Type;

37/2
        function Next (Position : Cursor) return Cursor;

38/2
        function Previous (Position : Cursor) return Cursor;

39/2
        procedure Next (Position : in out Cursor);

40/2
        procedure Previous (Position : in out Cursor);

41/2
        function Find (Container : List;
                       Item      : Element_Type;
                       Position  : Cursor := No_Element)
           return Cursor;

42/2
        function Reverse_Find (Container : List;
                               Item      : Element_Type;
                               Position  : Cursor := No_Element)
           return Cursor;

43/2
        function Contains (Container : List;
                           Item      : Element_Type) return Boolean;

44/3
     <This paragraph was deleted.>

45/2
        procedure Iterate
          (Container : in List;
           Process   : not null access procedure (Position : in Cursor));

46/2
        procedure Reverse_Iterate
          (Container : in List;
           Process   : not null access procedure (Position : in Cursor));

46.1/3
        function Iterate (Container : in List)
           return List_Iterator_Interfaces.Reversible_Iterator'Class;

46.2/3
        function Iterate (Container : in List; Start : in Cursor)
           return List_Iterator_Interfaces.Reversible_Iterator'Class;

47/2
        generic
           with function "<" (Left, Right : Element_Type)
              return Boolean is <>;
        package Generic_Sorting is

48/2
           function Is_Sorted (Container : List) return Boolean;

49/2
           procedure Sort (Container : in out List);

50/2
           procedure Merge (Target  : in out List;
                            Source  : in out List);

51/2
        end Generic_Sorting;

52/2
     private

53/2
        ... -- <not specified by the language>

54/2
     end Ada.Containers.Doubly_Linked_Lists;

55/2
The actual function for the generic formal function "=" on Element_Type
values is expected to define a reflexive and symmetric relationship and
return the same result value each time it is called with a particular
pair of values.  If it behaves in some other manner, the functions Find,
Reverse_Find, and "=" on list values return an unspecified value.  The
exact arguments and number of calls of this generic formal function by
the functions Find, Reverse_Find, and "=" on list values are
unspecified.

56/2
The type List is used to represent lists.  The type List needs
finalization (see *note 7.6::).

57/2
Empty_List represents the empty List object.  It has a length of 0.  If
an object of type List is not otherwise initialized, it is initialized
to the same value as Empty_List.

58/2
No_Element represents a cursor that designates no element.  If an object
of type Cursor is not otherwise initialized, it is initialized to the
same value as No_Element.

59/2
The predefined "=" operator for type Cursor returns True if both cursors
are No_Element, or designate the same element in the same container.

60/2
Execution of the default implementation of the Input, Output, Read, or
Write attribute of type Cursor raises Program_Error.

60.1/3
List'Write for a List object <L> writes Length(<L>) elements of the list
to the stream.  It also may write additional information about the list.

60.2/3
List'Read reads the representation of a list from the stream, and
assigns to <Item> a list with the same length and elements as was
written by List'Write.

61/2
Some operations of this generic package have access-to-subprogram
parameters.  To ensure such operations are well-defined, they guard
against certain actions by the designated subprogram.  In particular,
some operations check for "tampering with cursors" of a container
because they depend on the set of elements of the container remaining
constant, and others check for "tampering with elements" of a container
because they depend on elements of the container not being replaced.

62/2
A subprogram is said to <tamper with cursors> of a list object <L> if:

63/2
   * it inserts or deletes elements of <L>, that is, it calls the
     Insert, Clear, Delete, or Delete_Last procedures with <L> as a
     parameter; or

64/2
   * it reorders the elements of <L>, that is, it calls the Splice,
     Swap_Links, or Reverse_Elements procedures or the Sort or Merge
     procedures of an instance of Generic_Sorting with <L> as a
     parameter; or

65/2
   * it finalizes <L>; or

65.1/3
   * it calls the Assign procedure with <L> as the Target parameter; or

66/2
   * it calls the Move procedure with <L> as a parameter.

67/2
A subprogram is said to <tamper with elements> of a list object <L> if:

68/2
   * it tampers with cursors of <L>; or

69/2
   * it replaces one or more elements of <L>, that is, it calls the
     Replace_Element or Swap procedures with <L> as a parameter.

69.1/4
When tampering with cursors is <prohibited> for a particular list object
<L>, Program_Error is propagated by a call of any language-defined
subprogram that is defined to tamper with the cursors of <L>, leaving
<L> unmodified.  Similarly, when tampering with elements is <prohibited>
for a particular list object <L>, Program_Error is propagated by a call
of any language-defined subprogram that is defined to tamper with the
elements of <L> (or tamper with the cursors of <L>), leaving <L>
unmodified.  These checks are made before any other defined behavior of
the body of the language-defined subprogram.

69.2/3
     function Has_Element (Position : Cursor) return Boolean;

69.3/3
          Returns True if Position designates an element, and returns
          False otherwise.

70/2
     function "=" (Left, Right : List) return Boolean;

71/3
          If Left and Right denote the same list object, then the
          function returns True.  If Left and Right have different
          lengths, then the function returns False.  Otherwise, it
          compares each element in Left to the corresponding element in
          Right using the generic formal equality operator.  If any such
          comparison returns False, the function returns False;
          otherwise, it returns True.  Any exception raised during
          evaluation of element equality is propagated.

72/2
     function Length (Container : List) return Count_Type;

73/2
          Returns the number of elements in Container.

74/2
     function Is_Empty (Container : List) return Boolean;

75/2
          Equivalent to Length (Container) = 0.

76/2
     procedure Clear (Container : in out List);

77/2
          Removes all the elements from Container.

78/2
     function Element (Position : Cursor) return Element_Type;

79/2
          If Position equals No_Element, then Constraint_Error is
          propagated.  Otherwise, Element returns the element designated
          by Position.

80/2
     procedure Replace_Element (Container : in out List;
                                Position  : in     Cursor;
                                New_Item  : in     Element_Type);

81/3
          If Position equals No_Element, then Constraint_Error is
          propagated; if Position does not designate an element in
          Container, then Program_Error is propagated.  Otherwise,
          Replace_Element assigns the value New_Item to the element
          designated by Position.

82/2
     procedure Query_Element
       (Position : in Cursor;
        Process  : not null access procedure (Element : in Element_Type));

83/3
          If Position equals No_Element, then Constraint_Error is
          propagated.  Otherwise, Query_Element calls Process.all with
          the element designated by Position as the argument.  Tampering
          with the elements of the list that contains the element
          designated by Position is prohibited during the execution of
          the call on Process.all.  Any exception raised by Process.all
          is propagated.

84/2
     procedure Update_Element
       (Container : in out List;
        Position  : in     Cursor;
        Process   : not null access procedure (Element : in out Element_Type));

85/3
          If Position equals No_Element, then Constraint_Error is
          propagated; if Position does not designate an element in
          Container, then Program_Error is propagated.  Otherwise,
          Update_Element calls Process.all with the element designated
          by Position as the argument.  Tampering with the elements of
          Container is prohibited during the execution of the call on
          Process.all.  Any exception raised by Process.all is
          propagated.

86/2
          If Element_Type is unconstrained and definite, then the actual
          Element parameter of Process.all shall be unconstrained.

86.1/3
     type Constant_Reference_Type
           (Element : not null access constant Element_Type) is private
        with Implicit_Dereference => Element;

86.2/3
     type Reference_Type (Element : not null access Element_Type) is private
        with Implicit_Dereference => Element;

86.3/3
          The types Constant_Reference_Type and Reference_Type need
          finalization.

86.4/3
          The default initialization of an object of type
          Constant_Reference_Type or Reference_Type propagates
          Program_Error.

86.5/3
     function Constant_Reference (Container : aliased in List;
                                  Position  : in Cursor)
        return Constant_Reference_Type;

86.6/3
          This function (combined with the Constant_Indexing and
          Implicit_Dereference aspects) provides a convenient way to
          gain read access to an individual element of a list given a
          cursor.

86.7/3
          If Position equals No_Element, then Constraint_Error is
          propagated; if Position does not designate an element in
          Container, then Program_Error is propagated.  Otherwise,
          Constant_Reference returns an object whose discriminant is an
          access value that designates the element designated by
          Position.  Tampering with the elements of Container is
          prohibited while the object returned by Constant_Reference
          exists and has not been finalized.

86.8/3
     function Reference (Container : aliased in out List;
                         Position  : in Cursor)
        return Reference_Type;

86.9/3
          This function (combined with the Variable_Indexing and
          Implicit_Dereference aspects) provides a convenient way to
          gain read and write access to an individual element of a list
          given a cursor.

86.10/3
          If Position equals No_Element, then Constraint_Error is
          propagated; if Position does not designate an element in
          Container, then Program_Error is propagated.  Otherwise,
          Reference returns an object whose discriminant is an access
          value that designates the element designated by Position.
          Tampering with the elements of Container is prohibited while
          the object returned by Reference exists and has not been
          finalized.

86.11/3
     procedure Assign (Target : in out List; Source : in List);

86.12/3
          If Target denotes the same object as Source, the operation has
          no effect.  Otherwise, the elements of Source are copied to
          Target as for an assignment_statement assigning Source to
          Target.

86.13/3
     function Copy (Source : List) return List;

86.14/3
          Returns a list whose elements match the elements of Source.

87/2
     procedure Move (Target : in out List;
                     Source : in out List);

88/3
          If Target denotes the same object as Source, then the
          operation has no effect.  Otherwise, the operation is
          equivalent to Assign (Target, Source) followed by Clear
          (Source).

89/2
     procedure Insert (Container : in out List;
                       Before    : in     Cursor;
                       New_Item  : in     Element_Type;
                       Count     : in     Count_Type := 1);

90/2
          If Before is not No_Element, and does not designate an element
          in Container, then Program_Error is propagated.  Otherwise,
          Insert inserts Count copies of New_Item prior to the element
          designated by Before.  If Before equals No_Element, the new
          elements are inserted after the last node (if any).  Any
          exception raised during allocation of internal storage is
          propagated, and Container is not modified.

91/2
     procedure Insert (Container : in out List;
                       Before    : in     Cursor;
                       New_Item  : in     Element_Type;
                       Position  :    out Cursor;
                       Count     : in     Count_Type := 1);

92/3
          If Before is not No_Element, and does not designate an element
          in Container, then Program_Error is propagated.  Otherwise,
          Insert allocates Count copies of New_Item, and inserts them
          prior to the element designated by Before.  If Before equals
          No_Element, the new elements are inserted after the last
          element (if any).  Position designates the first
          newly-inserted element, or if Count equals 0, then Position is
          assigned the value of Before.  Any exception raised during
          allocation of internal storage is propagated, and Container is
          not modified.

93/2
     procedure Insert (Container : in out List;
                       Before    : in     Cursor;
                       Position  :    out Cursor;
                       Count     : in     Count_Type := 1);

94/3
          If Before is not No_Element, and does not designate an element
          in Container, then Program_Error is propagated.  Otherwise,
          Insert inserts Count new elements prior to the element
          designated by Before.  If Before equals No_Element, the new
          elements are inserted after the last node (if any).  The new
          elements are initialized by default (see *note 3.3.1::).
          Position designates the first newly-inserted element, or if
          Count equals 0, then Position is assigned the value of Before.
          Any exception raised during allocation of internal storage is
          propagated, and Container is not modified.

95/2
     procedure Prepend (Container : in out List;
                        New_Item  : in     Element_Type;
                        Count     : in     Count_Type := 1);

96/2
          Equivalent to Insert (Container, First (Container), New_Item,
          Count).

97/2
     procedure Append (Container : in out List;
                       New_Item  : in     Element_Type;
                       Count     : in     Count_Type := 1);

98/2
          Equivalent to Insert (Container, No_Element, New_Item, Count).

99/2
     procedure Delete (Container : in out List;
                       Position  : in out Cursor;
                       Count     : in     Count_Type := 1);

100/3
          If Position equals No_Element, then Constraint_Error is
          propagated.  If Position does not designate an element in
          Container, then Program_Error is propagated.  Otherwise,
          Delete removes (from Container) Count elements starting at the
          element designated by Position (or all of the elements
          starting at Position if there are fewer than Count elements
          starting at Position).  Finally, Position is set to
          No_Element.

101/2
     procedure Delete_First (Container : in out List;
                             Count     : in     Count_Type := 1);

102/3
          If Length (Container) <= Count, then Delete_First is
          equivalent to Clear (Container).  Otherwise, it removes the
          first Count nodes from Container.

103/2
     procedure Delete_Last (Container : in out List;
                            Count     : in     Count_Type := 1);

104/3
          If Length (Container) <= Count, then Delete_Last is equivalent
          to Clear (Container).  Otherwise, it removes the last Count
          nodes from Container.

105/2
     procedure Reverse_Elements (Container : in out List);

106/2
          Reorders the elements of Container in reverse order.

107/2
     procedure Swap (Container : in out List;
                     I, J      : in     Cursor);

108/2
          If either I or J is No_Element, then Constraint_Error is
          propagated.  If either I or J do not designate an element in
          Container, then Program_Error is propagated.  Otherwise, Swap
          exchanges the values of the elements designated by I and J.

109/2
     procedure Swap_Links (Container : in out List;
                           I, J      : in     Cursor);

110/2
          If either I or J is No_Element, then Constraint_Error is
          propagated.  If either I or J do not designate an element in
          Container, then Program_Error is propagated.  Otherwise,
          Swap_Links exchanges the nodes designated by I and J.

111/2
     procedure Splice (Target   : in out List;
                       Before   : in     Cursor;
                       Source   : in out List);

112/2
          If Before is not No_Element, and does not designate an element
          in Target, then Program_Error is propagated.  Otherwise, if
          Source denotes the same object as Target, the operation has no
          effect.  Otherwise, Splice reorders elements such that they
          are removed from Source and moved to Target, immediately prior
          to Before.  If Before equals No_Element, the nodes of Source
          are spliced after the last node of Target.  The length of
          Target is incremented by the number of nodes in Source, and
          the length of Source is set to 0.

113/2
     procedure Splice (Target   : in out List;
                       Before   : in     Cursor;
                       Source   : in out List;
                       Position : in out Cursor);

114/3
          If Position is No_Element, then Constraint_Error is
          propagated.  If Before does not equal No_Element, and does not
          designate an element in Target, then Program_Error is
          propagated.  If Position does not equal No_Element, and does
          not designate a node in Source, then Program_Error is
          propagated.  If Source denotes the same object as Target, then
          there is no effect if Position equals Before, else the element
          designated by Position is moved immediately prior to Before,
          or, if Before equals No_Element, after the last element.  In
          both cases, Position and the length of Target are unchanged.
          Otherwise, the element designated by Position is removed from
          Source and moved to Target, immediately prior to Before, or,
          if Before equals No_Element, after the last element of Target.
          The length of Target is incremented, the length of Source is
          decremented, and Position is updated to represent an element
          in Target.

115/2
     procedure Splice (Container: in out List;
                       Before   : in     Cursor;
                       Position : in     Cursor);

116/3
          If Position is No_Element, then Constraint_Error is
          propagated.  If Before does not equal No_Element, and does not
          designate an element in Container, then Program_Error is
          propagated.  If Position does not equal No_Element, and does
          not designate a node in Container, then Program_Error is
          propagated.  If Position equals Before there is no effect.
          Otherwise, the element designated by Position is moved
          immediately prior to Before, or, if Before equals No_Element,
          after the last element.  The length of Container is unchanged.

117/2
     function First (Container : List) return Cursor;

118/3
          If Container is empty, First returns the value No_Element.
          Otherwise, it returns a cursor that designates the first node
          in Container.

119/2
     function First_Element (Container : List) return Element_Type;

120/2
          Equivalent to Element (First (Container)).

121/2
     function Last (Container : List) return Cursor;

122/3
          If Container is empty, Last returns the value No_Element.
          Otherwise, it returns a cursor that designates the last node
          in Container.

123/2
     function Last_Element (Container : List) return Element_Type;

124/2
          Equivalent to Element (Last (Container)).

125/2
     function Next (Position : Cursor) return Cursor;

126/2
          If Position equals No_Element or designates the last element
          of the container, then Next returns the value No_Element.
          Otherwise, it returns a cursor that designates the successor
          of the element designated by Position.

127/2
     function Previous (Position : Cursor) return Cursor;

128/2
          If Position equals No_Element or designates the first element
          of the container, then Previous returns the value No_Element.
          Otherwise, it returns a cursor that designates the predecessor
          of the element designated by Position.

129/2
     procedure Next (Position : in out Cursor);

130/2
          Equivalent to Position := Next (Position).

131/2
     procedure Previous (Position : in out Cursor);

132/2
          Equivalent to Position := Previous (Position).

133/2
     function Find (Container : List;
                    Item      : Element_Type;
                    Position  : Cursor := No_Element)
       return Cursor;

134/2
          If Position is not No_Element, and does not designate an
          element in Container, then Program_Error is propagated.  Find
          searches the elements of Container for an element equal to
          Item (using the generic formal equality operator).  The search
          starts at the element designated by Position, or at the first
          element if Position equals No_Element.  It proceeds towards
          Last (Container).  If no equal element is found, then Find
          returns No_Element.  Otherwise, it returns a cursor
          designating the first equal element encountered.

135/2
     function Reverse_Find (Container : List;
                            Item      : Element_Type;
                            Position  : Cursor := No_Element)
        return Cursor;

136/2
          If Position is not No_Element, and does not designate an
          element in Container, then Program_Error is propagated.  Find
          searches the elements of Container for an element equal to
          Item (using the generic formal equality operator).  The search
          starts at the element designated by Position, or at the last
          element if Position equals No_Element.  It proceeds towards
          First (Container).  If no equal element is found, then
          Reverse_Find returns No_Element.  Otherwise, it returns a
          cursor designating the first equal element encountered.

137/2
     function Contains (Container : List;
                        Item      : Element_Type) return Boolean;

138/2
          Equivalent to Find (Container, Item) /= No_Element.

          <Paragraphs 139 and 140 were moved above.>

141/2
     procedure Iterate
       (Container : in List;
        Process   : not null access procedure (Position : in Cursor));

142/3
          Iterate calls Process.all with a cursor that designates each
          node in Container, starting with the first node and moving the
          cursor as per the Next function.  Tampering with the cursors
          of Container is prohibited during the execution of a call on
          Process.all.  Any exception raised by Process.all is
          propagated.

143/2
     procedure Reverse_Iterate
       (Container : in List;
        Process   : not null access procedure (Position : in Cursor));

144/3
          Iterates over the nodes in Container as per procedure Iterate,
          except that elements are traversed in reverse order, starting
          with the last node and moving the cursor as per the Previous
          function.

144.1/3
     function Iterate (Container : in List)
        return List_Iterator_Interfaces.Reversible_Iterator'Class;

144.2/3
          Iterate returns a reversible iterator object (see *note
          5.5.1::) that will generate a value for a loop parameter (see
          *note 5.5.2::) designating each node in Container, starting
          with the first node and moving the cursor as per the Next
          function when used as a forward iterator, and starting with
          the last node and moving the cursor as per the Previous
          function when used as a reverse iterator.  Tampering with the
          cursors of Container is prohibited while the iterator object
          exists (in particular, in the sequence_of_statements of the
          loop_statement whose iterator_specification denotes this
          object).  The iterator object needs finalization.

144.3/3
     function Iterate (Container : in List; Start : in Cursor)
        return List_Iterator_Interfaces.Reversible_Iterator'Class;

144.4/3
          If Start is not No_Element and does not designate an item in
          Container, then Program_Error is propagated.  If Start is
          No_Element, then Constraint_Error is propagated.  Otherwise,
          Iterate returns a reversible iterator object (see *note
          5.5.1::) that will generate a value for a loop parameter (see
          *note 5.5.2::) designating each node in Container, starting
          with the node designated by Start and moving the cursor as per
          the Next function when used as a forward iterator, or moving
          the cursor as per the Previous function when used as a reverse
          iterator.  Tampering with the cursors of Container is
          prohibited while the iterator object exists (in particular, in
          the sequence_of_statements of the loop_statement whose
          iterator_specification denotes this object).  The iterator
          object needs finalization.

145/3
The actual function for the generic formal function "<" of
Generic_Sorting is expected to return the same value each time it is
called with a particular pair of element values.  It should define a
strict weak ordering relationship (see *note A.18::); it should not
modify Container.  If the actual for "<" behaves in some other manner,
the behavior of the subprograms of Generic_Sorting are unspecified.  The
number of times the subprograms of Generic_Sorting call "<" is
unspecified.

146/2
     function Is_Sorted (Container : List) return Boolean;

147/2
          Returns True if the elements are sorted smallest first as
          determined by the generic formal "<" operator; otherwise,
          Is_Sorted returns False.  Any exception raised during
          evaluation of "<" is propagated.

148/2
     procedure Sort (Container : in out List);

149/2
          Reorders the nodes of Container such that the elements are
          sorted smallest first as determined by the generic formal "<"
          operator provided.  The sort is stable.  Any exception raised
          during evaluation of "<" is propagated.

150/2
     procedure Merge (Target  : in out List;
                      Source  : in out List);

151/3
          If Source is empty, then Merge does nothing.  If Source and
          Target are the same nonempty container object, then
          Program_Error is propagated.  Otherwise, Merge removes
          elements from Source and inserts them into Target; afterwards,
          Target contains the union of the elements that were initially
          in Source and Target; Source is left empty.  If Target and
          Source are initially sorted smallest first, then Target is
          ordered smallest first as determined by the generic formal "<"
          operator; otherwise, the order of elements in Target is
          unspecified.  Any exception raised during evaluation of "<" is
          propagated.

                      _Bounded (Run-Time) Errors_

152/2
Calling Merge in an instance of Generic_Sorting with either Source or
Target not ordered smallest first using the provided generic formal "<"
operator is a bounded error.  Either Program_Error is raised after
Target is updated as described for Merge, or the operation works as
defined.

152.1/3
It is a bounded error for the actual function associated with a generic
formal subprogram, when called as part of an operation of this package,
to tamper with elements of any List parameter of the operation.  Either
Program_Error is raised, or the operation works as defined on the value
of the List either prior to, or subsequent to, some or all of the
modifications to the List.

152.2/3
It is a bounded error to call any subprogram declared in the visible
part of Containers.Doubly_Linked_Lists when the associated container has
been finalized.  If the operation takes Container as an in out
parameter, then it raises Constraint_Error or Program_Error.  Otherwise,
the operation either proceeds as it would for an empty container, or it
raises Constraint_Error or Program_Error.

                         _Erroneous Execution_

153/2
A Cursor value is <invalid> if any of the following have occurred since
it was created: 

154/2
   * The list that contains the element it designates has been
     finalized;

154.1/3
   * The list that contains the element it designates has been used as
     the Target of a call to Assign, or as the target of an
     assignment_statement;

155/2
   * The list that contains the element it designates has been used as
     the Source or Target of a call to Move; or

156/3
   * The element it designates has been removed from the list that
     previously contained the element.

157/2
The result of "=" or Has_Element is unspecified if it is called with an
invalid cursor parameter.  Execution is erroneous if any other
subprogram declared in Containers.Doubly_Linked_Lists is called with an
invalid cursor parameter.  

157.1/3
Execution is erroneous if the list associated with the result of a call
to Reference or Constant_Reference is finalized before the result object
returned by the call to Reference or Constant_Reference is finalized.

                     _Implementation Requirements_

158/2
No storage associated with a doubly-linked List object shall be lost
upon assignment or scope exit.

159/3
The execution of an assignment_statement for a list shall have the
effect of copying the elements from the source list object to the target
list object and changing the length of the target object to that of the
source object.

                        _Implementation Advice_

160/2
Containers.Doubly_Linked_Lists should be implemented similarly to a
linked list.  In particular, if <N> is the length of a list, then the
worst-case time complexity of Element, Insert with Count=1, and Delete
with Count=1 should be <O>(log <N>).

161/2
The worst-case time complexity of a call on procedure Sort of an
instance of Containers.Doubly_Linked_Lists.Generic_Sorting should be
<O>(<N>**2), and the average time complexity should be better than
<O>(<N>**2).

162/2
Move should not copy elements, and should minimize copying of internal
data structures.

163/2
If an exception is propagated from a list operation, no storage should
be lost, nor any elements removed from a list unless specified by the
operation.

     NOTES

164/2
     50  Sorting a list never copies elements, and is a stable sort
     (equal elements remain in the original order).  This is different
     than sorting an array or vector, which may need to copy elements,
     and is probably not a stable sort.


File: arm2012.info,  Node: A.18.4,  Next: A.18.5,  Prev: A.18.3,  Up: A.18

A.18.4 Maps
-----------

1/2
The language-defined generic packages Containers.Hashed_Maps and
Containers.Ordered_Maps provide private types Map and Cursor, and a set
of operations for each type.  A map container allows an arbitrary type
to be used as a key to find the element associated with that key.  A
hashed map uses a hash function to organize the keys, while an ordered
map orders the keys per a specified relation.  

2/3
This subclause describes the declarations that are common to both kinds
of maps.  See *note A.18.5:: for a description of the semantics specific
to Containers.Hashed_Maps and *note A.18.6:: for a description of the
semantics specific to Containers.Ordered_Maps.

                          _Static Semantics_

3/2
The actual function for the generic formal function "=" on Element_Type
values is expected to define a reflexive and symmetric relationship and
return the same result value each time it is called with a particular
pair of values.  If it behaves in some other manner, the function "=" on
map values returns an unspecified value.  The exact arguments and number
of calls of this generic formal function by the function "=" on map
values are unspecified.

4/2
The type Map is used to represent maps.  The type Map needs finalization
(see *note 7.6::).

5/2
A map contains pairs of keys and elements, called <nodes>.  Map cursors
designate nodes, but also can be thought of as designating an element
(the element contained in the node) for consistency with the other
containers.  There exists an equivalence relation on keys, whose
definition is different for hashed maps and ordered maps.  A map never
contains two or more nodes with equivalent keys.  The <length> of a map
is the number of nodes it contains.

6/2
Each nonempty map has two particular nodes called the <first node> and
the <last node> (which may be the same).  Each node except for the last
node has a <successor node>.  If there are no other intervening
operations, starting with the first node and repeatedly going to the
successor node will visit each node in the map exactly once until the
last node is reached.  The exact definition of these terms is different
for hashed maps and ordered maps.

7/2
Some operations of these generic packages have access-to-subprogram
parameters.  To ensure such operations are well-defined, they guard
against certain actions by the designated subprogram.  In particular,
some operations check for "tampering with cursors" of a container
because they depend on the set of elements of the container remaining
constant, and others check for "tampering with elements" of a container
because they depend on elements of the container not being replaced.

8/2
A subprogram is said to <tamper with cursors> of a map object <M> if:

9/2
   * it inserts or deletes elements of <M>, that is, it calls the
     Insert, Include, Clear, Delete, or Exclude procedures with <M> as a
     parameter; or

10/2
   * it finalizes <M>; or

10.1/3
   * it calls the Assign procedure with <M> as the Target parameter; or

11/2
   * it calls the Move procedure with <M> as a parameter; or

12/2
   * it calls one of the operations defined to tamper with the cursors
     of <M>.

13/2
A subprogram is said to <tamper with elements> of a map object <M> if:

14/2
   * it tampers with cursors of <M>; or

15/2
   * it replaces one or more elements of <M>, that is, it calls the
     Replace or Replace_Element procedures with <M> as a parameter.

15.1/4
When tampering with cursors is <prohibited> for a particular map object
<M>, Program_Error is propagated by a call of any language-defined
subprogram that is defined to tamper with the cursors of <M>, leaving
<M> unmodified.  Similarly, when tampering with elements is <prohibited>
for a particular map object <M>, Program_Error is propagated by a call
of any language-defined subprogram that is defined to tamper with the
elements of <M> (or tamper with the cursors of <M>), leaving <M>
unmodified.  These checks are made before any other defined behavior of
the body of the language-defined subprogram.

16/2
Empty_Map represents the empty Map object.  It has a length of 0.  If an
object of type Map is not otherwise initialized, it is initialized to
the same value as Empty_Map.

17/2
No_Element represents a cursor that designates no node.  If an object of
type Cursor is not otherwise initialized, it is initialized to the same
value as No_Element.

18/2
The predefined "=" operator for type Cursor returns True if both cursors
are No_Element, or designate the same element in the same container.

19/2
Execution of the default implementation of the Input, Output, Read, or
Write attribute of type Cursor raises Program_Error.

19.1/3
Map'Write for a Map object <M> writes Length(<M>) elements of the map to
the stream.  It also may write additional information about the map.

19.2/3
Map'Read reads the representation of a map from the stream, and assigns
to <Item> a map with the same length and elements as was written by
Map'Write.

19.3/3
     function Has_Element (Position : Cursor) return Boolean;

19.4/3
          Returns True if Position designates an element, and returns
          False otherwise.

20/2
     function "=" (Left, Right : Map) return Boolean;

21/2
          If Left and Right denote the same map object, then the
          function returns True.  If Left and Right have different
          lengths, then the function returns False.  Otherwise, for each
          key <K> in Left, the function returns False if:

22/2
             * a key equivalent to <K> is not present in Right; or

23/2
             * the element associated with <K> in Left is not equal to
               the element associated with <K> in Right (using the
               generic formal equality operator for elements).

24/2
          If the function has not returned a result after checking all
          of the keys, it returns True.  Any exception raised during
          evaluation of key equivalence or element equality is
          propagated.

25/2
     function Length (Container : Map) return Count_Type;

26/2
          Returns the number of nodes in Container.

27/2
     function Is_Empty (Container : Map) return Boolean;

28/2
          Equivalent to Length (Container) = 0.

29/2
     procedure Clear (Container : in out Map);

30/2
          Removes all the nodes from Container.

31/2
     function Key (Position : Cursor) return Key_Type;

32/2
          If Position equals No_Element, then Constraint_Error is
          propagated.  Otherwise, Key returns the key component of the
          node designated by Position.

33/2
     function Element (Position : Cursor) return Element_Type;

34/2
          If Position equals No_Element, then Constraint_Error is
          propagated.  Otherwise, Element returns the element component
          of the node designated by Position.

35/2
     procedure Replace_Element (Container : in out Map;
                                Position  : in     Cursor;
                                New_Item  : in     Element_Type);

36/3
          If Position equals No_Element, then Constraint_Error is
          propagated; if Position does not designate an element in
          Container, then Program_Error is propagated.  Otherwise,
          Replace_Element assigns New_Item to the element of the node
          designated by Position.

37/2
     procedure Query_Element
       (Position : in Cursor;
        Process  : not null access procedure (Key     : in Key_Type;
                                              Element : in Element_Type));

38/3
          If Position equals No_Element, then Constraint_Error is
          propagated.  Otherwise, Query_Element calls Process.all with
          the key and element from the node designated by Position as
          the arguments.  Tampering with the elements of the map that
          contains the element designated by Position is prohibited
          during the execution of the call on Process.all.  Any
          exception raised by Process.all is propagated.

39/2
     procedure Update_Element
       (Container : in out Map;
        Position  : in     Cursor;
        Process   : not null access procedure (Key     : in     Key_Type;
                                               Element : in out Element_Type));

40/3
          If Position equals No_Element, then Constraint_Error is
          propagated; if Position does not designate an element in
          Container, then Program_Error is propagated.  Otherwise,
          Update_Element calls Process.all with the key and element from
          the node designated by Position as the arguments.  Tampering
          with the elements of Container is prohibited during the
          execution of the call on Process.all.  Any exception raised by
          Process.all is propagated.

41/2
          If Element_Type is unconstrained and definite, then the actual
          Element parameter of Process.all shall be unconstrained.

41.1/3
     type Constant_Reference_Type
           (Element : not null access constant Element_Type) is private
        with Implicit_Dereference => Element;

41.2/3
     type Reference_Type (Element : not null access Element_Type) is private
        with Implicit_Dereference => Element;

41.3/3
          The types Constant_Reference_Type and Reference_Type need
          finalization.

41.4/3
          The default initialization of an object of type
          Constant_Reference_Type or Reference_Type propagates
          Program_Error.

41.5/3
     function Constant_Reference (Container : aliased in Map;
                                  Position  : in Cursor)
        return Constant_Reference_Type;

41.6/3
          This function (combined with the Constant_Indexing and
          Implicit_Dereference aspects) provides a convenient way to
          gain read access to an individual element of a map given a
          cursor.

41.7/3
          If Position equals No_Element, then Constraint_Error is
          propagated; if Position does not designate an element in
          Container, then Program_Error is propagated.  Otherwise,
          Constant_Reference returns an object whose discriminant is an
          access value that designates the element designated by
          Position.  Tampering with the elements of Container is
          prohibited while the object returned by Constant_Reference
          exists and has not been finalized.

41.8/3
     function Reference (Container : aliased in out Map;
                         Position  : in Cursor)
        return Reference_Type;

41.9/3
          This function (combined with the Variable_Indexing and
          Implicit_Dereference aspects) provides a convenient way to
          gain read and write access to an individual element of a map
          given a cursor.

41.10/3
          If Position equals No_Element, then Constraint_Error is
          propagated; if Position does not designate an element in
          Container, then Program_Error is propagated.  Otherwise,
          Reference returns an object whose discriminant is an access
          value that designates the element designated by Position.
          Tampering with the elements of Container is prohibited while
          the object returned by Reference exists and has not been
          finalized.

41.11/3
     function Constant_Reference (Container : aliased in Map;
                                  Key       : in Key_Type)
        return Constant_Reference_Type;

41.12/3
          This function (combined with the Constant_Indexing and
          Implicit_Dereference aspects) provides a convenient way to
          gain read access to an individual element of a map given a key
          value.

41.13/3
          Equivalent to Constant_Reference (Container, Find (Container,
          Key)).

41.14/3
     function Reference (Container : aliased in out Map;
                         Key       : in Key_Type)
        return Reference_Type;

41.15/3
          This function (combined with the Variable_Indexing and
          Implicit_Dereference aspects) provides a convenient way to
          gain read and write access to an individual element of a map
          given a key value.

41.16/3
          Equivalent to Reference (Container, Find (Container, Key)).

41.17/3
     procedure Assign (Target : in out Map; Source : in Map);

41.18/3
          If Target denotes the same object as Source, the operation has
          no effect.  Otherwise, the key/element pairs of Source are
          copied to Target as for an assignment_statement assigning
          Source to Target.

42/2
     procedure Move (Target : in out Map;
                     Source : in out Map);

43/3
          If Target denotes the same object as Source, then the
          operation has no effect.  Otherwise, the operation is
          equivalent to Assign (Target, Source) followed by Clear
          (Source).

44/2
     procedure Insert (Container : in out Map;
                       Key       : in     Key_Type;
                       New_Item  : in     Element_Type;
                       Position  :    out Cursor;
                       Inserted  :    out Boolean);

45/2
          Insert checks if a node with a key equivalent to Key is
          already present in Container.  If a match is found, Inserted
          is set to False and Position designates the element with the
          matching key.  Otherwise, Insert allocates a new node,
          initializes it to Key and New_Item, and adds it to Container;
          Inserted is set to True and Position designates the
          newly-inserted node.  Any exception raised during allocation
          is propagated and Container is not modified.

46/2
     procedure Insert (Container : in out Map;
                       Key       : in     Key_Type;
                       Position  :    out Cursor;
                       Inserted  :    out Boolean);

47/2
          Insert inserts Key into Container as per the five-parameter
          Insert, with the difference that an element initialized by
          default (see *note 3.3.1::) is inserted.

48/2
     procedure Insert (Container : in out Map;
                       Key       : in     Key_Type;
                       New_Item  : in     Element_Type);

49/2
          Insert inserts Key and New_Item into Container as per the
          five-parameter Insert, with the difference that if a node with
          a key equivalent to Key is already in the map, then
          Constraint_Error is propagated.

50/2
     procedure Include (Container : in out Map;
                        Key       : in     Key_Type;
                        New_Item  : in     Element_Type);

51/2
          Include inserts Key and New_Item into Container as per the
          five-parameter Insert, with the difference that if a node with
          a key equivalent to Key is already in the map, then this
          operation assigns Key and New_Item to the matching node.  Any
          exception raised during assignment is propagated.

52/2
     procedure Replace (Container : in out Map;
                        Key       : in     Key_Type;
                        New_Item  : in     Element_Type);

53/2
          Replace checks if a node with a key equivalent to Key is
          present in Container.  If a match is found, Replace assigns
          Key and New_Item to the matching node; otherwise,
          Constraint_Error is propagated.

54/2
     procedure Exclude (Container : in out Map;
                        Key       : in     Key_Type);

55/2
          Exclude checks if a node with a key equivalent to Key is
          present in Container.  If a match is found, Exclude removes
          the node from the map.

56/2
     procedure Delete (Container : in out Map;
                       Key       : in     Key_Type);

57/2
          Delete checks if a node with a key equivalent to Key is
          present in Container.  If a match is found, Delete removes the
          node from the map; otherwise, Constraint_Error is propagated.

58/2
     procedure Delete (Container : in out Map;
                       Position  : in out Cursor);

59/2
          If Position equals No_Element, then Constraint_Error is
          propagated.  If Position does not designate an element in
          Container, then Program_Error is propagated.  Otherwise,
          Delete removes the node designated by Position from the map.
          Position is set to No_Element on return.

60/2
     function First (Container : Map) return Cursor;

61/2
          If Length (Container) = 0, then First returns No_Element.
          Otherwise, First returns a cursor that designates the first
          node in Container.

62/2
     function Next (Position  : Cursor) return Cursor;

63/2
          Returns a cursor that designates the successor of the node
          designated by Position.  If Position designates the last node,
          then No_Element is returned.  If Position equals No_Element,
          then No_Element is returned.

64/2
     procedure Next (Position  : in out Cursor);

65/2
          Equivalent to Position := Next (Position).

66/2
     function Find (Container : Map;
                    Key       : Key_Type) return Cursor;

67/2
          If Length (Container) equals 0, then Find returns No_Element.
          Otherwise, Find checks if a node with a key equivalent to Key
          is present in Container.  If a match is found, a cursor
          designating the matching node is returned; otherwise,
          No_Element is returned.

68/2
     function Element (Container : Map;
                       Key       : Key_Type) return Element_Type;

69/2
          Equivalent to Element (Find (Container, Key)).

70/2
     function Contains (Container : Map;
                        Key       : Key_Type) return Boolean;

71/2
          Equivalent to Find (Container, Key) /= No_Element.

          <Paragraphs 72 and 73 were moved above.>

74/2
     procedure Iterate
       (Container : in Map;
        Process   : not null access procedure (Position : in Cursor));

75/3
          Iterate calls Process.all with a cursor that designates each
          node in Container, starting with the first node and moving the
          cursor according to the successor relation.  Tampering with
          the cursors of Container is prohibited during the execution of
          a call on Process.all.  Any exception raised by Process.all is
          propagated.

                      _Bounded (Run-Time) Errors_

75.1/3
It is a bounded error for the actual function associated with a generic
formal subprogram, when called as part of an operation of a map package,
to tamper with elements of any map parameter of the operation.  Either
Program_Error is raised, or the operation works as defined on the value
of the map either prior to, or subsequent to, some or all of the
modifications to the map.

75.2/3
It is a bounded error to call any subprogram declared in the visible
part of a map package when the associated container has been finalized.
If the operation takes Container as an in out parameter, then it raises
Constraint_Error or Program_Error.  Otherwise, the operation either
proceeds as it would for an empty container, or it raises
Constraint_Error or Program_Error.

                         _Erroneous Execution_

76/2
A Cursor value is <invalid> if any of the following have occurred since
it was created: 

77/2
   * The map that contains the node it designates has been finalized;

77.1/3
   * The map that contains the node it designates has been used as the
     Target of a call to Assign, or as the target of an
     assignment_statement;

78/2
   * The map that contains the node it designates has been used as the
     Source or Target of a call to Move; or

79/3
   * The node it designates has been removed from the map that
     previously contained the node.

80/2
The result of "=" or Has_Element is unspecified if these functions are
called with an invalid cursor parameter.  Execution is erroneous if any
other subprogram declared in Containers.Hashed_Maps or
Containers.Ordered_Maps is called with an invalid cursor parameter.

80.1/3
Execution is erroneous if the map associated with the result of a call
to Reference or Constant_Reference is finalized before the result object
returned by the call to Reference or Constant_Reference is finalized.

                     _Implementation Requirements_

81/2
No storage associated with a Map object shall be lost upon assignment or
scope exit.

82/3
The execution of an assignment_statement for a map shall have the effect
of copying the elements from the source map object to the target map
object and changing the length of the target object to that of the
source object.

                        _Implementation Advice_

83/2
Move should not copy elements, and should minimize copying of internal
data structures.

84/2
If an exception is propagated from a map operation, no storage should be
lost, nor any elements removed from a map unless specified by the
operation.


File: arm2012.info,  Node: A.18.5,  Next: A.18.6,  Prev: A.18.4,  Up: A.18

A.18.5 The Generic Package Containers.Hashed_Maps
-------------------------------------------------

                          _Static Semantics_

1/2
The generic library package Containers.Hashed_Maps has the following
declaration:

2/3
     with Ada.Iterator_Interfaces;
     generic
        type Key_Type is private;
        type Element_Type is private;
        with function Hash (Key : Key_Type) return Hash_Type;
        with function Equivalent_Keys (Left, Right : Key_Type)
           return Boolean;
        with function "=" (Left, Right : Element_Type)
           return Boolean is <>;
     package Ada.Containers.Hashed_Maps is
        pragma Preelaborate(Hashed_Maps);
        pragma Remote_Types(Hashed_Maps);

3/3
        type Map is tagged private
           with Constant_Indexing => Constant_Reference,
                Variable_Indexing => Reference,
                Default_Iterator  => Iterate,
                Iterator_Element  => Element_Type;
        pragma Preelaborable_Initialization(Map);

4/2
        type Cursor is private;
        pragma Preelaborable_Initialization(Cursor);

5/2
        Empty_Map : constant Map;

6/2
        No_Element : constant Cursor;

6.1/3
        function Has_Element (Position : Cursor) return Boolean;

6.2/3
        package Map_Iterator_Interfaces is new
            Ada.Iterator_Interfaces (Cursor, Has_Element);

7/2
        function "=" (Left, Right : Map) return Boolean;

8/2
        function Capacity (Container : Map) return Count_Type;

9/2
        procedure Reserve_Capacity (Container : in out Map;
                                    Capacity  : in     Count_Type);

10/2
        function Length (Container : Map) return Count_Type;

11/2
        function Is_Empty (Container : Map) return Boolean;

12/2
        procedure Clear (Container : in out Map);

13/2
        function Key (Position : Cursor) return Key_Type;

14/2
        function Element (Position : Cursor) return Element_Type;

15/2
        procedure Replace_Element (Container : in out Map;
                                   Position  : in     Cursor;
                                   New_Item  : in     Element_Type);

16/2
        procedure Query_Element
          (Position : in Cursor;
           Process  : not null access procedure (Key     : in Key_Type;
                                                 Element : in Element_Type));

17/2
        procedure Update_Element
          (Container : in out Map;
           Position  : in     Cursor;
           Process   : not null access procedure
                           (Key     : in     Key_Type;
                            Element : in out Element_Type));

17.1/3
        type Constant_Reference_Type
              (Element : not null access constant Element_Type) is private
           with Implicit_Dereference => Element;

17.2/3
        type Reference_Type (Element : not null access Element_Type) is private
           with Implicit_Dereference => Element;

17.3/3
        function Constant_Reference (Container : aliased in Map;
                                     Position  : in Cursor)
           return Constant_Reference_Type;

17.4/3
        function Reference (Container : aliased in out Map;
                            Position  : in Cursor)
           return Reference_Type;

17.5/3
        function Constant_Reference (Container : aliased in Map;
                                     Key       : in Key_Type)
           return Constant_Reference_Type;

17.6/3
        function Reference (Container : aliased in out Map;
                            Key       : in Key_Type)
           return Reference_Type;

17.7/3
        procedure Assign (Target : in out Map; Source : in Map);

17.8/3
        function Copy (Source : Map; Capacity : Count_Type := 0) return Map;

18/2
        procedure Move (Target : in out Map;
                        Source : in out Map);

19/2
        procedure Insert (Container : in out Map;
                          Key       : in     Key_Type;
                          New_Item  : in     Element_Type;
                          Position  :    out Cursor;
                          Inserted  :    out Boolean);

20/2
        procedure Insert (Container : in out Map;
                          Key       : in     Key_Type;
                          Position  :    out Cursor;
                          Inserted  :    out Boolean);

21/2
        procedure Insert (Container : in out Map;
                          Key       : in     Key_Type;
                          New_Item  : in     Element_Type);

22/2
        procedure Include (Container : in out Map;
                           Key       : in     Key_Type;
                           New_Item  : in     Element_Type);

23/2
        procedure Replace (Container : in out Map;
                           Key       : in     Key_Type;
                           New_Item  : in     Element_Type);

24/2
        procedure Exclude (Container : in out Map;
                           Key       : in     Key_Type);

25/2
        procedure Delete (Container : in out Map;
                          Key       : in     Key_Type);

26/2
        procedure Delete (Container : in out Map;
                          Position  : in out Cursor);

27/2
        function First (Container : Map)
           return Cursor;

28/2
        function Next (Position  : Cursor) return Cursor;

29/2
        procedure Next (Position  : in out Cursor);

30/2
        function Find (Container : Map;
                       Key       : Key_Type)
           return Cursor;

31/2
        function Element (Container : Map;
                          Key       : Key_Type)
           return Element_Type;

32/2
        function Contains (Container : Map;
                           Key       : Key_Type) return Boolean;

33/3
     <This paragraph was deleted.>

34/2
        function Equivalent_Keys (Left, Right : Cursor)
           return Boolean;

35/2
        function Equivalent_Keys (Left  : Cursor;
                                  Right : Key_Type)
           return Boolean;

36/2
        function Equivalent_Keys (Left  : Key_Type;
                                  Right : Cursor)
           return Boolean;

37/2
        procedure Iterate
          (Container : in Map;
           Process   : not null access procedure (Position : in Cursor));

37.1/3
        function Iterate (Container : in Map)
           return Map_Iterator_Interfaces.Forward_Iterator'Class;

38/2
     private

39/2
        ... -- <not specified by the language>

40/2
     end Ada.Containers.Hashed_Maps;

41/2
An object of type Map contains an expandable hash table, which is used
to provide direct access to nodes.  The <capacity> of an object of type
Map is the maximum number of nodes that can be inserted into the hash
table prior to it being automatically expanded.

42/2
Two keys <K1> and <K2> are defined to be <equivalent> if Equivalent_Keys
(<K1>, <K2>) returns True.

43/2
The actual function for the generic formal function Hash is expected to
return the same value each time it is called with a particular key
value.  For any two equivalent key values, the actual for Hash is
expected to return the same value.  If the actual for Hash behaves in
some other manner, the behavior of this package is unspecified.  Which
subprograms of this package call Hash, and how many times they call it,
is unspecified.

44/2
The actual function for the generic formal function Equivalent_Keys on
Key_Type values is expected to return the same value each time it is
called with a particular pair of key values.  It should define an
equivalence relationship, that is, be reflexive, symmetric, and
transitive.  If the actual for Equivalent_Keys behaves in some other
manner, the behavior of this package is unspecified.  Which subprograms
of this package call Equivalent_Keys, and how many times they call it,
is unspecified.

45/2
If the value of a key stored in a node of a map is changed other than by
an operation in this package such that at least one of Hash or
Equivalent_Keys give different results, the behavior of this package is
unspecified.

46/2
Which nodes are the first node and the last node of a map, and which
node is the successor of a given node, are unspecified, other than the
general semantics described in *note A.18.4::.

47/2
     function Capacity (Container : Map) return Count_Type;

48/2
          Returns the capacity of Container.

49/2
     procedure Reserve_Capacity (Container : in out Map;
                                 Capacity  : in     Count_Type);

50/2
          Reserve_Capacity allocates a new hash table such that the
          length of the resulting map can become at least the value
          Capacity without requiring an additional call to
          Reserve_Capacity, and is large enough to hold the current
          length of Container.  Reserve_Capacity then rehashes the nodes
          in Container onto the new hash table.  It replaces the old
          hash table with the new hash table, and then deallocates the
          old hash table.  Any exception raised during allocation is
          propagated and Container is not modified.

51/2
          Reserve_Capacity tampers with the cursors of Container.

52/2
     procedure Clear (Container : in out Map);

53/2
          In addition to the semantics described in *note A.18.4::,
          Clear does not affect the capacity of Container.

53.1/3
     procedure Assign (Target : in out Map; Source : in Map);

53.2/3
          In addition to the semantics described in *note A.18.4::, if
          the length of Source is greater than the capacity of Target,
          Reserve_Capacity (Target, Length (Source)) is called before
          assigning any elements.

53.3/3
     function Copy (Source : Map; Capacity : Count_Type := 0) return Map;

53.4/3
          Returns a map whose keys and elements are initialized from the
          keys and elements of Source.  If Capacity is 0, then the map
          capacity is the length of Source; if Capacity is equal to or
          greater than the length of Source, the map capacity is at
          least the specified value.  Otherwise, the operation
          propagates Capacity_Error.

54/2
     procedure Insert (Container : in out Map;
                       Key       : in     Key_Type;
                       New_Item  : in     Element_Type;
                       Position  :    out Cursor;
                       Inserted  :    out Boolean);

55/2
          In addition to the semantics described in *note A.18.4::, if
          Length (Container) equals Capacity (Container), then Insert
          first calls Reserve_Capacity to increase the capacity of
          Container to some larger value.

56/2
     function Equivalent_Keys (Left, Right : Cursor)
           return Boolean;

57/2
          Equivalent to Equivalent_Keys (Key (Left), Key (Right)).

58/2
     function Equivalent_Keys (Left  : Cursor;
                               Right : Key_Type) return Boolean;

59/2
          Equivalent to Equivalent_Keys (Key (Left), Right).

60/2
     function Equivalent_Keys (Left  : Key_Type;
                               Right : Cursor) return Boolean;

61/2
          Equivalent to Equivalent_Keys (Left, Key (Right)).

61.1/3
     function Iterate (Container : in Map)
        return Map_Iterator_Interfaces.Forward_Iterator'Class;

61.2/3
          Iterate returns an iterator object (see *note 5.5.1::) that
          will generate a value for a loop parameter (see *note 5.5.2::)
          designating each node in Container, starting with the first
          node and moving the cursor according to the successor
          relation.  Tampering with the cursors of Container is
          prohibited while the iterator object exists (in particular, in
          the sequence_of_statements of the loop_statement whose
          iterator_specification denotes this object).  The iterator
          object needs finalization.

                        _Implementation Advice_

62/2
If <N> is the length of a map, the average time complexity of the
subprograms Element, Insert, Include, Replace, Delete, Exclude and Find
that take a key parameter should be <O>(log <N>).  The average time
complexity of the subprograms that take a cursor parameter should be
<O>(1).  The average time complexity of Reserve_Capacity should be
<O>(<N>).


File: arm2012.info,  Node: A.18.6,  Next: A.18.7,  Prev: A.18.5,  Up: A.18

A.18.6 The Generic Package Containers.Ordered_Maps
--------------------------------------------------

                          _Static Semantics_

1/2
The generic library package Containers.Ordered_Maps has the following
declaration:

2/3
     with Ada.Iterator_Interfaces;
     generic
        type Key_Type is private;
        type Element_Type is private;
        with function "<" (Left, Right : Key_Type) return Boolean is <>;
        with function "=" (Left, Right : Element_Type) return Boolean is <>;
     package Ada.Containers.Ordered_Maps is
        pragma Preelaborate(Ordered_Maps);
        pragma Remote_Types(Ordered_Maps);

3/2
        function Equivalent_Keys (Left, Right : Key_Type) return Boolean;

4/3
        type Map is tagged private
           with Constant_Indexing => Constant_Reference,
                Variable_Indexing => Reference,
                Default_Iterator  => Iterate,
                Iterator_Element  => Element_Type;
        pragma Preelaborable_Initialization(Map);

5/2
        type Cursor is private;
        pragma Preelaborable_Initialization(Cursor);

6/2
        Empty_Map : constant Map;

7/2
        No_Element : constant Cursor;

7.1/3
        function Has_Element (Position : Cursor) return Boolean;

7.2/3
        package Map_Iterator_Interfaces is new
            Ada.Iterator_Interfaces (Cursor, Has_Element);

8/2
        function "=" (Left, Right : Map) return Boolean;

9/2
        function Length (Container : Map) return Count_Type;

10/2
        function Is_Empty (Container : Map) return Boolean;

11/2
        procedure Clear (Container : in out Map);

12/2
        function Key (Position : Cursor) return Key_Type;

13/2
        function Element (Position : Cursor) return Element_Type;

14/2
        procedure Replace_Element (Container : in out Map;
                                   Position  : in     Cursor;
                                   New_Item  : in     Element_Type);

15/2
        procedure Query_Element
          (Position : in Cursor;
           Process  : not null access procedure (Key     : in Key_Type;
                                                 Element : in Element_Type));

16/2
        procedure Update_Element
          (Container : in out Map;
           Position  : in     Cursor;
           Process   : not null access procedure
                           (Key     : in     Key_Type;
                            Element : in out Element_Type));

16.1/3
        type Constant_Reference_Type
              (Element : not null access constant Element_Type) is private
           with Implicit_Dereference => Element;

16.2/3
        type Reference_Type (Element : not null access Element_Type) is private
           with Implicit_Dereference => Element;

16.3/3
        function Constant_Reference (Container : aliased in Map;
                                     Position  : in Cursor)
           return Constant_Reference_Type;

16.4/3
        function Reference (Container : aliased in out Map;
                            Position  : in Cursor)
           return Reference_Type;

16.5/3
        function Constant_Reference (Container : aliased in Map;
                                     Key       : in Key_Type)
           return Constant_Reference_Type;

16.6/3
        function Reference (Container : aliased in out Map;
                            Key       : in Key_Type)
           return Reference_Type;

16.7/3
        procedure Assign (Target : in out Map; Source : in Map);

16.8/3
        function Copy (Source : Map) return Map;

17/2
        procedure Move (Target : in out Map;
                        Source : in out Map);

18/2
        procedure Insert (Container : in out Map;
                          Key       : in     Key_Type;
                          New_Item  : in     Element_Type;
                          Position  :    out Cursor;
                          Inserted  :    out Boolean);

19/2
        procedure Insert (Container : in out Map;
                          Key       : in     Key_Type;
                          Position  :    out Cursor;
                          Inserted  :    out Boolean);

20/2
        procedure Insert (Container : in out Map;
                          Key       : in     Key_Type;
                          New_Item  : in     Element_Type);

21/2
        procedure Include (Container : in out Map;
                           Key       : in     Key_Type;
                           New_Item  : in     Element_Type);

22/2
        procedure Replace (Container : in out Map;
                           Key       : in     Key_Type;
                           New_Item  : in     Element_Type);

23/2
        procedure Exclude (Container : in out Map;
                           Key       : in     Key_Type);

24/2
        procedure Delete (Container : in out Map;
                          Key       : in     Key_Type);

25/2
        procedure Delete (Container : in out Map;
                          Position  : in out Cursor);

26/2
        procedure Delete_First (Container : in out Map);

27/2
        procedure Delete_Last (Container : in out Map);

28/2
        function First (Container : Map) return Cursor;

29/2
        function First_Element (Container : Map) return Element_Type;

30/2
        function First_Key (Container : Map) return Key_Type;

31/2
        function Last (Container : Map) return Cursor;

32/2
        function Last_Element (Container : Map) return Element_Type;

33/2
        function Last_Key (Container : Map) return Key_Type;

34/2
        function Next (Position : Cursor) return Cursor;

35/2
        procedure Next (Position : in out Cursor);

36/2
        function Previous (Position : Cursor) return Cursor;

37/2
        procedure Previous (Position : in out Cursor);

38/2
        function Find (Container : Map;
                       Key       : Key_Type) return Cursor;

39/2
        function Element (Container : Map;
                          Key       : Key_Type) return Element_Type;

40/2
        function Floor (Container : Map;
                        Key       : Key_Type) return Cursor;

41/2
        function Ceiling (Container : Map;
                          Key       : Key_Type) return Cursor;

42/2
        function Contains (Container : Map;
                           Key       : Key_Type) return Boolean;

43/3
     <This paragraph was deleted.>

44/2
        function "<" (Left, Right : Cursor) return Boolean;

45/2
        function ">" (Left, Right : Cursor) return Boolean;

46/2
        function "<" (Left : Cursor; Right : Key_Type) return Boolean;

47/2
        function ">" (Left : Cursor; Right : Key_Type) return Boolean;

48/2
        function "<" (Left : Key_Type; Right : Cursor) return Boolean;

49/2
        function ">" (Left : Key_Type; Right : Cursor) return Boolean;

50/2
        procedure Iterate
          (Container : in Map;
           Process   : not null access procedure (Position : in Cursor));

51/2
        procedure Reverse_Iterate
          (Container : in Map;
           Process   : not null access procedure (Position : in Cursor));

51.1/3
        function Iterate (Container : in Map)
           return Map_Iterator_Interfaces.Reversible_Iterator'Class;

51.2/3
        function Iterate (Container : in Map; Start : in Cursor)
           return Map_Iterator_Interfaces.Reversible_Iterator'Class;

52/2
     private

53/2
        ... -- <not specified by the language>

54/2
     end Ada.Containers.Ordered_Maps;

55/2
Two keys <K1> and <K2> are <equivalent> if both <K1> < <K2> and <K2> <
<K1> return False, using the generic formal "<" operator for keys.
Function Equivalent_Keys returns True if Left and Right are equivalent,
and False otherwise.

56/3
The actual function for the generic formal function "<" on Key_Type
values is expected to return the same value each time it is called with
a particular pair of key values.  It should define a strict weak
ordering relationship (see *note A.18::).  If the actual for "<" behaves
in some other manner, the behavior of this package is unspecified.
Which subprograms of this package call "<" and how many times they call
it, is unspecified.

57/2
If the value of a key stored in a map is changed other than by an
operation in this package such that at least one of "<" or "=" give
different results, the behavior of this package is unspecified.

58/3
The <first node> of a nonempty map is the one whose key is less than the
key of all the other nodes in the map.  The <last node> of a nonempty
map is the one whose key is greater than the key of all the other
elements in the map.  The <successor> of a node is the node with the
smallest key that is larger than the key of the given node.  The
<predecessor> of a node is the node with the largest key that is smaller
than the key of the given node.  All comparisons are done using the
generic formal "<" operator for keys.

58.1/3
     function Copy (Source : Map) return Map;

58.2/3
          Returns a map whose keys and elements are initialized from the
          corresponding keys and elements of Source.

59/2
     procedure Delete_First (Container : in out Map);

60/3
          If Container is empty, Delete_First has no effect.  Otherwise,
          the node designated by First (Container) is removed from
          Container.  Delete_First tampers with the cursors of
          Container.

61/2
     procedure Delete_Last (Container : in out Map);

62/3
          If Container is empty, Delete_Last has no effect.  Otherwise,
          the node designated by Last (Container) is removed from
          Container.  Delete_Last tampers with the cursors of Container.

63/2
     function First_Element (Container : Map) return Element_Type;

64/2
          Equivalent to Element (First (Container)).

65/2
     function First_Key (Container : Map) return Key_Type;

66/2
          Equivalent to Key (First (Container)).

67/2
     function Last (Container : Map) return Cursor;

68/2
          Returns a cursor that designates the last node in Container.
          If Container is empty, returns No_Element.

69/2
     function Last_Element (Container : Map) return Element_Type;

70/2
          Equivalent to Element (Last (Container)).

71/2
     function Last_Key (Container : Map) return Key_Type;

72/2
          Equivalent to Key (Last (Container)).

73/2
     function Previous (Position : Cursor) return Cursor;

74/3
          If Position equals No_Element, then Previous returns
          No_Element.  Otherwise, Previous returns a cursor designating
          the predecessor node of the one designated by Position.  If
          Position designates the first element, then Previous returns
          No_Element.

75/2
     procedure Previous (Position : in out Cursor);

76/2
          Equivalent to Position := Previous (Position).

77/2
     function Floor (Container : Map;
                     Key       : Key_Type) return Cursor;

78/3
          Floor searches for the last node whose key is not greater than
          Key, using the generic formal "<" operator for keys.  If such
          a node is found, a cursor that designates it is returned.
          Otherwise, No_Element is returned.

79/2
     function Ceiling (Container : Map;
                       Key       : Key_Type) return Cursor;

80/3
          Ceiling searches for the first node whose key is not less than
          Key, using the generic formal "<" operator for keys.  If such
          a node is found, a cursor that designates it is returned.
          Otherwise, No_Element is returned.

81/2
     function "<" (Left, Right : Cursor) return Boolean;

82/2
          Equivalent to Key (Left) < Key (Right).

83/2
     function ">" (Left, Right : Cursor) return Boolean;

84/2
          Equivalent to Key (Right) < Key (Left).

85/2
     function "<" (Left : Cursor; Right : Key_Type) return Boolean;

86/2
          Equivalent to Key (Left) < Right.

87/2
     function ">" (Left : Cursor; Right : Key_Type) return Boolean;

88/2
          Equivalent to Right < Key (Left).

89/2
     function "<" (Left : Key_Type; Right : Cursor) return Boolean;

90/2
          Equivalent to Left < Key (Right).

91/2
     function ">" (Left : Key_Type; Right : Cursor) return Boolean;

92/2
          Equivalent to Key (Right) < Left.

93/2
     procedure Reverse_Iterate
       (Container : in Map;
        Process   : not null access procedure (Position : in Cursor));

94/3
          Iterates over the nodes in Container as per procedure Iterate,
          with the difference that the nodes are traversed in
          predecessor order, starting with the last node.

94.1/3
     function Iterate (Container : in Map)
        return Map_Iterator_Interfaces.Reversible_Iterator'Class;

94.2/3
          Iterate returns a reversible iterator object (see *note
          5.5.1::) that will generate a value for a loop parameter (see
          *note 5.5.2::) designating each node in Container, starting
          with the first node and moving the cursor according to the
          successor relation when used as a forward iterator, and
          starting with the last node and moving the cursor according to
          the predecessor relation when used as a reverse iterator.
          Tampering with the cursors of Container is prohibited while
          the iterator object exists (in particular, in the
          sequence_of_statements of the loop_statement whose
          iterator_specification denotes this object).  The iterator
          object needs finalization.

94.3/3
     function Iterate (Container : in Map; Start : in Cursor)
        return Map_Iterator_Interfaces.Reversible_Iterator'Class;

94.4/3
          If Start is not No_Element and does not designate an item in
          Container, then Program_Error is propagated.  If Start is
          No_Element, then Constraint_Error is propagated.  Otherwise,
          Iterate returns a reversible iterator object (see *note
          5.5.1::) that will generate a value for a loop parameter (see
          *note 5.5.2::) designating each node in Container, starting
          with the node designated by Start and moving the cursor
          according to the successor relation when used as a forward
          iterator, or moving the cursor according to the predecessor
          relation when used as a reverse iterator.  Tampering with the
          cursors of Container is prohibited while the iterator object
          exists (in particular, in the sequence_of_statements of the
          loop_statement whose iterator_specification denotes this
          object).  The iterator object needs finalization.

                        _Implementation Advice_

95/2
If <N> is the length of a map, then the worst-case time complexity of
the Element, Insert, Include, Replace, Delete, Exclude and Find
operations that take a key parameter should be <O>((log <N>)**2) or
better.  The worst-case time complexity of the subprograms that take a
cursor parameter should be <O>(1).


File: arm2012.info,  Node: A.18.7,  Next: A.18.8,  Prev: A.18.6,  Up: A.18

A.18.7 Sets
-----------

1/2
The language-defined generic packages Containers.Hashed_Sets and
Containers.Ordered_Sets provide private types Set and Cursor, and a set
of operations for each type.  A set container allows elements of an
arbitrary type to be stored without duplication.  A hashed set uses a
hash function to organize elements, while an ordered set orders its
element per a specified relation.  

2/3
This subclause describes the declarations that are common to both kinds
of sets.  See *note A.18.8:: for a description of the semantics specific
to Containers.Hashed_Sets and *note A.18.9:: for a description of the
semantics specific to Containers.Ordered_Sets.

                          _Static Semantics_

3/2
The actual function for the generic formal function "=" on Element_Type
values is expected to define a reflexive and symmetric relationship and
return the same result value each time it is called with a particular
pair of values.  If it behaves in some other manner, the function "=" on
set values returns an unspecified value.  The exact arguments and number
of calls of this generic formal function by the function "=" on set
values are unspecified.

4/2
The type Set is used to represent sets.  The type Set needs finalization
(see *note 7.6::).

5/2
A set contains elements.  Set cursors designate elements.  There exists
an equivalence relation on elements, whose definition is different for
hashed sets and ordered sets.  A set never contains two or more
equivalent elements.  The <length> of a set is the number of elements it
contains.

6/2
Each nonempty set has two particular elements called the <first element>
and the <last element> (which may be the same).  Each element except for
the last element has a <successor element>.  If there are no other
intervening operations, starting with the first element and repeatedly
going to the successor element will visit each element in the set
exactly once until the last element is reached.  The exact definition of
these terms is different for hashed sets and ordered sets.

7/2
Some operations of these generic packages have access-to-subprogram
parameters.  To ensure such operations are well-defined, they guard
against certain actions by the designated subprogram.  In particular,
some operations check for "tampering with cursors" of a container
because they depend on the set of elements of the container remaining
constant, and others check for "tampering with elements" of a container
because they depend on elements of the container not being replaced.

8/2
A subprogram is said to <tamper with cursors> of a set object <S> if:

9/2
   * it inserts or deletes elements of <S>, that is, it calls the
     Insert, Include, Clear, Delete, Exclude, or Replace_Element
     procedures with <S> as a parameter; or

10/2
   * it finalizes <S>; or

10.1/3
   * it calls the Assign procedure with <S> as the Target parameter; or

11/2
   * it calls the Move procedure with <S> as a parameter; or

12/2
   * it calls one of the operations defined to tamper with cursors of
     <S>.

13/2
A subprogram is said to <tamper with elements> of a set object <S> if:

14/2
   * it tampers with cursors of <S>.

14.1/4
When tampering with cursors is <prohibited> for a particular set object
<S>, Program_Error is propagated by a call of any language-defined
subprogram that is defined to tamper with the cursors of <S>, leaving
<S> unmodified.  Similarly, when tampering with elements is <prohibited>
for a particular set object <S>, Program_Error is propagated by a call
of any language-defined subprogram that is defined to tamper with the
elements of <S> (or tamper with the cursors of <S>), leaving <S>
unmodified.  These checks are made before any other defined behavior of
the body of the language-defined subprogram.

15/2
Empty_Set represents the empty Set object.  It has a length of 0.  If an
object of type Set is not otherwise initialized, it is initialized to
the same value as Empty_Set.

16/2
No_Element represents a cursor that designates no element.  If an object
of type Cursor is not otherwise initialized, it is initialized to the
same value as No_Element.

17/2
The predefined "=" operator for type Cursor returns True if both cursors
are No_Element, or designate the same element in the same container.

18/2
Execution of the default implementation of the Input, Output, Read, or
Write attribute of type Cursor raises Program_Error.

18.1/3
Set'Write for a Set object <S> writes Length(<S>) elements of the set to
the stream.  It also may write additional information about the set.

18.2/3
Set'Read reads the representation of a set from the stream, and assigns
to <Item> a set with the same length and elements as was written by
Set'Write.

18.3/3
     function Has_Element (Position : Cursor) return Boolean;

18.4/3
          Returns True if Position designates an element, and returns
          False otherwise.

19/2
     function "=" (Left, Right : Set) return Boolean;

20/2
          If Left and Right denote the same set object, then the
          function returns True.  If Left and Right have different
          lengths, then the function returns False.  Otherwise, for each
          element <E> in Left, the function returns False if an element
          equal to <E> (using the generic formal equality operator) is
          not present in Right.  If the function has not returned a
          result after checking all of the elements, it returns True.
          Any exception raised during evaluation of element equality is
          propagated.

21/2
     function Equivalent_Sets (Left, Right : Set) return Boolean;

22/2
          If Left and Right denote the same set object, then the
          function returns True.  If Left and Right have different
          lengths, then the function returns False.  Otherwise, for each
          element <E> in Left, the function returns False if an element
          equivalent to <E> is not present in Right.  If the function
          has not returned a result after checking all of the elements,
          it returns True.  Any exception raised during evaluation of
          element equivalence is propagated.

23/2
     function To_Set (New_Item : Element_Type) return Set;

24/2
          Returns a set containing the single element New_Item.

25/2
     function Length (Container : Set) return Count_Type;

26/2
          Returns the number of elements in Container.

27/2
     function Is_Empty (Container : Set) return Boolean;

28/2
          Equivalent to Length (Container) = 0.

29/2
     procedure Clear (Container : in out Set);

30/2
          Removes all the elements from Container.

31/2
     function Element (Position : Cursor) return Element_Type;

32/2
          If Position equals No_Element, then Constraint_Error is
          propagated.  Otherwise, Element returns the element designated
          by Position.

33/2
     procedure Replace_Element (Container : in out Set;
                                Position  : in     Cursor;
                                New_Item  : in     Element_Type);

34/2
          If Position equals No_Element, then Constraint_Error is
          propagated; if Position does not designate an element in
          Container, then Program_Error is propagated.  If an element
          equivalent to New_Item is already present in Container at a
          position other than Position, Program_Error is propagated.
          Otherwise, Replace_Element assigns New_Item to the element
          designated by Position.  Any exception raised by the
          assignment is propagated.

35/2
     procedure Query_Element
       (Position : in Cursor;
        Process  : not null access procedure (Element : in Element_Type));

36/3
          If Position equals No_Element, then Constraint_Error is
          propagated.  Otherwise, Query_Element calls Process.all with
          the element designated by Position as the argument.  Tampering
          with the elements of the set that contains the element
          designated by Position is prohibited during the execution of
          the call on Process.all.  Any exception raised by Process.all
          is propagated.

36.1/3
     type Constant_Reference_Type
           (Element : not null access constant Element_Type) is private
        with Implicit_Dereference => Element;

36.2/3
          The type Constant_Reference_Type needs finalization.

36.3/3
          The default initialization of an object of type
          Constant_Reference_Type propagates Program_Error.

36.4/3
     function Constant_Reference (Container : aliased in Set;
                                  Position  : in Cursor)
        return Constant_Reference_Type;

36.5/3
          This function (combined with the Constant_Indexing and
          Implicit_Dereference aspects) provides a convenient way to
          gain read access to an individual element of a set given a
          cursor.

36.6/3
          If Position equals No_Element, then Constraint_Error is
          propagated; if Position does not designate an element in
          Container, then Program_Error is propagated.  Otherwise,
          Constant_Reference returns an object whose discriminant is an
          access value that designates the element designated by
          Position.  Tampering with the elements of Container is
          prohibited while the object returned by Constant_Reference
          exists and has not been finalized.

36.7/3
     procedure Assign (Target : in out Set; Source : in Set);

36.8/3
          If Target denotes the same object as Source, the operation has
          no effect.  Otherwise, the elements of Source are copied to
          Target as for an assignment_statement assigning Source to
          Target.

37/2
     procedure Move (Target : in out Set;
                     Source : in out Set);

38/3
          If Target denotes the same object as Source, then the
          operation has no effect.  Otherwise, the operation is
          equivalent to Assign (Target, Source) followed by Clear
          (Source).

39/2
     procedure Insert (Container : in out Set;
                       New_Item  : in     Element_Type;
                       Position  :    out Cursor;
                       Inserted  :    out Boolean);

40/2
          Insert checks if an element equivalent to New_Item is already
          present in Container.  If a match is found, Inserted is set to
          False and Position designates the matching element.
          Otherwise, Insert adds New_Item to Container; Inserted is set
          to True and Position designates the newly-inserted element.
          Any exception raised during allocation is propagated and
          Container is not modified.

41/2
     procedure Insert (Container : in out Set;
                       New_Item  : in     Element_Type);

42/2
          Insert inserts New_Item into Container as per the
          four-parameter Insert, with the difference that if an element
          equivalent to New_Item is already in the set, then
          Constraint_Error is propagated.

43/2
     procedure Include (Container : in out Set;
                        New_Item  : in     Element_Type);

44/2
          Include inserts New_Item into Container as per the
          four-parameter Insert, with the difference that if an element
          equivalent to New_Item is already in the set, then it is
          replaced.  Any exception raised during assignment is
          propagated.

45/2
     procedure Replace (Container : in out Set;
                        New_Item  : in     Element_Type);

46/2
          Replace checks if an element equivalent to New_Item is already
          in the set.  If a match is found, that element is replaced
          with New_Item; otherwise, Constraint_Error is propagated.

47/2
     procedure Exclude (Container : in out Set;
                        Item      : in     Element_Type);

48/2
          Exclude checks if an element equivalent to Item is present in
          Container.  If a match is found, Exclude removes the element
          from the set.

49/2
     procedure Delete (Container : in out Set;
                       Item      : in     Element_Type);

50/2
          Delete checks if an element equivalent to Item is present in
          Container.  If a match is found, Delete removes the element
          from the set; otherwise, Constraint_Error is propagated.

51/2
     procedure Delete (Container : in out Set;
                       Position  : in out Cursor);

52/2
          If Position equals No_Element, then Constraint_Error is
          propagated.  If Position does not designate an element in
          Container, then Program_Error is propagated.  Otherwise,
          Delete removes the element designated by Position from the
          set.  Position is set to No_Element on return.

53/2
     procedure Union (Target : in out Set;
                      Source : in     Set);

54/2
          Union inserts into Target the elements of Source that are not
          equivalent to some element already in Target.

55/2
     function Union (Left, Right : Set) return Set;

56/2
          Returns a set comprising all of the elements of Left, and the
          elements of Right that are not equivalent to some element of
          Left.

57/2
     procedure Intersection (Target : in out Set;
                             Source : in     Set);

58/3
          Intersection deletes from Target the elements of Target that
          are not equivalent to some element of Source.

59/2
     function Intersection (Left, Right : Set) return Set;

60/2
          Returns a set comprising all the elements of Left that are
          equivalent to the some element of Right.

61/2
     procedure Difference (Target : in out Set;
                           Source : in     Set);

62/2
          If Target denotes the same object as Source, then Difference
          clears Target.  Otherwise, it deletes from Target the elements
          that are equivalent to some element of Source.

63/2
     function Difference (Left, Right : Set) return Set;

64/2
          Returns a set comprising the elements of Left that are not
          equivalent to some element of Right.

65/2
     procedure Symmetric_Difference (Target : in out Set;
                                     Source : in     Set);

66/2
          If Target denotes the same object as Source, then
          Symmetric_Difference clears Target.  Otherwise, it deletes
          from Target the elements that are equivalent to some element
          of Source, and inserts into Target the elements of Source that
          are not equivalent to some element of Target.

67/2
     function Symmetric_Difference (Left, Right : Set) return Set;

68/2
          Returns a set comprising the elements of Left that are not
          equivalent to some element of Right, and the elements of Right
          that are not equivalent to some element of Left.

69/2
     function Overlap (Left, Right : Set) return Boolean;

70/3
          If an element of Left is equivalent to some element of Right,
          then Overlap returns True.  Otherwise, it returns False.

71/2
     function Is_Subset (Subset : Set;
                         Of_Set : Set) return Boolean;

72/3
          If an element of Subset is not equivalent to some element of
          Of_Set, then Is_Subset returns False.  Otherwise, it returns
          True.

73/2
     function First (Container : Set) return Cursor;

74/2
          If Length (Container) = 0, then First returns No_Element.
          Otherwise, First returns a cursor that designates the first
          element in Container.

75/2
     function Next (Position  : Cursor) return Cursor;

76/2
          Returns a cursor that designates the successor of the element
          designated by Position.  If Position designates the last
          element, then No_Element is returned.  If Position equals
          No_Element, then No_Element is returned.

77/2
     procedure Next (Position  : in out Cursor);

78/2
          Equivalent to Position := Next (Position).

79/3
          <This paragraph was deleted.>

80/2
     function Find (Container : Set;
                    Item      : Element_Type) return Cursor;

81/2
          If Length (Container) equals 0, then Find returns No_Element.
          Otherwise, Find checks if an element equivalent to Item is
          present in Container.  If a match is found, a cursor
          designating the matching element is returned; otherwise,
          No_Element is returned.

82/2
     function Contains (Container : Set;
                        Item      : Element_Type) return Boolean;

82.1/3
          Equivalent to Find (Container, Item) /= No_Element.

          <Paragraphs 83 and 84 were moved above.>

85/2
     procedure Iterate
       (Container : in Set;
        Process   : not null access procedure (Position : in Cursor));

86/3
          Iterate calls Process.all with a cursor that designates each
          element in Container, starting with the first element and
          moving the cursor according to the successor relation.
          Tampering with the cursors of Container is prohibited during
          the execution of a call on Process.all.  Any exception raised
          by Process.all is propagated.

87/2
Both Containers.Hashed_Set and Containers.Ordered_Set declare a nested
generic package Generic_Keys, which provides operations that allow set
manipulation in terms of a key (typically, a portion of an element)
instead of a complete element.  The formal function Key of Generic_Keys
extracts a key value from an element.  It is expected to return the same
value each time it is called with a particular element.  The behavior of
Generic_Keys is unspecified if Key behaves in some other manner.

88/2
A key is expected to unambiguously determine a single equivalence class
for elements.  The behavior of Generic_Keys is unspecified if the formal
parameters of this package behave in some other manner.

89/2
     function Key (Position : Cursor) return Key_Type;

90/2
          Equivalent to Key (Element (Position)).

91/2
The subprograms in package Generic_Keys named Contains, Find, Element,
Delete, and Exclude, are equivalent to the corresponding subprograms in
the parent package, with the difference that the Key parameter is used
to locate an element in the set.

92/2
     procedure Replace (Container : in out Set;
                        Key       : in     Key_Type;
                        New_Item  : in     Element_Type);

93/2
          Equivalent to Replace_Element (Container, Find (Container,
          Key), New_Item).

94/2
     procedure Update_Element_Preserving_Key
       (Container : in out Set;
        Position  : in     Cursor;
        Process   : not null access procedure
                                      (Element : in out Element_Type));

95/3
          If Position equals No_Element, then Constraint_Error is
          propagated; if Position does not designate an element in
          Container, then Program_Error is propagated.  Otherwise,
          Update_Element_Preserving_Key uses Key to save the key value
          <K> of the element designated by Position.
          Update_Element_Preserving_Key then calls Process.all with that
          element as the argument.  Tampering with the elements of
          Container is prohibited during the execution of the call on
          Process.all.  Any exception raised by Process.all is
          propagated.  After Process.all returns,
          Update_Element_Preserving_Key checks if <K> determines the
          same equivalence class as that for the new element; if not,
          the element is removed from the set and Program_Error is
          propagated.

96/2
          If Element_Type is unconstrained and definite, then the actual
          Element parameter of Process.all shall be unconstrained.

96.1/3
     type Reference_Type (Element : not null access Element_Type) is private
        with Implicit_Dereference => Element;

96.2/3
          The type Reference_Type needs finalization.

96.3/3
          The default initialization of an object of type Reference_Type
          propagates Program_Error.

96.4/3
     function Reference_Preserving_Key (Container : aliased in out Set;
                                        Position  : in Cursor)
        return Reference_Type;

96.5/3
          This function (combined with the Implicit_Dereference aspect)
          provides a convenient way to gain read and write access to an
          individual element of a set given a cursor.

96.6/3
          If Position equals No_Element, then Constraint_Error is
          propagated; if Position does not designate an element in
          Container, then Program_Error is propagated.  Otherwise,
          Reference_Preserving_Key uses Key to save the key value <K>;
          then returns an object whose discriminant is an access value
          that designates the element designated by Position.  Tampering
          with the elements of Container is prohibited while the object
          returned by Reference_Preserving_Key exists and has not been
          finalized.  When the object returned by
          Reference_Preserving_Key is finalized, a check is made if <K>
          determines the same equivalence class as that for the new
          element; if not, the element is removed from the set and
          Program_Error is propagated.

96.7/3
     function Constant_Reference (Container : aliased in Set;
                                  Key       : in Key_Type)
        return Constant_Reference_Type;

96.8/3
          This function (combined with the Implicit_Dereference aspect)
          provides a convenient way to gain read access to an individual
          element of a set given a key value.

96.9/3
          Equivalent to Constant_Reference (Container, Find (Container,
          Key)).

96.10/3
     function Reference_Preserving_Key (Container : aliased in out Set;
                                        Key       : in Key_Type)
        return Reference_Type;

96.11/3
          This function (combined with the Implicit_Dereference aspect)
          provides a convenient way to gain read and write access to an
          individual element of a set given a key value.

96.12/3
          Equivalent to Reference_Preserving_Key (Container, Find
          (Container, Key)).

                      _Bounded (Run-Time) Errors_

96.13/3
It is a bounded error for the actual function associated with a generic
formal subprogram, when called as part of an operation of a set package,
to tamper with elements of any set parameter of the operation.  Either
Program_Error is raised, or the operation works as defined on the value
of the set either prior to, or subsequent to, some or all of the
modifications to the set.

96.14/3
It is a bounded error to call any subprogram declared in the visible
part of a set package when the associated container has been finalized.
If the operation takes Container as an in out parameter, then it raises
Constraint_Error or Program_Error.  Otherwise, the operation either
proceeds as it would for an empty container, or it raises
Constraint_Error or Program_Error.

                         _Erroneous Execution_

97/2
A Cursor value is <invalid> if any of the following have occurred since
it was created: 

98/2
   * The set that contains the element it designates has been finalized;

98.1/3
   * The set that contains the element it designates has been used as
     the Target of a call to Assign, or as the target of an
     assignment_statement;

99/2
   * The set that contains the element it designates has been used as
     the Source or Target of a call to Move; or

100/3
   * The element it designates has been removed from the set that
     previously contained the element.

101/2
The result of "=" or Has_Element is unspecified if these functions are
called with an invalid cursor parameter.  Execution is erroneous if any
other subprogram declared in Containers.Hashed_Sets or
Containers.Ordered_Sets is called with an invalid cursor parameter.

101.1/3
Execution is erroneous if the set associated with the result of a call
to Reference or Constant_Reference is finalized before the result object
returned by the call to Reference or Constant_Reference is finalized.

                     _Implementation Requirements_

102/2
No storage associated with a Set object shall be lost upon assignment or
scope exit.

103/3
The execution of an assignment_statement for a set shall have the effect
of copying the elements from the source set object to the target set
object and changing the length of the target object to that of the
source object.

                        _Implementation Advice_

104/2
Move should not copy elements, and should minimize copying of internal
data structures.

105/2
If an exception is propagated from a set operation, no storage should be
lost, nor any elements removed from a set unless specified by the
operation.


File: arm2012.info,  Node: A.18.8,  Next: A.18.9,  Prev: A.18.7,  Up: A.18

A.18.8 The Generic Package Containers.Hashed_Sets
-------------------------------------------------

                          _Static Semantics_

1/2
The generic library package Containers.Hashed_Sets has the following
declaration:

2/3
     with Ada.Iterator_Interfaces;
     generic
        type Element_Type is private;
        with function Hash (Element : Element_Type) return Hash_Type;
        with function Equivalent_Elements (Left, Right : Element_Type)
                      return Boolean;
        with function "=" (Left, Right : Element_Type) return Boolean is <>;
     package Ada.Containers.Hashed_Sets is
        pragma Preelaborate(Hashed_Sets);
        pragma Remote_Types(Hashed_Sets);

3/3
        type Set is tagged private
           with Constant_Indexing => Constant_Reference,
                Default_Iterator  => Iterate,
                Iterator_Element  => Element_Type;
        pragma Preelaborable_Initialization(Set);

4/2
        type Cursor is private;
        pragma Preelaborable_Initialization(Cursor);

5/2
        Empty_Set : constant Set;

6/2
        No_Element : constant Cursor;

6.1/3
        function Has_Element (Position : Cursor) return Boolean;

6.2/3
        package Set_Iterator_Interfaces is new
            Ada.Iterator_Interfaces (Cursor, Has_Element);

7/2
        function "=" (Left, Right : Set) return Boolean;

8/2
        function Equivalent_Sets (Left, Right : Set) return Boolean;

9/2
        function To_Set (New_Item : Element_Type) return Set;

10/2
        function Capacity (Container : Set) return Count_Type;

11/2
        procedure Reserve_Capacity (Container : in out Set;
                                    Capacity  : in     Count_Type);

12/2
        function Length (Container : Set) return Count_Type;

13/2
        function Is_Empty (Container : Set) return Boolean;

14/2
        procedure Clear (Container : in out Set);

15/2
        function Element (Position : Cursor) return Element_Type;

16/2
        procedure Replace_Element (Container : in out Set;
                                   Position  : in     Cursor;
                                   New_Item  : in     Element_Type);

17/2
        procedure Query_Element
          (Position : in Cursor;
           Process  : not null access procedure (Element : in Element_Type));

17.1/3
        type Constant_Reference_Type
              (Element : not null access constant Element_Type) is private
           with Implicit_Dereference => Element;

17.2/3
        function Constant_Reference (Container : aliased in Set;
                                     Position  : in Cursor)
           return Constant_Reference_Type;

17.3/3
        procedure Assign (Target : in out Set; Source : in Set);

17.4/3
        function Copy (Source : Set; Capacity : Count_Type := 0) return Set;

18/2
        procedure Move (Target : in out Set;
                        Source : in out Set);

19/2
        procedure Insert (Container : in out Set;
                          New_Item  : in     Element_Type;
                          Position  :    out Cursor;
                          Inserted  :    out Boolean);

20/2
        procedure Insert (Container : in out Set;
                          New_Item  : in     Element_Type);

21/2
        procedure Include (Container : in out Set;
                           New_Item  : in     Element_Type);

22/2
        procedure Replace (Container : in out Set;
                           New_Item  : in     Element_Type);

23/2
        procedure Exclude (Container : in out Set;
                           Item      : in     Element_Type);

24/2
        procedure Delete (Container : in out Set;
                          Item      : in     Element_Type);

25/2
        procedure Delete (Container : in out Set;
                          Position  : in out Cursor);

26/2
        procedure Union (Target : in out Set;
                         Source : in     Set);

27/2
        function Union (Left, Right : Set) return Set;

28/2
        function "or" (Left, Right : Set) return Set renames Union;

29/2
        procedure Intersection (Target : in out Set;
                                Source : in     Set);

30/2
        function Intersection (Left, Right : Set) return Set;

31/2
        function "and" (Left, Right : Set) return Set renames Intersection;

32/2
        procedure Difference (Target : in out Set;
                              Source : in     Set);

33/2
        function Difference (Left, Right : Set) return Set;

34/2
        function "-" (Left, Right : Set) return Set renames Difference;

35/2
        procedure Symmetric_Difference (Target : in out Set;
                                        Source : in     Set);

36/2
        function Symmetric_Difference (Left, Right : Set) return Set;

37/2
        function "xor" (Left, Right : Set) return Set
          renames Symmetric_Difference;

38/2
        function Overlap (Left, Right : Set) return Boolean;

39/2
        function Is_Subset (Subset : Set;
                            Of_Set : Set) return Boolean;

40/2
        function First (Container : Set) return Cursor;

41/2
        function Next (Position : Cursor) return Cursor;

42/2
        procedure Next (Position : in out Cursor);

43/2
        function Find (Container : Set;
                       Item      : Element_Type) return Cursor;

44/2
        function Contains (Container : Set;
                           Item      : Element_Type) return Boolean;

45/3
     <This paragraph was deleted.>

46/2
        function Equivalent_Elements (Left, Right : Cursor)
          return Boolean;

47/2
        function Equivalent_Elements (Left  : Cursor;
                                      Right : Element_Type)
          return Boolean;

48/2
        function Equivalent_Elements (Left  : Element_Type;
                                      Right : Cursor)
          return Boolean;

49/2
        procedure Iterate
          (Container : in Set;
           Process   : not null access procedure (Position : in Cursor));

49.1/3
        function Iterate (Container : in Set)
           return Set_Iterator_Interfaces.Forward_Iterator'Class;

50/2
        generic
           type Key_Type (<>) is private;
           with function Key (Element : Element_Type) return Key_Type;
           with function Hash (Key : Key_Type) return Hash_Type;
           with function Equivalent_Keys (Left, Right : Key_Type)
                                          return Boolean;
        package Generic_Keys is

51/2
           function Key (Position : Cursor) return Key_Type;

52/2
           function Element (Container : Set;
                             Key       : Key_Type)
             return Element_Type;

53/2
           procedure Replace (Container : in out Set;
                              Key       : in     Key_Type;
                              New_Item  : in     Element_Type);

54/2
           procedure Exclude (Container : in out Set;
                              Key       : in     Key_Type);

55/2
           procedure Delete (Container : in out Set;
                             Key       : in     Key_Type);

56/2
           function Find (Container : Set;
                          Key       : Key_Type)
              return Cursor;

57/2
           function Contains (Container : Set;
                              Key       : Key_Type)
              return Boolean;

58/2
           procedure Update_Element_Preserving_Key
             (Container : in out Set;
              Position  : in     Cursor;
              Process   : not null access procedure
                              (Element : in out Element_Type));

58.1/3
           type Reference_Type
                 (Element : not null access Element_Type) is private
              with Implicit_Dereference => Element;

58.2/3
           function Reference_Preserving_Key (Container : aliased in out Set;
                                              Position  : in Cursor)
              return Reference_Type;

58.3/3
           function Constant_Reference (Container : aliased in Set;
                                        Key       : in Key_Type)
              return Constant_Reference_Type;

58.4/3
           function Reference_Preserving_Key (Container : aliased in out Set;
                                              Key       : in Key_Type)
              return Reference_Type;

59/2
        end Generic_Keys;

60/2
     private

61/2
        ... -- <not specified by the language>

62/2
     end Ada.Containers.Hashed_Sets;

63/2
An object of type Set contains an expandable hash table, which is used
to provide direct access to elements.  The <capacity> of an object of
type Set is the maximum number of elements that can be inserted into the
hash table prior to it being automatically expanded.

64/2
Two elements <E1> and <E2> are defined to be <equivalent> if
Equivalent_Elements (<E1>, <E2>) returns True.

65/2
The actual function for the generic formal function Hash is expected to
return the same value each time it is called with a particular element
value.  For any two equivalent elements, the actual for Hash is expected
to return the same value.  If the actual for Hash behaves in some other
manner, the behavior of this package is unspecified.  Which subprograms
of this package call Hash, and how many times they call it, is
unspecified.

66/2
The actual function for the generic formal function Equivalent_Elements
is expected to return the same value each time it is called with a
particular pair of Element values.  It should define an equivalence
relationship, that is, be reflexive, symmetric, and transitive.  If the
actual for Equivalent_Elements behaves in some other manner, the
behavior of this package is unspecified.  Which subprograms of this
package call Equivalent_Elements, and how many times they call it, is
unspecified.

66.1/3
If the actual function for the generic formal function "=" returns True
for any pair of nonequivalent elements, then the behavior of the
container function "=" is unspecified.

67/2
If the value of an element stored in a set is changed other than by an
operation in this package such that at least one of Hash or
Equivalent_Elements give different results, the behavior of this package
is unspecified.

68/2
Which elements are the first element and the last element of a set, and
which element is the successor of a given element, are unspecified,
other than the general semantics described in *note A.18.7::.

69/2
     function Capacity (Container : Set) return Count_Type;

70/2
          Returns the capacity of Container.

71/2
     procedure Reserve_Capacity (Container : in out Set;
                                 Capacity  : in     Count_Type);

72/2
          Reserve_Capacity allocates a new hash table such that the
          length of the resulting set can become at least the value
          Capacity without requiring an additional call to
          Reserve_Capacity, and is large enough to hold the current
          length of Container.  Reserve_Capacity then rehashes the
          elements in Container onto the new hash table.  It replaces
          the old hash table with the new hash table, and then
          deallocates the old hash table.  Any exception raised during
          allocation is propagated and Container is not modified.

73/2
          Reserve_Capacity tampers with the cursors of Container.

74/2
     procedure Clear (Container : in out Set);

75/2
          In addition to the semantics described in *note A.18.7::,
          Clear does not affect the capacity of Container.

75.1/3
     procedure Assign (Target : in out Set; Source : in Set);

75.2/3
          In addition to the semantics described in *note A.18.7::, if
          the length of Source is greater than the capacity of Target,
          Reserve_Capacity (Target, Length (Source)) is called before
          assigning any elements.

75.3/3
     function Copy (Source : Set; Capacity : Count_Type := 0) return Set;

75.4/3
          Returns a set whose elements are initialized from the elements
          of Source.  If Capacity is 0, then the set capacity is the
          length of Source; if Capacity is equal to or greater than the
          length of Source, the set capacity is at least the specified
          value.  Otherwise, the operation propagates Capacity_Error.

76/2
     procedure Insert (Container : in out Set;
                       New_Item  : in     Element_Type;
                       Position  :    out Cursor;
                       Inserted  :    out Boolean);

77/2
          In addition to the semantics described in *note A.18.7::, if
          Length (Container) equals Capacity (Container), then Insert
          first calls Reserve_Capacity to increase the capacity of
          Container to some larger value.

78/2
     function First (Container : Set) return Cursor;

79/2
          If Length (Container) = 0, then First returns No_Element.
          Otherwise, First returns a cursor that designates the first
          hashed element in Container.

80/2
     function Equivalent_Elements (Left, Right : Cursor)
           return Boolean;

81/2
          Equivalent to Equivalent_Elements (Element (Left), Element
          (Right)).

82/2
     function Equivalent_Elements (Left  : Cursor;
                                   Right : Element_Type) return Boolean;

83/2
          Equivalent to Equivalent_Elements (Element (Left), Right).

84/2
     function Equivalent_Elements (Left  : Element_Type;
                                   Right : Cursor) return Boolean;

85/2
          Equivalent to Equivalent_Elements (Left, Element (Right)).

85.1/3
     function Iterate (Container : in Set)
        return Set_Iterator_Interfaces.Forward_Iterator'Class;

85.2/3
          Iterate returns an iterator object (see *note 5.5.1::) that
          will generate a value for a loop parameter (see *note 5.5.2::)
          designating each element in Container, starting with the first
          element and moving the cursor according to the successor
          relation.  Tampering with the cursors of Container is
          prohibited while the iterator object exists (in particular, in
          the sequence_of_statements of the loop_statement whose
          iterator_specification denotes this object).  The iterator
          object needs finalization.

86/2
For any element <E>, the actual function for the generic formal function
Generic_Keys.Hash is expected to be such that Hash (<E>) =
Generic_Keys.Hash (Key (<E>)).  If the actuals for Key or
Generic_Keys.Hash behave in some other manner, the behavior of
Generic_Keys is unspecified.  Which subprograms of Generic_Keys call
Generic_Keys.Hash, and how many times they call it, is unspecified.

87/2
For any two elements <E1> and <E2>, the boolean values
Equivalent_Elements (<E1>, <E2>) and Equivalent_Keys (Key (<E1>), Key
(<E2>)) are expected to be equal.  If the actuals for Key or
Equivalent_Keys behave in some other manner, the behavior of
Generic_Keys is unspecified.  Which subprograms of Generic_Keys call
Equivalent_Keys, and how many times they call it, is unspecified.

                        _Implementation Advice_

88/2
If <N> is the length of a set, the average time complexity of the
subprograms Insert, Include, Replace, Delete, Exclude and Find that take
an element parameter should be <O>(log <N>).  The average time
complexity of the subprograms that take a cursor parameter should be
<O>(1).  The average time complexity of Reserve_Capacity should be
<O>(<N>).


File: arm2012.info,  Node: A.18.9,  Next: A.18.10,  Prev: A.18.8,  Up: A.18

A.18.9 The Generic Package Containers.Ordered_Sets
--------------------------------------------------

                          _Static Semantics_

1/2
The generic library package Containers.Ordered_Sets has the following
declaration:

2/3
     with Ada.Iterator_Interfaces;
     generic
        type Element_Type is private;
        with function "<" (Left, Right : Element_Type) return Boolean is <>;
        with function "=" (Left, Right : Element_Type) return Boolean is <>;
     package Ada.Containers.Ordered_Sets is
        pragma Preelaborate(Ordered_Sets);
        pragma Remote_Types(Ordered_Sets);

3/2
        function Equivalent_Elements (Left, Right : Element_Type) return Boolean;

4/3
        type Set is tagged private
           with Constant_Indexing => Constant_Reference,
                Default_Iterator  => Iterate,
                Iterator_Element  => Element_Type;
        pragma Preelaborable_Initialization(Set);

5/2
        type Cursor is private;
        pragma Preelaborable_Initialization(Cursor);

6/2
        Empty_Set : constant Set;

7/2
        No_Element : constant Cursor;

7.1/3
        function Has_Element (Position : Cursor) return Boolean;

7.2/3
        package Set_Iterator_Interfaces is new
            Ada.Iterator_Interfaces (Cursor, Has_Element);

8/2
        function "=" (Left, Right : Set) return Boolean;

9/2
        function Equivalent_Sets (Left, Right : Set) return Boolean;

10/2
        function To_Set (New_Item : Element_Type) return Set;

11/2
        function Length (Container : Set) return Count_Type;

12/2
        function Is_Empty (Container : Set) return Boolean;

13/2
        procedure Clear (Container : in out Set);

14/2
        function Element (Position : Cursor) return Element_Type;

15/2
        procedure Replace_Element (Container : in out Set;
                                   Position  : in     Cursor;
                                   New_Item  : in     Element_Type);

16/2
        procedure Query_Element
          (Position : in Cursor;
           Process  : not null access procedure (Element : in Element_Type));

16.1/3
        type Constant_Reference_Type
              (Element : not null access constant Element_Type) is private
           with Implicit_Dereference => Element;

16.2/3
        function Constant_Reference (Container : aliased in Set;
                                     Position  : in Cursor)
           return Constant_Reference_Type;

16.3/3
        procedure Assign (Target : in out Set; Source : in Set);

16.4/3
        function Copy (Source : Set) return Set;

17/2
        procedure Move (Target : in out Set;
                        Source : in out Set);

18/2
        procedure Insert (Container : in out Set;
                          New_Item  : in     Element_Type;
                          Position  :    out Cursor;
                          Inserted  :    out Boolean);

19/2
        procedure Insert (Container : in out Set;
                          New_Item  : in     Element_Type);

20/2
        procedure Include (Container : in out Set;
                           New_Item  : in     Element_Type);

21/2
        procedure Replace (Container : in out Set;
                           New_Item  : in     Element_Type);

22/2
        procedure Exclude (Container : in out Set;
                           Item      : in     Element_Type);

23/2
        procedure Delete (Container : in out Set;
                          Item      : in     Element_Type);

24/2
        procedure Delete (Container : in out Set;
                          Position  : in out Cursor);

25/2
        procedure Delete_First (Container : in out Set);

26/2
        procedure Delete_Last (Container : in out Set);

27/2
        procedure Union (Target : in out Set;
                         Source : in     Set);

28/2
        function Union (Left, Right : Set) return Set;

29/2
        function "or" (Left, Right : Set) return Set renames Union;

30/2
        procedure Intersection (Target : in out Set;
                                Source : in     Set);

31/2
        function Intersection (Left, Right : Set) return Set;

32/2
        function "and" (Left, Right : Set) return Set renames Intersection;

33/2
        procedure Difference (Target : in out Set;
                              Source : in     Set);

34/2
        function Difference (Left, Right : Set) return Set;

35/2
        function "-" (Left, Right : Set) return Set renames Difference;

36/2
        procedure Symmetric_Difference (Target : in out Set;
                                        Source : in     Set);

37/2
        function Symmetric_Difference (Left, Right : Set) return Set;

38/2
        function "xor" (Left, Right : Set) return Set renames
           Symmetric_Difference;

39/2
        function Overlap (Left, Right : Set) return Boolean;

40/2
        function Is_Subset (Subset : Set;
                            Of_Set : Set) return Boolean;

41/2
        function First (Container : Set) return Cursor;

42/2
        function First_Element (Container : Set) return Element_Type;

43/2
        function Last (Container : Set) return Cursor;

44/2
        function Last_Element (Container : Set) return Element_Type;

45/2
        function Next (Position : Cursor) return Cursor;

46/2
        procedure Next (Position : in out Cursor);

47/2
        function Previous (Position : Cursor) return Cursor;

48/2
        procedure Previous (Position : in out Cursor);

49/2
        function Find (Container : Set;
                       Item      : Element_Type)
           return Cursor;

50/2
        function Floor (Container : Set;
                        Item      : Element_Type)
           return Cursor;

51/2
        function Ceiling (Container : Set;
                          Item      : Element_Type)
           return Cursor;

52/2
        function Contains (Container : Set;
                           Item      : Element_Type) return Boolean;

53/3
     <This paragraph was deleted.>

54/2
        function "<" (Left, Right : Cursor) return Boolean;

55/2
        function ">" (Left, Right : Cursor) return Boolean;

56/2
        function "<" (Left : Cursor; Right : Element_Type)
           return Boolean;

57/2
        function ">" (Left : Cursor; Right : Element_Type)
           return Boolean;

58/2
        function "<" (Left : Element_Type; Right : Cursor)
           return Boolean;

59/2
        function ">" (Left : Element_Type; Right : Cursor)
           return Boolean;

60/2
        procedure Iterate
          (Container : in Set;
           Process   : not null access procedure (Position : in Cursor));

61/2
        procedure Reverse_Iterate
          (Container : in Set;
           Process   : not null access procedure (Position : in Cursor));

61.1/3
        function Iterate (Container : in Set)
           return Set_Iterator_Interfaces.Reversible_Iterator'Class;

61.2/3
        function Iterate (Container : in Set; Start : in Cursor)
           return Set_Iterator_Interfaces.Reversible_Iterator'Class;

62/2
        generic
           type Key_Type (<>) is private;
           with function Key (Element : Element_Type) return Key_Type;
           with function "<" (Left, Right : Key_Type)
              return Boolean is <>;
        package Generic_Keys is

63/2
            function Equivalent_Keys (Left, Right : Key_Type)
               return Boolean;

64/2
            function Key (Position : Cursor) return Key_Type;

65/2
            function Element (Container : Set;
                              Key       : Key_Type)
               return Element_Type;

66/2
            procedure Replace (Container : in out Set;
                               Key       : in     Key_Type;
                               New_Item  : in     Element_Type);

67/2
            procedure Exclude (Container : in out Set;
                               Key       : in     Key_Type);

68/2
            procedure Delete (Container : in out Set;
                              Key       : in     Key_Type);

69/2
            function Find (Container : Set;
                           Key       : Key_Type)
               return Cursor;

70/2
            function Floor (Container : Set;
                            Key       : Key_Type)
               return Cursor;

71/2
            function Ceiling (Container : Set;
                              Key       : Key_Type)
               return Cursor;

72/2
            function Contains (Container : Set;
                               Key       : Key_Type) return Boolean;

73/2
            procedure Update_Element_Preserving_Key
              (Container : in out Set;
               Position  : in     Cursor;
               Process   : not null access procedure
                               (Element : in out Element_Type));

73.1/3
           type Reference_Type
                 (Element : not null access Element_Type) is private
              with Implicit_Dereference => Element;

73.2/3
           function Reference_Preserving_Key (Container : aliased in out Set;
                                              Position  : in Cursor)
              return Reference_Type;

73.3/3
           function Constant_Reference (Container : aliased in Set;
                                        Key       : in Key_Type)
              return Constant_Reference_Type;

73.4/3
           function Reference_Preserving_Key (Container : aliased in out Set;
                                              Key       : in Key_Type)
              return Reference_Type;

74/2
        end Generic_Keys;

75/2
     private

76/2
        ... -- <not specified by the language>

77/2
     end Ada.Containers.Ordered_Sets;

78/2
Two elements <E1> and <E2> are <equivalent> if both <E1> < <E2> and <E2>
< <E1> return False, using the generic formal "<" operator for elements.
Function Equivalent_Elements returns True if Left and Right are
equivalent, and False otherwise.

79/3
The actual function for the generic formal function "<" on Element_Type
values is expected to return the same value each time it is called with
a particular pair of key values.  It should define a strict weak
ordering relationship (see *note A.18::).  If the actual for "<" behaves
in some other manner, the behavior of this package is unspecified.
Which subprograms of this package call "<" and how many times they call
it, is unspecified.

79.1/3
If the actual function for the generic formal function "=" returns True
for any pair of nonequivalent elements, then the behavior of the
container function "=" is unspecified.

80/2
If the value of an element stored in a set is changed other than by an
operation in this package such that at least one of "<" or "=" give
different results, the behavior of this package is unspecified.

81/3
The <first element> of a nonempty set is the one which is less than all
the other elements in the set.  The <last element> of a nonempty set is
the one which is greater than all the other elements in the set.  The
<successor> of an element is the smallest element that is larger than
the given element.  The <predecessor> of an element is the largest
element that is smaller than the given element.  All comparisons are
done using the generic formal "<" operator for elements.

81.1/3
     function Copy (Source : Set) return Set;

81.2/3
          Returns a set whose elements are initialized from the
          corresponding elements of Source.

82/2
     procedure Delete_First (Container : in out Set);

83/3
          If Container is empty, Delete_First has no effect.  Otherwise,
          the element designated by First (Container) is removed from
          Container.  Delete_First tampers with the cursors of
          Container.

84/2
     procedure Delete_Last (Container : in out Set);

85/3
          If Container is empty, Delete_Last has no effect.  Otherwise,
          the element designated by Last (Container) is removed from
          Container.  Delete_Last tampers with the cursors of Container.

86/2
     function First_Element (Container : Set) return Element_Type;

87/2
          Equivalent to Element (First (Container)).

88/2
     function Last (Container : Set) return Cursor;

89/2
          Returns a cursor that designates the last element in
          Container.  If Container is empty, returns No_Element.

90/2
     function Last_Element (Container : Set) return Element_Type;

91/2
          Equivalent to Element (Last (Container)).

92/2
     function Previous (Position : Cursor) return Cursor;

93/3
          If Position equals No_Element, then Previous returns
          No_Element.  Otherwise, Previous returns a cursor designating
          the predecessor element of the one designated by Position.  If
          Position designates the first element, then Previous returns
          No_Element.

94/2
     procedure Previous (Position : in out Cursor);

95/2
          Equivalent to Position := Previous (Position).

96/2
     function Floor (Container : Set;
                     Item      : Element_Type) return Cursor;

97/3
          Floor searches for the last element which is not greater than
          Item.  If such an element is found, a cursor that designates
          it is returned.  Otherwise, No_Element is returned.

98/2
     function Ceiling (Container : Set;
                       Item      : Element_Type) return Cursor;

99/3
          Ceiling searches for the first element which is not less than
          Item.  If such an element is found, a cursor that designates
          it is returned.  Otherwise, No_Element is returned.

100/2
     function "<" (Left, Right : Cursor) return Boolean;

101/2
          Equivalent to Element (Left) < Element (Right).

102/2
     function ">" (Left, Right : Cursor) return Boolean;

103/2
          Equivalent to Element (Right) < Element (Left).

104/2
     function "<" (Left : Cursor; Right : Element_Type) return Boolean;

105/2
          Equivalent to Element (Left) < Right.

106/2
     function ">" (Left : Cursor; Right : Element_Type) return Boolean;

107/2
          Equivalent to Right < Element (Left).

108/2
     function "<" (Left : Element_Type; Right : Cursor) return Boolean;

109/2
          Equivalent to Left < Element (Right).

110/2
     function ">" (Left : Element_Type; Right : Cursor) return Boolean;

111/2
          Equivalent to Element (Right) < Left.

112/2
     procedure Reverse_Iterate
        (Container : in Set;
         Process   : not null access procedure (Position : in Cursor));

113/3
          Iterates over the elements in Container as per procedure
          Iterate, with the difference that the elements are traversed
          in predecessor order, starting with the last element.

113.1/3
     function Iterate (Container : in Set)
        return Set_Iterator_Interfaces.Reversible_Iterator'Class;

113.2/3
          Iterate returns a reversible iterator object (see *note
          5.5.1::) that will generate a value for a loop parameter (see
          *note 5.5.2::) designating each element in Container, starting
          with the first element and moving the cursor according to the
          successor relation when used as a forward iterator, and
          starting with the last element and moving the cursor according
          to the predecessor relation when used as a reverse iterator.
          Tampering with the cursors of Container is prohibited while
          the iterator object exists (in particular, in the
          sequence_of_statements of the loop_statement whose
          iterator_specification denotes this object).  The iterator
          object needs finalization.

113.3/3
     function Iterate (Container : in Set; Start : in Cursor)
        return Set_Iterator_Interfaces.Reversible_Iterator'Class;

113.4/3
          If Start is not No_Element and does not designate an item in
          Container, then Program_Error is propagated.  If Start is
          No_Element, then Constraint_Error is propagated.  Otherwise,
          Iterate returns a reversible iterator object (see *note
          5.5.1::) that will generate a value for a loop parameter (see
          *note 5.5.2::) designating each element in Container, starting
          with the element designated by Start and moving the cursor
          according to the successor relation when used as a forward
          iterator, or moving the cursor according to the predecessor
          relation when used as a reverse iterator.  Tampering with the
          cursors of Container is prohibited while the iterator object
          exists (in particular, in the sequence_of_statements of the
          loop_statement whose iterator_specification denotes this
          object).  The iterator object needs finalization.

114/2
For any two elements <E1> and <E2>, the boolean values (<E1> < <E2>) and
(Key(<E1>) < Key(<E2>)) are expected to be equal.  If the actuals for
Key or Generic_Keys."<" behave in some other manner, the behavior of
this package is unspecified.  Which subprograms of this package call Key
and Generic_Keys."<", and how many times the functions are called, is
unspecified.

115/2
In addition to the semantics described in *note A.18.7::, the
subprograms in package Generic_Keys named Floor and Ceiling, are
equivalent to the corresponding subprograms in the parent package, with
the difference that the Key subprogram parameter is compared to elements
in the container using the Key and "<" generic formal functions.  The
function named Equivalent_Keys in package Generic_Keys returns True if
both Left < Right and Right < Left return False using the generic formal
"<" operator, and returns True otherwise.

                        _Implementation Advice_

116/2
If <N> is the length of a set, then the worst-case time complexity of
the Insert, Include, Replace, Delete, Exclude and Find operations that
take an element parameter should be <O>((log <N>)**2) or better.  The
worst-case time complexity of the subprograms that take a cursor
parameter should be <O>(1).


File: arm2012.info,  Node: A.18.10,  Next: A.18.11,  Prev: A.18.9,  Up: A.18

A.18.10 The Generic Package Containers.Multiway_Trees
-----------------------------------------------------

1/3
The language-defined generic package Containers.Multiway_Trees provides
private types Tree and Cursor, and a set of operations for each type.  A
multiway tree container is well-suited to represent nested structures.

2/4
A multiway tree container object manages a tree of <nodes>, consisting
of a <root node> and a set of <internal nodes>; each internal node
contains an element and pointers to the parent, first child, last child,
next (successor) sibling, and previous (predecessor) sibling internal
nodes.  A cursor designates a particular node within a tree (and by
extension the element contained in that node, if any).  A cursor keeps
designating the same node (and element) as long as the node is part of
the container, even if the node is moved within the container.

3/4
A <subtree> is a particular node (which <roots the subtree>) and all of
its child nodes (including all of the children of the child nodes,
recursively).  The root node is always present and has neither an
associated element value nor any parent node; it has pointers to its
first child and its last child, if any.  The root node provides a place
to add nodes to an otherwise empty tree and represents the base of the
tree.

4/3
A node that has no children is called a <leaf node>.  The <ancestors> of
a node are the node itself, its parent node, the parent of the parent
node, and so on until a node with no parent is reached.  Similarly, the
<descendants> of a node are the node itself, its child nodes, the
children of each child node, and so on.

5/3
The nodes of a subtree can be visited in several different orders.  For
a <depth-first order>, after visiting a node, the nodes of its child
list are each visited in depth-first order, with each child node visited
in natural order (first child to last child).

                          _Static Semantics_

6/3
The generic library package Containers.Multiway_Trees has the following
declaration:

7/3
     with Ada.Iterator_Interfaces;
     generic
        type Element_Type is private;
        with function "=" (Left, Right : Element_Type) return Boolean is <>;
     package Ada.Containers.Multiway_Trees is
        pragma Preelaborate(Multiway_Trees);
        pragma Remote_Types(Multiway_Trees);

8/3
        type Tree is tagged private
           with Constant_Indexing => Constant_Reference,
                Variable_Indexing => Reference,
                Default_Iterator  => Iterate,
                Iterator_Element  => Element_Type;
        pragma Preelaborable_Initialization(Tree);

9/3
        type Cursor is private;
        pragma Preelaborable_Initialization(Cursor);

10/3
        Empty_Tree : constant Tree;

11/3
        No_Element : constant Cursor;

12/3
        function Has_Element (Position : Cursor) return Boolean;

13/3
        package Tree_Iterator_Interfaces is new
           Ada.Iterator_Interfaces (Cursor, Has_Element);

14/3
        function Equal_Subtree (Left_Position : Cursor;
                                Right_Position: Cursor) return Boolean;

15/3
        function "=" (Left, Right : Tree) return Boolean;

16/3
        function Is_Empty (Container : Tree) return Boolean;

17/3
        function Node_Count (Container : Tree) return Count_Type;

18/3
        function Subtree_Node_Count (Position : Cursor) return Count_Type;

19/3
        function Depth (Position : Cursor) return Count_Type;

20/3
        function Is_Root (Position : Cursor) return Boolean;

21/3
        function Is_Leaf (Position : Cursor) return Boolean;

22/3
        function Root (Container : Tree) return Cursor;

23/3
        procedure Clear (Container : in out Tree);

24/3
        function Element (Position : Cursor) return Element_Type;

25/3
        procedure Replace_Element (Container : in out Tree;
                                   Position  : in     Cursor;
                                   New_Item  : in     Element_Type);

26/3
        procedure Query_Element
          (Position : in Cursor;
           Process  : not null access procedure (Element : in Element_Type));

27/3
        procedure Update_Element
          (Container : in out Tree;
           Position  : in     Cursor;
           Process   : not null access procedure
                           (Element : in out Element_Type));

28/3
        type Constant_Reference_Type
              (Element : not null access constant Element_Type) is private
           with Implicit_Dereference => Element;

29/3
        type Reference_Type (Element : not null access Element_Type) is private
           with Implicit_Dereference => Element;

30/3
        function Constant_Reference (Container : aliased in Tree;
                                     Position  : in Cursor)
           return Constant_Reference_Type;

31/3
        function Reference (Container : aliased in out Tree;
                            Position  : in Cursor)
           return Reference_Type;

32/3
        procedure Assign (Target : in out Tree; Source : in Tree);

33/3
        function Copy (Source : Tree) return Tree;

34/3
        procedure Move (Target : in out Tree;
                        Source : in out Tree);

35/3
        procedure Delete_Leaf (Container : in out Tree;
                               Position  : in out Cursor);

36/3
        procedure Delete_Subtree (Container : in out Tree;
                                  Position  : in out Cursor);

37/3
        procedure Swap (Container : in out Tree;
                        I, J      : in     Cursor);

38/3
        function Find (Container : Tree;
                       Item      : Element_Type)
           return Cursor;

39/3
        function Find_In_Subtree (Position : Cursor;
                                  Item     : Element_Type)
           return Cursor;

40/3
        function Ancestor_Find (Position : Cursor;
                                Item     : Element_Type)
           return Cursor;

41/3
        function Contains (Container : Tree;
                           Item      : Element_Type) return Boolean;

42/3
        procedure Iterate
          (Container : in Tree;
           Process   : not null access procedure (Position : in Cursor));

43/3
        procedure Iterate_Subtree
          (Position  : in Cursor;
           Process   : not null access procedure (Position : in Cursor));

44/3
        function Iterate (Container : in Tree)
           return Tree_Iterator_Interfaces.Forward_Iterator'Class;

45/3
        function Iterate_Subtree (Position : in Cursor)
           return Tree_Iterator_Interfaces.Forward_Iterator'Class;

46/3
        function Child_Count (Parent : Cursor) return Count_Type;

47/3
        function Child_Depth (Parent, Child : Cursor) return Count_Type;

48/3
        procedure Insert_Child (Container : in out Tree;
                                Parent    : in     Cursor;
                                Before    : in     Cursor;
                                New_Item  : in     Element_Type;
                                Count     : in     Count_Type := 1);

49/3
        procedure Insert_Child (Container : in out Tree;
                                Parent    : in     Cursor;
                                Before    : in     Cursor;
                                New_Item  : in     Element_Type;
                                Position  :    out Cursor;
                                Count     : in     Count_Type := 1);

50/3
        procedure Insert_Child (Container : in out Tree;
                                Parent    : in     Cursor;
                                Before    : in     Cursor;
                                Position  :    out Cursor;
                                Count     : in     Count_Type := 1);

51/3
        procedure Prepend_Child (Container : in out Tree;
                                 Parent    : in     Cursor;
                                 New_Item  : in     Element_Type;
                                 Count     : in     Count_Type := 1);

52/3
        procedure Append_Child (Container : in out Tree;
                                Parent    : in     Cursor;
                                New_Item  : in     Element_Type;
                                Count     : in     Count_Type := 1);

53/3
        procedure Delete_Children (Container : in out Tree;
                                   Parent    : in     Cursor);

54/3
        procedure Copy_Subtree (Target   : in out Tree;
                                Parent   : in     Cursor;
                                Before   : in     Cursor;
                                Source   : in     Cursor);

55/3
        procedure Splice_Subtree (Target   : in out Tree;
                                  Parent   : in     Cursor;
                                  Before   : in     Cursor;
                                  Source   : in out Tree;
                                  Position : in out Cursor);

56/3
        procedure Splice_Subtree (Container: in out Tree;
                                  Parent   : in     Cursor;
                                  Before   : in     Cursor;
                                  Position : in     Cursor);

57/3
        procedure Splice_Children (Target          : in out Tree;
                                   Target_Parent   : in     Cursor;
                                   Before          : in     Cursor;
                                   Source          : in out Tree;
                                   Source_Parent   : in     Cursor);

58/3
        procedure Splice_Children (Container       : in out Tree;
                                   Target_Parent   : in     Cursor;
                                   Before          : in     Cursor;
                                   Source_Parent   : in     Cursor);

59/3
        function Parent (Position : Cursor) return Cursor;

60/3
        function First_Child (Parent : Cursor) return Cursor;

61/3
        function First_Child_Element (Parent : Cursor) return Element_Type;

62/3
        function Last_Child (Parent : Cursor) return Cursor;

63/3
        function Last_Child_Element (Parent : Cursor) return Element_Type;

64/3
        function Next_Sibling (Position : Cursor) return Cursor;

65/3
        function Previous_Sibling (Position : Cursor) return Cursor;

66/3
        procedure Next_Sibling (Position : in out Cursor);

67/3
        procedure Previous_Sibling (Position : in out Cursor);

68/3
        procedure Iterate_Children
          (Parent  : in Cursor;
           Process : not null access procedure (Position : in Cursor));

69/3
        procedure Reverse_Iterate_Children
          (Parent  : in Cursor;
           Process : not null access procedure (Position : in Cursor));

70/3
        function Iterate_Children (Container : in Tree; Parent : in Cursor)
           return Tree_Iterator_Interfaces.Reversible_Iterator'Class;

71/3
     private
        ... -- <not specified by the language>
     end Ada.Containers.Multiway_Trees;

72/3
The actual function for the generic formal function "=" on Element_Type
values is expected to define a reflexive and symmetric relationship and
return the same result value each time it is called with a particular
pair of values.  If it behaves in some other manner, the functions Find,
Reverse_Find, Equal_Subtree, and "=" on tree values return an
unspecified value.  The exact arguments and number of calls of this
generic formal function by the functions Find, Reverse_Find,
Equal_Subtree, and "=" on tree values are unspecified.

73/3
The type Tree is used to represent trees.  The type Tree needs
finalization (see *note 7.6::).

74/3
Empty_Tree represents the empty Tree object.  It contains only the root
node (Node_Count (Empty_Tree) returns 1).  If an object of type Tree is
not otherwise initialized, it is initialized to the same value as
Empty_Tree.

75/3
No_Element represents a cursor that designates no element.  If an object
of type Cursor is not otherwise initialized, it is initialized to the
same value as No_Element.

76/3
The predefined "=" operator for type Cursor returns True if both cursors
are No_Element, or designate the same element in the same container.

77/3
Execution of the default implementation of the Input, Output, Read, or
Write attribute of type Cursor raises Program_Error.

78/3
Tree'Write for a Tree object <T> writes Node_Count(<T>) - 1 elements of
the tree to the stream.  It also may write additional information about
the tree.

79/3
Tree'Read reads the representation of a tree from the stream, and
assigns to <Item> a tree with the same elements and structure as was
written by Tree'Write.

80/3
Some operations of this generic package have access-to-subprogram
parameters.  To ensure such operations are well-defined, they guard
against certain actions by the designated subprogram.  In particular,
some operations check for "tampering with cursors" of a container
because they depend on the set of elements of the container remaining
constant, and others check for "tampering with elements" of a container
because they depend on elements of the container not being replaced.

81/3
A subprogram is said to <tamper with cursors> of a tree object <T> if:

82/3
   * it inserts or deletes elements of <T>, that is, it calls the Clear,
     Delete_Leaf, Insert_Child, Delete_Children, Delete_Subtree, or
     Copy_Subtree procedures with <T> as a parameter; or

83/3
   * it reorders the elements of <T>, that is, it calls the
     Splice_Subtree or Splice_Children procedures with <T> as a
     parameter; or

84/3
   * it finalizes <T>; or

85/3
   * it calls Assign with <T> as the Target parameter; or

86/3
   * it calls the Move procedure with <T> as a parameter.

87/3
A subprogram is said to <tamper with elements> of a tree object <T> if:

88/3
   * it tampers with cursors of <T>; or

89/3
   * it replaces one or more elements of <T>, that is, it calls the
     Replace_Element or Swap procedures with <T> as a parameter.

90/4
When tampering with cursors is <prohibited> for a particular tree object
<T>, Program_Error is propagated by a call of any language-defined
subprogram that is defined to tamper with the cursors of <T>, leaving
<T> unmodified.  Similarly, when tampering with elements is <prohibited>
for a particular tree object <T>, Program_Error is propagated by a call
of any language-defined subprogram that is defined to tamper with the
elements of <T> (or tamper with the cursors of <T>), leaving <T>
unmodified.  These checks are made before any other defined behavior of
the body of the language-defined subprogram.

91/3
     function Has_Element (Position : Cursor) return Boolean;

92/3
          Returns True if Position designates an element, and returns
          False otherwise.  In particular, Has_Element returns False if
          the cursor designates a root node or equals No_Element.

93/3
     function Equal_Subtree (Left_Position : Cursor;
                             Right_Position: Cursor) return Boolean;

94/3
          If Left_Position or Right_Position equals No_Element,
          propagates Constraint_Error.  If the number of child nodes of
          the element designated by Left_Position is different from the
          number of child nodes of the element designated by
          Right_Position, the function returns False.  If Left_Position
          designates a root node and Right_Position does not, the
          function returns False.  If Right_Position designates a root
          node and Left_Position does not, the function returns False.
          Unless both cursors designate a root node, the elements are
          compared using the generic formal equality operator.  If the
          result of the element comparison is False, the function
          returns False.  Otherwise, it calls Equal_Subtree on a cursor
          designating each child element of the element designated by
          Left_Position and a cursor designating the corresponding child
          element of the element designated by Right_Position.  If any
          such call returns False, the function returns False;
          otherwise, it returns True.  Any exception raised during the
          evaluation of element equality is propagated.

95/3
     function "=" (Left, Right : Tree) return Boolean;

96/3
          If Left and Right denote the same tree object, then the
          function returns True.  Otherwise, it calls Equal_Subtree with
          cursors designating the root nodes of Left and Right; the
          result is returned.  Any exception raised during the
          evaluation of Equal_Subtree is propagated.

97/3
     function Node_Count (Container : Tree) return Count_Type;

98/3
          Node_Count returns the number of nodes in Container.

99/3
     function Subtree_Node_Count (Position : Cursor) return Count_Type;

100/3
          If Position is No_Element, Subtree_Node_Count returns 0;
          otherwise, Subtree_Node_Count returns the number of nodes in
          the subtree that is rooted by Position.

101/3
     function Is_Empty (Container : Tree) return Boolean;

102/3
          Equivalent to Node_Count (Container) = 1.

103/3
     function Depth (Position : Cursor) return Count_Type;

104/3
          If Position equals No_Element, Depth returns 0; otherwise,
          Depth returns the number of ancestor nodes of the node
          designated by Position (including the node itself).

105/3
     function Is_Root (Position : Cursor) return Boolean;

106/3
          Is_Root returns True if the Position designates the root node
          of some tree; and returns False otherwise.

107/3
     function Is_Leaf (Position : Cursor) return Boolean;

108/3
          Is_Leaf returns True if Position designates a node that does
          not have any child nodes; and returns False otherwise.

109/3
     function Root (Container : Tree) return Cursor;

110/3
          Root returns a cursor that designates the root node of
          Container.

111/3
     procedure Clear (Container : in out Tree);

112/3
          Removes all the elements from Container.

113/3
     function Element (Position : Cursor) return Element_Type;

114/3
          If Position equals No_Element, then Constraint_Error is
          propagated; if Position designates the root node of a tree,
          then Program_Error is propagated.  Otherwise, Element returns
          the element designated by Position.

115/3
     procedure Replace_Element (Container : in out Tree;
                                Position  : in     Cursor;
                                New_Item  : in     Element_Type);

116/3
          If Position equals No_Element, then Constraint_Error is
          propagated; if Position does not designate an element in
          Container (including if it designates the root node), then
          Program_Error is propagated.  Otherwise, Replace_Element
          assigns the value New_Item to the element designated by
          Position.

117/3
     procedure Query_Element
       (Position : in Cursor;
        Process  : not null access procedure (Element : in Element_Type));

118/3
          If Position equals No_Element, then Constraint_Error is
          propagated; if Position designates the root node of a tree,
          then Program_Error is propagated.  Otherwise, Query_Element
          calls Process.all with the element designated by Position as
          the argument.  Tampering with the elements of the tree that
          contains the element designated by Position is prohibited
          during the execution of the call on Process.all.  Any
          exception raised by Process.all is propagated.

119/3
     procedure Update_Element
       (Container : in out Tree;
        Position  : in     Cursor;
        Process   : not null access procedure
                        (Element : in out Element_Type));

120/3
          If Position equals No_Element, then Constraint_Error is
          propagated; if Position does not designate an element in
          Container (including if it designates the root node), then
          Program_Error is propagated.  Otherwise, Update_Element calls
          Process.all with the element designated by Position as the
          argument.  Tampering with the elements of Container is
          prohibited during the execution of the call on Process.all.
          Any exception raised by Process.all is propagated.

121/3
          If Element_Type is unconstrained and definite, then the actual
          Element parameter of Process.all shall be unconstrained.

122/3
     type Constant_Reference_Type
           (Element : not null access constant Element_Type) is private
        with Implicit_Dereference => Element;

123/3
     type Reference_Type (Element : not null access Element_Type) is private
        with Implicit_Dereference => Element;

124/3
          The types Constant_Reference_Type and Reference_Type need
          finalization.

125/3
          The default initialization of an object of type
          Constant_Reference_Type or Reference_Type propagates
          Program_Error.

126/3
     function Constant_Reference (Container : aliased in Tree;
                                  Position  : in Cursor)
        return Constant_Reference_Type;

127/3
          This function (combined with the Constant_Indexing and
          Implicit_Dereference aspects) provides a convenient way to
          gain read access to an individual element of a tree given a
          cursor.

128/3
          If Position equals No_Element, then Constraint_Error is
          propagated; if Position does not designate an element in
          Container, then Program_Error is propagated.  Otherwise,
          Constant_Reference returns an object whose discriminant is an
          access value that designates the element designated by
          Position.  Tampering with the elements of Container is
          prohibited while the object returned by Constant_Reference
          exists and has not been finalized.

129/3
     function Reference (Container : aliased in out Tree;
                         Position  : in Cursor)
        return Reference_Type;

130/3
          This function (combined with the Variable_Indexing and
          Implicit_Dereference aspects) provides a convenient way to
          gain read and write access to an individual element of a tree
          given a cursor.

131/3
          If Position equals No_Element, then Constraint_Error is
          propagated; if Position does not designate an element in
          Container, then Program_Error is propagated.  Otherwise,
          Reference returns an object whose discriminant is an access
          value that designates the element designated by Position.
          Tampering with the elements of Container is prohibited while
          the object returned by Reference exists and has not been
          finalized.

132/3
     procedure Assign (Target : in out Tree; Source : in Tree);

133/3
          If Target denotes the same object as Source, the operation has
          no effect.  Otherwise, the elements of Source are copied to
          Target as for an assignment_statement assigning Source to
          Target.

134/3
     function Copy (Source : Tree) return Tree;

135/3
          Returns a tree with the same structure as Source and whose
          elements are initialized from the corresponding elements of
          Source.

136/3
     procedure Move (Target : in out Tree;
                     Source : in out Tree);

137/3
          If Target denotes the same object as Source, then the
          operation has no effect.  Otherwise, Move first calls Clear
          (Target).  Then, the nodes other than the root node in Source
          are moved to Target (in the same positions).  After Move
          completes, Node_Count (Target) is the number of nodes
          originally in Source, and Node_Count (Source) is 1.

138/3
     procedure Delete_Leaf (Container : in out Tree;
                            Position  : in out Cursor);

139/3
          If Position equals No_Element, then Constraint_Error is
          propagated; if Position does not designate an element in
          Container (including if it designates the root node), then
          Program_Error is propagated.  If the element designated by
          position has any child elements, then Constraint_Error is
          propagated.  Otherwise, Delete_Leaf removes (from Container)
          the element designated by Position.  Finally, Position is set
          to No_Element.

140/3
     procedure Delete_Subtree (Container : in out Tree;
                               Position  : in out Cursor);

141/3
          If Position equals No_Element, then Constraint_Error is
          propagated.  If Position does not designate an element in
          Container (including if it designates the root node), then
          Program_Error is propagated.  Otherwise, Delete_Subtree
          removes (from Container) the subtree designated by Position
          (that is, all descendants of the node designated by Position
          including the node itself), and Position is set to No_Element.

142/3
     procedure Swap (Container : in out Tree;
                     I, J      : in     Cursor);

143/3
          If either I or J equals No_Element, then Constraint_Error is
          propagated.  If either I or J do not designate an element in
          Container (including if either designates the root node), then
          Program_Error is propagated.  Otherwise, Swap exchanges the
          values of the elements designated by I and J.

144/3
     function Find (Container : Tree;
                    Item      : Element_Type)
        return Cursor;

145/3
          Find searches the elements of Container for an element equal
          to Item (using the generic formal equality operator).  The
          search starts at the root node.  The search traverses the tree
          in a depth-first order.  If no equal element is found, then
          Find returns No_Element.  Otherwise, it returns a cursor
          designating the first equal element encountered.

146/3
     function Find_In_Subtree (Position : Cursor;
                               Item     : Element_Type)
        return Cursor;

147/3
          If Position equals No_Element, then Constraint_Error is
          propagated.  Find_In_Subtree searches the subtree rooted by
          Position for an element equal to Item (using the generic
          formal equality operator).  The search starts at the element
          designated by Position.  The search traverses the subtree in a
          depth-first order.  If no equal element is found, then Find
          returns No_Element.  Otherwise, it returns a cursor
          designating the first equal element encountered.

148/3
     function Ancestor_Find (Position : Cursor;
                             Item     : Element_Type)
        return Cursor;

149/3
          If Position equals No_Element, then Constraint_Error is
          propagated.  Otherwise, Ancestor_Find searches for an element
          equal to Item (using the generic formal equality operator).
          The search starts at the node designated by Position, and
          checks each ancestor proceeding toward the root of the
          subtree.  If no equal element is found, then Ancestor_Find
          returns No_Element.  Otherwise, it returns a cursor
          designating the first equal element encountered.

150/3
     function Contains (Container : Tree;
                        Item      : Element_Type) return Boolean;

151/3
          Equivalent to Find (Container, Item) /= No_Element.

152/3
     procedure Iterate
       (Container : in Tree;
        Process   : not null access procedure (Position : in Cursor));

153/4
          Iterate calls Process.all with a cursor that designates each
          element in Container, starting from the root node and
          proceeding in a depth-first order.  Tampering with the cursors
          of Container is prohibited during the execution of a call on
          Process.all.  Any exception raised by Process.all is
          propagated.

154/3
     procedure Iterate_Subtree
       (Position  : in Cursor;
        Process   : not null access procedure (Position : in Cursor));

155/4
          If Position equals No_Element, then Constraint_Error is
          propagated.  Otherwise, Iterate_Subtree calls Process.all with
          a cursor that designates each element in the subtree rooted by
          the node designated by Position, starting from the node
          designated by Position and proceeding in a depth-first order.
          Tampering with the cursors of the tree that contains the
          element designated by Position is prohibited during the
          execution of a call on Process.all.  Any exception raised by
          Process.all is propagated.

156/3
     function Iterate (Container : in Tree)
        return Tree_Iterator_Interfaces.Forward_Iterator'Class;

157/4
          Iterate returns an iterator object (see *note 5.5.1::) that
          will generate a value for a loop parameter (see *note 5.5.2::)
          designating each element in Container, starting from the root
          node and proceeding in a depth-first order.  Tampering with
          the cursors of Container is prohibited while the iterator
          object exists (in particular, in the sequence_of_statements of
          the loop_statement whose iterator_specification denotes this
          object).  The iterator object needs finalization.

158/3
     function Iterate_Subtree (Position : in Cursor)
        return Tree_Iterator_Interfaces.Forward_Iterator'Class;

159/4
          If Position equals No_Element, then Constraint_Error is
          propagated.  Otherwise, Iterate_Subtree returns an iterator
          object (see *note 5.5.1::) that will generate a value for a
          loop parameter (see *note 5.5.2::) designating each element in
          the subtree rooted by the node designated by Position,
          starting from the node designated by Position and proceeding
          in a depth-first order.  If Position equals No_Element, then
          Constraint_Error is propagated.  Tampering with the cursors of
          the container that contains the node designated by Position is
          prohibited while the iterator object exists (in particular, in
          the sequence_of_statements of the loop_statement whose
          iterator_specification denotes this object).  The iterator
          object needs finalization.

160/3
     function Child_Count (Parent : Cursor) return Count_Type;

161/3
          Child_Count returns the number of child nodes of the node
          designated by Parent.

162/3
     function Child_Depth (Parent, Child : Cursor) return Count_Type;

163/3
          If Child or Parent is equal to No_Element, then
          Constraint_Error is propagated.  Otherwise, Child_Depth
          returns the number of ancestor nodes of Child (including Child
          itself), up to but not including Parent; Program_Error is
          propagated if Parent is not an ancestor of Child.

164/3
     procedure Insert_Child (Container : in out Tree;
                             Parent    : in     Cursor;
                             Before    : in     Cursor;
                             New_Item  : in     Element_Type;
                             Count     : in     Count_Type := 1);

165/3
          If Parent equals No_Element, then Constraint_Error is
          propagated.  If Parent does not designate a node in Container,
          then Program_Error is propagated.  If Before is not equal to
          No_Element, and does not designate a node in Container, then
          Program_Error is propagated.  If Before is not equal to
          No_Element, and Parent does not designate the parent node of
          the node designated by Before, then Constraint_Error is
          propagated.  Otherwise, Insert_Child allocates Count nodes
          containing copies of New_Item and inserts them as children of
          Parent.  If Parent already has child nodes, then the new nodes
          are inserted prior to the node designated by Before, or, if
          Before equals No_Element, the new nodes are inserted after the
          last existing child node of Parent.  Any exception raised
          during allocation of internal storage is propagated, and
          Container is not modified.

166/3
     procedure Insert_Child (Container : in out Tree;
                             Parent    : in     Cursor;
                             Before    : in     Cursor;
                             New_Item  : in     Element_Type;
                             Position  :    out Cursor;
                             Count     : in     Count_Type := 1);

167/3
          If Parent equals No_Element, then Constraint_Error is
          propagated.  If Parent does not designate a node in Container,
          then Program_Error is propagated.  If Before is not equal to
          No_Element, and does not designate a node in Container, then
          Program_Error is propagated.  If Before is not equal to
          No_Element, and Parent does not designate the parent node of
          the node designated by Before, then Constraint_Error is
          propagated.  Otherwise, Insert_Child allocates Count nodes
          containing copies of New_Item and inserts them as children of
          Parent.  If Parent already has child nodes, then the new nodes
          are inserted prior to the node designated by Before, or, if
          Before equals No_Element, the new nodes are inserted after the
          last existing child node of Parent.  Position designates the
          first newly-inserted node, or if Count equals 0, then Position
          is assigned the value of Before.  Any exception raised during
          allocation of internal storage is propagated, and Container is
          not modified.

168/3
     procedure Insert_Child (Container : in out Tree;
                             Parent    : in     Cursor;
                             Before    : in     Cursor;
                             Position  :    out Cursor;
                             Count     : in     Count_Type := 1);

169/3
          If Parent equals No_Element, then Constraint_Error is
          propagated.  If Parent does not designate a node in Container,
          then Program_Error is propagated.  If Before is not equal to
          No_Element, and does not designate a node in Container, then
          Program_Error is propagated.  If Before is not equal to
          No_Element, and Parent does not designate the parent node of
          the node designated by Before, then Constraint_Error is
          propagated.  Otherwise, Insert_Child allocates Count nodes,
          the elements contained in the new nodes are initialized by
          default (see *note 3.3.1::), and the new nodes are inserted as
          children of Parent.  If Parent already has child nodes, then
          the new nodes are inserted prior to the node designated by
          Before, or, if Before equals No_Element, the new nodes are
          inserted after the last existing child node of Parent.
          Position designates the first newly-inserted node, or if Count
          equals 0, then Position is assigned the value of Before.  Any
          exception raised during allocation of internal storage is
          propagated, and Container is not modified.

170/3
     procedure Prepend_Child (Container : in out Tree;
                              Parent    : in     Cursor;
                              New_Item  : in     Element_Type;
                              Count     : in     Count_Type := 1);

171/3
          Equivalent to Insert_Child (Container, Parent, First_Child
          (Container, Parent), New_Item, Count).

172/3
     procedure Append_Child (Container : in out Tree;
                             Parent    : in     Cursor;
                             New_Item  : in     Element_Type;
                             Count     : in     Count_Type := 1);

173/3
          Equivalent to Insert_Child (Container, Parent, No_Element,
          New_Item, Count).

174/3
     procedure Delete_Children (Container : in out Tree;
                                Parent    : in     Cursor);

175/3
          If Parent equals No_Element, then Constraint_Error is
          propagated.  If Parent does not designate a node in Container,
          Program_Error is propagated.  Otherwise, Delete_Children
          removes (from Container) all of the descendants of Parent
          other than Parent itself.

176/3
     procedure Copy_Subtree (Target   : in out Tree;
                             Parent   : in     Cursor;
                             Before   : in     Cursor;
                             Source   : in     Cursor);

177/3
          If Parent equals No_Element, then Constraint_Error is
          propagated.  If Parent does not designate a node in Target,
          then Program_Error is propagated.  If Before is not equal to
          No_Element, and does not designate a node in Target, then
          Program_Error is propagated.  If Before is not equal to
          No_Element, and Parent does not designate the parent node of
          the node designated by Before, then Constraint_Error is
          propagated.  If Source designates a root node, then
          Constraint_Error is propagated.  If Source is equal to
          No_Element, then the operation has no effect.  Otherwise, the
          subtree rooted by Source (which can be from any tree; it does
          not have to be a subtree of Target) is copied (new nodes are
          allocated to create a new subtree with the same structure as
          the Source subtree, with each element initialized from the
          corresponding element of the Source subtree) and inserted into
          Target as a child of Parent.  If Parent already has child
          nodes, then the new nodes are inserted prior to the node
          designated by Before, or, if Before equals No_Element, the new
          nodes are inserted after the last existing child node of
          Parent.  The parent of the newly created subtree is set to
          Parent, and the overall count of Target is incremented by
          Subtree_Node_Count (Source).  Any exception raised during
          allocation of internal storage is propagated, and Container is
          not modified.

178/3
     procedure Splice_Subtree (Target   : in out Tree;
                               Parent   : in     Cursor;
                               Before   : in     Cursor;
                               Source   : in out Tree;
                               Position : in out Cursor);

179/3
          If Parent equals No_Element, then Constraint_Error is
          propagated.  If Parent does not designate a node in Target,
          then Program_Error is propagated.  If Before is not equal to
          No_Element, and does not designate a node in Target, then
          Program_Error is propagated.  If Before is not equal to
          No_Element, and Parent does not designate the parent node of
          the node designated by Before, then Constraint_Error is
          propagated.  If Position equals No_Element, Constraint_Error
          is propagated.  If Position does not designate a node in
          Source or designates a root node, then Program_Error is
          propagated.  If Source denotes the same object as Target,
          then: if Position equals Before there is no effect; if
          Position designates an ancestor of Parent (including Parent
          itself), Constraint_Error is propagated; otherwise, the
          subtree rooted by the element designated by Position is moved
          to be a child of Parent.  If Parent already has child nodes,
          then the moved nodes are inserted prior to the node designated
          by Before, or, if Before equals No_Element, the moved nodes
          are inserted after the last existing child node of Parent.  In
          each of these cases, Position and the count of Target are
          unchanged, and the parent of the element designated by
          Position is set to Parent.

180/3
          Otherwise (if Source does not denote the same object as
          Target), the subtree designated by Position is removed from
          Source and moved to Target.  The subtree is inserted as a
          child of Parent.  If Parent already has child nodes, then the
          moved nodes are inserted prior to the node designated by
          Before, or, if Before equals No_Element, the moved nodes are
          inserted after the last existing child node of Parent.  In
          each of these cases, the count of Target is incremented by
          Subtree_Node_Count (Position), and the count of Source is
          decremented by Subtree_Node_Count (Position), Position is
          updated to represent an element in Target.

181/3
     procedure Splice_Subtree (Container: in out Tree;
                               Parent   : in     Cursor;
                               Before   : in     Cursor;
                               Position : in     Cursor);

182/3
          If Parent equals No_Element, then Constraint_Error is
          propagated.  If Parent does not designate a node in Container,
          then Program_Error is propagated.  If Before is not equal to
          No_Element, and does not designate a node in Container, then
          Program_Error is propagated.  If Before is not equal to
          No_Element, and Parent does not designate the parent node of
          the node designated by Before, then Constraint_Error is
          propagated.  If Position equals No_Element, Constraint_Error
          is propagated.  If Position does not designate a node in
          Container or designates a root node, then Program_Error is
          propagated.  If Position equals Before, there is no effect.
          If Position designates an ancestor of Parent (including Parent
          itself), Constraint_Error is propagated.  Otherwise, the
          subtree rooted by the element designated by Position is moved
          to be a child of Parent.  If Parent already has child nodes,
          then the moved nodes are inserted prior to the node designated
          by Before, or, if Before equals No_Element, the moved nodes
          are inserted after the last existing child node of Parent.
          The parent of the element designated by Position is set to
          Parent.

183/3
     procedure Splice_Children (Target          : in out Tree;
                                Target_Parent   : in     Cursor;
                                Before          : in     Cursor;
                                Source          : in out Tree;
                                Source_Parent   : in     Cursor);

184/3
          If Target_Parent equals No_Element, then Constraint_Error is
          propagated.  If Target_Parent does not designate a node in
          Target, then Program_Error is propagated.  If Before is not
          equal to No_Element, and does not designate an element in
          Target, then Program_Error is propagated.  If Source_Parent
          equals No_Element, then Constraint_Error is propagated.  If
          Source_Parent does not designate a node in Source, then
          Program_Error is propagated.  If Before is not equal to
          No_Element, and Target_Parent does not designate the parent
          node of the node designated by Before, then Constraint_Error
          is propagated.

185/3
          If Source denotes the same object as Target, then:

186/3
             * if Target_Parent equals Source_Parent there is no effect;
               else

187/3
             * if Source_Parent is an ancestor of Target_Parent other
               than Target_Parent itself, then Constraint_Error is
               propagated; else

188/3
             * the child elements (and the further descendants) of
               Source_Parent are moved to be child elements of
               Target_Parent.  If Target_Parent already has child
               elements, then the moved elements are inserted prior to
               the node designated by Before, or, if Before equals
               No_Element, the moved elements are inserted after the
               last existing child node of Target_Parent.  The parent of
               each moved child element is set to Target_Parent.

189/3
          Otherwise (if Source does not denote the same object as
          Target), the child elements (and the further descendants) of
          Source_Parent are removed from Source and moved to Target.
          The child elements are inserted as children of Target_Parent.
          If Target_Parent already has child elements, then the moved
          elements are inserted prior to the node designated by Before,
          or, if Before equals No_Element, the moved elements are
          inserted after the last existing child node of Target_Parent.
          In each of these cases, the overall count of Target is
          incremented by Subtree_Node_Count (Source_Parent)-1, and the
          overall count of Source is decremented by Subtree_Node_Count
          (Source_Parent)-1.

190/3
     procedure Splice_Children (Container       : in out Tree;
                                Target_Parent   : in     Cursor;
                                Before          : in     Cursor;
                                Source_Parent   : in     Cursor);

191/3
          If Target_Parent equals No_Element, then Constraint_Error is
          propagated.  If Target_Parent does not designate a node in
          Container, then Program_Error is propagated.  If Before is not
          equal to No_Element, and does not designate an element in
          Container, then Program_Error is propagated.  If Source_Parent
          equals No_Element, then Constraint_Error is propagated.  If
          Source_Parent does not designate a node in Container, then
          Program_Error is propagated.  If Before is not equal to
          No_Element, and Target_Parent does not designate the parent
          node of the node designated by Before, then Constraint_Error
          is propagated.  If Target_Parent equals Source_Parent there is
          no effect.  If Source_Parent is an ancestor of Target_Parent
          other than Target_Parent itself, then Constraint_Error is
          propagated.  Otherwise, the child elements (and the further
          descendants) of Source_Parent are moved to be child elements
          of Target_Parent.  If Target_Parent already has child
          elements, then the moved elements are inserted prior to the
          node designated by Before, or, if Before equals No_Element,
          the moved elements are inserted after the last existing child
          node of Target_Parent.  The parent of each moved child element
          is set to Target_Parent.

192/3
     function Parent (Position : Cursor) return Cursor;

193/3
          If Position is equal to No_Element or designates a root node,
          No_Element is returned.  Otherwise, a cursor designating the
          parent node of the node designated by Position is returned.

194/3
     function First_Child (Parent : Cursor) return Cursor;

195/3
          If Parent is equal to No_Element, then Constraint_Error is
          propagated.  Otherwise, First_Child returns a cursor
          designating the first child node of the node designated by
          Parent; if there is no such node, No_Element is returned.

196/3
     function First_Child_Element (Parent : Cursor) return Element_Type;

197/3
          Equivalent to Element (First_Child (Parent)).

198/3
     function Last_Child (Parent : Cursor) return Cursor;

199/3
          If Parent is equal to No_Element, then Constraint_Error is
          propagated.  Otherwise, Last_Child returns a cursor
          designating the last child node of the node designated by
          Parent; if there is no such node, No_Element is returned.

200/3
     function Last_Child_Element (Parent : Cursor) return Element_Type;

201/3
          Equivalent to Element (Last_Child (Parent)).

202/3
     function Next_Sibling (Position : Cursor) return Cursor;

203/3
          If Position equals No_Element or designates the last child
          node of its parent, then Next_Sibling returns the value
          No_Element.  Otherwise, it returns a cursor that designates
          the successor (with the same parent) of the node designated by
          Position.

204/3
     function Previous_Sibling (Position : Cursor) return Cursor;

205/3
          If Position equals No_Element or designates the first child
          node of its parent, then Previous_Sibling returns the value
          No_Element.  Otherwise, it returns a cursor that designates
          the predecessor (with the same parent) of the node designated
          by Position.

206/3
     procedure Next_Sibling (Position : in out Cursor);

207/3
          Equivalent to Position := Next_Sibling (Position);

208/3
     procedure Previous_Sibling (Position : in out Cursor);

209/3
          Equivalent to Position := Previous_Sibling (Position);

210/3
     procedure Iterate_Children
       (Parent  : in Cursor;
        Process : not null access procedure (Position : in Cursor));

211/3
          If Parent equals No_Element, then Constraint_Error is
          propagated.

212/3
          Iterate_Children calls Process.all with a cursor that
          designates each child node of Parent, starting with the first
          child node and moving the cursor as per the Next_Sibling
          function.

213/3
          Tampering with the cursors of the tree containing Parent is
          prohibited during the execution of a call on Process.all.  Any
          exception raised by Process.all is propagated.

214/3
     procedure Reverse_Iterate_Children
       (Parent  : in Cursor;
        Process : not null access procedure (Position : in Cursor));

215/3
          If Parent equals No_Element, then Constraint_Error is
          propagated.

216/3
          Reverse_Iterate_Children calls Process.all with a cursor that
          designates each child node of Parent, starting with the last
          child node and moving the cursor as per the Previous_Sibling
          function.

217/3
          Tampering with the cursors of the tree containing Parent is
          prohibited during the execution of a call on Process.all.  Any
          exception raised by Process.all is propagated.

218/3
     function Iterate_Children (Container : in Tree; Parent : in Cursor)
        return Tree_Iterator_Interfaces.Reversible_Iterator'Class;

219/3
          Iterate_Children returns a reversible iterator object (see
          *note 5.5.1::) that will generate a value for a loop parameter
          (see *note 5.5.2::) designating each child node of Parent.  If
          Parent equals No_Element, then Constraint_Error is propagated.
          If Parent does not designate a node in Container, then
          Program_Error is propagated.  Otherwise, when used as a
          forward iterator, the nodes are designated starting with the
          first child node and moving the cursor as per the function
          Next_Sibling; when used as a reverse iterator, the nodes are
          designated starting with the last child node and moving the
          cursor as per the function Previous_Sibling.  Tampering with
          the cursors of Container is prohibited while the iterator
          object exists (in particular, in the sequence_of_statements of
          the loop_statement whose iterator_specification denotes this
          object).  The iterator object needs finalization.

                      _Bounded (Run-Time) Errors_

220/3
It is a bounded error for the actual function associated with a generic
formal subprogram, when called as part of an operation of this package,
to tamper with elements of any Tree parameter of the operation.  Either
Program_Error is raised, or the operation works as defined on the value
of the Tree either prior to, or subsequent to, some or all of the
modifications to the Tree.

221/3
It is a bounded error to call any subprogram declared in the visible
part of Containers.Multiway_Trees when the associated container has been
finalized.  If the operation takes Container as an in out parameter,
then it raises Constraint_Error or Program_Error.  Otherwise, the
operation either proceeds as it would for an empty container, or it
raises Constraint_Error or Program_Error.

                         _Erroneous Execution_

222/3
A Cursor value is <invalid> if any of the following have occurred since
it was created: 

223/3
   * The tree that contains the element it designates has been
     finalized;

224/3
   * The tree that contains the element it designates has been used as
     the Source or Target of a call to Move;

225/3
   * The tree that contains the element it designates has been used as
     the Target of a call to Assign or the target of an
     assignment_statement;

226/3
   * The element it designates has been removed from the tree that
     previously contained the element.

227/3
The result of "=" or Has_Element is unspecified if it is called with an
invalid cursor parameter.  Execution is erroneous if any other
subprogram declared in Containers.Multiway_Trees is called with an
invalid cursor parameter.

228/3
Execution is erroneous if the tree associated with the result of a call
to Reference or Constant_Reference is finalized before the result object
returned by the call to Reference or Constant_Reference is finalized.

                     _Implementation Requirements_

229/3
No storage associated with a multiway tree object shall be lost upon
assignment or scope exit.

230/3
The execution of an assignment_statement for a tree shall have the
effect of copying the elements from the source tree object to the target
tree object and changing the node count of the target object to that of
the source object.

                        _Implementation Advice_

231/3
Containers.Multiway_Trees should be implemented similarly to a multiway
tree.  In particular, if <N> is the overall number of nodes for a
particular tree, then the worst-case time complexity of Element, Parent,
First_Child, Last_Child, Next_Sibling, Previous_Sibling, Insert_Child
with Count=1, and Delete should be <O>(log <N>).

232/3
Move should not copy elements, and should minimize copying of internal
data structures.

233/3
If an exception is propagated from a tree operation, no storage should
be lost, nor any elements removed from a tree unless specified by the
operation.


File: arm2012.info,  Node: A.18.11,  Next: A.18.12,  Prev: A.18.10,  Up: A.18

A.18.11 The Generic Package Containers.Indefinite_Vectors
---------------------------------------------------------

1/2
The language-defined generic package Containers.Indefinite_Vectors
provides a private type Vector and a set of operations.  It provides the
same operations as the package Containers.Vectors (see *note A.18.2::),
with the difference that the generic formal Element_Type is indefinite.

                          _Static Semantics_

2/3
The declaration of the generic library package
Containers.Indefinite_Vectors has the same contents and semantics as
Containers.Vectors except:

3/2
   * The generic formal Element_Type is indefinite.

4/2
   * The procedures with the profiles:

5/2
     procedure Insert (Container : in out Vector;
                       Before    : in     Extended_Index;
                       Count     : in     Count_Type := 1);

6/2
     procedure Insert (Container : in out Vector;
                       Before    : in     Cursor;
                       Position  :    out Cursor;
                       Count     : in     Count_Type := 1);

7/2
     are omitted.

8/2
   * The actual Element parameter of access subprogram Process of
     Update_Element may be constrained even if Element_Type is
     unconstrained.

9/4
   * The operations "&", Append, Insert, Prepend, Replace_Element, and
     To_Vector that have a formal parameter of type Element_Type perform
     indefinite insertion (see *note A.18::).


File: arm2012.info,  Node: A.18.12,  Next: A.18.13,  Prev: A.18.11,  Up: A.18

A.18.12 The Generic Package Containers.Indefinite_Doubly_Linked_Lists
---------------------------------------------------------------------

1/2
The language-defined generic package
Containers.Indefinite_Doubly_Linked_Lists provides private types List
and Cursor, and a set of operations for each type.  It provides the same
operations as the package Containers.Doubly_Linked_Lists (see *note
A.18.3::), with the difference that the generic formal Element_Type is
indefinite.

                          _Static Semantics_

2/3
The declaration of the generic library package
Containers.Indefinite_Doubly_Linked_Lists has the same contents and
semantics as Containers.Doubly_Linked_Lists except:

3/2
   * The generic formal Element_Type is indefinite.

4/2
   * The procedure with the profile:

5/2
     procedure Insert (Container : in out List;
                       Before    : in     Cursor;
                       Position  :    out Cursor;
                       Count     : in     Count_Type := 1);

6/2
     is omitted.

7/2
   * The actual Element parameter of access subprogram Process of
     Update_Element may be constrained even if Element_Type is
     unconstrained.

8/4
   * The operations Append, Insert, Prepend, and Replace_Element that
     have a formal parameter of type Element_Type perform indefinite
     insertion (see *note A.18::).


File: arm2012.info,  Node: A.18.13,  Next: A.18.14,  Prev: A.18.12,  Up: A.18

A.18.13 The Generic Package Containers.Indefinite_Hashed_Maps
-------------------------------------------------------------

1/2
The language-defined generic package Containers.Indefinite_Hashed_Maps
provides a map with the same operations as the package
Containers.Hashed_Maps (see *note A.18.5::), with the difference that
the generic formal types Key_Type and Element_Type are indefinite.

                          _Static Semantics_

2/3
The declaration of the generic library package
Containers.Indefinite_Hashed_Maps has the same contents and semantics as
Containers.Hashed_Maps except:

3/2
   * The generic formal Key_Type is indefinite.

4/2
   * The generic formal Element_Type is indefinite.

5/2
   * The procedure with the profile:

6/2
     procedure Insert (Container : in out Map;
                       Key       : in     Key_Type;
                       Position  :    out Cursor;
                       Inserted  :    out Boolean);

7/2
     is omitted.

8/2
   * The actual Element parameter of access subprogram Process of
     Update_Element may be constrained even if Element_Type is
     unconstrained.

9/4
   * The operations Include, Insert, Replace, and Replace_Element that
     have a formal parameter of type Element_Type perform indefinite
     insertion (see *note A.18::).


File: arm2012.info,  Node: A.18.14,  Next: A.18.15,  Prev: A.18.13,  Up: A.18

A.18.14 The Generic Package Containers.Indefinite_Ordered_Maps
--------------------------------------------------------------

1/2
The language-defined generic package Containers.Indefinite_Ordered_Maps
provides a map with the same operations as the package
Containers.Ordered_Maps (see *note A.18.6::), with the difference that
the generic formal types Key_Type and Element_Type are indefinite.

                          _Static Semantics_

2/3
The declaration of the generic library package
Containers.Indefinite_Ordered_Maps has the same contents and semantics
as Containers.Ordered_Maps except:

3/2
   * The generic formal Key_Type is indefinite.

4/2
   * The generic formal Element_Type is indefinite.

5/2
   * The procedure with the profile:

6/2
     procedure Insert (Container : in out Map;
                       Key       : in     Key_Type;
                       Position  :    out Cursor;
                       Inserted  :    out Boolean);

7/2
     is omitted.

8/2
   * The actual Element parameter of access subprogram Process of
     Update_Element may be constrained even if Element_Type is
     unconstrained.

9/4
   * The operations Include, Insert, Replace, and Replace_Element that
     have a formal parameter of type Element_Type perform indefinite
     insertion (see *note A.18::).


File: arm2012.info,  Node: A.18.15,  Next: A.18.16,  Prev: A.18.14,  Up: A.18

A.18.15 The Generic Package Containers.Indefinite_Hashed_Sets
-------------------------------------------------------------

1/2
The language-defined generic package Containers.Indefinite_Hashed_Sets
provides a set with the same operations as the package
Containers.Hashed_Sets (see *note A.18.8::), with the difference that
the generic formal type Element_Type is indefinite.

                          _Static Semantics_

2/3
The declaration of the generic library package
Containers.Indefinite_Hashed_Sets has the same contents and semantics as
Containers.Hashed_Sets except:

3/2
   * The generic formal Element_Type is indefinite.

4/2
   * The actual Element parameter of access subprogram Process of
     Update_Element_Preserving_Key may be constrained even if
     Element_Type is unconstrained.

5/4
   * The operations Include, Insert, Replace, Replace_Element, and
     To_Set that have a formal parameter of type Element_Type perform
     indefinite insertion (see *note A.18::).


File: arm2012.info,  Node: A.18.16,  Next: A.18.17,  Prev: A.18.15,  Up: A.18

A.18.16 The Generic Package Containers.Indefinite_Ordered_Sets
--------------------------------------------------------------

1/2
The language-defined generic package Containers.Indefinite_Ordered_Sets
provides a set with the same operations as the package
Containers.Ordered_Sets (see *note A.18.9::), with the difference that
the generic formal type Element_Type is indefinite.

                          _Static Semantics_

2/3
The declaration of the generic library package
Containers.Indefinite_Ordered_Sets has the same contents and semantics
as Containers.Ordered_Sets except:

3/2
   * The generic formal Element_Type is indefinite.

4/2
   * The actual Element parameter of access subprogram Process of
     Update_Element_Preserving_Key may be constrained even if
     Element_Type is unconstrained.

5/4
   * The operations Include, Insert, Replace, Replace_Element, and
     To_Set that have a formal parameter of type Element_Type perform
     indefinite insertion (see *note A.18::).


File: arm2012.info,  Node: A.18.17,  Next: A.18.18,  Prev: A.18.16,  Up: A.18

A.18.17 The Generic Package Containers.Indefinite_Multiway_Trees
----------------------------------------------------------------

1/3
The language-defined generic package
Containers.Indefinite_Multiway_Trees provides a multiway tree with the
same operations as the package Containers.Multiway_Trees (see *note
A.18.10::), with the difference that the generic formal Element_Type is
indefinite.

                          _Static Semantics_

2/3
The declaration of the generic library package
Containers.Indefinite_Multiway_Trees has the same contents and semantics
as Containers.Multiway_Trees except:

3/3
   * The generic formal Element_Type is indefinite.

4/3
   * The procedure with the profile:

5/3
     procedure Insert_Child (Container : in out Tree;
                             Parent    : in     Cursor;
                             Before    : in     Cursor;
                             Position  :    out Cursor;
                             Count     : in     Count_Type := 1);

6/3
     is omitted.

7/3
   * The actual Element parameter of access subprogram Process of
     Update_Element may be constrained even if Element_Type is
     unconstrained.

8/4
   * The operations Append_Child, Insert_Child, Prepend_Child, and
     Replace_Element that have a formal parameter of type Element_Type
     perform indefinite insertion (see *note A.18::).


File: arm2012.info,  Node: A.18.18,  Next: A.18.19,  Prev: A.18.17,  Up: A.18

A.18.18 The Generic Package Containers.Indefinite_Holders
---------------------------------------------------------

1/3
The language-defined generic package Containers.Indefinite_Holders
provides a private type Holder and a set of operations for that type.  A
holder container holds a single element of an indefinite type.

2/3
A holder container allows the declaration of an object that can be used
like an uninitialized variable or component of an indefinite type.

3/3
A holder container may be <empty>.  An empty holder does not contain an
element.

                          _Static Semantics_

4/3
The generic library package Containers.Indefinite_Holders has the
following declaration:

5/3
     generic
        type Element_Type (<>) is private;
        with function "=" (Left, Right : Element_Type) return Boolean is <>;
     package Ada.Containers.Indefinite_Holders is
        pragma Preelaborate(Indefinite_Holders);
        pragma Remote_Types(Indefinite_Holders);

6/3
        type Holder is tagged private;
        pragma Preelaborable_Initialization (Holder);

7/3
        Empty_Holder : constant Holder;

8/3
        function "=" (Left, Right : Holder) return Boolean;

9/3
        function To_Holder (New_Item : Element_Type) return Holder;

10/3
        function Is_Empty (Container : Holder) return Boolean;

11/3
        procedure Clear (Container : in out Holder);

12/3
        function Element (Container : Holder) return Element_Type;

13/3
        procedure Replace_Element (Container : in out Holder;
                                   New_Item  : in     Element_Type);

14/3
        procedure Query_Element
       (Container : in Holder;
        Process   : not null access procedure (Element : in Element_Type));

15/3
        procedure Update_Element
       (Container : in out Holder;
        Process   : not null access procedure (Element : in out Element_Type));

16/3
        type Constant_Reference_Type
           (Element : not null access constant Element_Type) is private
        with Implicit_Dereference => Element;

17/3
        type Reference_Type (Element : not null access Element_Type) is private
        with Implicit_Dereference => Element;

18/3
        function Constant_Reference (Container : aliased in Holder)
        return Constant_Reference_Type;

19/3
        function Reference (Container : aliased in out Holder)
        return Reference_Type;

20/3
        procedure Assign (Target : in out Holder; Source : in Holder);

21/3
        function Copy (Source : Holder) return Holder;

22/3
        procedure Move (Target : in out Holder; Source : in out Holder);

23/3
     private

24/3
        ... -- <not specified by the language>

25/3
     end Ada.Containers.Indefinite_Holders;

26/3
The actual function for the generic formal function "=" on Element_Type
values is expected to define a reflexive and symmetric relationship and
return the same result value each time it is called with a particular
pair of values.  If it behaves in some other manner, the function "=" on
holder values returns an unspecified value.  The exact arguments and
number of calls of this generic formal function by the function "=" on
holder values are unspecified.

27/3
The type Holder is used to represent holder containers.  The type Holder
needs finalization (see *note 7.6::).

28/3
Empty_Holder represents an empty holder object.  If an object of type
Holder is not otherwise initialized, it is initialized to the same value
as Empty_Holder.

29/3
Some operations of this generic package have access-to-subprogram
parameters.  To ensure such operations are well-defined, they guard
against certain actions by the designated subprogram.  In particular,
some operations check for "tampering with the element" of a container
because they depend on the element of the container not being replaced.

30/3
A subprogram is said to <tamper with the element> of a holder object <H>
if:

31/3
   * It clears the element contained by <H>, that is, it calls the Clear
     procedure with <H> as a parameter;

32/3
   * It replaces the element contained by <H>, that is, it calls the
     Replace_Element procedure with <H> as a parameter;

33/3
   * It calls the Move procedure with <H> as a parameter;

34/3
   * It finalizes <H>.

35/4
When tampering with the element is <prohibited> for a particular holder
object <H>, Program_Error is propagated by a call of any
language-defined subprogram that is defined to tamper with the element
of <H>, leaving <H> unmodified.  These checks are made before any other
defined behavior of the body of the language-defined subprogram.

36/3
     function "=" (Left, Right : Holder) return Boolean;

37/3
          If Left and Right denote the same holder object, then the
          function returns True.  Otherwise, it compares the element
          contained in Left to the element contained in Right using the
          generic formal equality operator, returning the result of that
          operation.  Any exception raised during the evaluation of
          element equality is propagated.

38/3
     function To_Holder (New_Item : Element_Type) return Holder;

39/4
          Returns a nonempty holder containing an element initialized to
          New_Item.  To_Holder performs indefinite insertion (see *note
          A.18::).

40/3
     function Is_Empty (Container : Holder) return Boolean;

41/3
          Returns True if Container is empty, and False if it contains
          an element.

42/3
     procedure Clear (Container : in out Holder);

43/3
          Removes the element from Container.  Container is empty after
          a successful Clear operation.

44/3
     function Element (Container : Holder) return Element_Type;

45/3
          If Container is empty, Constraint_Error is propagated.
          Otherwise, returns the element stored in Container.

46/3
     procedure Replace_Element (Container : in out Holder;
                                New_Item  : in     Element_Type);

47/4
          Replace_Element assigns the value New_Item into Container,
          replacing any preexisting content of Container;
          Replace_Element performs indefinite insertion (see *note
          A.18::).  Container is not empty after a successful call to
          Replace_Element.

48/3
     procedure Query_Element
       (Container : in Holder;
        Process   : not null access procedure (Element : in Element_Type));

49/3
          If Container is empty, Constraint_Error is propagated.
          Otherwise, Query_Element calls Process.all with the contained
          element as the argument.  Tampering with the element of
          Container is prohibited during the execution of the call on
          Process.all.  Any exception raised by Process.all is
          propagated.

50/3
     procedure Update_Element
       (Container : in out Holder;
        Process   : not null access procedure (Element : in out Element_Type));

51/3
          If Container is empty, Constraint_Error is propagated.
          Otherwise, Update_Element calls Process.all with the contained
          element as the argument.  Tampering with the element of
          Container is prohibited during the execution of the call on
          Process.all.  Any exception raised by Process.all is
          propagated.

52/3
     type Constant_Reference_Type
           (Element : not null access constant Element_Type) is private
        with Implicit_Dereference => Element;

53/3
     type Reference_Type (Element : not null access Element_Type) is private
        with Implicit_Dereference => Element;

54/3
          The types Constant_Reference_Type and Reference_Type need
          finalization.

55/3
          The default initialization of an object of type
          Constant_Reference_Type or Reference_Type propagates
          Program_Error.

56/3
     function Constant_Reference (Container : aliased in Holder)
        return Constant_Reference_Type;

57/3
          This function (combined with the Implicit_Dereference aspect)
          provides a convenient way to gain read access to the contained
          element of a holder container.

58/3
          If Container is empty, Constraint_Error is propagated.
          Otherwise, Constant_Reference returns an object whose
          discriminant is an access value that designates the contained
          element.  Tampering with the elements of Container is
          prohibited while the object returned by Constant_Reference
          exists and has not been finalized.

59/3
     function Reference (Container : aliased in out Holder)
        return Reference_Type;

60/3
          This function (combined with the Implicit_Dereference aspects)
          provides a convenient way to gain read and write access to the
          contained element of a holder container.

61/3
          If Container is empty, Constraint_Error is propagated.
          Otherwise, Reference returns an object whose discriminant is
          an access value that designates the contained element.
          Tampering with the elements of Container is prohibited while
          the object returned by Reference exists and has not been
          finalized.

62/3
     procedure Assign (Target : in out Holder; Source : in Holder);

63/3
          If Target denotes the same object as Source, the operation has
          no effect.  If Source is empty, Clear (Target) is called.
          Otherwise, Replace_Element (Target, Element (Source)) is
          called.

64/3
     function Copy (Source : Holder) return Holder;

65/3
          If Source is empty, returns an empty holder container;
          otherwise, returns To_Holder (Element (Source)).

66/3
     procedure Move (Target : in out Holder; Source : in out Holder);

67/3
          If Target denotes the same object as Source, then the
          operation has no effect.  Otherwise, the element contained by
          Source (if any) is removed from Source and inserted into
          Target, replacing any preexisting content.  Source is empty
          after a successful call to Move.

                      _Bounded (Run-Time) Errors_

68/3
It is a bounded error for the actual function associated with a generic
formal subprogram, when called as part of an operation of this package,
to tamper with the element of any Holder parameter of the operation.
Either Program_Error is raised, or the operation works as defined on the
value of the Holder either prior to, or subsequent to, some or all of
the modifications to the Holder.

69/3
It is a bounded error to call any subprogram declared in the visible
part of Containers.Indefinite_Holders when the associated container has
been finalized.  If the operation takes Container as an in out
parameter, then it raises Constraint_Error or Program_Error.  Otherwise,
the operation either proceeds as it would for an empty container, or it
raises Constraint_Error or Program_Error.

                         _Erroneous Execution_

70/3
Execution is erroneous if the holder container associated with the
result of a call to Reference or Constant_Reference is finalized before
the result object returned by the call to Reference or
Constant_Reference is finalized.

                     _Implementation Requirements_

71/3
No storage associated with a holder object shall be lost upon assignment
or scope exit.

72/3
The execution of an assignment_statement for a holder container shall
have the effect of copying the element (if any) from the source holder
object to the target holder object.

                        _Implementation Advice_

73/3
Move should not copy the element, and should minimize copying of
internal data structures.

74/3
If an exception is propagated from a holder operation, no storage should
be lost, nor should the element be removed from a holder container
unless specified by the operation.


File: arm2012.info,  Node: A.18.19,  Next: A.18.20,  Prev: A.18.18,  Up: A.18

A.18.19 The Generic Package Containers.Bounded_Vectors
------------------------------------------------------

1/3
The language-defined generic package Containers.Bounded_Vectors provides
a private type Vector and a set of operations.  It provides the same
operations as the package Containers.Vectors (see *note A.18.2::), with
the difference that the maximum storage is bounded.

                          _Static Semantics_

2/3
The declaration of the generic library package
Containers.Bounded_Vectors has the same contents and semantics as
Containers.Vectors except:

3/3
   * The pragma Preelaborate is replaced with pragma Pure.

4/3
   * The type Vector is declared with a discriminant that specifies the
     capacity:

5/3
       type Vector (Capacity : Count_Type) is tagged private;

6/3
   * The type Vector needs finalization if and only if type Element_Type
     needs finalization.

7/3
   * In function Copy, if the Capacity parameter is equal to or greater
     than the length of Source, the vector capacity exactly equals the
     value of the Capacity parameter.

8/3
   * The description of Reserve_Capacity is replaced with:

9/3
          If the specified Capacity is larger than the capacity of
          Container, then Reserve_Capacity propagates Capacity_Error.
          Otherwise, the operation has no effect.

                      _Bounded (Run-Time) Errors_

10/3
It is a bounded error to assign from a bounded vector object while
tampering with elements or cursors of that object is prohibited.  Either
Program_Error is raised by the assignment, execution proceeds with the
target object prohibiting tampering with elements or cursors, or
execution proceeds normally.

                         _Erroneous Execution_

11/3
When a bounded vector object <V> is finalized, if tampering with cursors
is prohibited for <V> other than due to an assignment from another
vector, then execution is erroneous.  

                     _Implementation Requirements_

12/3
For each instance of Containers.Vectors and each instance of
Containers.Bounded_Vectors, if the two instances meet the following
conditions, then the output generated by the Vector'Output or
Vector'Write subprograms of either instance shall be readable by the
Vector'Input or Vector'Read of the other instance, respectively:

13/3
   * the Element_Type parameters of the two instances are statically
     matching subtypes of the same type; and

14/3
   * the output generated by Element_Type'Output or Element_Type'Write
     is readable by Element_Type'Input or Element_Type'Read,
     respectively (where Element_Type denotes the type of the two actual
     Element_Type parameters); and

15/3
   * the preceding two conditions also hold for the Index_Type
     parameters of the instances.

                        _Implementation Advice_

16/3
Bounded vector objects should be implemented without implicit pointers
or dynamic allocation.

17/3
The implementation advice for procedure Move to minimize copying does
not apply.


File: arm2012.info,  Node: A.18.20,  Next: A.18.21,  Prev: A.18.19,  Up: A.18

A.18.20 The Generic Package Containers.Bounded_Doubly_Linked_Lists
------------------------------------------------------------------

1/3
The language-defined generic package
Containers.Bounded_Doubly_Linked_Lists provides a private type List and
a set of operations.  It provides the same operations as the package
Containers.Doubly_Linked_Lists (see *note A.18.3::), with the difference
that the maximum storage is bounded.

                          _Static Semantics_

2/3
The declaration of the generic library package
Containers.Bounded_Doubly_Linked_Lists has the same contents and
semantics as Containers.Doubly_Linked_Lists except:

3/3
   * The pragma Preelaborate is replaced with pragma Pure.

4/3
   * The type List is declared with a discriminant that specifies the
     capacity (maximum number of elements) as follows:

5/3
       type List (Capacity : Count_Type) is tagged private;

6/3
   * The type List needs finalization if and only if type Element_Type
     needs finalization.

7/3
   * The allocation of internal storage includes a check that the
     capacity is not exceeded, and Capacity_Error is raised if this
     check fails.

8/3
   * In procedure Assign, if Source length is greater than Target
     capacity, then Capacity_Error is propagated.

9/3
   * The function Copy is replaced with:

10/3
       function Copy (Source : List; Capacity : Count_Type := 0)
          return List;

11/3
          If Capacity is 0, then the list capacity is the length of
          Source; if Capacity is equal to or greater than the length of
          Source, the list capacity equals the value of the Capacity
          parameter; otherwise, the operation propagates Capacity_Error.

12/3
   * In the three-parameter procedure Splice whose Source has type List,
     if the sum of the length of Target and the length of Source is
     greater than the capacity of Target, then Splice propagates
     Capacity_Error.

13/3
   * In the four-parameter procedure Splice, if the length of Target
     equals the capacity of Target, then Splice propagates
     Capacity_Error.

                      _Bounded (Run-Time) Errors_

14/3
It is a bounded error to assign from a bounded list object while
tampering with elements or cursors of that object is prohibited.  Either
Program_Error is raised by the assignment, execution proceeds with the
target object prohibiting tampering with elements or cursors, or
execution proceeds normally.

                         _Erroneous Execution_

15/3
When a bounded list object <L> is finalized, if tampering with cursors
is prohibited for <L> other than due to an assignment from another list,
then execution is erroneous.  

                     _Implementation Requirements_

16/3
For each instance of Containers.Doubly_Linked_Lists and each instance of
Containers.Bounded_Doubly_Linked_Lists, if the two instances meet the
following conditions, then the output generated by the List'Output or
List'Write subprograms of either instance shall be readable by the
List'Input or List'Read of the other instance, respectively:

17/3
   * the Element_Type parameters of the two instances are statically
     matching subtypes of the same type; and

18/3
   * the output generated by Element_Type'Output or Element_Type'Write
     is readable by Element_Type'Input or Element_Type'Read,
     respectively (where Element_Type denotes the type of the two actual
     Element_Type parameters).

                        _Implementation Advice_

19/3
Bounded list objects should be implemented without implicit pointers or
dynamic allocation.

20/3
The implementation advice for procedure Move to minimize copying does
not apply.


File: arm2012.info,  Node: A.18.21,  Next: A.18.22,  Prev: A.18.20,  Up: A.18

A.18.21 The Generic Package Containers.Bounded_Hashed_Maps
----------------------------------------------------------

1/3
The language-defined generic package Containers.Bounded_Hashed_Maps
provides a private type Map and a set of operations.  It provides the
same operations as the package Containers.Hashed_Maps (see *note
A.18.5::), with the difference that the maximum storage is bounded.

                          _Static Semantics_

2/3
The declaration of the generic library package
Containers.Bounded_Hashed_Maps has the same contents and semantics as
Containers.Hashed_Maps except:

3/3
   * The pragma Preelaborate is replaced with pragma Pure.

4/3
   * The type Map is declared with discriminants that specify both the
     capacity (number of elements) and modulus (number of distinct hash
     values) of the hash table as follows:

5/3
       type Map (Capacity : Count_Type;
                 Modulus  : Hash_Type) is tagged private;

6/3
   * The type Map needs finalization if and only if type Key_Type or
     type Element_Type needs finalization.

7/3
   * The description of Reserve_Capacity is replaced with:

8/3
          If the specified Capacity is larger than the capacity of
          Container, then Reserve_Capacity propagates Capacity_Error.
          Otherwise, the operation has no effect.

9/3
   * An additional operation is added immediately following
     Reserve_Capacity:

10/3
       function Default_Modulus (Capacity : Count_Type) return Hash_Type;

11/3
          Default_Modulus returns an implementation-defined value for
          the number of distinct hash values to be used for the given
          capacity (maximum number of elements).

12/3
   * The function Copy is replaced with:

13/3
       function Copy (Source   : Map;
                      Capacity : Count_Type := 0;
                      Modulus  : Hash_Type := 0) return Map;

14/3
          Returns a map with key/element pairs initialized from the
          values in Source.  If Capacity is 0, then the map capacity is
          the length of Source; if Capacity is equal to or greater than
          the length of Source, the map capacity is the value of the
          Capacity parameter; otherwise, the operation propagates
          Capacity_Error.  If the Modulus argument is 0, then the map
          modulus is the value returned by a call to Default_Modulus
          with the map capacity as its argument; otherwise, the map
          modulus is the value of the Modulus parameter.

                      _Bounded (Run-Time) Errors_

15/3
It is a bounded error to assign from a bounded map object while
tampering with elements or cursors of that object is prohibited.  Either
Program_Error is raised by the assignment, execution proceeds with the
target object prohibiting tampering with elements or cursors, or
execution proceeds normally.

                         _Erroneous Execution_

16/3
When a bounded map object <M> is finalized, if tampering with cursors is
prohibited for <M> other than due to an assignment from another map,
then execution is erroneous.  

                     _Implementation Requirements_

17/3
For each instance of Containers.Hashed_Maps and each instance of
Containers.Bounded_Hashed_Maps, if the two instances meet the following
conditions, then the output generated by the Map'Output or Map'Write
subprograms of either instance shall be readable by the Map'Input or
Map'Read of the other instance, respectively:

18/3
   * the Element_Type parameters of the two instances are statically
     matching subtypes of the same type; and

19/3
   * the output generated by Element_Type'Output or Element_Type'Write
     is readable by Element_Type'Input or Element_Type'Read,
     respectively (where Element_Type denotes the type of the two actual
     Element_Type parameters); and

20/3
   * the preceding two conditions also hold for the Key_Type parameters
     of the instances.

                        _Implementation Advice_

21/3
Bounded hashed map objects should be implemented without implicit
pointers or dynamic allocation.

22/3
The implementation advice for procedure Move to minimize copying does
not apply.


File: arm2012.info,  Node: A.18.22,  Next: A.18.23,  Prev: A.18.21,  Up: A.18

A.18.22 The Generic Package Containers.Bounded_Ordered_Maps
-----------------------------------------------------------

1/3
The language-defined generic package Containers.Bounded_Ordered_Maps
provides a private type Map and a set of operations.  It provides the
same operations as the package Containers.Ordered_Maps (see *note
A.18.6::), with the difference that the maximum storage is bounded.

                          _Static Semantics_

2/3
The declaration of the generic library package
Containers.Bounded_Ordered_Maps has the same contents and semantics as
Containers.Ordered_Maps except:

3/3
   * The pragma Preelaborate is replaced with pragma Pure.

4/3
   * The type Map is declared with a discriminant that specifies the
     capacity (maximum number of elements) as follows:

5/3
       type Map (Capacity : Count_Type) is tagged private;

6/3
   * The type Map needs finalization if and only if type Key_Type or
     type Element_Type needs finalization.

7/3
   * The allocation of a new node includes a check that the capacity is
     not exceeded, and Capacity_Error is raised if this check fails.

8/3
   * In procedure Assign, if Source length is greater than Target
     capacity, then Capacity_Error is propagated.

9/3
   * The function Copy is replaced with:

10/3
       function Copy (Source   : Map;
                      Capacity : Count_Type := 0) return Map;

11/3
          Returns a map with key/element pairs initialized from the
          values in Source.  If Capacity is 0, then the map capacity is
          the length of Source; if Capacity is equal to or greater than
          the length of Source, the map capacity is the specified value;
          otherwise, the operation propagates Capacity_Error.

                      _Bounded (Run-Time) Errors_

12/3
It is a bounded error to assign from a bounded map object while
tampering with elements or cursors of that object is prohibited.  Either
Program_Error is raised by the assignment, execution proceeds with the
target object prohibiting tampering with elements or cursors, or
execution proceeds normally.

                         _Erroneous Execution_

13/3
When a bounded map object <M> is finalized, if tampering with cursors is
prohibited for <M> other than due to an assignment from another map,
then execution is erroneous.  

                     _Implementation Requirements_

14/3
For each instance of Containers.Ordered_Maps and each instance of
Containers.Bounded_Ordered_Maps, if the two instances meet the following
conditions, then the output generated by the Map'Output or Map'Write
subprograms of either instance shall be readable by the Map'Input or
Map'Read of the other instance, respectively:

15/3
   * the Element_Type parameters of the two instances are statically
     matching subtypes of the same type; and

16/3
   * the output generated by Element_Type'Output or Element_Type'Write
     is readable by Element_Type'Input or Element_Type'Read,
     respectively (where Element_Type denotes the type of the two actual
     Element_Type parameters); and

17/3
   * the preceding two conditions also hold for the Key_Type parameters
     of the instances.

                        _Implementation Advice_

18/3
Bounded ordered map objects should be implemented without implicit
pointers or dynamic allocation.

19/3
The implementation advice for procedure Move to minimize copying does
not apply.


File: arm2012.info,  Node: A.18.23,  Next: A.18.24,  Prev: A.18.22,  Up: A.18

A.18.23 The Generic Package Containers.Bounded_Hashed_Sets
----------------------------------------------------------

1/3
The language-defined generic package Containers.Bounded_Hashed_Sets
provides a private type Set and a set of operations.  It provides the
same operations as the package Containers.Hashed_Sets (see *note
A.18.8::), with the difference that the maximum storage is bounded.

                          _Static Semantics_

2/3
The declaration of the generic library package
Containers.Bounded_Hashed_Sets has the same contents and semantics as
Containers.Hashed_Sets except:

3/3
   * The pragma Preelaborate is replaced with pragma Pure.

4/3
   * The type Set is declared with discriminants that specify both the
     capacity (number of elements) and modulus (number of distinct hash
     values) of the hash table as follows:

5/3
       type Set (Capacity : Count_Type;
                 Modulus  : Hash_Type) is tagged private;

6/3
   * The type Set needs finalization if and only if type Element_Type
     needs finalization.

7/3
   * The description of Reserve_Capacity is replaced with:

8/3
          If the specified Capacity is larger than the capacity of
          Container, then Reserve_Capacity propagates Capacity_Error.
          Otherwise, the operation has no effect.

9/3
   * An additional operation is added immediately following
     Reserve_Capacity:

10/3
       function Default_Modulus (Capacity : Count_Type) return Hash_Type;

11/3
          Default_Modulus returns an implementation-defined value for
          the number of distinct hash values to be used for the given
          capacity (maximum number of elements).

12/3
   * The function Copy is replaced with:

13/3
       function Copy (Source   : Set;
                      Capacity : Count_Type := 0;
                      Modulus  : Hash_Type := 0) return Set;

14/3
          Returns a set whose elements are initialized from the values
          in Source.  If Capacity is 0, then the set capacity is the
          length of Source; if Capacity is equal to or greater than the
          length of Source, the set capacity is the value of the
          Capacity parameter; otherwise, the operation propagates
          Capacity_Error.  If the Modulus argument is 0, then the set
          modulus is the value returned by a call to Default_Modulus
          with the set capacity as its argument; otherwise, the set
          modulus is the value of the Modulus parameter.

                      _Bounded (Run-Time) Errors_

15/3
It is a bounded error to assign from a bounded set object while
tampering with elements or cursors of that object is prohibited.  Either
Program_Error is raised by the assignment, execution proceeds with the
target object prohibiting tampering with elements or cursors, or
execution proceeds normally.

                         _Erroneous Execution_

16/3
When a bounded set object <S> is finalized, if tampering with cursors is
prohibited for <S> other than due to an assignment from another set,
then execution is erroneous.  

                     _Implementation Requirements_

17/3
For each instance of Containers.Hashed_Sets and each instance of
Containers.Bounded_Hashed_Sets, if the two instances meet the following
conditions, then the output generated by the Set'Output or Set'Write
subprograms of either instance shall be readable by the Set'Input or
Set'Read of the other instance, respectively:

18/3
   * the Element_Type parameters of the two instances are statically
     matching subtypes of the same type; and

19/3
   * the output generated by Element_Type'Output or Element_Type'Write
     is readable by Element_Type'Input or Element_Type'Read,
     respectively (where Element_Type denotes the type of the two actual
     Element_Type parameters).

                        _Implementation Advice_

20/3
Bounded hashed set objects should be implemented without implicit
pointers or dynamic allocation.

21/3
The implementation advice for procedure Move to minimize copying does
not apply.


File: arm2012.info,  Node: A.18.24,  Next: A.18.25,  Prev: A.18.23,  Up: A.18

A.18.24 The Generic Package Containers.Bounded_Ordered_Sets
-----------------------------------------------------------

1/3
The language-defined generic package Containers.Bounded_Ordered_Sets
provides a private type Set and a set of operations.  It provides the
same operations as the package Containers.Ordered_Sets (see *note
A.18.9::), with the difference that the maximum storage is bounded.

                          _Static Semantics_

2/3
The declaration of the generic library package
Containers.Bounded_Ordered_Sets has the same contents and semantics as
Containers.Ordered_Sets except:

3/3
   * The pragma Preelaborate is replaced with pragma Pure.

4/3
   * The type Set is declared with a discriminant that specifies the
     capacity (maximum number of elements) as follows:

5/3
       type Set (Capacity : Count_Type) is tagged private;

6/3
   * The type Set needs finalization if and only if type Element_Type
     needs finalization.

7/3
   * If Insert (or Include) adds an element, a check is made that the
     capacity is not exceeded, and Capacity_Error is raised if this
     check fails.

8/3
   * In procedure Assign, if Source length is greater than Target
     capacity, then Capacity_Error is propagated.

9/3
   * The function Copy is replaced with:

10/3
       function Copy (Source   : Set;
                      Capacity : Count_Type := 0) return Set;

11/3
          Returns a set whose elements are initialized from the values
          in Source.  If Capacity is 0, then the set capacity is the
          length of Source; if Capacity is equal to or greater than the
          length of Source, the set capacity is the specified value;
          otherwise, the operation propagates Capacity_Error.

                      _Bounded (Run-Time) Errors_

12/3
It is a bounded error to assign from a bounded set object while
tampering with elements or cursors of that object is prohibited.  Either
Program_Error is raised by the assignment, execution proceeds with the
target object prohibiting tampering with elements or cursors, or
execution proceeds normally.

                         _Erroneous Execution_

13/3
When a bounded set object <S> is finalized, if tampering with cursors is
prohibited for <S> other than due to an assignment from another set,
then execution is erroneous.  

                     _Implementation Requirements_

14/3
For each instance of Containers.Ordered_Sets and each instance of
Containers.Bounded_Ordered_Sets, if the two instances meet the following
conditions, then the output generated by the Set'Output or Set'Write
subprograms of either instance shall be readable by the Set'Input or
Set'Read of the other instance, respectively:

15/3
   * the Element_Type parameters of the two instances are statically
     matching subtypes of the same type; and

16/3
   * the output generated by Element_Type'Output or Element_Type'Write
     is readable by Element_Type'Input or Element_Type'Read,
     respectively (where Element_Type denotes the type of the two actual
     Element_Type parameters).

                        _Implementation Advice_

17/3
Bounded ordered set objects should be implemented without implicit
pointers or dynamic allocation.

18/3
The implementation advice for procedure Move to minimize copying does
not apply.


File: arm2012.info,  Node: A.18.25,  Next: A.18.26,  Prev: A.18.24,  Up: A.18

A.18.25 The Generic Package Containers.Bounded_Multiway_Trees
-------------------------------------------------------------

1/3
The language-defined generic package Containers.Bounded_Multiway_Trees
provides a private type Tree and a set of operations.  It provides the
same operations as the package Containers.Multiway_Trees (see *note
A.18.10::), with the difference that the maximum storage is bounded.

                          _Static Semantics_

2/3
The declaration of the generic library package
Containers.Bounded_Multiway_Trees has the same contents and semantics as
Containers.Multiway_Trees except:

3/3
   * The pragma Preelaborate is replaced with pragma Pure.

4/3
   * The type Tree is declared with a discriminant that specifies the
     capacity (maximum number of elements) as follows:

5/3
       type Tree (Capacity : Count_Type) is tagged private;

6/3
   * The type Tree needs finalization if and only if type Element_Type
     needs finalization.

7/3
   * The allocation of internal storage includes a check that the
     capacity is not exceeded, and Capacity_Error is raised if this
     check fails.

8/3
   * In procedure Assign, if Source length is greater than Target
     capacity, then Capacity_Error is propagated.

9/3
   * Function Copy is declared as follows:

10/4
       function Copy (Source : Tree; Capacity : Count_Type := 0)
          return Tree;

11/3
     If Capacity is 0, then the tree capacity is the count of Source; if
     Capacity is equal to or greater than Source.Count, the tree
     capacity equals the value of the Capacity parameter; otherwise, the
     operation propagates Capacity_Error.

12/3
   * In the five-parameter procedure Splice_Subtree, if Source is not
     the same object as Target, and if the sum of Target.Count and
     Subtree_Node_Count (Position) is greater than Target.Capacity, then
     Splice_Subtree propagates Capacity_Error.

13/3
   * In the five-parameter procedure Splice_Children, if Source is not
     the same object as Target, and if the sum of Target.Count and
     Subtree_Node_Count (Source_Parent)-1 is greater than
     Target.Capacity, then Splice_Children propagates Capacity_Error.

                      _Bounded (Run-Time) Errors_

14/3
It is a bounded error to assign from a bounded tree object while
tampering with elements or cursors of that object is prohibited.  Either
Program_Error is raised by the assignment, execution proceeds with the
target object prohibiting tampering with elements or cursors, or
execution proceeds normally.

                         _Erroneous Execution_

15/3
When a bounded tree object <T> is finalized, if tampering with cursors
is prohibited for <T> other than due to an assignment from another tree,
then execution is erroneous.  

                     _Implementation Requirements_

16/3
For each instance of Containers.Multiway_Trees and each instance of
Containers.Bounded_Multiway_Trees, if the two instances meet the
following conditions, then the output generated by the Tree'Output or
Tree'Write subprograms of either instance shall be readable by the
Tree'Input or Tree'Read of the other instance, respectively:

17/3
   * the Element_Type parameters of the two instances are statically
     matching subtypes of the same type; and

18/3
   * the output generated by Element_Type'Output or Element_Type'Write
     is readable by Element_Type'Input or Element_Type'Read,
     respectively (where Element_Type denotes the type of the two actual
     Element_Type parameters).

                        _Implementation Advice_

19/3
Bounded tree objects should be implemented without implicit pointers or
dynamic allocation.

20/3
The implementation advice for procedure Move to minimize copying does
not apply.


File: arm2012.info,  Node: A.18.26,  Next: A.18.27,  Prev: A.18.25,  Up: A.18

A.18.26 Array Sorting
---------------------

1/3
The language-defined generic procedures Containers.Generic_Array_Sort,
Containers.Generic_Constrained_Array_Sort, and Containers.Generic_Sort
provide sorting on arbitrary array types.

                          _Static Semantics_

2/2
The generic library procedure Containers.Generic_Array_Sort has the
following declaration:

3/2
     generic
        type Index_Type is (<>);
        type Element_Type is private;
        type Array_Type is array (Index_Type range <>) of Element_Type;
        with function "<" (Left, Right : Element_Type)
           return Boolean is <>;
     procedure Ada.Containers.Generic_Array_Sort (Container : in out Array_Type);
     pragma Pure(Ada.Containers.Generic_Array_Sort);

4/2
          Reorders the elements of Container such that the elements are
          sorted smallest first as determined by the generic formal "<"
          operator provided.  Any exception raised during evaluation of
          "<" is propagated.

5/3
          The actual function for the generic formal function "<" of
          Generic_Array_Sort is expected to return the same value each
          time it is called with a particular pair of element values.
          It should define a strict weak ordering relationship (see
          *note A.18::); it should not modify Container.  If the actual
          for "<" behaves in some other manner, the behavior of the
          instance of Generic_Array_Sort is unspecified.  The number of
          times Generic_Array_Sort calls "<" is unspecified.

6/2
The generic library procedure Containers.Generic_Constrained_Array_Sort
has the following declaration:

7/2
     generic
        type Index_Type is (<>);
        type Element_Type is private;
        type Array_Type is array (Index_Type) of Element_Type;
        with function "<" (Left, Right : Element_Type)
           return Boolean is <>;
     procedure Ada.Containers.Generic_Constrained_Array_Sort
           (Container : in out Array_Type);
     pragma Pure(Ada.Containers.Generic_Constrained_Array_Sort);

8/2
          Reorders the elements of Container such that the elements are
          sorted smallest first as determined by the generic formal "<"
          operator provided.  Any exception raised during evaluation of
          "<" is propagated.

9/3
          The actual function for the generic formal function "<" of
          Generic_Constrained_Array_Sort is expected to return the same
          value each time it is called with a particular pair of element
          values.  It should define a strict weak ordering relationship
          (see *note A.18::); it should not modify Container.  If the
          actual for "<" behaves in some other manner, the behavior of
          the instance of Generic_Constrained_Array_Sort is unspecified.
          The number of times Generic_Constrained_Array_Sort calls "<"
          is unspecified.

9.1/3
The generic library procedure Containers.Generic_Sort has the following
declaration:

9.2/4
     generic
        type Index_Type is (<>);
        with function Before (Left, Right : Index_Type) return Boolean;
        with procedure Swap (Left, Right : in Index_Type);
     procedure Ada.Containers.Generic_Sort
           (First, Last : Index_Type'Base);
     pragma Pure(Ada.Containers.Generic_Sort);

9.3/3
          Reorders the elements of an indexable structure, over the
          range First ..  Last, such that the elements are sorted in the
          ordering determined by the generic formal function Before;
          Before should return True if Left is to be sorted before
          Right.  The generic formal Before compares the elements having
          the given indices, and the generic formal Swap exchanges the
          values of the indicated elements.  Any exception raised during
          evaluation of Before or Swap is propagated.

9.4/3
          The actual function for the generic formal function Before of
          Generic_Sort is expected to return the same value each time it
          is called with index values that identify a particular pair of
          element values.  It should define a strict weak ordering
          relationship (see *note A.18::); it should not modify the
          elements.  The actual function for the generic formal Swap
          should exchange the values of the indicated elements.  If the
          actual for either Before or Swap behaves in some other manner,
          the behavior of Generic_Sort is unspecified.  The number of
          times the Generic_Sort calls Before or Swap is unspecified.

                        _Implementation Advice_

10/2
The worst-case time complexity of a call on an instance of
Containers.Generic_Array_Sort or
Containers.Generic_Constrained_Array_Sort should be <O>(<N>**2) or
better, and the average time complexity should be better than
<O>(<N>**2), where <N> is the length of the Container parameter.

11/2
Containers.Generic_Array_Sort and
Containers.Generic_Constrained_Array_Sort should minimize copying of
elements.

12/3
The worst-case time complexity of a call on an instance of
Containers.Generic_Sort should be <O>(<N>**2) or better, and the average
time complexity should be better than <O>(<N>**2), where <N> is the
difference between the Last and First parameters plus 1.

13/3
Containers.Generic_Sort should minimize calls to the generic formal
Swap.


File: arm2012.info,  Node: A.18.27,  Next: A.18.28,  Prev: A.18.26,  Up: A.18

A.18.27 The Generic Package Containers.Synchronized_Queue_Interfaces
--------------------------------------------------------------------

1/3
The language-defined generic package
Containers.Synchronized_Queue_Interfaces provides interface type Queue,
and a set of operations for that type.  Interface Queue specifies a
first-in, first-out queue.

                          _Static Semantics_

2/3
The generic library package Containers.Synchronized_Queue_Interfaces has
the following declaration:

3/3
     generic
        type Element_Type is private;
     package Ada.Containers.Synchronized_Queue_Interfaces is
        pragma Pure(Synchronized_Queue_Interfaces);

4/3
        type Queue is synchronized interface;

5/3
        procedure Enqueue
          (Container : in out Queue;
           New_Item  : in     Element_Type) is abstract
            with Synchronization => By_Entry;

6/3
        procedure Dequeue
          (Container : in out Queue;
           Element   :    out Element_Type) is abstract
            with Synchronization => By_Entry;

7/3
        function Current_Use (Container : Queue) return Count_Type is abstract;
        function Peak_Use (Container : Queue) return Count_Type is abstract;

8/3
     end Ada.Containers.Synchronized_Queue_Interfaces;

9/3
     procedure Enqueue
       (Container : in out Queue;
        New_Item  : in     Element_Type) is abstract;

10/3
          A queue type that implements this interface is allowed to have
          a bounded <capacity>.  If the queue object has a bounded
          capacity, and the number of existing elements equals the
          capacity, then Enqueue blocks until storage becomes available;
          otherwise, Enqueue does not block.  In any case, it then
          copies New_Item onto the queue.

11/3
     procedure Dequeue
       (Container : in out Queue;
        Element   :    out Element_Type) is abstract;

12/3
          If the queue is empty, then Dequeue blocks until an item
          becomes available.  In any case, it then assigns the element
          at the head of the queue to Element, and removes it from the
          queue.

13/3
     function Current_Use (Container : Queue) return Count_Type is abstract;

14/3
          Returns the number of elements currently in the queue.

15/3
     function Peak_Use (Container : Queue) return Count_Type is abstract;

16/3
          Returns the maximum number of elements that have been in the
          queue at any one time.

     NOTES

17/3
     51  Unlike other language-defined containers, there are no queues
     whose element types are indefinite.  Elements of an indefinite type
     can be handled by defining the element of the queue to be a holder
     container (see *note A.18.18::) of the indefinite type, or to be an
     explicit access type that designates the indefinite type.


File: arm2012.info,  Node: A.18.28,  Next: A.18.29,  Prev: A.18.27,  Up: A.18

A.18.28 The Generic Package Containers.Unbounded_Synchronized_Queues
--------------------------------------------------------------------

                          _Static Semantics_

1/3
The language-defined generic package
Containers.Unbounded_Synchronized_Queues provides type Queue, which
implements the interface type
Containers.Synchronized_Queue_Interfaces.Queue.

2/3
     with System;
     with Ada.Containers.Synchronized_Queue_Interfaces;
     generic
        with package Queue_Interfaces is new Ada.Containers.Synchronized_Queue_Interfaces (<>);
        Default_Ceiling : System.Any_Priority := System.Priority'Last;
     package Ada.Containers.Unbounded_Synchronized_Queues is
        pragma Preelaborate(Unbounded_Synchronized_Queues);

3/3
        package Implementation is
           ... -- <not specified by the language>
        end Implementation;

4/3
        protected type Queue
             (Ceiling : System.Any_Priority := Default_Ceiling)
                with Priority => Ceiling is
             new Queue_Interfaces.Queue with

5/3
           overriding
           entry Enqueue (New_Item : in Queue_Interfaces.Element_Type);
           overriding
           entry Dequeue (Element : out Queue_Interfaces.Element_Type);

6/3
           overriding
           function Current_Use return Count_Type;
           overriding
           function Peak_Use return Count_Type;

7/3
        private
           ... -- <not specified by the language>
        end Queue;

8/3
     private

9/3
        ... -- <not specified by the language>

10/3
     end Ada.Containers.Unbounded_Synchronized_Queues;

11/3
The type Queue is used to represent task-safe queues.

12/3
The capacity for instances of type Queue is unbounded.


File: arm2012.info,  Node: A.18.29,  Next: A.18.30,  Prev: A.18.28,  Up: A.18

A.18.29 The Generic Package Containers.Bounded_Synchronized_Queues
------------------------------------------------------------------

                          _Static Semantics_

1/3
The language-defined generic package
Containers.Bounded_Synchronized_Queues provides type Queue, which
implements the interface type
Containers.Synchronized_Queue_Interfaces.Queue.

2/3
     with System;
     with Ada.Containers.Synchronized_Queue_Interfaces;
     generic
        with package Queue_Interfaces is new Ada.Containers.Synchronized_Queue_Interfaces (<>);
        Default_Capacity : Count_Type;
        Default_Ceiling  : System.Any_Priority := System.Priority'Last;
     package Ada.Containers.Bounded_Synchronized_Queues is
        pragma Preelaborate(Bounded_Synchronized_Queues);

3/3
        package Implementation is
           ... -- <not specified by the language>
        end Implementation;

4/3
        protected type Queue
             (Capacity : Count_Type := Default_Capacity;
              Ceiling  : System.Any_Priority := Default_Ceiling)
                with Priority => Ceiling is
             new Queue_Interfaces.Queue with

5/3
           overriding
           entry Enqueue (New_Item : in Queue_Interfaces.Element_Type);
           overriding
           entry Dequeue (Element : out Queue_Interfaces.Element_Type);

6/3
           overriding
           function Current_Use return Count_Type;
           overriding
           function Peak_Use return Count_Type;

7/3
        private
           ... -- <not specified by the language>
        end Queue;

8/3
     private

9/3
        ... -- <not specified by the language>

10/3
     end Ada.Containers.Bounded_Synchronized_Queues;

11/3
The semantics are the same as for Unbounded_Synchronized_Queues, except:

12/3
   * The capacity for instances of type Queue is bounded and specified
     by the discriminant Capacity.

                        _Implementation Advice_

13/3
Bounded queue objects should be implemented without implicit pointers or
dynamic allocation.


File: arm2012.info,  Node: A.18.30,  Next: A.18.31,  Prev: A.18.29,  Up: A.18

A.18.30 The Generic Package Containers.Unbounded_Priority_Queues
----------------------------------------------------------------

                          _Static Semantics_

1/3
The language-defined generic package
Containers.Unbounded_Priority_Queues provides type Queue, which
implements the interface type
Containers.Synchronized_Queue_Interfaces.Queue.

2/3
     with System;
     with Ada.Containers.Synchronized_Queue_Interfaces;
     generic
        with package Queue_Interfaces is new Ada.Containers.Synchronized_Queue_Interfaces (<>);
        type Queue_Priority is private;
        with function Get_Priority
          (Element : Queue_Interfaces.Element_Type) return Queue_Priority is <>;
        with function Before
          (Left, Right : Queue_Priority) return Boolean is <>;
        Default_Ceiling : System.Any_Priority := System.Priority'Last;
     package Ada.Containers.Unbounded_Priority_Queues is
        pragma Preelaborate(Unbounded_Priority_Queues);

3/3
        package Implementation is
           ... -- <not specified by the language>
        end Implementation;

4/3
        protected type Queue
             (Ceiling : System.Any_Priority := Default_Ceiling)
                with Priority => Ceiling is
             new Queue_Interfaces.Queue with

5/3
           overriding
           entry Enqueue (New_Item : in Queue_Interfaces.Element_Type);
           overriding
           entry Dequeue (Element : out Queue_Interfaces.Element_Type);

6/3
           not overriding
           procedure Dequeue_Only_High_Priority
             (At_Least : in     Queue_Priority;
              Element  : in out Queue_Interfaces.Element_Type;
              Success  :    out Boolean);

7/3
           overriding
           function Current_Use return Count_Type;
           overriding
           function Peak_Use return Count_Type;

8/3
        private
           ... -- <not specified by the language>
        end Queue;

9/3
     private

10/3
        ... -- <not specified by the language>

11/3
     end Ada.Containers.Unbounded_Priority_Queues;

12/3
The type Queue is used to represent task-safe priority queues.

13/3
The capacity for instances of type Queue is unbounded.

14/3
Two elements <E1> and <E2> are equivalent if Before(Get_Priority(<E1>),
Get_Priority(<E2>)) and Before(Get_Priority(<E2>), Get_Priority(<E1>))
both return False.

15/3
The actual functions for Get_Priority and Before are expected to return
the same value each time they are called with the same actuals, and
should not modify their actuals.  Before should define a strict weak
ordering relationship (see *note A.18::).  If the actual functions
behave in some other manner, the behavior of Unbounded_Priority_Queues
is unspecified.

16/3
Enqueue inserts an item according to the order specified by the Before
function on the result of Get_Priority on the elements; Before should
return True if Left is to be inserted before Right.  If the queue
already contains elements equivalent to New_Item, then it is inserted
after the existing equivalent elements.

17/3
For a call on Dequeue_Only_High_Priority, if the head of the nonempty
queue is <E>, and the function Before(At_Least, Get_Priority(<E>))
returns False, then <E> is assigned to Element and then removed from the
queue, and Success is set to True; otherwise, Success is set to False
and Element is unchanged.


File: arm2012.info,  Node: A.18.31,  Next: A.18.32,  Prev: A.18.30,  Up: A.18

A.18.31 The Generic Package Containers.Bounded_Priority_Queues
--------------------------------------------------------------

                          _Static Semantics_

1/3
The language-defined generic package Containers.Bounded_Priority_Queues
provides type Queue, which implements the interface type
Containers.Synchronized_Queue_Interfaces.Queue.

2/3
     with System;
     with Ada.Containers.Synchronized_Queue_Interfaces;
     generic
        with package Queue_Interfaces is new Ada.Containers.Synchronized_Queue_Interfaces (<>);
        type Queue_Priority is private;
        with function Get_Priority
          (Element : Queue_Interfaces.Element_Type) return Queue_Priority is <>;
        with function Before
          (Left, Right : Queue_Priority) return Boolean is <>;
        Default_Capacity : Count_Type;
        Default_Ceiling  : System.Any_Priority := System.Priority'Last;
     package Ada.Containers.Bounded_Priority_Queues is
        pragma Preelaborate(Bounded_Priority_Queues);

3/3
        package Implementation is
           ... -- <not specified by the language>
        end Implementation;

4/3
        protected type Queue
             (Capacity : Count_Type := Default_Capacity;
              Ceiling  : System.Any_Priority := Default_Ceiling)
                with Priority => Ceiling is
           new Queue_Interfaces.Queue with

5/3
           overriding
           entry Enqueue (New_Item : in Queue_Interfaces.Element_Type);
           overriding
           entry Dequeue (Element : out Queue_Interfaces.Element_Type);

6/3
           not overriding
           procedure Dequeue_Only_High_Priority
             (At_Least : in     Queue_Priority;
              Element  : in out Queue_Interfaces.Element_Type;
              Success  :    out Boolean);

7/3
           overriding
           function Current_Use return Count_Type;
           overriding
           function Peak_Use return Count_Type;

8/3
        private
           ... -- <not specified by the language>
        end Queue;

9/3
     private

10/3
        ... -- <not specified by the language>

11/3
     end Ada.Containers.Bounded_Priority_Queues;

12/3
The semantics are the same as for Unbounded_Priority_Queues, except:

13/3
   * The capacity for instances of type Queue is bounded and specified
     by the discriminant Capacity.

                        _Implementation Advice_

14/3
Bounded priority queue objects should be implemented without implicit
pointers or dynamic allocation.


File: arm2012.info,  Node: A.18.32,  Prev: A.18.31,  Up: A.18

A.18.32 Example of Container Use
--------------------------------

                              _Examples_

1/3
The following example is an implementation of Dijkstra's shortest path
algorithm in a directed graph with positive distances.  The graph is
represented by a map from nodes to sets of edges.

2/3
     with Ada.Containers.Vectors;
     with Ada.Containers.Doubly_Linked_Lists;
     use Ada.Containers;
     generic
        type Node is range <>;
     package Shortest_Paths is
        type Distance is new Float range 0.0 .. Float'Last;
        type Edge is record
           To, From : Node;
           Length   : Distance;
        end record;

3/3
        package Node_Maps is new Vectors (Node, Node);
        -- <The algorithm builds a map to indicate the node used to reach a given>
        -- <node in the shortest distance.>

4/3
        package Adjacency_Lists is new Doubly_Linked_Lists (Edge);
        use Adjacency_Lists;

5/3
        package Graphs is new Vectors (Node, Adjacency_Lists.List);

6/3
        package Paths is new Doubly_Linked_Lists (Node);

7/3
        function Shortest_Path
          (G : Graphs.Vector; Source : Node; Target : Node) return Paths.List
           with Pre => G (Source) /= Adjacency_Lists.Empty_List;

8/3
     end Shortest_Paths;

9/3
     package body Shortest_Paths is
        function Shortest_Path
          (G : Graphs.Vector; Source : Node; Target : Node) return Paths.List
        is
           use Adjacency_Lists, Node_Maps, Paths, Graphs;
           Reached  : array (Node) of Boolean := (others => False);
           -- <The set of nodes whose shortest distance to the source is known.>

10/3
           Reached_From : array (Node) of Node;
           So_Far   : array (Node) of Distance := (others => Distance'Last);
           The_Path : Paths.List := Paths.Empty_List;
           Nearest_Distance : Distance;
           Next     : Node;
        begin
           So_Far(Source)  := 0.0;

11/3
           while not Reached(Target) loop
              Nearest_Distance := Distance'Last;

12/3
              -- <Find closest node not reached yet, by iterating over all nodes.>
              -- <A more efficient algorithm uses a priority queue for this step.>

13/3
              Next := Source;
              for N in Node'First .. Node'Last loop
                 if not Reached(N)
                   and then So_Far(N) < Nearest_Distance then
                      Next := N;
                      Nearest_Distance := So_Far(N);
                 end if;
              end loop;

14/3
              if Nearest_Distance = Distance'Last then
                 -- <No next node found, graph is not connected>
                 return Paths.Empty_List;

15/3
              else
                 Reached(Next) := True;
              end if;

16/3
              -- <Update minimum distance to newly reachable nodes.>

17/3
              for E of G (Next) loop
                 if not Reached(E.To) then
                    Nearest_Distance := E.Length + So_Far(Next);

18/3
                    if Nearest_Distance < So_Far(E.To) then
                       Reached_From(E.To) := Next;
                       So_Far(E.To) := Nearest_Distance;
                    end if;
                 end if;
              end loop;
           end loop;

19/3
           -- <Rebuild path from target to source.>

20/3
           declare
              N : Node := Target;
           begin
              while N /= Source loop
                 N := Reached_From(N);
                 Prepend (The_Path, N);
              end loop;
           end;

21/3
           return The_Path;
        end;
     end Shortest_Paths;

22/3
Note that the effect of the Constant_Indexing aspect (on type Vector)
and the Implicit_Dereference aspect (on type Reference_Type) is that

23/3
     G (Next)

24/3
is a convenient short hand for

25/3
     G.Constant_Reference (Next).Element.all

26/3
Similarly, the effect of the loop:

27/3
     for E of G (Next) loop
        if not Reached(E.To) then
           ...
        end if;
     end loop;

28/3
is the same as:

29/4
     for C in G (Next).Iterate loop
        declare
           E : Edge renames G (Next)(C);
        begin
           if not Reached(E.To) then
              ...
           end if;
        end;
     end loop;

30/3
which is the same as:

31/4
     declare
        L : Adjacency_Lists.List renames G (Next);
        C : Adjacency_Lists.Cursor := L.First;
     begin
        while Has_Element (C) loop
           declare
              E : Edge renames L(C);
           begin
              if not Reached(E.To) then
                 ...
              end if;
           end;
           C := L.Next (C);
        end loop;
     end;


File: arm2012.info,  Node: A.19,  Prev: A.18,  Up: Annex A

A.19 The Package Locales
========================

1/3
A <locale> identifies a geopolitical place or region and its associated
language, which can be used to determine other
internationalization-related characteristics.

                          _Static Semantics_

2/3
The library package Locales has the following declaration:

3/3
     package Ada.Locales is
        pragma Preelaborate(Locales);
        pragma Remote_Types(Locales);

4/4
        type Language_Code is new String (1 .. 3)
           with Dynamic_Predicate =>
              (for all E of Language_Code => E in 'a' .. 'z');
        type Country_Code is new String (1 .. 2)
           with Dynamic_Predicate =>
              (for all E of Country_Code  => E in 'A' .. 'Z');

5/3
        Language_Unknown : constant Language_Code := "und";
        Country_Unknown : constant Country_Code := "ZZ";

6/3
        function Language return Language_Code;
        function Country return Country_Code;

7/3
     end Ada.Locales;

8/3
The <active locale> is the locale associated with the partition of the
current task.

9/3
Language_Code is a lower-case string representation of an ISO 639-3
alpha-3 code that identifies a language.

10/3
Country_Code is an upper-case string representation of an ISO 3166-1
alpha-2 code that identifies a country.

11/3
Function Language returns the code of the language associated with the
active locale.  If the Language_Code associated with the active locale
cannot be determined from the environment, then Language returns
Language_Unknown.

12/3
Function Country returns the code of the country associated with the
active locale.  If the Country_Code associated with the active locale
cannot be determined from the environment, then Country returns
Country_Unknown.


File: arm2012.info,  Node: Annex B,  Next: Annex C,  Prev: Annex A,  Up: Top

Annex B Interface to Other Languages
************************************

1
This Annex describes features for writing mixed-language programs.
General interface support is presented first; then specific support for
C, COBOL, and Fortran is defined, in terms of language interface
packages for each of these languages.

                     _Implementation Requirements_

2/3
Support for interfacing to any foreign language is optional.  However,
an implementation shall not provide any optional aspect, attribute,
library unit, or pragma having the same name as an aspect, attribute,
library unit, or pragma (respectively) specified in the subclauses of
this Annex unless the provided construct is either as specified in those
subclauses or is more limited in capability than that required by those
subclauses.  A program that attempts to use an unsupported capability of
this Annex shall either be identified by the implementation before run
time or shall raise an exception at run time.

* Menu:

* B.1 ::      Interfacing Aspects
* B.2 ::      The Package Interfaces
* B.3 ::      Interfacing with C and C++
* B.4 ::      Interfacing with COBOL
* B.5 ::      Interfacing with Fortran


File: arm2012.info,  Node: B.1,  Next: B.2,  Up: Annex B

B.1 Interfacing Aspects
=======================

0.1/3
An <interfacing> aspect is a representation aspect that is one of the
aspects Import, Export, Link_Name, External_Name, or Convention.

1/3
Specifying the Import aspect to have the value True is used to import an
entity defined in a foreign language into an Ada program, thus allowing
a foreign-language subprogram to be called from Ada, or a
foreign-language variable to be accessed from Ada.  In contrast, 
specifying the Export aspect to have the value True is used to export an
Ada entity to a foreign language, thus allowing an Ada subprogram to be
called from a foreign language, or an Ada object to be accessed from a
foreign language.  The Import and Export aspects are intended primarily
for objects and subprograms, although implementations are allowed to
support other entities.  The Link_Name and External_Name aspects are
used to specify the link name and external name, respectively, to be
used to identify imported or exported entities in the external
environment.  

2/3
The Convention aspect is used to indicate that an Ada entity should use
the conventions of another language.  It is intended primarily for types
and "callback" subprograms.  For example, "with Convention => Fortran"
on the declaration of an array type Matrix implies that Matrix should be
represented according to the conventions of the supported Fortran
implementation, namely column-major order.

3
A pragma Linker_Options is used to specify the system linker parameters
needed when a given compilation unit is included in a partition.

                               _Syntax_

4/3
     The form of a pragma Linker_Options is as follows:

     <Paragraphs 5 through 7 were moved to *note Annex J::, "*note Annex
     J:: Obsolescent Features".>

8
       pragma Linker_Options(<string_>expression);

9
     A pragma Linker_Options is allowed only at the place of a
     declarative_item.

9.1/3
     <This paragraph was deleted.>

                        _Name Resolution Rules_

9.2/3
The Import and Export aspects are of type Boolean.

10/3
The Link_Name and External_Name aspects are of type String.

10.1/3
The expected type for the <string_>expression in pragma Linker_Options
is String.

                           _Legality Rules_

11/3
The aspect Convention shall be specified by a <convention_>identifier
which shall be the name of a <convention>.  The convention names are
implementation defined, except for certain language-defined ones, such
as Ada and Intrinsic, as explained in *note 6.3.1::, "*note 6.3.1::
Conformance Rules".  Additional convention names generally represent the
calling conventions of foreign languages, language implementations, or
specific run-time models.  The convention of a callable entity is its
<calling convention>.

12
If <L> is a <convention_>identifier for a language, then a type T is
said to be <compatible with convention L>, (alternatively, is said to be
an <L-compatible type>) if any of the following conditions are met:

13
   * T is declared in a language interface package corresponding to <L>
     and is defined to be <L>-compatible (see *note B.3::, *note
     B.3.1::, *note B.3.2::, *note B.4::, *note B.5::),

14/3
   * Convention <L> has been specified for T, and T is <eligible for
     convention L>; that is:

14.1/4
             * T is an enumeration type such that all internal codes
               (whether assigned by default or explicitly) are within an
               implementation-defined range that includes at least the
               range of values 0 ..  2**15-1;

15
             * T is an array type with either an unconstrained or
               statically-constrained first subtype, and its component
               type is <L>-compatible,

16
             * T is a record type that has no discriminants and that
               only has components with statically-constrained subtypes,
               and each component type is <L>-compatible,

17/3
             * T is an access-to-object type, its designated type is
               <L>-compatible, and its designated subtype is not an
               unconstrained array subtype,

18
             * T is an access-to-subprogram type, and its designated
               profile's parameter and result types are all
               <L>-compatible.

19
   * T is derived from an <L>-compatible type,

20
   * The implementation permits T as an <L>-compatible type.

21/3
If the Convention aspect is specified for a type, then the type shall
either be compatible with or eligible for the specified convention.

22/3
Notwithstanding any rule to the contrary, a declaration with a True
Import aspect shall not have a completion.

23/3
An entity with a True Import aspect (or Export aspect) is said to be
<imported> (respectively, <exported>).  An entity shall not be both
imported and exported.

24
The declaration of an imported object shall not include an explicit
initialization expression.  Default initializations are not performed.

25/3
The type of an imported or exported object shall be compatible with the
specified Convention aspect, if any.

26/3
For an imported or exported subprogram, the result and parameter types
shall each be compatible with the specified Convention aspect, if any.

27/3
The aspect_definition (if any) used to directly specify an Import,
Export, External_Name, or Link_Name aspect shall be a static expression.
The <string_>expression of a pragma Linker_Options shall be static.  An
External_Name or Link_Name aspect shall be specified only for an entity
that is either imported or exported.

                          _Static Semantics_

<Paragraphs 28 and 29 were deleted.>

30/3
The Convention aspect represents the calling convention or
representation convention of the entity.  For an access-to-subprogram
type, it represents the calling convention of designated subprograms.
In addition:

31/3
   * A True Import aspect indicates that the entity is defined
     externally (that is, outside the Ada program).  This aspect is
     never inherited; if not directly specified, the Import aspect is
     False.

32/3
   * A True Export aspect indicates that the entity is used externally.
     This aspect is never inherited; if not directly specified, the
     Export aspect is False.

33/3
   * For an entity with a True Import or Export aspect, an external
     name, link name, or both may also be specified.

34
An <external name> is a string value for the name used by a foreign
language program either for an entity that an Ada program imports, or
for referring to an entity that an Ada program exports.

35
A <link name> is a string value for the name of an exported or imported
entity, based on the conventions of the foreign language's compiler in
interfacing with the system's linker tool.

36
The meaning of link names is implementation defined.  If neither a link
name nor the Address attribute of an imported or exported entity is
specified, then a link name is chosen in an implementation-defined
manner, based on the external name if one is specified.

37
Pragma Linker_Options has the effect of passing its string argument as a
parameter to the system linker (if one exists), if the immediately
enclosing compilation unit is included in the partition being linked.
The interpretation of the string argument, and the way in which the
string arguments from multiple Linker_Options pragmas are combined, is
implementation defined.

                          _Dynamic Semantics_

38/3
Notwithstanding what this International Standard says elsewhere, the
elaboration of a declaration with a True Import aspect does not create
the entity.  Such an elaboration has no other effect than to allow the
defining name to denote the external entity.

                         _Erroneous Execution_

38.1/3
It is the programmer's responsibility to ensure that the use of
interfacing aspects does not violate Ada semantics; otherwise, program
execution is erroneous.

                        _Implementation Advice_

39/3
If an implementation supports Export for a given language, then it
should also allow the main subprogram to be written in that language.
It should support some mechanism for invoking the elaboration of the Ada
library units included in the system, and for invoking the finalization
of the environment task.  On typical systems, the recommended mechanism
is to provide two subprograms whose link names are "adainit" and
"adafinal".  Adainit should contain the elaboration code for library
units.  Adafinal should contain the finalization code.  These
subprograms should have no effect the second and subsequent time they
are called.  

40/3
Automatic elaboration of preelaborated packages should be provided when
specifying the Export aspect as True is supported.

41/4
For each supported convention <L> other than Intrinsic, an
implementation should support specifying the Import and Export aspects
for objects of <L>-compatible types and for subprograms, and the
Convention aspect for <L>-eligible types and for subprograms, presuming
the other language has corresponding features.  Specifying the
Convention aspect need not be supported for scalar types, other than
enumeration types whose internal codes fall within the range 0 ..
2**15-1.

     NOTES

42/3
     1  Implementations may place restrictions on interfacing aspects;
     for example, requiring each exported entity to be declared at the
     library level.

43/3
     2  The Convention aspect in combination with the Import aspect
     indicates the conventions for accessing external entities.  It is
     possible that the actual entity is written in assembly language,
     but reflects the conventions of a particular language.  For
     example, with Convention => Ada can be used to interface to an
     assembly language routine that obeys the Ada compiler's calling
     conventions.

44/3
     3  To obtain "call-back" to an Ada subprogram from a foreign
     language environment, the Convention aspect should be specified
     both for the access-to-subprogram type and the specific
     subprogram(s) to which 'Access is applied.

     <Paragraphs 45 and 46 were deleted.>

47
     4  See also *note 13.8::, "*note 13.8:: Machine Code Insertions".

48/3
     5  If both External_Name and Link_Name are specified for a given
     entity, then the External_Name is ignored.

49/2
     <This paragraph was deleted.>

                              _Examples_

50/4
<Example of interfacing aspects:>

51/3
     package Fortran_Library is
       function Sqrt (X : Float) return Float
         with Import => True, Convention => Fortran;
       type Matrix is array (Natural range <>, Natural range <>) of Float
         with Convention => Fortran;
       function Invert (M : Matrix) return Matrix
         with Import => True, Convention => Fortran;
     end Fortran_Library;


File: arm2012.info,  Node: B.2,  Next: B.3,  Prev: B.1,  Up: Annex B

B.2 The Package Interfaces
==========================

1
Package Interfaces is the parent of several library packages that
declare types and other entities useful for interfacing to foreign
languages.  It also contains some implementation-defined types that are
useful across more than one language (in particular for interfacing to
assembly language).

                          _Static Semantics_

2
The library package Interfaces has the following skeletal declaration:

3

     package Interfaces is
        pragma Pure(Interfaces);

4
        type Integer_<n> is range -2**(<n>-1) .. 2**(<n>-1) - 1;  --<2's complement>

5
        type Unsigned_<n> is mod 2**<n>;

6
        function Shift_Left  (Value : Unsigned_<n>; Amount : Natural)
           return Unsigned_<n>;
        function Shift_Right (Value : Unsigned_<n>; Amount : Natural)
           return Unsigned_<n>;
        function Shift_Right_Arithmetic (Value : Unsigned_<n>; Amount : Natural)
           return Unsigned_<n>;
        function Rotate_Left  (Value : Unsigned_<n>; Amount : Natural)
           return Unsigned_<n>;
        function Rotate_Right (Value : Unsigned_<n>; Amount : Natural)
           return Unsigned_<n>;
        ...
     end Interfaces;

                     _Implementation Requirements_

7
An implementation shall provide the following declarations in the
visible part of package Interfaces:

8
   * Signed and modular integer types of <n> bits, if supported by the
     target architecture, for each <n> that is at least the size of a
     storage element and that is a factor of the word size.  The names
     of these types are of the form Integer_<n> for the signed types,
     and Unsigned_<n> for the modular types;

9
   * For each such modular type in Interfaces, shifting and rotating
     subprograms as specified in the declaration of Interfaces above.
     These subprograms are Intrinsic.  They operate on a bit-by-bit
     basis, using the binary representation of the value of the operands
     to yield a binary representation for the result.  The Amount
     parameter gives the number of bits by which to shift or rotate.
     For shifting, zero bits are shifted in, except in the case of
     Shift_Right_Arithmetic, where one bits are shifted in if Value is
     at least half the modulus.

10
   * Floating point types corresponding to each floating point format
     fully supported by the hardware.

                     _Implementation Permissions_

11
An implementation may provide implementation-defined library units that
are children of Interfaces, and may add declarations to the visible part
of Interfaces in addition to the ones defined above.

11.1/3
A child package of package Interfaces with the name of a convention may
be provided independently of whether the convention is supported by the
Convention aspect and vice versa.  Such a child package should contain
any declarations that would be useful for interfacing to the language
(implementation) represented by the convention.  Any declarations useful
for interfacing to any language on the given hardware architecture
should be provided directly in Interfaces.

                        _Implementation Advice_

12/2
<This paragraph was deleted.>

13/3
An implementation supporting an interface to C, COBOL, or Fortran should
provide the corresponding package or packages described in the following
subclauses.


File: arm2012.info,  Node: B.3,  Next: B.4,  Prev: B.2,  Up: Annex B

B.3 Interfacing with C and C++
==============================

1/4
The facilities relevant to interfacing with the C language and the
corresponding subset of the C++ language are the package Interfaces.C
and its children, and support for specifying the Convention aspect with
<convention_>identifiers C, C_Pass_By_Copy, and any of the
C_Variadic_<n> conventions described below.

2/3
The package Interfaces.C contains the basic types, constants, and
subprograms that allow an Ada program to pass scalars and strings to C
and C++ functions.  When this subclause mentions a C entity, the
reference also applies to the corresponding entity in C++.

                          _Static Semantics_

3
The library package Interfaces.C has the following declaration:

4
     package Interfaces.C is
        pragma Pure(C);

5
        <-- Declarations based on C's <limits.h>>

6
        CHAR_BIT  : constant := <implementation-defined>;  <-- typically 8>
        SCHAR_MIN : constant := <implementation-defined>;  <-- typically -128>
        SCHAR_MAX : constant := <implementation-defined>;  <-- typically 127>
        UCHAR_MAX : constant := <implementation-defined>;  <-- typically 255>

7
        <-- Signed and Unsigned Integers>
        type int   is range <implementation-defined>;
        type short is range <implementation-defined>;
        type long  is range <implementation-defined>;

8
        type signed_char is range SCHAR_MIN .. SCHAR_MAX;
        for signed_char'Size use CHAR_BIT;

9
        type unsigned       is mod <implementation-defined>;
        type unsigned_short is mod <implementation-defined>;
        type unsigned_long  is mod <implementation-defined>;

10
        type unsigned_char is mod (UCHAR_MAX+1);
        for unsigned_char'Size use CHAR_BIT;

11
        subtype plain_char is <implementation-defined>;

12
        type ptrdiff_t is range <implementation-defined>;

13
        type size_t is mod <implementation-defined>;

14
        <-- Floating Point>

15
        type C_float     is digits <implementation-defined>;

16
        type double      is digits <implementation-defined>;

17
        type long_double is digits <implementation-defined>;

18
        <-- Characters and Strings >

19
        type char is <<implementation-defined character type>>;

20/1
        nul : constant char := <implementation-defined>;

21
        function To_C   (Item : in Character) return char;

22
        function To_Ada (Item : in char) return Character;

23/3
        type char_array is array (size_t range <>) of aliased char
           with Pack;
        for char_array'Component_Size use CHAR_BIT;

24
        function Is_Nul_Terminated (Item : in char_array) return Boolean;

25
        function To_C   (Item       : in String;
                         Append_Nul : in Boolean := True)
           return char_array;

26
        function To_Ada (Item     : in char_array;
                         Trim_Nul : in Boolean := True)
           return String;

27
        procedure To_C (Item       : in  String;
                        Target     : out char_array;
                        Count      : out size_t;
                        Append_Nul : in  Boolean := True);

28
        procedure To_Ada (Item     : in  char_array;
                          Target   : out String;
                          Count    : out Natural;
                          Trim_Nul : in  Boolean := True);

29
        <-- Wide Character and Wide String>

30/1
        type wchar_t is <<implementation-defined character type>>;

31/1
        wide_nul : constant wchar_t := <implementation-defined>;

32
        function To_C   (Item : in Wide_Character) return wchar_t;
        function To_Ada (Item : in wchar_t       ) return Wide_Character;

33/3
        type wchar_array is array (size_t range <>) of aliased wchar_t
           with Pack;

34/3
     <This paragraph was deleted.>

35
        function Is_Nul_Terminated (Item : in wchar_array) return Boolean;

36
        function To_C   (Item       : in Wide_String;
                         Append_Nul : in Boolean := True)
           return wchar_array;

37
        function To_Ada (Item     : in wchar_array;
                         Trim_Nul : in Boolean := True)
           return Wide_String;

38
        procedure To_C (Item       : in  Wide_String;
                        Target     : out wchar_array;
                        Count      : out size_t;
                        Append_Nul : in  Boolean := True);

39
        procedure To_Ada (Item     : in  wchar_array;
                          Target   : out Wide_String;
                          Count    : out Natural;
                          Trim_Nul : in  Boolean := True);

39.1/2
        -- <ISO/IEC 10646:2003 compatible types defined by ISO/IEC TR 19769:2004.>

39.2/2
        type char16_t is <<implementation-defined character type>>;

39.3/2
        char16_nul : constant char16_t := <implementation-defined>;

39.4/2
        function To_C (Item : in Wide_Character) return char16_t;
        function To_Ada (Item : in char16_t) return Wide_Character;

39.5/3
        type char16_array is array (size_t range <>) of aliased char16_t
           with Pack;

39.6/3
     <This paragraph was deleted.>

39.7/2
        function Is_Nul_Terminated (Item : in char16_array) return Boolean;
        function To_C (Item       : in Wide_String;
                       Append_Nul : in Boolean := True)
           return char16_array;

39.8/2
        function To_Ada (Item     : in char16_array;
                         Trim_Nul : in Boolean := True)
           return Wide_String;

39.9/2
        procedure To_C (Item       : in  Wide_String;
                        Target     : out char16_array;
                        Count      : out size_t;
                        Append_Nul : in  Boolean := True);

39.10/2
        procedure To_Ada (Item     : in  char16_array;
                          Target   : out Wide_String;
                          Count    : out Natural;
                          Trim_Nul : in  Boolean := True);

39.11/2
        type char32_t is <<implementation-defined character type>>;

39.12/2
        char32_nul : constant char32_t := <implementation-defined>;

39.13/2
        function To_C (Item : in Wide_Wide_Character) return char32_t;
        function To_Ada (Item : in char32_t) return Wide_Wide_Character;

39.14/3
        type char32_array is array (size_t range <>) of aliased char32_t
           with Pack;

39.15/3
     <This paragraph was deleted.>

39.16/2
        function Is_Nul_Terminated (Item : in char32_array) return Boolean;
        function To_C (Item       : in Wide_Wide_String;
                       Append_Nul : in Boolean := True)
           return char32_array;

39.17/2
        function To_Ada (Item     : in char32_array;
                         Trim_Nul : in Boolean := True)
           return Wide_Wide_String;

39.18/2
        procedure To_C (Item       : in  Wide_Wide_String;
                        Target     : out char32_array;
                        Count      : out size_t;
                        Append_Nul : in  Boolean := True);

39.19/2
        procedure To_Ada (Item     : in  char32_array;
                          Target   : out Wide_Wide_String;
                          Count    : out Natural;
                          Trim_Nul : in  Boolean := True);

40
        Terminator_Error : exception;

41
     end Interfaces.C;

42
Each of the types declared in Interfaces.C is C-compatible.

43/2
The types int, short, long, unsigned, ptrdiff_t, size_t, double, char,
wchar_t, char16_t, and char32_t correspond respectively to the C types
having the same names.  The types signed_char, unsigned_short,
unsigned_long, unsigned_char, C_float, and long_double correspond
respectively to the C types signed char, unsigned short, unsigned long,
unsigned char, float, and long double.

44
The type of the subtype plain_char is either signed_char or
unsigned_char, depending on the C implementation.

45
     function To_C   (Item : in Character) return char;
     function To_Ada (Item : in char     ) return Character;

46
          The functions To_C and To_Ada map between the Ada type
          Character and the C type char.

47
     function Is_Nul_Terminated (Item : in char_array) return Boolean;

48
          The result of Is_Nul_Terminated is True if Item contains nul,
          and is False otherwise.

49
     function To_C   (Item : in String;     Append_Nul : in Boolean := True)
        return char_array;

     function To_Ada (Item : in char_array; Trim_Nul   : in Boolean := True)
        return String;

50/2
          The result of To_C is a char_array value of length Item'Length
          (if Append_Nul is False) or Item'Length+1 (if Append_Nul is
          True).  The lower bound is 0.  For each component Item(I), the
          corresponding component in the result is To_C applied to
          Item(I). The value nul is appended if Append_Nul is True.  If
          Append_Nul is False and Item'Length is 0, then To_C propagates
          Constraint_Error.

51
          The result of To_Ada is a String whose length is Item'Length
          (if Trim_Nul is False) or the length of the slice of Item
          preceding the first nul (if Trim_Nul is True).  The lower
          bound of the result is 1.  If Trim_Nul is False, then for each
          component Item(I) the corresponding component in the result is
          To_Ada applied to Item(I). If Trim_Nul is True, then for each
          component Item(I) before the first nul the corresponding
          component in the result is To_Ada applied to Item(I). The
          function propagates Terminator_Error if Trim_Nul is True and
          Item does not contain nul.

52
     procedure To_C (Item       : in  String;
                     Target     : out char_array;
                     Count      : out size_t;
                     Append_Nul : in  Boolean := True);

     procedure To_Ada (Item     : in  char_array;
                       Target   : out String;
                       Count    : out Natural;
                       Trim_Nul : in  Boolean := True);

53
          For procedure To_C, each element of Item is converted (via the
          To_C function) to a char, which is assigned to the
          corresponding element of Target.  If Append_Nul is True, nul
          is then assigned to the next element of Target.  In either
          case, Count is set to the number of Target elements assigned.          If Target is not long enough, Constraint_Error is propagated.

54
          For procedure To_Ada, each element of Item (if Trim_Nul is
          False) or each element of Item preceding the first nul (if
          Trim_Nul is True) is converted (via the To_Ada function) to a
          Character, which is assigned to the corresponding element of
          Target.  Count is set to the number of Target elements
          assigned.  If Target is not long enough, Constraint_Error is
          propagated.  If Trim_Nul is True and Item does not contain
          nul, then Terminator_Error is propagated.

55
     function Is_Nul_Terminated (Item : in wchar_array) return Boolean;

56
          The result of Is_Nul_Terminated is True if Item contains
          wide_nul, and is False otherwise.

57
     function To_C   (Item : in Wide_Character) return wchar_t;
     function To_Ada (Item : in wchar_t       ) return Wide_Character;

58
          To_C and To_Ada provide the mappings between the Ada and C
          wide character types.

59
     function To_C   (Item       : in Wide_String;
                      Append_Nul : in Boolean := True)
        return wchar_array;

     function To_Ada (Item     : in wchar_array;
                      Trim_Nul : in Boolean := True)
        return Wide_String;

     procedure To_C (Item       : in  Wide_String;
                     Target     : out wchar_array;
                     Count      : out size_t;
                     Append_Nul : in  Boolean := True);

     procedure To_Ada (Item     : in  wchar_array;
                       Target   : out Wide_String;
                       Count    : out Natural;
                       Trim_Nul : in  Boolean := True);

60
          The To_C and To_Ada subprograms that convert between
          Wide_String and wchar_array have analogous effects to the To_C
          and To_Ada subprograms that convert between String and
          char_array, except that wide_nul is used instead of nul.

60.1/2
     function Is_Nul_Terminated (Item : in char16_array) return Boolean;

60.2/2
          The result of Is_Nul_Terminated is True if Item contains
          char16_nul, and is False otherwise.

60.3/2
     function To_C (Item : in Wide_Character) return char16_t;
     function To_Ada (Item : in char16_t ) return Wide_Character;

60.4/2
          To_C and To_Ada provide mappings between the Ada and C 16-bit
          character types.

60.5/2
     function To_C (Item       : in Wide_String;
                    Append_Nul : in Boolean := True)
        return char16_array;

     function To_Ada (Item     : in char16_array;
                      Trim_Nul : in Boolean := True)
        return Wide_String;

     procedure To_C (Item       : in  Wide_String;
                     Target     : out char16_array;
                     Count      : out size_t;
                     Append_Nul : in  Boolean := True);

     procedure To_Ada (Item     : in  char16_array;
                       Target   : out Wide_String;
                       Count    : out Natural;
                       Trim_Nul : in  Boolean := True);

60.6/2
          The To_C and To_Ada subprograms that convert between
          Wide_String and char16_array have analogous effects to the
          To_C and To_Ada subprograms that convert between String and
          char_array, except that char16_nul is used instead of nul.

60.7/2
     function Is_Nul_Terminated (Item : in char32_array) return Boolean;

60.8/2
          The result of Is_Nul_Terminated is True if Item contains
          char16_nul, and is False otherwise.

60.9/2
     function To_C (Item : in Wide_Wide_Character) return char32_t;
     function To_Ada (Item : in char32_t ) return Wide_Wide_Character;

60.10/2
          To_C and To_Ada provide mappings between the Ada and C 32-bit
          character types.

60.11/2
     function To_C (Item       : in Wide_Wide_String;
                    Append_Nul : in Boolean := True)
        return char32_array;

     function To_Ada (Item     : in char32_array;
                      Trim_Nul : in Boolean := True)
        return Wide_Wide_String;

     procedure To_C (Item       : in  Wide_Wide_String;
                     Target     : out char32_array;
                     Count      : out size_t;
                     Append_Nul : in  Boolean := True);

     procedure To_Ada (Item     : in  char32_array;
                       Target   : out Wide_Wide_String;
                       Count    : out Natural;
                       Trim_Nul : in  Boolean := True);

60.12/2
          The To_C and To_Ada subprograms that convert between
          Wide_Wide_String and char32_array have analogous effects to
          the To_C and To_Ada subprograms that convert between String
          and char_array, except that char32_nul is used instead of nul.

60.13/3
The Convention aspect with <convention_>identifier C_Pass_By_Copy shall
only be specified for a type.

60.14/2
The eligibility rules in *note B.1:: do not apply to convention
C_Pass_By_Copy.  Instead, a type T is eligible for convention
C_Pass_By_Copy if T is an unchecked union type or if T is a record type
that has no discriminants and that only has components with statically
constrained subtypes, and each component is C-compatible.

60.15/3
If a type is C_Pass_By_Copy-compatible, then it is also C-compatible.

60.16/4
The identifiers C_Variadic_0, C_Variadic_1, C_Variadic_2, and so on are
<convention_>identifiers.  These conventions are said to be
<C_Variadic>.  The convention C_Variadic_<n> is the calling convention
for a variadic C function taking <n> fixed parameters and then a
variable number of additional parameters.  The C_Variadic_<n> convention
shall only be specified as the convention aspect for a subprogram, or
for an access-to-subprogram type, having at least <n> parameters.  A
type is compatible with a C_Variadic convention if and only if the type
is C-compatible.

                     _Implementation Requirements_

61/3
An implementation shall support specifying aspect Convention with a C
<convention_>identifier for a C-eligible type (see *note B.1::).  An
implementation shall support specifying aspect Convention with a
C_Pass_By_Copy <convention_>identifier for a C_Pass_By_Copy-eligible
type.

                     _Implementation Permissions_

62
An implementation may provide additional declarations in the C interface
packages.

62.1/3
An implementation need not support specifying the Convention aspect with
<convention_>identifier C in the following cases:

62.2/3
   * for a subprogram that has a parameter of an unconstrained array
     subtype, unless the Import aspect has the value True for the
     subprogram;

62.3/3
   * for a function with an unconstrained array result subtype;

62.4/3
   * for an object whose nominal subtype is an unconstrained array
     subtype.

                        _Implementation Advice_

62.5/3
The constants nul, wide_nul, char16_nul, and char32_nul should have a
representation of zero.

63
An implementation should support the following interface correspondences
between Ada and C.

64
   * An Ada procedure corresponds to a void-returning C function.

65
   * An Ada function corresponds to a non-void C function.

65.1/4
   * An Ada enumeration type corresponds to a C enumeration type with
     corresponding enumeration literals having the same internal codes,
     provided the internal codes fall within the range of the C int
     type.

66
   * An Ada in scalar parameter is passed as a scalar argument to a C
     function.

67
   * An Ada in parameter of an access-to-object type with designated
     type T is passed as a t* argument to a C function, where t is the C
     type corresponding to the Ada type T.

68
   * An Ada access T parameter, or an Ada out or in out parameter of an
     elementary type T, is passed as a t* argument to a C function,
     where t is the C type corresponding to the Ada type T. In the case
     of an elementary out or in out parameter, a pointer to a temporary
     copy is used to preserve by-copy semantics.

68.1/2
   * An Ada parameter of a (record) type T of convention C_Pass_By_Copy,
     of mode in, is passed as a t argument to a C function, where t is
     the C struct corresponding to the Ada type T.

69/2
   * An Ada parameter of a record type T, of any mode, other than an in
     parameter of a type of convention C_Pass_By_Copy, is passed as a t*
     argument to a C function, where t is the C struct corresponding to
     the Ada type T.

70
   * An Ada parameter of an array type with component type T, of any
     mode, is passed as a t* argument to a C function, where t is the C
     type corresponding to the Ada type T.

71
   * An Ada parameter of an access-to-subprogram type is passed as a
     pointer to a C function whose prototype corresponds to the
     designated subprogram's specification.

71.1/3
   * An Ada parameter of a private type is passed as specified for the
     full view of the type.

71.2/3
   * The rules of correspondence given above for parameters of mode in
     also apply to the return object of a function.

71.3/3
<This paragraph was deleted.>

     NOTES

72
     6  Values of type char_array are not implicitly terminated with
     nul.  If a char_array is to be passed as a parameter to an imported
     C function requiring nul termination, it is the programmer's
     responsibility to obtain this effect.

73
     7  To obtain the effect of C's sizeof(item_type), where Item_Type
     is the corresponding Ada type, evaluate the expression:
     size_t(Item_Type'Size/CHAR_BIT).

74/2
     <This paragraph was deleted.>

75/4
     8  A variadic C function can correspond to several Ada subprograms,
     taking various specific numbers and types of parameters.

                              _Examples_

76
<Example of using the Interfaces.C package:>

77
     <--Calling the C Library Function strcpy>
     with Interfaces.C;
     procedure Test is
        package C renames Interfaces.C;
        use type C.char_array;
        <-- Call <string.h>strcpy:>
        <-- C definition of strcpy:  char *strcpy(char *s1, const char *s2);>
        <--    This function copies the string pointed to by s2 (including the terminating null character)>
        <--     into the array pointed to by s1. If copying takes place between objects that overlap, >
        <--     the behavior is undefined. The strcpy function returns the value of s1.>

78/3
        <-- Note: since the C function's return value is of no interest, the Ada interface is a procedure>
        procedure Strcpy (Target : out C.char_array;
                          Source : in  C.char_array)
           with Import => True, Convention => C, External_Name => "strcpy";

79/3
     <This paragraph was deleted.>

80
        Chars1 :  C.char_array(1..20);
        Chars2 :  C.char_array(1..20);

81
     begin
        Chars2(1..6) := "qwert" & C.nul;

82
        Strcpy(Chars1, Chars2);

83
     <-- Now Chars1(1..6) = "qwert" & C.Nul>

84
     end Test;

* Menu:

* B.3.1 ::    The Package Interfaces.C.Strings
* B.3.2 ::    The Generic Package Interfaces.C.Pointers
* B.3.3 ::    Unchecked Union Types


File: arm2012.info,  Node: B.3.1,  Next: B.3.2,  Up: B.3

B.3.1 The Package Interfaces.C.Strings
--------------------------------------

1/3
The package Interfaces.C.Strings declares types and subprograms allowing
an Ada program to allocate, reference, update, and free C-style strings.
In particular, the private type chars_ptr corresponds to a common use of
"char *" in C programs, and an object of this type can be passed to a
subprogram to which with Import => True, Convention => C has been
specified, and for which "char *" is the type of the argument of the C
function.

                          _Static Semantics_

2
The library package Interfaces.C.Strings has the following declaration:

3
     package Interfaces.C.Strings is
        pragma Preelaborate(Strings);

4
        type char_array_access is access all char_array;

5/2
        type chars_ptr is private;
        pragma Preelaborable_Initialization(chars_ptr);

6/2
        type chars_ptr_array is array (size_t range <>) of aliased chars_ptr;

7
        Null_Ptr : constant chars_ptr;

8
        function To_Chars_Ptr (Item      : in char_array_access;
                               Nul_Check : in Boolean := False)
           return chars_ptr;

9
        function New_Char_Array (Chars   : in char_array) return chars_ptr;

10
        function New_String (Str : in String) return chars_ptr;

11
        procedure Free (Item : in out chars_ptr);

12
        Dereference_Error : exception;

13
        function Value (Item : in chars_ptr) return char_array;

14
        function Value (Item : in chars_ptr; Length : in size_t)
           return char_array;

15
        function Value (Item : in chars_ptr) return String;

16
        function Value (Item : in chars_ptr; Length : in size_t)
           return String;

17
        function Strlen (Item : in chars_ptr) return size_t;

18
        procedure Update (Item   : in chars_ptr;
                          Offset : in size_t;
                          Chars  : in char_array;
                          Check  : in Boolean := True);

19
        procedure Update (Item   : in chars_ptr;
                          Offset : in size_t;
                          Str    : in String;
                          Check  : in Boolean := True);

20
        Update_Error : exception;

21
     private
        ... -- <not specified by the language>
     end Interfaces.C.Strings;

22
The type chars_ptr is C-compatible and corresponds to the use of C's
"char *" for a pointer to the first char in a char array terminated by
nul.  When an object of type chars_ptr is declared, its value is by
default set to Null_Ptr, unless the object is imported (see *note
B.1::).

23
     function To_Chars_Ptr (Item      : in char_array_access;
                            Nul_Check : in Boolean := False)
        return chars_ptr;

24/3
          If Item is null, then To_Chars_Ptr returns Null_Ptr.  If Item
          is not null, Nul_Check is True, and Item.all does not contain
          nul, then the function propagates Terminator_Error; otherwise,
          To_Chars_Ptr performs a pointer conversion with no allocation
          of memory.

25
     function New_Char_Array (Chars   : in char_array) return chars_ptr;

26
          This function returns a pointer to an allocated object
          initialized to Chars(Chars'First ..  Index) & nul, where

27
             * Index = Chars'Last if Chars does not contain nul, or

28
             * Index is the smallest size_t value I such that Chars(I+1)
               = nul.

28.1
          Storage_Error is propagated if the allocation fails.

29
     function New_String (Str : in String) return chars_ptr;

30
          This function is equivalent to New_Char_Array(To_C(Str)).

31
     procedure Free (Item : in out chars_ptr);

32
          If Item is Null_Ptr, then Free has no effect.  Otherwise, Free
          releases the storage occupied by Value(Item), and resets Item
          to Null_Ptr.

33
     function Value (Item : in chars_ptr) return char_array;

34/3
          If Item = Null_Ptr, then Value propagates Dereference_Error.
          Otherwise, Value returns the prefix of the array of chars
          pointed to by Item, up to and including the first nul.  The
          lower bound of the result is 0.  If Item does not point to a
          nul-terminated string, then execution of Value is erroneous.

35
     function Value (Item : in chars_ptr; Length : in size_t)
        return char_array;

36/3
          If Item = Null_Ptr, then Value propagates Dereference_Error.
          Otherwise, Value returns the shorter of two arrays, either the
          first Length chars pointed to by Item, or Value(Item).  The
          lower bound of the result is 0.  If Length is 0, then Value
          propagates Constraint_Error.

37
     function Value (Item : in chars_ptr) return String;

38
          Equivalent to To_Ada(Value(Item), Trim_Nul=>True).

39
     function Value (Item : in chars_ptr; Length : in size_t)
        return String;

40/1
          Equivalent to To_Ada(Value(Item, Length) & nul,
          Trim_Nul=>True).

41
     function Strlen (Item : in chars_ptr) return size_t;

42
          Returns <Val>'Length-1 where <Val> = Value(Item); propagates
          Dereference_Error if Item = Null_Ptr.

43
     procedure Update (Item   : in chars_ptr;
                       Offset : in size_t;
                       Chars  : in char_array;
                       Check  : Boolean := True);

44/1
          If Item = Null_Ptr, then Update propagates Dereference_Error.
          Otherwise, this procedure updates the value pointed to by
          Item, starting at position Offset, using Chars as the data to
          be copied into the array.  Overwriting the nul terminator, and
          skipping with the Offset past the nul terminator, are both
          prevented if Check is True, as follows:

45
             * Let N = Strlen(Item).  If Check is True, then:

46
                       * If Offset+Chars'Length>N, propagate
                         Update_Error.

47
                       * Otherwise, overwrite the data in the array
                         pointed to by Item, starting at the char at
                         position Offset, with the data in Chars.

48
             * If Check is False, then processing is as above, but with
               no check that Offset+Chars'Length>N.

49
     procedure Update (Item   : in chars_ptr;
                       Offset : in size_t;
                       Str    : in String;
                       Check  : in Boolean := True);

50/2
          Equivalent to Update(Item, Offset, To_C(Str, Append_Nul =>
          False), Check).

                         _Erroneous Execution_

51
Execution of any of the following is erroneous if the Item parameter is
not null_ptr and Item does not point to a nul-terminated array of chars.

52
   * a Value function not taking a Length parameter,

53
   * the Free procedure,

54
   * the Strlen function.

55
Execution of Free(X) is also erroneous if the chars_ptr X was not
returned by New_Char_Array or New_String.

56
Reading or updating a freed char_array is erroneous.

57
Execution of Update is erroneous if Check is False and a call with Check
equal to True would have propagated Update_Error.

     NOTES

58
     9  New_Char_Array and New_String might be implemented either
     through the allocation function from the C environment ("malloc")
     or through Ada dynamic memory allocation ("new").  The key points
     are

59
        * the returned value (a chars_ptr) is represented as a C "char
          *" so that it may be passed to C functions;

60
        * the allocated object should be freed by the programmer via a
          call of Free, not by a called C function.


File: arm2012.info,  Node: B.3.2,  Next: B.3.3,  Prev: B.3.1,  Up: B.3

B.3.2 The Generic Package Interfaces.C.Pointers
-----------------------------------------------

1
The generic package Interfaces.C.Pointers allows the Ada programmer to
perform C-style operations on pointers.  It includes an access type
Pointer, Value functions that dereference a Pointer and deliver the
designated array, several pointer arithmetic operations, and "copy"
procedures that copy the contents of a source pointer into the array
designated by a destination pointer.  As in C, it treats an object Ptr
of type Pointer as a pointer to the first element of an array, so that
for example, adding 1 to Ptr yields a pointer to the second element of
the array.

2
The generic allows two styles of usage: one in which the array is
terminated by a special terminator element; and another in which the
programmer needs to keep track of the length.

                          _Static Semantics_

3
The generic library package Interfaces.C.Pointers has the following
declaration:

4
     generic
        type Index is (<>);
        type Element is private;
        type Element_Array is array (Index range <>) of aliased Element;
        Default_Terminator : Element;
     package Interfaces.C.Pointers is
        pragma Preelaborate(Pointers);

5
        type Pointer is access all Element;

6
        function Value(Ref        : in Pointer;
                       Terminator : in Element := Default_Terminator)
           return Element_Array;

7
        function Value(Ref    : in Pointer;
                       Length : in ptrdiff_t)
           return Element_Array;

8
        Pointer_Error : exception;

9
        <-- C-style Pointer arithmetic>

10/3
        function "+" (Left : in Pointer;   Right : in ptrdiff_t) return Pointer
           with Convention => Intrinsic;
        function "+" (Left : in ptrdiff_t; Right : in Pointer)   return Pointer
           with Convention => Intrinsic;
        function "-" (Left : in Pointer;   Right : in ptrdiff_t) return Pointer
           with Convention => Intrinsic;
        function "-" (Left : in Pointer;   Right : in Pointer) return ptrdiff_t
           with Convention => Intrinsic;

11/3
        procedure Increment (Ref : in out Pointer)
           with Convention => Intrinsic;
        procedure Decrement (Ref : in out Pointer)
           with Convention => Intrinsic;

12/3
     <This paragraph was deleted.>

13
        function Virtual_Length (Ref        : in Pointer;
                                 Terminator : in Element := Default_Terminator)
           return ptrdiff_t;

14
        procedure Copy_Terminated_Array
           (Source     : in Pointer;
            Target     : in Pointer;
            Limit      : in ptrdiff_t := ptrdiff_t'Last;
            Terminator : in Element :=  Default_Terminator);

15
        procedure Copy_Array (Source  : in Pointer;
                              Target  : in Pointer;
                              Length  : in ptrdiff_t);

16
     end Interfaces.C.Pointers;

17
The type Pointer is C-compatible and corresponds to one use of C's
"Element *".  An object of type Pointer is interpreted as a pointer to
the initial Element in an Element_Array.  Two styles are supported:

18
   * Explicit termination of an array value with Default_Terminator (a
     special terminator value);

19
   * Programmer-managed length, with Default_Terminator treated simply
     as a data element.

20
     function Value(Ref        : in Pointer;
                    Terminator : in Element := Default_Terminator)
        return Element_Array;

21
          This function returns an Element_Array whose value is the
          array pointed to by Ref, up to and including the first
          Terminator; the lower bound of the array is Index'First.
          Interfaces.C.Strings.Dereference_Error is propagated if Ref is
          null.

22
     function Value(Ref    : in Pointer;
                    Length : in ptrdiff_t)
        return Element_Array;

23
          This function returns an Element_Array comprising the first
          Length elements pointed to by Ref.  The exception
          Interfaces.C.Strings.Dereference_Error is propagated if Ref is
          null.

24
The "+" and "-" functions perform arithmetic on Pointer values, based on
the Size of the array elements.  In each of these functions,
Pointer_Error is propagated if a Pointer parameter is null.

25
     procedure Increment (Ref : in out Pointer);

26
          Equivalent to Ref := Ref+1.

27
     procedure Decrement (Ref : in out Pointer);

28
          Equivalent to Ref := Ref-1.

29
     function Virtual_Length (Ref        : in Pointer;
                              Terminator : in Element := Default_Terminator)
        return ptrdiff_t;

30
          Returns the number of Elements, up to the one just before the
          first Terminator, in Value(Ref, Terminator).

31
     procedure Copy_Terminated_Array
        (Source     : in Pointer;
         Target     : in Pointer;
         Limit      : in ptrdiff_t := ptrdiff_t'Last;
         Terminator : in Element := Default_Terminator);

32
          This procedure copies Value(Source, Terminator) into the array
          pointed to by Target; it stops either after Terminator has
          been copied, or the number of elements copied is Limit,
          whichever occurs first.  Dereference_Error is propagated if
          either Source or Target is null.

33
     procedure Copy_Array (Source  : in Pointer;
                           Target  : in Pointer;
                           Length  : in ptrdiff_t);

34
          This procedure copies the first Length elements from the array
          pointed to by Source, into the array pointed to by Target.
          Dereference_Error is propagated if either Source or Target is
          null.

                         _Erroneous Execution_

35
It is erroneous to dereference a Pointer that does not designate an
aliased Element.

36
Execution of Value(Ref, Terminator) is erroneous if Ref does not
designate an aliased Element in an Element_Array terminated by
Terminator.

37
Execution of Value(Ref, Length) is erroneous if Ref does not designate
an aliased Element in an Element_Array containing at least Length
Elements between the designated Element and the end of the array,
inclusive.

38
Execution of Virtual_Length(Ref, Terminator) is erroneous if Ref does
not designate an aliased Element in an Element_Array terminated by
Terminator.

39
Execution of Copy_Terminated_Array(Source, Target, Limit, Terminator) is
erroneous in either of the following situations:

40
   * Execution of both Value(Source, Terminator) and Value(Source,
     Limit) are erroneous, or

41
   * Copying writes past the end of the array containing the Element
     designated by Target.

42
Execution of Copy_Array(Source, Target, Length) is erroneous if either
Value(Source, Length) is erroneous, or copying writes past the end of
the array containing the Element designated by Target.

     NOTES

43
     10  To compose a Pointer from an Element_Array, use 'Access on the
     first element.  For example (assuming appropriate instantiations):

44
          Some_Array   : Element_Array(0..5) ;
          Some_Pointer : Pointer := Some_Array(0)'Access;

                              _Examples_

45
<Example of Interfaces.C.Pointers:>

46
     with Interfaces.C.Pointers;
     with Interfaces.C.Strings;
     procedure Test_Pointers is
        package C renames Interfaces.C;
        package Char_Ptrs is
           new C.Pointers (Index              => C.size_t,
                           Element            => C.char,
                           Element_Array      => C.char_array,
                           Default_Terminator => C.nul);

47
        use type Char_Ptrs.Pointer;
        subtype Char_Star is Char_Ptrs.Pointer;

48
        procedure Strcpy (Target_Ptr, Source_Ptr : Char_Star) is
           Target_Temp_Ptr : Char_Star := Target_Ptr;
           Source_Temp_Ptr : Char_Star := Source_Ptr;
           Element : C.char;
        begin
           if Target_Temp_Ptr = null or Source_Temp_Ptr = null then
              raise C.Strings.Dereference_Error;
           end if;

49/1
           loop
              Element             := Source_Temp_Ptr.all;
              Target_Temp_Ptr.all := Element;
              exit when C."="(Element, C.nul);
              Char_Ptrs.Increment(Target_Temp_Ptr);
              Char_Ptrs.Increment(Source_Temp_Ptr);
           end loop;
        end Strcpy;
     begin
        ...
     end Test_Pointers;


File: arm2012.info,  Node: B.3.3,  Prev: B.3.2,  Up: B.3

B.3.3 Unchecked Union Types
---------------------------

1/3
Specifying aspect Unchecked_Union to have the value True defines an
interface correspondence between a given discriminated type and some C
union.  The aspect requires that the associated type shall be given a
representation that allocates no space for its discriminant(s).

<Paragraphs 2 through 3 were moved to *note Annex J::, "*note Annex J::
Obsolescent Features".>

                          _Static Semantics_

3.1/3
For a discriminated record type having a variant_part, the following
language-defined representation aspect may be specified:

3.2/3
Unchecked_Union
               The type of aspect Unchecked_Union is Boolean.  If
               directly specified, the aspect_definition shall be a
               static expression.  If not specified (including by
               inheritance), the aspect is False.

                           _Legality Rules_

<Paragraphs 4 and 5 were deleted.>

6/3
A type for which aspect Unchecked_Union is True is called an <unchecked
union type>.  A subtype of an unchecked union type is defined to be an
<unchecked union subtype>.  An object of an unchecked union type is
defined to be an <unchecked union object>.

7/2
All component subtypes of an unchecked union type shall be C-compatible.

8/2
If a component subtype of an unchecked union type is subject to a
per-object constraint, then the component subtype shall be an unchecked
union subtype.

9/3
Any name that denotes a discriminant of an object of an unchecked union
type shall occur within the declarative region of the type, and shall
not occur within a record_representation_clause.

10/3
The type of a component declared in a variant_part of an unchecked union
type shall not need finalization.  In addition to the places where
Legality Rules normally apply (see *note 12.3::), this rule also applies
in the private part of an instance of a generic unit.  For an unchecked
union type declared within the body of a generic unit, or within the
body of any of its descendant library units, no part of the type of a
component declared in a variant_part of the unchecked union type shall
be of a formal private type or formal private extension declared within
the formal part of the generic unit.

11/2
The completion of an incomplete or private type declaration having a
known_discriminant_part shall not be an unchecked union type.

12/2
An unchecked union subtype shall only be passed as a generic actual
parameter if the corresponding formal type has no known discriminants or
is an unchecked union type.

                          _Static Semantics_

13/2
An unchecked union type is eligible for convention C.

14/2
All objects of an unchecked union type have the same size.

15/2
Discriminants of objects of an unchecked union type are of size zero.

16/2
Any check which would require reading a discriminant of an unchecked
union object is suppressed (see *note 11.5::).  These checks include:

17/2
   * The check performed when addressing a variant component (i.e., a
     component that was declared in a variant part) of an unchecked
     union object that the object has this component (see *note
     4.1.3::).

18/2
   * Any checks associated with a type or subtype conversion of a value
     of an unchecked union type (see *note 4.6::).  This includes, for
     example, the check associated with the implicit subtype conversion
     of an assignment statement.

19/2
   * The subtype membership check associated with the evaluation of a
     qualified expression (see *note 4.7::) or an uninitialized
     allocator (see *note 4.8::).

                          _Dynamic Semantics_

20/2
A view of an unchecked union object (including a type conversion or
function call) has <inferable discriminants> if it has a constrained
nominal subtype, unless the object is a component of an enclosing
unchecked union object that is subject to a per-object constraint and
the enclosing object lacks inferable discriminants.

21/2
An expression of an unchecked union type has inferable discriminants if
it is either a name of an object with inferable discriminants or a
qualified expression whose subtype_mark denotes a constrained subtype.

22/2
Program_Error is raised in the following cases:

23/2
   * Evaluation of the predefined equality operator for an unchecked
     union type if either of the operands lacks inferable discriminants.

24/2
   * Evaluation of the predefined equality operator for a type which has
     a subcomponent of an unchecked union type whose nominal subtype is
     unconstrained.

25/2
   * Evaluation of a membership test if the subtype_mark denotes a
     constrained unchecked union subtype and the expression lacks
     inferable discriminants.

26/2
   * Conversion from a derived unchecked union type to an unconstrained
     non-unchecked-union type if the operand of the conversion lacks
     inferable discriminants.

27/2
   * Execution of the default implementation of the Write or Read
     attribute of an unchecked union type.

28/2
   * Execution of the default implementation of the Output or Input
     attribute of an unchecked union type if the type lacks default
     discriminant values.

<Paragraph 29 was deleted.>

     NOTES

30/2
     11  The use of an unchecked union to obtain the effect of an
     unchecked conversion results in erroneous execution (see *note
     11.5::).  Execution of the following example is erroneous even if
     Float'Size = Integer'Size:

31/3
          type T (Flag : Boolean := False) is
             record
                 case Flag is
                     when False =>
                         F1 : Float := 0.0;
                     when True =>
                         F2 : Integer := 0;
                 end case;
              end record
              with Unchecked_Union;

32/2
          X : T;
          Y : Integer := X.F2; -- <erroneous>


File: arm2012.info,  Node: B.4,  Next: B.5,  Prev: B.3,  Up: Annex B

B.4 Interfacing with COBOL
==========================

1/3
The facilities relevant to interfacing with the COBOL language are the
package Interfaces.COBOL and support for specifying the Convention
aspect with <convention_>identifier COBOL.

2
The COBOL interface package supplies several sets of facilities:

3
   * A set of types corresponding to the native COBOL types of the
     supported COBOL implementation (so-called "internal COBOL
     representations"), allowing Ada data to be passed as parameters to
     COBOL programs

4
   * A set of types and constants reflecting external data
     representations such as might be found in files or databases,
     allowing COBOL-generated data to be read by an Ada program, and
     Ada-generated data to be read by COBOL programs

5
   * A generic package for converting between an Ada decimal type value
     and either an internal or external COBOL representation

                          _Static Semantics_

6
The library package Interfaces.COBOL has the following declaration:

7
     package Interfaces.COBOL is
        pragma Preelaborate(COBOL);

8
     <-- Types and operations for internal data representations>

9
        type Floating      is digits <implementation-defined>;
        type Long_Floating is digits <implementation-defined>;

10
        type Binary      is range <implementation-defined>;
        type Long_Binary is range <implementation-defined>;

11
        Max_Digits_Binary      : constant := <implementation-defined>;
        Max_Digits_Long_Binary : constant := <implementation-defined>;

12/3
        type Decimal_Element  is mod <implementation-defined>;
        type Packed_Decimal is array (Positive range <>) of Decimal_Element
           with Pack;

13
        type COBOL_Character is <implementation-defined character type>;

14
        Ada_To_COBOL : array (Character) of COBOL_Character := <implementation-defined>;

15
        COBOL_To_Ada : array (COBOL_Character) of Character := <implementation-defined>;

16/3
        type Alphanumeric is array (Positive range <>) of COBOL_Character
           with Pack;

17
        function To_COBOL (Item : in String) return Alphanumeric;
        function To_Ada   (Item : in Alphanumeric) return String;

18
        procedure To_COBOL (Item       : in String;
                            Target     : out Alphanumeric;
                            Last       : out Natural);

19
        procedure To_Ada (Item     : in Alphanumeric;
                          Target   : out String;
                          Last     : out Natural);

20/3
        type Numeric is array (Positive range <>) of COBOL_Character
           with Pack;

21
     <-- Formats for COBOL data representations>

22
        type Display_Format is private;

23
        Unsigned             : constant Display_Format;
        Leading_Separate     : constant Display_Format;
        Trailing_Separate    : constant Display_Format;
        Leading_Nonseparate  : constant Display_Format;
        Trailing_Nonseparate : constant Display_Format;

24
        type Binary_Format is private;

25
        High_Order_First  : constant Binary_Format;
        Low_Order_First   : constant Binary_Format;
        Native_Binary     : constant Binary_Format;

26
        type Packed_Format is private;

27
        Packed_Unsigned   : constant Packed_Format;
        Packed_Signed     : constant Packed_Format;

28
     <-- Types for external representation of COBOL binary data>

29/3
        type Byte is mod 2**COBOL_Character'Size;
        type Byte_Array is array (Positive range <>) of Byte
           with Pack;

30
        Conversion_Error : exception;

31
        generic
           type Num is delta <> digits <>;
        package Decimal_Conversions is

32
           <-- Display Formats: data values are represented as Numeric>

33
           function Valid (Item   : in Numeric;
                           Format : in Display_Format) return Boolean;

34
           function Length (Format : in Display_Format) return Natural;

35
           function To_Decimal (Item   : in Numeric;
                                Format : in Display_Format) return Num;

36
           function To_Display (Item   : in Num;
                                Format : in Display_Format) return Numeric;

37
           <-- Packed Formats: data values are represented as Packed_Decimal>

38
           function Valid (Item   : in Packed_Decimal;
                           Format : in Packed_Format) return Boolean;

39
           function Length (Format : in Packed_Format) return Natural;

40
           function To_Decimal (Item   : in Packed_Decimal;
                                Format : in Packed_Format) return Num;

41
           function To_Packed (Item   : in Num;
                               Format : in Packed_Format) return Packed_Decimal;

42
           <-- Binary Formats: external data values are represented as Byte_Array>

43
           function Valid (Item   : in Byte_Array;
                           Format : in Binary_Format) return Boolean;

44
           function Length (Format : in Binary_Format) return Natural;
           function To_Decimal (Item   : in Byte_Array;
                                Format : in Binary_Format) return Num;

45
           function To_Binary (Item   : in Num;
                             Format : in Binary_Format) return Byte_Array;

46
           <-- Internal Binary formats: data values are of type Binary or Long_Binary>

47
           function To_Decimal (Item : in Binary)      return Num;
           function To_Decimal (Item : in Long_Binary) return Num;

48
           function To_Binary      (Item : in Num)  return Binary;
           function To_Long_Binary (Item : in Num)  return Long_Binary;

49
        end Decimal_Conversions;

50
     private
        ... -- <not specified by the language>
     end Interfaces.COBOL;

51
Each of the types in Interfaces.COBOL is COBOL-compatible.

52
The types Floating and Long_Floating correspond to the native types in
COBOL for data items with computational usage implemented by floating
point.  The types Binary and Long_Binary correspond to the native types
in COBOL for data items with binary usage, or with computational usage
implemented by binary.

53
Max_Digits_Binary is the largest number of decimal digits in a numeric
value that is represented as Binary.  Max_Digits_Long_Binary is the
largest number of decimal digits in a numeric value that is represented
as Long_Binary.

54
The type Packed_Decimal corresponds to COBOL's packed-decimal usage.

55
The type COBOL_Character defines the run-time character set used in the
COBOL implementation.  Ada_To_COBOL and COBOL_To_Ada are the mappings
between the Ada and COBOL run-time character sets.

56
Type Alphanumeric corresponds to COBOL's alphanumeric data category.

57
Each of the functions To_COBOL and To_Ada converts its parameter based
on the mappings Ada_To_COBOL and COBOL_To_Ada, respectively.  The length
of the result for each is the length of the parameter, and the lower
bound of the result is 1.  Each component of the result is obtained by
applying the relevant mapping to the corresponding component of the
parameter.

58
Each of the procedures To_COBOL and To_Ada copies converted elements
from Item to Target, using the appropriate mapping (Ada_To_COBOL or
COBOL_To_Ada, respectively).  The index in Target of the last element
assigned is returned in Last (0 if Item is a null array).  If
Item'Length exceeds Target'Length, Constraint_Error is propagated.

59
Type Numeric corresponds to COBOL's numeric data category with display
usage.

60
The types Display_Format, Binary_Format, and Packed_Format are used in
conversions between Ada decimal type values and COBOL internal or
external data representations.  The value of the constant Native_Binary
is either High_Order_First or Low_Order_First, depending on the
implementation.

61
     function Valid (Item   : in Numeric;
                     Format : in Display_Format) return Boolean;

62
          The function Valid checks that the Item parameter has a value
          consistent with the value of Format.  If the value of Format
          is other than Unsigned, Leading_Separate, and
          Trailing_Separate, the effect is implementation defined.  If
          Format does have one of these values, the following rules
          apply:

63/3
             * Format=Unsigned: if Item comprises one or more decimal
               digit characters, then Valid returns True, else it
               returns False.

64/1
             * Format=Leading_Separate: if Item comprises a single
               occurrence of the plus or minus sign character, and then
               one or more decimal digit characters, then Valid returns
               True, else it returns False.

65/1
             * Format=Trailing_Separate: if Item comprises one or more
               decimal digit characters and finally a plus or minus sign
               character, then Valid returns True, else it returns
               False.

66
     function Length (Format : in Display_Format) return Natural;

67
          The Length function returns the minimal length of a Numeric
          value sufficient to hold any value of type Num when
          represented as Format.

68
     function To_Decimal (Item   : in Numeric;
                          Format : in Display_Format) return Num;

69
          Produces a value of type Num corresponding to Item as
          represented by Format.  The number of digits after the assumed
          radix point in Item is Num'Scale.  Conversion_Error is
          propagated if the value represented by Item is outside the
          range of Num.

70
     function To_Display (Item   : in Num;
                          Format : in Display_Format) return Numeric;

71/1
          This function returns the Numeric value for Item, represented
          in accordance with Format.  The length of the returned value
          is Length(Format), and the lower bound is 1.  Conversion_Error
          is propagated if Num is negative and Format is Unsigned.

72
     function Valid (Item   : in Packed_Decimal;
                     Format : in Packed_Format) return Boolean;

73
          This function returns True if Item has a value consistent with
          Format, and False otherwise.  The rules for the formation of
          Packed_Decimal values are implementation defined.

74
     function Length (Format : in Packed_Format) return Natural;

75
          This function returns the minimal length of a Packed_Decimal
          value sufficient to hold any value of type Num when
          represented as Format.

76
     function To_Decimal (Item   : in Packed_Decimal;
                          Format : in Packed_Format) return Num;

77
          Produces a value of type Num corresponding to Item as
          represented by Format.  Num'Scale is the number of digits
          after the assumed radix point in Item.  Conversion_Error is
          propagated if the value represented by Item is outside the
          range of Num.

78
     function To_Packed (Item   : in Num;
                         Format : in Packed_Format) return Packed_Decimal;

79/1
          This function returns the Packed_Decimal value for Item,
          represented in accordance with Format.  The length of the
          returned value is Length(Format), and the lower bound is 1.
          Conversion_Error is propagated if Num is negative and Format
          is Packed_Unsigned.

80
     function Valid (Item   : in Byte_Array;
                     Format : in Binary_Format) return Boolean;

81
          This function returns True if Item has a value consistent with
          Format, and False otherwise.

82
     function Length (Format : in Binary_Format) return Natural;

83
          This function returns the minimal length of a Byte_Array value
          sufficient to hold any value of type Num when represented as
          Format.

84
     function To_Decimal (Item   : in Byte_Array;
                          Format : in Binary_Format) return Num;

85
          Produces a value of type Num corresponding to Item as
          represented by Format.  Num'Scale is the number of digits
          after the assumed radix point in Item.  Conversion_Error is
          propagated if the value represented by Item is outside the
          range of Num.

86
     function To_Binary (Item   : in Num;
                         Format : in Binary_Format) return Byte_Array;

87/1
          This function returns the Byte_Array value for Item,
          represented in accordance with Format.  The length of the
          returned value is Length(Format), and the lower bound is 1.

88
     function To_Decimal (Item : in Binary)      return Num;

     function To_Decimal (Item : in Long_Binary) return Num;

89
          These functions convert from COBOL binary format to a
          corresponding value of the decimal type Num.  Conversion_Error
          is propagated if Item is too large for Num.

90
     function To_Binary      (Item : in Num)  return Binary;

     function To_Long_Binary (Item : in Num)  return Long_Binary;

91
          These functions convert from Ada decimal to COBOL binary
          format.  Conversion_Error is propagated if the value of Item
          is too large to be represented in the result type.

                     _Implementation Requirements_

92/3
An implementation shall support specifying aspect Convention with a
COBOL <convention>_identifier for a COBOL-eligible type (see *note
B.1::).

                     _Implementation Permissions_

93
An implementation may provide additional constants of the private types
Display_Format, Binary_Format, or Packed_Format.

94
An implementation may provide further floating point and integer types
in Interfaces.COBOL to match additional native COBOL types, and may also
supply corresponding conversion functions in the generic package
Decimal_Conversions.

                        _Implementation Advice_

95
An Ada implementation should support the following interface
correspondences between Ada and COBOL.

96
   * An Ada access T parameter is passed as a "BY REFERENCE" data item
     of the COBOL type corresponding to T.

97
   * An Ada in scalar parameter is passed as a "BY CONTENT" data item of
     the corresponding COBOL type.

98
   * Any other Ada parameter is passed as a "BY REFERENCE" data item of
     the COBOL type corresponding to the Ada parameter type; for
     scalars, a local copy is used if necessary to ensure by-copy
     semantics.

     NOTES

99/3
     12  An implementation is not required to support specifying aspect
     Convention for access types, nor is it required to support
     specifying aspects Import, Export, or Convention for functions.

100
     13  If an Ada subprogram is exported to COBOL, then a call from
     COBOL call may specify either "BY CONTENT" or "BY REFERENCE".

                              _Examples_

101
<Examples of Interfaces.COBOL:>

102
     with Interfaces.COBOL;
     procedure Test_Call is

103
        <-- Calling a foreign COBOL program>
        <-- Assume that a COBOL program PROG has the following declaration>
        <--  in its LINKAGE section:>
        <--  01 Parameter-Area>
        <--     05 NAME   PIC X(20).>
        <--     05 SSN    PIC X(9).>
        <--     05 SALARY PIC 99999V99 USAGE COMP.>
        <-- The effect of PROG is to update SALARY based on some algorithm>

104
        package COBOL renames Interfaces.COBOL;

105
        type Salary_Type is delta 0.01 digits 7;

106/3
        type COBOL_Record is
           record
              Name   : COBOL.Numeric(1..20);
              SSN    : COBOL.Numeric(1..9);
              Salary : COBOL.Binary;  <-- Assume Binary = 32 bits>
           end record
           with Convention => COBOL;

107/3
        procedure Prog (Item : in out COBOL_Record)
           with Import => True, Convention => COBOL;

108
        package Salary_Conversions is
           new COBOL.Decimal_Conversions(Salary_Type);

109
        Some_Salary : Salary_Type := 12_345.67;
        Some_Record : COBOL_Record :=
           (Name   => "Johnson, John       ",
            SSN    => "111223333",
            Salary => Salary_Conversions.To_Binary(Some_Salary));

110
     begin
        Prog (Some_Record);
        ...
     end Test_Call;

111
     with Interfaces.COBOL;
     with COBOL_Sequential_IO; <-- Assumed to be supplied by implementation>
     procedure Test_External_Formats is

112
        <-- Using data created by a COBOL program>
        <-- Assume that a COBOL program has created a sequential file with>
        <--  the following record structure, and that we need to>
        <--  process the records in an Ada program>
        <--  01 EMPLOYEE-RECORD>
        <--     05 NAME    PIC X(20).>
        <--     05 SSN     PIC X(9).>
        <--     05 SALARY  PIC 99999V99 USAGE COMP.>
        <--     05 ADJUST  PIC S999V999 SIGN LEADING SEPARATE.>
        <-- The COMP data is binary (32 bits), high-order byte first>

113
        package COBOL renames Interfaces.COBOL;

114
        type Salary_Type      is delta 0.01  digits 7;
        type Adjustments_Type is delta 0.001 digits 6;

115/3
        type COBOL_Employee_Record_Type is  <-- External representation>
           record
              Name    : COBOL.Alphanumeric(1..20);
              SSN     : COBOL.Alphanumeric(1..9);
              Salary  : COBOL.Byte_Array(1..4);
              Adjust  : COBOL.Numeric(1..7);  <-- Sign and 6 digits>
           end record
           with Convention => COBOL;

116
        package COBOL_Employee_IO is
           new COBOL_Sequential_IO(COBOL_Employee_Record_Type);
        use COBOL_Employee_IO;

117
        COBOL_File : File_Type;

118
        type Ada_Employee_Record_Type is  <-- Internal representation>
           record
              Name    : String(1..20);
              SSN     : String(1..9);
              Salary  : Salary_Type;
              Adjust  : Adjustments_Type;
           end record;

119
        COBOL_Record : COBOL_Employee_Record_Type;
        Ada_Record   : Ada_Employee_Record_Type;

120
        package Salary_Conversions is
           new COBOL.Decimal_Conversions(Salary_Type);
        use Salary_Conversions;

121
        package Adjustments_Conversions is
           new COBOL.Decimal_Conversions(Adjustments_Type);
        use Adjustments_Conversions;

122
     begin
        Open (COBOL_File, Name => "Some_File");

123
        loop
          Read (COBOL_File, COBOL_Record);

124
          Ada_Record.Name := To_Ada(COBOL_Record.Name);
          Ada_Record.SSN  := To_Ada(COBOL_Record.SSN);
          Ada_Record.Salary :=
             To_Decimal(COBOL_Record.Salary, COBOL.High_Order_First);
          Ada_Record.Adjust :=
             To_Decimal(COBOL_Record.Adjust, COBOL.Leading_Separate);
          ... <-- Process Ada_Record>
        end loop;
     exception
        when End_Error => ...
     end Test_External_Formats;


File: arm2012.info,  Node: B.5,  Prev: B.4,  Up: Annex B

B.5 Interfacing with Fortran
============================

1/3
The facilities relevant to interfacing with the Fortran language are the
package Interfaces.Fortran and support for specifying the Convention
aspect with <convention_>identifier Fortran.

2
The package Interfaces.Fortran defines Ada types whose representations
are identical to the default representations of the Fortran intrinsic
types Integer, Real, Double Precision, Complex, Logical, and Character
in a supported Fortran implementation.  These Ada types can therefore be
used to pass objects between Ada and Fortran programs.

                          _Static Semantics_

3
The library package Interfaces.Fortran has the following declaration:

4
     with Ada.Numerics.Generic_Complex_Types;  <-- see *note G.1.1::>
     pragma Elaborate_All(Ada.Numerics.Generic_Complex_Types);
     package Interfaces.Fortran is
        pragma Pure(Fortran);

5
        type Fortran_Integer is range <implementation-defined>;

6
        type Real             is digits <implementation-defined>;
        type Double_Precision is digits <implementation-defined>;

7
        type Logical is new Boolean;

8
        package Single_Precision_Complex_Types is
           new Ada.Numerics.Generic_Complex_Types (Real);

9
        type Complex is new Single_Precision_Complex_Types.Complex;

10
        subtype Imaginary is Single_Precision_Complex_Types.Imaginary;
        i : Imaginary renames Single_Precision_Complex_Types.i;
        j : Imaginary renames Single_Precision_Complex_Types.j;

11
        type Character_Set is <implementation-defined character type>;

12/3
        type Fortran_Character is array (Positive range <>) of Character_Set
           with Pack;

13
        function To_Fortran (Item : in Character) return Character_Set;
        function To_Ada (Item : in Character_Set) return Character;

14
        function To_Fortran (Item : in String) return Fortran_Character;
        function To_Ada     (Item : in Fortran_Character) return String;

15
        procedure To_Fortran (Item       : in String;
                              Target     : out Fortran_Character;
                              Last       : out Natural);

16
        procedure To_Ada (Item     : in Fortran_Character;
                          Target   : out String;
                          Last     : out Natural);

17
     end Interfaces.Fortran;

18
The types Fortran_Integer, Real, Double_Precision, Logical, Complex, and
Fortran_Character are Fortran-compatible.

19
The To_Fortran and To_Ada functions map between the Ada type Character
and the Fortran type Character_Set, and also between the Ada type String
and the Fortran type Fortran_Character.  The To_Fortran and To_Ada
procedures have analogous effects to the string conversion subprograms
found in Interfaces.COBOL.

                     _Implementation Requirements_

20/3
An implementation shall support specifying aspect Convention with a
Fortran <convention>_identifier for a Fortran-eligible type (see *note
B.1::).

                     _Implementation Permissions_

21
An implementation may add additional declarations to the Fortran
interface packages.  For example, the Fortran interface package for an
implementation of Fortran 77 (ANSI X3.9-1978) that defines types like
Integer*<n>, Real*<n>, Logical*<n>, and Complex*<n> may contain the
declarations of types named Integer_Star_<n>, Real_Star_<n>,
Logical_Star_<n>, and Complex_Star_<n>.  (This convention should not
apply to Character*<n>, for which the Ada analog is the constrained
array subtype Fortran_Character (1..<n>).)  Similarly, the Fortran
interface package for an implementation of Fortran 90 that provides
multiple <kinds> of intrinsic types, e.g.  Integer (Kind=<n>), Real
(Kind=<n>), Logical (Kind=<n>), Complex (Kind=<n>), and Character
(Kind=<n>), may contain the declarations of types with the recommended
names Integer_Kind_<n>, Real_Kind_<n>, Logical_Kind_<n>,
Complex_Kind_<n>, and Character_Kind_<n>.

                        _Implementation Advice_

22
An Ada implementation should support the following interface
correspondences between Ada and Fortran:

23
   * An Ada procedure corresponds to a Fortran subroutine.

24
   * An Ada function corresponds to a Fortran function.

25
   * An Ada parameter of an elementary, array, or record type T is
     passed as a TF argument to a Fortran procedure, where TF is the
     Fortran type corresponding to the Ada type T, and where the INTENT
     attribute of the corresponding dummy argument matches the Ada
     formal parameter mode; the Fortran implementation's parameter
     passing conventions are used.  For elementary types, a local copy
     is used if necessary to ensure by-copy semantics.

26
   * An Ada parameter of an access-to-subprogram type is passed as a
     reference to a Fortran procedure whose interface corresponds to the
     designated subprogram's specification.

     NOTES

27
     14  An object of a Fortran-compatible record type, declared in a
     library package or subprogram, can correspond to a Fortran common
     block; the type also corresponds to a Fortran "derived type".

                              _Examples_

28
<Example of Interfaces.Fortran:>

29
     with Interfaces.Fortran;
     use Interfaces.Fortran;
     procedure Ada_Application is

30/3
        type Fortran_Matrix is array (Integer range <>,
                                      Integer range <>) of Double_Precision
           with Convention => Fortran;                  <-- stored in Fortran's>
                                                        <-- column-major order>
        procedure Invert (Rank : in Fortran_Integer; X : in out Fortran_Matrix)
           with Import => True, Convention => Fortran; <-- a Fortran subroutine>

31
        Rank      : constant Fortran_Integer := 100;
        My_Matrix : Fortran_Matrix (1 .. Rank, 1 .. Rank);

32
     begin

33
        ...
        My_Matrix := ...;
        ...
        Invert (Rank, My_Matrix);
        ...

34
     end Ada_Application;


File: arm2012.info,  Node: Annex C,  Next: Annex D,  Prev: Annex B,  Up: Top

Annex C Systems Programming
***************************

1
The Systems Programming Annex specifies additional capabilities provided
for low-level programming.  These capabilities are also required in many
real-time, embedded, distributed, and information systems.

* Menu:

* C.1 ::      Access to Machine Operations
* C.2 ::      Required Representation Support
* C.3 ::      Interrupt Support
* C.4 ::      Preelaboration Requirements
* C.5 ::      Aspect Discard_Names
* C.6 ::      Shared Variable Control
* C.7 ::      Task Information


File: arm2012.info,  Node: C.1,  Next: C.2,  Up: Annex C

C.1 Access to Machine Operations
================================

1/3
This subclause specifies rules regarding access to machine instructions
from within an Ada program.

                     _Implementation Requirements_

2
The implementation shall support machine code insertions (see *note
13.8::) or intrinsic subprograms (see *note 6.3.1::) (or both).
Implementation-defined attributes shall be provided to allow the use of
Ada entities as operands.

                        _Implementation Advice_

3
The machine code or intrinsics support should allow access to all
operations normally available to assembly language programmers for the
target environment, including privileged instructions, if any.

4/3
The support for interfacing aspects (see *note Annex B::) should include
interface to assembler; the default assembler should be associated with
the convention identifier Assembler.

5
If an entity is exported to assembly language, then the implementation
should allocate it at an addressable location, and should ensure that it
is retained by the linking process, even if not otherwise referenced
from the Ada code.  The implementation should assume that any call to a
machine code or assembler subprogram is allowed to read or update every
object that is specified as exported.

                     _Documentation Requirements_

6
The implementation shall document the overhead associated with calling
machine-code or intrinsic subprograms, as compared to a fully-inlined
call, and to a regular out-of-line call.

7
The implementation shall document the types of the package
System.Machine_Code usable for machine code insertions, and the
attributes to be used in machine code insertions for references to Ada
entities.

8/3
The implementation shall document the subprogram calling conventions
associated with the convention identifiers available for use with the
Convention aspect (Ada and Assembler, at a minimum), including register
saving, exception propagation, parameter passing, and function value
returning.

9
For exported and imported subprograms, the implementation shall document
the mapping between the Link_Name string, if specified, or the Ada
designator, if not, and the external link name used for such a
subprogram.

                        _Implementation Advice_

10
The implementation should ensure that little or no overhead is
associated with calling intrinsic and machine-code subprograms.

11
It is recommended that intrinsic subprograms be provided for convenient
access to any machine operations that provide special capabilities or
efficiency and that are not otherwise available through the language
constructs.  Examples of such instructions include:

12
   * Atomic read-modify-write operations -- e.g., test and set, compare
     and swap, decrement and test, enqueue/dequeue.

13
   * Standard numeric functions -- e.g., <sin>, <log>.

14
   * String manipulation operations -- e.g., translate and test.

15
   * Vector operations -- e.g., compare vector against thresholds.

16
   * Direct operations on I/O ports.


File: arm2012.info,  Node: C.2,  Next: C.3,  Prev: C.1,  Up: Annex C

C.2 Required Representation Support
===================================

1/3
This subclause specifies minimal requirements on the support for
representation items and related features.

                     _Implementation Requirements_

2/3
The implementation shall support at least the functionality defined by
the recommended levels of support in Clause *note 13::.


File: arm2012.info,  Node: C.3,  Next: C.4,  Prev: C.2,  Up: Annex C

C.3 Interrupt Support
=====================

1/3
This subclause specifies the language-defined model for hardware
interrupts in addition to mechanisms for handling interrupts.  

                          _Dynamic Semantics_

2
An <interrupt> represents a class of events that are detected by the
hardware or the system software.  Interrupts are said to occur.  An
<occurrence> of an interrupt is separable into generation and delivery.<Generation> of an interrupt is the event in the underlying hardware or
system that makes the interrupt available to the program.  <Delivery> is
the action that invokes part of the program as response to the interrupt
occurrence.  Between generation and delivery, the interrupt occurrence
(or interrupt) is <pending>.  Some or all interrupts may be <blocked>.
When an interrupt is blocked, all occurrences of that interrupt are
prevented from being delivered.  Certain interrupts are <reserved>.  The
set of reserved interrupts is implementation defined.  A reserved
interrupt is either an interrupt for which user-defined handlers are not
supported, or one which already has an attached handler by some other
implementation-defined means.  Program units can be connected to
nonreserved interrupts.  While connected, the program unit is said to be
<attached> to that interrupt.  The execution of that program unit, the
<interrupt handler>, is invoked upon delivery of the interrupt
occurrence.

3
While a handler is attached to an interrupt, it is called once for each
delivered occurrence of that interrupt.  While the handler executes, the
corresponding interrupt is blocked.

4
While an interrupt is blocked, all occurrences of that interrupt are
prevented from being delivered.  Whether such occurrences remain pending
or are lost is implementation defined.

5
Each interrupt has a <default treatment> which determines the system's
response to an occurrence of that interrupt when no user-defined handler
is attached.  The set of possible default treatments is implementation
defined, as is the method (if one exists) for configuring the default
treatments for interrupts.

6
An interrupt is delivered to the handler (or default treatment) that is
in effect for that interrupt at the time of delivery.

7
An exception propagated from a handler that is invoked by an interrupt
has no effect.

8
If the Ceiling_Locking policy (see *note D.3::) is in effect, the
interrupt handler executes with the active priority that is the ceiling
priority of the corresponding protected object.

                     _Implementation Requirements_

9
The implementation shall provide a mechanism to determine the minimum
stack space that is needed for each interrupt handler and to reserve
that space for the execution of the handler.  This space should
accommodate nested invocations of the handler where the system permits
this.

10
If the hardware or the underlying system holds pending interrupt
occurrences, the implementation shall provide for later delivery of
these occurrences to the program.

11
If the Ceiling_Locking policy is not in effect, the implementation shall
provide means for the application to specify whether interrupts are to
be blocked during protected actions.

                     _Documentation Requirements_

12
The implementation shall document the following items:

13
     1.  For each interrupt, which interrupts are blocked from delivery
     when a handler attached to that interrupt executes (either as a
     result of an interrupt delivery or of an ordinary call on a
     procedure of the corresponding protected object).

14
     2.  Any interrupts that cannot be blocked, and the effect of
     attaching handlers to such interrupts, if this is permitted.

15
     3.  Which run-time stack an interrupt handler uses when it executes
     as a result of an interrupt delivery; if this is configurable, what
     is the mechanism to do so; how to specify how much space to reserve
     on that stack.

16
     4.  Any implementation- or hardware-specific activity that happens
     before a user-defined interrupt handler gets control (e.g., reading
     device registers, acknowledging devices).

17
     5.  Any timing or other limitations imposed on the execution of
     interrupt handlers.

18
     6.  The state (blocked/unblocked) of the nonreserved interrupts
     when the program starts; if some interrupts are unblocked, what is
     the mechanism a program can use to protect itself before it can
     attach the corresponding handlers.

19
     7.  Whether the interrupted task is allowed to resume execution
     before the interrupt handler returns.

20
     8.  The treatment of interrupt occurrences that are generated while
     the interrupt is blocked; i.e., whether one or more occurrences are
     held for later delivery, or all are lost.

21
     9.  Whether predefined or implementation-defined exceptions are
     raised as a result of the occurrence of any interrupt, and the
     mapping between the machine interrupts (or traps) and the
     predefined exceptions.

22
     10.  On a multi-processor, the rules governing the delivery of an
     interrupt to a particular processor.

                     _Implementation Permissions_

23/2
If the underlying system or hardware does not allow interrupts to be
blocked, then no blocking is required as part of the execution of
subprograms of a protected object for which one of its subprograms is an
interrupt handler.

24
In a multi-processor with more than one interrupt subsystem, it is
implementation defined whether (and how) interrupt sources from separate
subsystems share the same Interrupt_Id type (see *note C.3.2::).  In
particular, the meaning of a blocked or pending interrupt may then be
applicable to one processor only.

25
Implementations are allowed to impose timing or other limitations on the
execution of interrupt handlers.

26/3
Other forms of handlers are allowed to be supported, in which case the
rules of this subclause should be adhered to.

27
The active priority of the execution of an interrupt handler is allowed
to vary from one occurrence of the same interrupt to another.

                        _Implementation Advice_

28/2
If the Ceiling_Locking policy is not in effect, the implementation
should provide means for the application to specify which interrupts are
to be blocked during protected actions, if the underlying system allows
for finer-grained control of interrupt blocking.

     NOTES

29
     1  The default treatment for an interrupt can be to keep the
     interrupt pending or to deliver it to an implementation-defined
     handler.  Examples of actions that an implementation-defined
     handler is allowed to perform include aborting the partition,
     ignoring (i.e., discarding occurrences of) the interrupt, or
     queuing one or more occurrences of the interrupt for possible later
     delivery when a user-defined handler is attached to that interrupt.

30
     2  It is a bounded error to call Task_Identification.Current_Task
     (see *note C.7.1::) from an interrupt handler.

31
     3  The rule that an exception propagated from an interrupt handler
     has no effect is modeled after the rule about exceptions propagated
     out of task bodies.

* Menu:

* C.3.1 ::    Protected Procedure Handlers
* C.3.2 ::    The Package Interrupts


File: arm2012.info,  Node: C.3.1,  Next: C.3.2,  Up: C.3

C.3.1 Protected Procedure Handlers
----------------------------------

<Paragraphs 1 through 6 were moved to *note Annex J::, "*note Annex J::
Obsolescent Features".>

                          _Static Semantics_

6.1/3
For a parameterless protected procedure, the following language-defined
representation aspects may be specified:

6.2/3
Interrupt_Handler
               The type of aspect Interrupt_Handler is Boolean.  If
               directly specified, the aspect_definition shall be a
               static expression.  This aspect is never inherited; if
               not directly specified, the aspect is False.

6.3/3
Attach_Handler
               The aspect Attach_Handler is an expression, which shall
               be of type Interrupts.Interrupt_Id.  This aspect is never
               inherited.

                           _Legality Rules_

7/3
If either the Attach_Handler or Interrupt_Handler aspect are specified
for a protected procedure, the corresponding protected_type_declaration
(*note 9.4: S0210.) or single_protected_declaration (*note 9.4: S0211.)
shall be a library-level declaration and shall not be declared within a
generic body.  In addition to the places where Legality Rules normally
apply (see *note 12.3::), this rule also applies in the private part of
an instance of a generic unit.

8/3
<This paragraph was deleted.>

                          _Dynamic Semantics_

9/3
If the Interrupt_Handler aspect of a protected procedure is True, then
the procedure may be attached dynamically, as a handler, to interrupts
(see *note C.3.2::).  Such procedures are allowed to be attached to
multiple interrupts.

10/3
The expression specified for the Attach_Handler aspect of a protected
procedure <P> is evaluated as part of the creation of the protected
object that contains <P>.  The value of the expression identifies an
interrupt.  As part of the initialization of that object, <P> (the
<handler> procedure) is attached to the identified interrupt.  A check
is made that the corresponding interrupt is not reserved.  Program_Error
is raised if the check fails, and the existing treatment for the
interrupt is not affected.

11/3
If the Ceiling_Locking policy (see *note D.3::) is in effect, then upon
the initialization of a protected object that contains a protected
procedure for which either the Attach_Handler aspect is specified or the
Interrupt_Handler aspect is True, a check is made that the initial
ceiling priority of the object is in the range of
System.Interrupt_Priority.  If the check fails, Program_Error is raised.

12/3
When a protected object is finalized, for any of its procedures that are
attached to interrupts, the handler is detached.  If the handler was
attached by a procedure in the Interrupts package or if no user handler
was previously attached to the interrupt, the default treatment is
restored.  If the Attach_Handler aspect was specified and the most
recently attached handler for the same interrupt is the same as the one
that was attached at the time the protected object was initialized, the
previous handler is restored.

13
When a handler is attached to an interrupt, the interrupt is blocked
(subject to the Implementation Permission in *note C.3::) during the
execution of every protected action on the protected object containing
the handler.

                         _Erroneous Execution_

14
If the Ceiling_Locking policy (see *note D.3::) is in effect and an
interrupt is delivered to a handler, and the interrupt hardware priority
is higher than the ceiling priority of the corresponding protected
object, the execution of the program is erroneous.

14.1/3
If the handlers for a given interrupt attached via aspect Attach_Handler
are not attached and detached in a stack-like (LIFO) order, program
execution is erroneous.  In particular, when a protected object is
finalized, the execution is erroneous if any of the procedures of the
protected object are attached to interrupts via aspect Attach_Handler
and the most recently attached handler for the same interrupt is not the
same as the one that was attached at the time the protected object was
initialized.

                               _Metrics_

15
The following metric shall be documented by the implementation:

16/2
   * The worst-case overhead for an interrupt handler that is a
     parameterless protected procedure, in clock cycles.  This is the
     execution time not directly attributable to the handler procedure
     or the interrupted execution.  It is estimated as C - (A+B), where
     A is how long it takes to complete a given sequence of instructions
     without any interrupt, B is how long it takes to complete a normal
     call to a given protected procedure, and C is how long it takes to
     complete the same sequence of instructions when it is interrupted
     by one execution of the same procedure called via an interrupt.

                     _Implementation Permissions_

17/3
When the aspects Attach_Handler or Interrupt_Handler are specified for a
protected procedure, the implementation is allowed to impose
implementation-defined restrictions on the corresponding
protected_type_declaration (*note 9.4: S0210.) and protected_body (*note
9.4: S0215.).

18
An implementation may use a different mechanism for invoking a protected
procedure in response to a hardware interrupt than is used for a call to
that protected procedure from a task.

19/3
Notwithstanding what this subclause says elsewhere, the Attach_Handler
and Interrupt_Handler aspects are allowed to be used for other,
implementation defined, forms of interrupt handlers.

                        _Implementation Advice_

20
Whenever possible, the implementation should allow interrupt handlers to
be called directly by the hardware.

21
Whenever practical, the implementation should detect violations of any
implementation-defined restrictions before run time.

     NOTES

22/3
     4  The Attach_Handler aspect may provide static attachment of
     handlers to interrupts if the implementation supports
     preelaboration of protected objects.  (See *note C.4::.)

23/2
     5  A protected object that has a (protected) procedure attached to
     an interrupt should have a ceiling priority at least as high as the
     highest processor priority at which that interrupt will ever be
     delivered.

24
     6  Protected procedures can also be attached dynamically to
     interrupts via operations declared in the predefined package
     Interrupts.

25
     7  An example of a possible implementation-defined restriction is
     disallowing the use of the standard storage pools within the body
     of a protected procedure that is an interrupt handler.


File: arm2012.info,  Node: C.3.2,  Prev: C.3.1,  Up: C.3

C.3.2 The Package Interrupts
----------------------------

                          _Static Semantics_

1
The following language-defined packages exist:

2/3
     with System;
     with System.Multiprocessors;
     package Ada.Interrupts is
        type Interrupt_Id is <implementation-defined>;
        type Parameterless_Handler is
           access protected procedure;

3/1
     <This paragraph was deleted.>

4
        function Is_Reserved (Interrupt : Interrupt_Id)
           return Boolean;

5
        function Is_Attached (Interrupt : Interrupt_Id)
           return Boolean;

6
        function Current_Handler (Interrupt : Interrupt_Id)
           return Parameterless_Handler;

7
        procedure Attach_Handler
           (New_Handler : in Parameterless_Handler;
            Interrupt   : in Interrupt_Id);

8
        procedure Exchange_Handler
           (Old_Handler : out Parameterless_Handler;
            New_Handler : in Parameterless_Handler;
            Interrupt   : in Interrupt_Id);

9
        procedure Detach_Handler
           (Interrupt : in Interrupt_Id);

10
        function Reference (Interrupt : Interrupt_Id)
           return System.Address;

10.1/3
        function Get_CPU (Interrupt : Interrupt_Id)
           return System.Multiprocessors.CPU_Range;

11
     private
        ... -- <not specified by the language>
     end Ada.Interrupts;

12
     package Ada.Interrupts.Names is
        <implementation-defined> : constant Interrupt_Id :=
          <implementation-defined>;
           . . .
        <implementation-defined> : constant Interrupt_Id :=
          <implementation-defined>;
     end Ada.Interrupts.Names;

                          _Dynamic Semantics_

13
The Interrupt_Id type is an implementation-defined discrete type used to
identify interrupts.

14
The Is_Reserved function returns True if and only if the specified
interrupt is reserved.

15
The Is_Attached function returns True if and only if a user-specified
interrupt handler is attached to the interrupt.

16/1
The Current_Handler function returns a value that represents the
attached handler of the interrupt.  If no user-defined handler is
attached to the interrupt, Current_Handler returns null.

17/3
The Attach_Handler procedure attaches the specified handler to the
interrupt, overriding any existing treatment (including a user handler)
in effect for that interrupt.  If New_Handler is null, the default
treatment is restored.  If New_Handler designates a protected procedure
for which the aspect Interrupt_Handler is False, Program_Error is
raised.  In this case, the operation does not modify the existing
interrupt treatment.

18/1
The Exchange_Handler procedure operates in the same manner as
Attach_Handler with the addition that the value returned in Old_Handler
designates the previous treatment for the specified interrupt.  If the
previous treatment is not a user-defined handler, null is returned.

19
The Detach_Handler procedure restores the default treatment for the
specified interrupt.

20
For all operations defined in this package that take a parameter of type
Interrupt_Id, with the exception of Is_Reserved and Reference, a check
is made that the specified interrupt is not reserved.  Program_Error is
raised if this check fails.

21/3
If, by using the Attach_Handler, Detach_Handler, or Exchange_Handler
procedures, an attempt is made to detach a handler that was attached
statically (using the aspect Attach_Handler), the handler is not
detached and Program_Error is raised.  

22/2
The Reference function returns a value of type System.Address that can
be used to attach a task entry via an address clause (see *note J.7.1::)
to the interrupt specified by Interrupt.  This function raises
Program_Error if attaching task entries to interrupts (or to this
particular interrupt) is not supported.  

22.1/3
The function Get_CPU returns the processor on which the handler for
Interrupt is executed.  If the handler can execute on more than one
processor the value System.Multiprocessors.Not_A_Specific_CPU is
returned.

                     _Implementation Requirements_

23
At no time during attachment or exchange of handlers shall the current
handler of the corresponding interrupt be undefined.

                     _Documentation Requirements_

24/3
If the Ceiling_Locking policy (see *note D.3::) is in effect, the
implementation shall document the default ceiling priority assigned to a
protected object that contains a protected procedure that specifies
either the Attach_Handler or Interrupt_Handler aspects, but does not
specify the Interrupt_Priority aspect.  This default need not be the
same for all interrupts.

                        _Implementation Advice_

25
If implementation-defined forms of interrupt handler procedures are
supported, such as protected procedures with parameters, then for each
such form of a handler, a type analogous to Parameterless_Handler should
be specified in a child package of Interrupts, with the same operations
as in the predefined package Interrupts.

     NOTES

26
     8  The package Interrupts.Names contains implementation-defined
     names (and constant values) for the interrupts that are supported
     by the implementation.

                              _Examples_

27
<Example of interrupt handlers:>

28/3
     Device_Priority : constant
       array (1..5) of System.Interrupt_Priority := ( ... );
     protected type Device_Interface
       (Int_Id : Ada.Interrupts.Interrupt_Id) 
          with Interrupt_Priority => Device_Priority(Int_Id) is
       procedure Handler
          with Attach_Handler => Int_Id;
       ...
       end Device_Interface;
       ...
     Device_1_Driver : Device_Interface(1);
       ...
     Device_5_Driver : Device_Interface(5);
       ...


File: arm2012.info,  Node: C.4,  Next: C.5,  Prev: C.3,  Up: Annex C

C.4 Preelaboration Requirements
===============================

1/3
This subclause specifies additional implementation and documentation
requirements for the Preelaborate pragma (see *note 10.2.1::).

                     _Implementation Requirements_

2
The implementation shall not incur any run-time overhead for the
elaboration checks of subprograms and protected_bodies declared in
preelaborated library units.  

3
The implementation shall not execute any memory write operations after
load time for the elaboration of constant objects declared immediately
within the declarative region of a preelaborated library package, so
long as the subtype and initial expression (or default initial
expressions if initialized by default) of the object_declaration satisfy
the following restrictions.  The meaning of <load time> is
implementation defined.

4
   * Any subtype_mark denotes a statically constrained subtype, with
     statically constrained subcomponents, if any;

4.1/2
   * no subtype_mark denotes a controlled type, a private type, a
     private extension, a generic formal private type, a generic formal
     derived type, or a descendant of such a type;

5
   * any constraint is a static constraint;

6
   * any allocator is for an access-to-constant type;

7
   * any uses of predefined operators appear only within static
     expressions;

8
   * any primaries that are names, other than attribute_references for
     the Access or Address attributes, appear only within static
     expressions;

9
   * any name that is not part of a static expression is an expanded
     name or direct_name that statically denotes some entity;

10
   * any discrete_choice of an array_aggregate is static;

11
   * no language-defined check associated with the elaboration of the
     object_declaration can fail.

                     _Documentation Requirements_

12
The implementation shall document any circumstances under which the
elaboration of a preelaborated package causes code to be executed at run
time.

13
The implementation shall document whether the method used for
initialization of preelaborated variables allows a partition to be
restarted without reloading.

                        _Implementation Advice_

14
It is recommended that preelaborated packages be implemented in such a
way that there should be little or no code executed at run time for the
elaboration of entities not already covered by the Implementation
Requirements.


File: arm2012.info,  Node: C.5,  Next: C.6,  Prev: C.4,  Up: Annex C

C.5 Aspect Discard_Names
========================

1/4
Specifying the aspect Discard_Names can be used to request a reduction
in storage used for the names of entities with runtime name text.

                          _Static Semantics_

1.1/4
An entity with <runtime name text> is a nonderived enumeration first
subtype, a tagged first subtype, or an exception.

1.2/4
For an entity with runtime name text, the following language-defined
representation aspect may be specified:

1.3/4
Discard_Names
               The type of aspect Discard_Names is Boolean.  If directly
               specified, the aspect_definition shall be a static
               expression.  If not specified (including by inheritance),
               the aspect is False.

                               _Syntax_

2
     The form of a pragma Discard_Names is as follows:

3
       pragma Discard_Names[([On => ] local_name)];

4
     A pragma Discard_Names is allowed only immediately within a
     declarative_part, immediately within a package_specification, or as
     a configuration pragma.  

                           _Legality Rules_

5/4
The local_name (if present) shall denote an entity with runtime name
text.  The pragma specifies that the aspect Discard_Names for the type
or exception has the value True.  Without a local_name, the pragma
specifies that all entities with runtime name text declared after the
pragma, within the same declarative region have the value True for
aspect Discard_Names.  Alternatively, the pragma can be used as a
configuration pragma.  If the configuration pragma Discard_Names applies
to a compilation unit, all entities with runtime name text declared in
the compilation unit have the value True for the aspect Discard_Names..

                          _Static Semantics_

6
If a local_name is given, then a pragma Discard_Names is a
representation pragma.

7/4
If the aspect Discard_Names is True for an enumeration type, then the
semantics of the Wide_Wide_Image and Wide_Wide_Value attributes are
implementation defined for that type; the semantics of Image,
Wide_Image, Value, and Wide_Value are still defined in terms of
Wide_Wide_Image and Wide_Wide_Value.  In addition, the semantics of
Text_IO.Enumeration_IO are implementation defined.  If the aspect
Discard_Names is True for a tagged type, then the semantics of the
Tags.Wide_Wide_Expanded_Name function are implementation defined for
that type; the semantics of Tags.Expanded_Name and
Tags.Wide_Expanded_Name are still defined in terms of
Tags.Wide_Wide_Expanded_Name.  If the aspect Discard_Names is True for
an exception, then the semantics of the
Exceptions.Wide_Wide_Exception_Name function are implementation defined
for that exception; the semantics of Exceptions.Exception_Name and
Exceptions.Wide_Exception_Name are still defined in terms of
Exceptions.Wide_Wide_Exception_Name.

                        _Implementation Advice_

8/4
If the aspect Discard_Names is True for an entity, then the
implementation should reduce the amount of storage used for storing
names associated with that entity.


File: arm2012.info,  Node: C.6,  Next: C.7,  Prev: C.5,  Up: Annex C

C.6 Shared Variable Control
===========================

1/3
This subclause defines representation aspects that control the use of
shared variables.

<Paragraphs 2 through 6 were moved to *note Annex J::, "*note Annex J::
Obsolescent Features".>

                          _Static Semantics_

6.1/3
For an object_declaration, a component_declaration, or a
full_type_declaration, the following representation aspects may be
specified:

6.2/3
Atomic
               The type of aspect Atomic is Boolean.

6.3/3
Independent
               The type of aspect Independent is Boolean.

6.4/3
Volatile
               The type of aspect Volatile is Boolean.

6.5/3
For a full_type_declaration of an array type (including the anonymous
type of an object_declaration of an anonymous array object), the
following representation aspects may be specified:

6.6/3
Atomic_Components
               The type of aspect Atomic_Components is Boolean.

6.7/3
Volatile_Components
               The type of aspect Volatile_Components is Boolean.

6.8/3
For a full_type_declaration (including the anonymous type of an
object_declaration of an anonymous array object), the following
representation aspect may be specified:

6.9/3
Independent_Components
               The type of aspect Independent_Components is Boolean.

6.10/3
If any of these aspects are directly specified, the aspect_definition
shall be a static expression.  If not specified (including by
inheritance), each of these aspects is False.

7/3
An <atomic> type is one for which the aspect Atomic is True.  An
<atomic> object (including a component) is one for which the aspect
Atomic is True, or a component of an array for which the aspect
Atomic_Components is True for the associated type, or any object of an
atomic type, other than objects obtained by evaluating a slice.

8/3
A <volatile> type is one for which the aspect Volatile is True.  A
<volatile> object (including a component) is one for which the aspect
Volatile is True, or a component of an array for which the aspect
Volatile_Components is True for the associated type, or any object of a
volatile type.  In addition, every atomic type or object is also defined
to be volatile.  Finally, if an object is volatile, then so are all of
its subcomponents (the same does not apply to atomic).

8.1/4
When True, the aspects Independent and Independent_Components <specify
as independently addressable> the named object or component(s), or in
the case of a type, all objects or components of that type.  All atomic
objects and aliased objects are considered to be specified as
independently addressable.

<Paragraph 9 was moved to *note Annex J::, "*note Annex J:: Obsolescent
Features".>

                           _Legality Rules_

9.1/3
If aspect Independent_Components is specified for a
full_type_declaration, the declaration shall be that of an array or
record type.

10/4
It is illegal to specify either of the aspects Atomic or
Atomic_Components to have the value True for an object or type if the
implementation cannot support the indivisible and independent reads and
updates required by the aspect (see below).

11/4
It is illegal to specify the Size attribute of an atomic object, the
Component_Size attribute for an array type with atomic components, or
the layout attributes of an atomic component, in a way that prevents the
implementation from performing the required indivisible and independent
reads and updates.

12/3
If an atomic object is passed as a parameter, then the formal parameter
shall either have an atomic type or allow pass by copy.  If an atomic
object is used as an actual for a generic formal object of mode in out,
then the type of the generic formal object shall be atomic.  If the
prefix of an attribute_reference for an Access attribute denotes an
atomic object (including a component), then the designated type of the
resulting access type shall be atomic.  If an atomic type is used as an
actual for a generic formal derived type, then the ancestor of the
formal type shall be atomic.  Corresponding rules apply to volatile
objects and types.

12.1/3
If a volatile type is used as an actual for a generic formal array type,
then the element type of the formal type shall be volatile.

13/3
If an aspect Volatile, Volatile_Components, Atomic, or Atomic_Components
is directly specified to have the value True for a stand-alone constant
object, then the aspect Import shall also be specified as True for it.

13.1/3
It is illegal to specify the aspect Independent or
Independent_Components as True for a component, object or type if the
implementation cannot provide the independent addressability required by
the aspect (see *note 9.10::).

13.2/3
It is illegal to specify a representation aspect for a component, object
or type for which the aspect Independent or Independent_Components is
True, in a way that prevents the implementation from providing the
independent addressability required by the aspect.

<Paragraph 14 was moved to *note Annex J::, "*note Annex J:: Obsolescent
Features".>

                          _Dynamic Semantics_

15
For an atomic object (including an atomic component) all reads and
updates of the object as a whole are indivisible.

16/3
All tasks of the program (on all processors) that read or update
volatile variables see the same order of updates to the variables.  A
use of an atomic variable or other mechanism may be necessary to avoid
erroneous execution and to ensure that access to nonatomic volatile
variables is sequential (see *note 9.10::).

17
Two actions are sequential (see *note 9.10::) if each is the read or
update of the same atomic object.

18
If a type is atomic or volatile and it is not a by-copy type, then the
type is defined to be a by-reference type.  If any subcomponent of a
type is atomic or volatile, then the type is defined to be a
by-reference type.

19
If an actual parameter is atomic or volatile, and the corresponding
formal parameter is not, then the parameter is passed by copy.

                     _Implementation Requirements_

20
The external effect of a program (see *note 1.1.3::) is defined to
include each read and update of a volatile or atomic object.  The
implementation shall not generate any memory reads or updates of atomic
or volatile objects other than those specified by the program.

21/4
<This paragraph was deleted.>

                        _Implementation Advice_

22/2
A load or store of a volatile object whose size is a multiple of
System.Storage_Unit and whose alignment is nonzero, should be
implemented by accessing exactly the bits of the object and no others.

23/2
A load or store of an atomic object should, where possible, be
implemented by a single load or store instruction.

     NOTES

24
     9  An imported volatile or atomic constant behaves as a constant
     (i.e.  read-only) with respect to other parts of the Ada program,
     but can still be modified by an "external source."

25/4
     10  Specifying the Pack aspect cannot override the effect of
     specifying an Atomic or Atomic_Components aspect.


File: arm2012.info,  Node: C.7,  Prev: C.6,  Up: Annex C

C.7 Task Information
====================

1/3
This subclause describes operations and attributes that can be used to
obtain the identity of a task.  In addition, a package that associates
user-defined information with a task is defined.  Finally, a package
that associates termination procedures with a task or set of tasks is
defined.

* Menu:

* C.7.1 ::    The Package Task_Identification
* C.7.2 ::    The Package Task_Attributes
* C.7.3 ::    The Package Task_Termination


File: arm2012.info,  Node: C.7.1,  Next: C.7.2,  Up: C.7

C.7.1 The Package Task_Identification
-------------------------------------

                          _Static Semantics_

1
The following language-defined library package exists:

2/2
     package Ada.Task_Identification is
        pragma Preelaborate(Task_Identification);
        type Task_Id is private;
        pragma Preelaborable_Initialization (Task_Id);
        Null_Task_Id : constant Task_Id;
        function  "=" (Left, Right : Task_Id) return Boolean;

3/3
        function  Image                  (T : Task_Id) return String;
        function  Current_Task     return Task_Id;
        function  Environment_Task return Task_Id;
        procedure Abort_Task             (T : in Task_Id);

4/3
        function  Is_Terminated          (T : Task_Id) return Boolean;
        function  Is_Callable            (T : Task_Id) return Boolean;
        function  Activation_Is_Complete (T : Task_Id) return Boolean;
     private
        ... -- <not specified by the language>
     end Ada.Task_Identification;

                          _Dynamic Semantics_

5
A value of the type Task_Id identifies an existent task.  The constant
Null_Task_Id does not identify any task.  Each object of the type
Task_Id is default initialized to the value of Null_Task_Id.

6
The function "=" returns True if and only if Left and Right identify the
same task or both have the value Null_Task_Id.

7
The function Image returns an implementation-defined string that
identifies T. If T equals Null_Task_Id, Image returns an empty string.

8
The function Current_Task returns a value that identifies the calling
task.

8.1/3
The function Environment_Task returns a value that identifies the
environment task.

9
The effect of Abort_Task is the same as the abort_statement for the task
identified by T. In addition, if T identifies the environment task, the
entire partition is aborted, See *note E.1::.

10
The functions Is_Terminated and Is_Callable return the value of the
corresponding attribute of the task identified by T.

10.1/3
The function Activation_Is_Complete returns True if the task identified
by T has completed its activation (whether successfully or not).  It
returns False otherwise.  If T identifies the environment task,
Activation_Is_Complete returns True after the elaboration of the
library_items of the partition has completed.

11
For a prefix T that is of a task type (after any implicit dereference),
the following attribute is defined:

12
T'Identity
               Yields a value of the type Task_Id that identifies the
               task denoted by T.

13
For a prefix E that denotes an entry_declaration, the following
attribute is defined:

14/3
E'Caller
               Yields a value of the type Task_Id that identifies the
               task whose call is now being serviced.  Use of this
               attribute is allowed only inside an accept_statement, or
               entry_body after the entry_barrier, corresponding to the
               entry_declaration denoted by E.

15
Program_Error is raised if a value of Null_Task_Id is passed as a
parameter to Abort_Task, Is_Terminated, and Is_Callable.

16
Abort_Task is a potentially blocking operation (see *note 9.5.1::).

                      _Bounded (Run-Time) Errors_

17/3
It is a bounded error to call the Current_Task function from an
entry_body, interrupt handler, or finalization of a task attribute.
Program_Error is raised, or an implementation-defined value of the type
Task_Id is returned.

                         _Erroneous Execution_

18
If a value of Task_Id is passed as a parameter to any of the operations
declared in this package (or any language-defined child of this
package), and the corresponding task object no longer exists, the
execution of the program is erroneous.

                     _Documentation Requirements_

19
The implementation shall document the effect of calling Current_Task
from an entry body or interrupt handler.

     NOTES

20
     11  This package is intended for use in writing user-defined task
     scheduling packages and constructing server tasks.  Current_Task
     can be used in conjunction with other operations requiring a task
     as an argument such as Set_Priority (see *note D.5::).

21
     12  The function Current_Task and the attribute Caller can return a
     Task_Id value that identifies the environment task.


File: arm2012.info,  Node: C.7.2,  Next: C.7.3,  Prev: C.7.1,  Up: C.7

C.7.2 The Package Task_Attributes
---------------------------------

                          _Static Semantics_

1
The following language-defined generic library package exists:

2
     with Ada.Task_Identification; use Ada.Task_Identification;
     generic
        type Attribute is private;
        Initial_Value : in Attribute;
     package Ada.Task_Attributes is

3
        type Attribute_Handle is access all Attribute;

4
        function Value(T : Task_Id := Current_Task)
          return Attribute;

5
        function Reference(T : Task_Id := Current_Task)
          return Attribute_Handle;

6
        procedure Set_Value(Val : in Attribute;
                            T : in Task_Id := Current_Task);
        procedure Reinitialize(T : in Task_Id := Current_Task);

7
     end Ada.Task_Attributes;

                          _Dynamic Semantics_

8
When an instance of Task_Attributes is elaborated in a given active
partition, an object of the actual type corresponding to the formal type
Attribute is implicitly created for each task (of that partition) that
exists and is not yet terminated.  This object acts as a user-defined
attribute of the task.  A task created previously in the partition and
not yet terminated has this attribute from that point on.  Each task
subsequently created in the partition will have this attribute when
created.  In all these cases, the initial value of the given attribute
is Initial_Value.

9
The Value operation returns the value of the corresponding attribute of
T.

10
The Reference operation returns an access value that designates the
corresponding attribute of T.

11
The Set_Value operation performs any finalization on the old value of
the attribute of T and assigns Val to that attribute (see *note 5.2::
and *note 7.6::).

12
The effect of the Reinitialize operation is the same as Set_Value where
the Val parameter is replaced with Initial_Value.

13
For all the operations declared in this package, Tasking_Error is raised
if the task identified by T is terminated.  Program_Error is raised if
the value of T is Null_Task_Id.

13.1/2
After a task has terminated, all of its attributes are finalized, unless
they have been finalized earlier.  When the master of an instantiation
of Ada.Task_Attributes is finalized, the corresponding attribute of each
task is finalized, unless it has been finalized earlier.

                      _Bounded (Run-Time) Errors_

13.2/1
If the package Ada.Task_Attributes is instantiated with a controlled
type and the controlled type has user-defined Adjust or Finalize
operations that in turn access task attributes by any of the above
operations, then a call of Set_Value of the instantiated package
constitutes a bounded error.  The call may perform as expected or may
result in forever blocking the calling task and subsequently some or all
tasks of the partition.

                         _Erroneous Execution_

14
It is erroneous to dereference the access value returned by a given call
on Reference after a subsequent call on Reinitialize for the same task
attribute, or after the associated task terminates.

15
If a value of Task_Id is passed as a parameter to any of the operations
declared in this package and the corresponding task object no longer
exists, the execution of the program is erroneous.

15.1/2
An access to a task attribute via a value of type Attribute_Handle is
erroneous if executed concurrently with another such access or a call of
any of the operations declared in package Task_Attributes.  An access to
a task attribute is erroneous if executed concurrently with or after the
finalization of the task attribute.

                     _Implementation Requirements_

16/1
For a given attribute of a given task, the implementation shall perform
the operations declared in this package atomically with respect to any
of these operations of the same attribute of the same task.  The
granularity of any locking mechanism necessary to achieve such atomicity
is implementation defined.

17/2
After task attributes are finalized, the implementation shall reclaim
any storage associated with the attributes.

                     _Documentation Requirements_

18
The implementation shall document the limit on the number of attributes
per task, if any, and the limit on the total storage for attribute
values per task, if such a limit exists.

19
In addition, if these limits can be configured, the implementation shall
document how to configure them.

                               _Metrics_

20/2
The implementation shall document the following metrics: A task calling
the following subprograms shall execute at a sufficiently high priority
as to not be preempted during the measurement period.  This period shall
start just before issuing the call and end just after the call
completes.  If the attributes of task T are accessed by the measurement
tests, no other task shall access attributes of that task during the
measurement period.  For all measurements described here, the Attribute
type shall be a scalar type whose size is equal to the size of the
predefined type Integer.  For each measurement, two cases shall be
documented: one where the accessed attributes are of the calling task
(that is, the default value for the T parameter is used), and the other,
where T identifies another, nonterminated, task.

21
The following calls (to subprograms in the Task_Attributes package)
shall be measured:

22
   * a call to Value, where the return value is Initial_Value;

23
   * a call to Value, where the return value is not equal to
     Initial_Value;

24
   * a call to Reference, where the return value designates a value
     equal to Initial_Value;

25
   * a call to Reference, where the return value designates a value not
     equal to Initial_Value;

26/2
   * a call to Set_Value where the Val parameter is not equal to
     Initial_Value and the old attribute value is equal to
     Initial_Value;

27
   * a call to Set_Value where the Val parameter is not equal to
     Initial_Value and the old attribute value is not equal to
     Initial_Value.

                     _Implementation Permissions_

28
An implementation need not actually create the object corresponding to a
task attribute until its value is set to something other than that of
Initial_Value, or until Reference is called for the task attribute.
Similarly, when the value of the attribute is to be reinitialized to
that of Initial_Value, the object may instead be finalized and its
storage reclaimed, to be recreated when needed later.  While the object
does not exist, the function Value may simply return Initial_Value,
rather than implicitly creating the object.

29
An implementation is allowed to place restrictions on the maximum number
of attributes a task may have, the maximum size of each attribute, and
the total storage size allocated for all the attributes of a task.

                        _Implementation Advice_

30/2
Some implementations are targeted to domains in which memory use at run
time must be completely deterministic.  For such implementations, it is
recommended that the storage for task attributes will be pre-allocated
statically and not from the heap.  This can be accomplished by either
placing restrictions on the number and the size of the attributes of a
task, or by using the pre-allocated storage for the first N attribute
objects, and the heap for the others.  In the latter case, N should be
documented.

30.1/2
Finalization of task attributes and reclamation of associated storage
should be performed as soon as possible after task termination.

     NOTES

31
     13  An attribute always exists (after instantiation), and has the
     initial value.  It need not occupy memory until the first operation
     that potentially changes the attribute value.  The same holds true
     after Reinitialize.

32
     14  The result of the Reference function should be used with care;
     it is always safe to use that result in the task body whose
     attribute is being accessed.  However, when the result is being
     used by another task, the programmer must make sure that the task
     whose attribute is being accessed is not yet terminated.  Failing
     to do so could make the program execution erroneous.


File: arm2012.info,  Node: C.7.3,  Prev: C.7.2,  Up: C.7

C.7.3 The Package Task_Termination
----------------------------------

                          _Static Semantics_

1/2
The following language-defined library package exists:

2/2
     with Ada.Task_Identification;
     with Ada.Exceptions;
     package Ada.Task_Termination is
        pragma Preelaborate(Task_Termination);

3/2
        type Cause_Of_Termination is (Normal, Abnormal, Unhandled_Exception);

4/2
        type Termination_Handler is access protected procedure
          (Cause : in Cause_Of_Termination;
           T     : in Ada.Task_Identification.Task_Id;
           X     : in Ada.Exceptions.Exception_Occurrence);

5/2
        procedure Set_Dependents_Fallback_Handler
          (Handler: in Termination_Handler);
        function Current_Task_Fallback_Handler return Termination_Handler;

6/2
        procedure Set_Specific_Handler
          (T       : in Ada.Task_Identification.Task_Id;
           Handler : in Termination_Handler);
        function Specific_Handler (T : Ada.Task_Identification.Task_Id)
           return Termination_Handler;

7/2
     end Ada.Task_Termination;

                          _Dynamic Semantics_

8/3
The type Termination_Handler identifies a protected procedure to be
executed by the implementation when a task terminates.  Such a protected
procedure is called a <handler>.  In all cases T identifies the task
that is terminating.  If the task terminates due to completing the last
statement of its body, or as a result of waiting on a terminate
alternative, and the finalization of the task completes normally, then
Cause is set to Normal and X is set to Null_Occurrence.  If the task
terminates because it is being aborted, then Cause is set to Abnormal; X
is set to Null_Occurrence if the finalization of the task completes
normally.  If the task terminates because of an exception raised by the
execution of its task_body, then Cause is set to Unhandled_Exception; X
is set to the associated exception occurrence if the finalization of the
task completes normally.  Independent of how the task completes, if
finalization of the task propagates an exception, then Cause is either
Unhandled_Exception or Abnormal, and X is an exception occurrence that
identifies the Program_Error exception.

9/2
Each task has two termination handlers, a <fall-back handler> and a
<specific handler>.  The specific handler applies only to the task
itself, while the fall-back handler applies only to the dependent tasks
of the task.  A handler is said to be <set> if it is associated with a
nonnull value of type Termination_Handler, and <cleared> otherwise.
When a task is created, its specific handler and fall-back handler are
cleared.

10/3
The procedure Set_Dependents_Fallback_Handler changes the fall-back
handler for the calling task: if Handler is null, that fall-back handler
is cleared; otherwise, it is set to be Handler.all.  If a fall-back
handler had previously been set it is replaced.

11/3
The function Current_Task_Fallback_Handler returns the fall-back handler
that is currently set for the calling task, if one is set; otherwise, it
returns null.

12/3
The procedure Set_Specific_Handler changes the specific handler for the
task identified by T: if Handler is null, that specific handler is
cleared; otherwise, it is set to be Handler.all.  If a specific handler
had previously been set it is replaced.

13/3
The function Specific_Handler returns the specific handler that is
currently set for the task identified by T, if one is set; otherwise, it
returns null.

14/2
As part of the finalization of a task_body, after performing the actions
specified in *note 7.6:: for finalization of a master, the specific
handler for the task, if one is set, is executed.  If the specific
handler is cleared, a search for a fall-back handler proceeds by
recursively following the master relationship for the task.  If a task
is found whose fall-back handler is set, that handler is executed;
otherwise, no handler is executed.

15/2
For Set_Specific_Handler or Specific_Handler, Tasking_Error is raised if
the task identified by T has already terminated.  Program_Error is
raised if the value of T is Ada.Task_Identification.Null_Task_Id.

16/2
An exception propagated from a handler that is invoked as part of the
termination of a task has no effect.

                         _Erroneous Execution_

17/2
For a call of Set_Specific_Handler or Specific_Handler, if the task
identified by T no longer exists, the execution of the program is
erroneous.


File: arm2012.info,  Node: Annex D,  Next: Annex E,  Prev: Annex C,  Up: Top

Annex D Real-Time Systems
*************************

1
This Annex specifies additional characteristics of Ada implementations
intended for real-time systems software.  To conform to this Annex, an
implementation shall also conform to the Systems Programming Annex.

                               _Metrics_

2
The metrics are documentation requirements; an implementation shall
document the values of the language-defined metrics for at least one
configuration of hardware or an underlying system supported by the
implementation, and shall document the details of that configuration.

3
The metrics do not necessarily yield a simple number.  For some, a range
is more suitable, for others a formula dependent on some parameter is
appropriate, and for others, it may be more suitable to break the metric
into several cases.  Unless specified otherwise, the metrics in this
annex are expressed in processor clock cycles.  For metrics that require
documentation of an upper bound, if there is no upper bound, the
implementation shall report that the metric is unbounded.

     NOTES

4
     1  The specification of the metrics makes a distinction between
     upper bounds and simple execution times.  Where something is just
     specified as "the execution time of" a piece of code, this leaves
     one the freedom to choose a nonpathological case.  This kind of
     metric is of the form "there exists a program such that the value
     of the metric is V". Conversely, the meaning of upper bounds is
     "there is no program such that the value of the metric is greater
     than V". This kind of metric can only be partially tested, by
     finding the value of V for one or more test programs.

5
     2  The metrics do not cover the whole language; they are limited to
     features that are specified in *note Annex C::, "*note Annex C::
     Systems Programming" and in this Annex.  The metrics are intended
     to provide guidance to potential users as to whether a particular
     implementation of such a feature is going to be adequate for a
     particular real-time application.  As such, the metrics are aimed
     at known implementation choices that can result in significant
     performance differences.

6
     3  The purpose of the metrics is not necessarily to provide
     fine-grained quantitative results or to serve as a comparison
     between different implementations on the same or different
     platforms.  Instead, their goal is rather qualitative; to define a
     standard set of approximate values that can be measured and used to
     estimate the general suitability of an implementation, or to
     evaluate the comparative utility of certain features of an
     implementation for a particular real-time application.

* Menu:

* D.1 ::      Task Priorities
* D.2 ::      Priority Scheduling
* D.3 ::      Priority Ceiling Locking
* D.4 ::      Entry Queuing Policies
* D.5 ::      Dynamic Priorities
* D.6 ::      Preemptive Abort
* D.7 ::      Tasking Restrictions
* D.8 ::      Monotonic Time
* D.9 ::      Delay Accuracy
* D.10 ::     Synchronous Task Control
* D.11 ::     Asynchronous Task Control
* D.12 ::     Other Optimizations and Determinism Rules
* D.13 ::     The Ravenscar Profile
* D.14 ::     Execution Time
* D.15 ::     Timing Events
* D.16 ::     Multiprocessor Implementation


File: arm2012.info,  Node: D.1,  Next: D.2,  Up: Annex D

D.1 Task Priorities
===================

1/3
This subclause specifies the priority model for real-time systems.  In
addition, the methods for specifying priorities are defined.

<Paragraphs 2 through 6 were moved to *note Annex J::, "*note Annex J::
Obsolescent Features".>

                          _Static Semantics_

6.1/3
For a task type (including the anonymous type of a
single_task_declaration), protected type (including the anonymous type
of a single_protected_declaration), or subprogram, the following
language-defined representation aspects may be specified:

6.2/3
Priority
               The aspect Priority is an expression, which shall be of
               type Integer.

6.3/3
Interrupt_Priority
               The aspect Interrupt_Priority is an expression, which
               shall be of type Integer.

                           _Legality Rules_

7/3
<This paragraph was deleted.>

8/3
If the Priority aspect is specified for a subprogram, the expression
shall be static, and its value shall be in the range of System.Priority.

8.1/3
At most one of the Priority and Interrupt_Priority aspects may be
specified for a given entity.

8.2/3
Neither of the Priority or Interrupt_Priority aspects shall be specified
for a synchronized interface type.

                          _Static Semantics_

9
The following declarations exist in package System:

10
     subtype Any_Priority is Integer range <implementation-defined>;
     subtype Priority is Any_Priority
        range Any_Priority'First .. <implementation-defined>;
     subtype Interrupt_Priority is Any_Priority
        range Priority'Last+1 .. Any_Priority'Last;

11
     Default_Priority : constant Priority := (Priority'First + Priority'Last)/2;

12
The full range of priority values supported by an implementation is
specified by the subtype Any_Priority.  The subrange of priority values
that are high enough to require the blocking of one or more interrupts
is specified by the subtype Interrupt_Priority.  The subrange of
priority values below System.Interrupt_Priority'First is specified by
the subtype System.Priority.

13/3
<This paragraph was deleted.>

                          _Dynamic Semantics_

14/3
The Priority aspect has no effect if it is specified for a subprogram
other than the main subprogram; the Priority value is not associated
with any task.

15
A <task priority> is an integer value that indicates a degree of urgency
and is the basis for resolving competing demands of tasks for resources.
Unless otherwise specified, whenever tasks compete for processors or
other implementation-defined resources, the resources are allocated to
the task with the highest priority value.  The <base priority> of a task
is the priority with which it was created, or to which it was later set
by Dynamic_Priorities.Set_Priority (see *note D.5::).  At all times, a
task also has an <active priority>, which generally reflects its base
priority as well as any priority it inherits from other sources.
<Priority inheritance> is the process by which the priority of a task or
other entity (e.g.  a protected object; see *note D.3::) is used in the
evaluation of another task's active priority.

16/3
The effect of specifying a Priority or Interrupt_Priority aspect for a
protected type or single_protected_declaration is discussed in *note
D.3::.

17/4
The expression specified for the Priority or Interrupt_Priority aspect
of a task type is evaluated each time an object of the task type is
created (see *note 9.1::).  For the Priority aspect, the value of the
expression is converted to the subtype Priority; for the
Interrupt_Priority aspect, this value is converted to the subtype
Any_Priority.  The priority value is then associated with the task
object.  

18/3
Likewise, the priority value is associated with the environment task if
the aspect is specified for the main subprogram.

19/3
The initial value of a task's base priority is specified by default or
by means of a Priority or Interrupt_Priority aspect.  After a task is
created, its base priority can be changed only by a call to
Dynamic_Priorities.Set_Priority (see *note D.5::).  The initial base
priority of a task in the absence of an aspect is the base priority of
the task that creates it at the time of creation (see *note 9.1::).  If
the aspect Priority is not specified for the main subprogram, the
initial base priority of the environment task is
System.Default_Priority.  The task's active priority is used when the
task competes for processors.  Similarly, the task's active priority is
used to determine the task's position in any queue when Priority_Queuing
is specified (see *note D.4::).

20/2
At any time, the active priority of a task is the maximum of all the
priorities the task is inheriting at that instant.  For a task that is
not held (see *note D.11::), its base priority is a source of priority
inheritance unless otherwise specified for a particular task dispatching
policy.  Other sources of priority inheritance are specified under the
following conditions:

21/1
   * During activation, a task being activated inherits the active
     priority that its activator (see *note 9.2::) had at the time the
     activation was initiated.

22/1
   * During rendezvous, the task accepting the entry call inherits the
     priority of the entry call (see *note 9.5.3:: and *note D.4::).

23
   * During a protected action on a protected object, a task inherits
     the ceiling priority of the protected object (see *note 9.5:: and
     *note D.3::).

24
In all of these cases, the priority ceases to be inherited as soon as
the condition calling for the inheritance no longer exists.

                     _Implementation Requirements_

25
The range of System.Interrupt_Priority shall include at least one value.

26
The range of System.Priority shall include at least 30 values.

     NOTES

27
     4  The priority expression can include references to discriminants
     of the enclosing type.

28
     5  It is a consequence of the active priority rules that at the
     point when a task stops inheriting a priority from another source,
     its active priority is re-evaluated.  This is in addition to other
     instances described in this Annex for such re-evaluation.

29/3
     6  An implementation may provide a nonstandard mode in which tasks
     inherit priorities under conditions other than those specified
     above.


File: arm2012.info,  Node: D.2,  Next: D.3,  Prev: D.1,  Up: Annex D

D.2 Priority Scheduling
=======================

1/3
This subclause describes the rules that determine which task is selected
for execution when more than one task is ready (see *note 9::).

* Menu:

* D.2.1 ::    The Task Dispatching Model
* D.2.2 ::    Task Dispatching Pragmas
* D.2.3 ::    Preemptive Dispatching
* D.2.4 ::    Non-Preemptive Dispatching
* D.2.5 ::    Round Robin Dispatching
* D.2.6 ::    Earliest Deadline First Dispatching


File: arm2012.info,  Node: D.2.1,  Next: D.2.2,  Up: D.2

D.2.1 The Task Dispatching Model
--------------------------------

1/2
The task dispatching model specifies task scheduling, based on
conceptual priority-ordered ready queues.

                          _Static Semantics_

1.1/2
The following language-defined library package exists:

1.2/3
     package Ada.Dispatching is
       pragma Preelaborate(Dispatching);

1.3/3
       procedure Yield;

1.4/3
       Dispatching_Policy_Error : exception;
     end Ada.Dispatching;

1.5/2
Dispatching serves as the parent of other language-defined library units
concerned with task dispatching.

                          _Dynamic Semantics_

2/2
A task can become a <running task> only if it is ready (see *note 9::)
and the execution resources required by that task are available.
Processors are allocated to tasks based on each task's active priority.

3
It is implementation defined whether, on a multiprocessor, a task that
is waiting for access to a protected object keeps its processor busy.

4/2
<Task dispatching> is the process by which one ready task is selected
for execution on a processor.  This selection is done at certain points
during the execution of a task called <task dispatching points>.  A task
reaches a task dispatching point whenever it becomes blocked, and when
it terminates.  Other task dispatching points are defined throughout
this Annex for specific policies.

5/2
<Task dispatching policies> are specified in terms of conceptual <ready
queues> and task states.  A ready queue is an ordered list of ready
tasks.  The first position in a queue is called the <head of the queue>,
and the last position is called the <tail of the queue>.  A task is
<ready> if it is in a ready queue, or if it is running.  Each processor
has one ready queue for each priority value.  At any instant, each ready
queue of a processor contains exactly the set of tasks of that priority
that are ready for execution on that processor, but are not running on
any processor; that is, those tasks that are ready, are not running on
any processor, and can be executed using that processor and other
available resources.  A task can be on the ready queues of more than one
processor.

6/2
Each processor also has one <running task>, which is the task currently
being executed by that processor.  Whenever a task running on a
processor reaches a task dispatching point it goes back to one or more
ready queues; a task (possibly the same task) is then selected to run on
that processor.  The task selected is the one at the head of the highest
priority nonempty ready queue; this task is then removed from all ready
queues to which it belongs.

7/3
A call of Yield is a task dispatching point.  Yield is a potentially
blocking operation (see *note 9.5.1::).

8/2
<This paragraph was deleted.>

                     _Implementation Permissions_

9/2
An implementation is allowed to define additional resources as execution
resources, and to define the corresponding allocation policies for them.
Such resources may have an implementation-defined effect on task
dispatching.

10
An implementation may place implementation-defined restrictions on tasks
whose active priority is in the Interrupt_Priority range.

10.1/2
For optimization purposes, an implementation may alter the points at
which task dispatching occurs, in an implementation-defined manner.
However, a delay_statement always corresponds to at least one task
dispatching point.

     NOTES

11/3
     7  Clause *note 9:: specifies under which circumstances a task
     becomes ready.  The ready state is affected by the rules for task
     activation and termination, delay statements, and entry calls.
     When a task is not ready, it is said to be blocked.

12
     8  An example of a possible implementation-defined execution
     resource is a page of physical memory, which needs to be loaded
     with a particular page of virtual memory before a task can continue
     execution.

13
     9  The ready queues are purely conceptual; there is no requirement
     that such lists physically exist in an implementation.

14
     10  While a task is running, it is not on any ready queue.  Any
     time the task that is running on a processor is added to a ready
     queue, a new running task is selected for that processor.

15
     11  In a multiprocessor system, a task can be on the ready queues
     of more than one processor.  At the extreme, if several processors
     share the same set of ready tasks, the contents of their ready
     queues is identical, and so they can be viewed as sharing one ready
     queue, and can be implemented that way.  Thus, the dispatching
     model covers multiprocessors where dispatching is implemented using
     a single ready queue, as well as those with separate dispatching
     domains.

16
     12  The priority of a task is determined by rules specified in this
     subclause, and under *note D.1::, "*note D.1:: Task Priorities",
     *note D.3::, "*note D.3:: Priority Ceiling Locking", and *note
     D.5::, "*note D.5:: Dynamic Priorities".

17/2
     13  The setting of a task's base priority as a result of a call to
     Set_Priority does not always take effect immediately when
     Set_Priority is called.  The effect of setting the task's base
     priority is deferred while the affected task performs a protected
     action.


File: arm2012.info,  Node: D.2.2,  Next: D.2.3,  Prev: D.2.1,  Up: D.2

D.2.2 Task Dispatching Pragmas
------------------------------

1/3
This subclause allows a single task dispatching policy to be defined for
all priorities, or the range of priorities to be split into subranges
that are assigned individual dispatching policies.

                               _Syntax_

2
     The form of a pragma Task_Dispatching_Policy is as follows:

3
       pragma Task_Dispatching_Policy(<policy_>identifier);

3.1/2
     The form of a pragma Priority_Specific_Dispatching is as follows:

3.2/2
       pragma Priority_Specific_Dispatching (
          <policy_>identifier, <first_priority_>expression,
     <last_priority_>expression);

                        _Name Resolution Rules_

3.3/2
The expected type for <first_priority_>expression and
<last_priority_>expression is Integer.

                           _Legality Rules_

4/2
The <policy_>identifier used in a pragma Task_Dispatching_Policy shall
be the name of a task dispatching policy.

4.1/2
The <policy_>identifier used in a pragma Priority_Specific_Dispatching
shall be the name of a task dispatching policy.

4.2/2
Both <first_priority_>expression and <last_priority_>expression shall be
static expressions in the range of System.Any_Priority;
<last_priority_>expression shall have a value greater than or equal to
<first_priority_>expression.

                          _Static Semantics_

4.3/2
Pragma Task_Dispatching_Policy specifies the single task dispatching
policy.

4.4/2
Pragma Priority_Specific_Dispatching specifies the task dispatching
policy for the specified range of priorities.  Tasks with base
priorities within the range of priorities specified in a
Priority_Specific_Dispatching pragma have their active priorities
determined according to the specified dispatching policy.  Tasks with
active priorities within the range of priorities specified in a
Priority_Specific_Dispatching pragma are dispatched according to the
specified dispatching policy.

4.5/3
If a partition contains one or more Priority_Specific_Dispatching
pragmas, the dispatching policy for priorities not covered by any
Priority_Specific_Dispatching pragmas is FIFO_Within_Priorities.

                       _Post-Compilation Rules_

5/2
A Task_Dispatching_Policy pragma is a configuration pragma.  A
Priority_Specific_Dispatching pragma is a configuration pragma.  

5.1/2
The priority ranges specified in more than one
Priority_Specific_Dispatching pragma within the same partition shall not
be overlapping.

5.2/2
If a partition contains one or more Priority_Specific_Dispatching
pragmas it shall not contain a Task_Dispatching_Policy pragma.

6/2
<This paragraph was deleted.>

                          _Dynamic Semantics_

7/2
A <task dispatching policy> specifies the details of task dispatching
that are not covered by the basic task dispatching model.  These rules
govern when tasks are inserted into and deleted from the ready queues.
A single task dispatching policy is specified by a
Task_Dispatching_Policy pragma.  Pragma Priority_Specific_Dispatching
assigns distinct dispatching policies to subranges of
System.Any_Priority.

7.1/2
If neither pragma applies to any of the program units comprising a
partition, the task dispatching policy for that partition is
unspecified.

7.2/3
If a partition contains one or more Priority_Specific_Dispatching
pragmas, a task dispatching point occurs for the currently running task
of a processor whenever there is a nonempty ready queue for that
processor with a higher priority than the priority of the running task.

7.3/2
A task that has its base priority changed may move from one dispatching
policy to another.  It is immediately subject to the new dispatching
policy.

<Paragraphs 7 through 13 were moved to D.2.3.>

                     _Implementation Requirements_

14.1/2
An implementation shall allow, for a single partition, both the locking
policy (see *note D.3::) to be specified as Ceiling_Locking and also one
or more Priority_Specific_Dispatching pragmas to be given.

                     _Documentation Requirements_

<Paragraphs 14 through 16 were moved to D.2.3.>

                     _Implementation Permissions_

18/2
Implementations are allowed to define other task dispatching policies,
but need not support more than one task dispatching policy per
partition.

19/2
An implementation need not support pragma Priority_Specific_Dispatching
if it is infeasible to support it in the target environment.

     NOTES

     <Paragraphs 19 through 21 were deleted.>


File: arm2012.info,  Node: D.2.3,  Next: D.2.4,  Prev: D.2.2,  Up: D.2

D.2.3 Preemptive Dispatching
----------------------------

1/3
This subclause defines a preemptive task dispatching policy.

                          _Static Semantics_

2/2
The <policy_>identifier FIFO_Within_Priorities is a task dispatching
policy.

                          _Dynamic Semantics_

3/2
When FIFO_Within_Priorities is in effect, modifications to the ready
queues occur only as follows:

4/2
   * When a blocked task becomes ready, it is added at the tail of the
     ready queue for its active priority.

5/2
   * When the active priority of a ready task that is not running
     changes, or the setting of its base priority takes effect, the task
     is removed from the ready queue for its old active priority and is
     added at the tail of the ready queue for its new active priority,
     except in the case where the active priority is lowered due to the
     loss of inherited priority, in which case the task is added at the
     head of the ready queue for its new active priority.

6/2
   * When the setting of the base priority of a running task takes
     effect, the task is added to the tail of the ready queue for its
     active priority.

7/2
   * When a task executes a delay_statement that does not result in
     blocking, it is added to the tail of the ready queue for its active
     priority.

8/2
Each of the events specified above is a task dispatching point (see
*note D.2.1::).

9/2
A task dispatching point occurs for the currently running task of a
processor whenever there is a nonempty ready queue for that processor
with a higher priority than the priority of the running task.  The
currently running task is said to be <preempted> and it is added at the
head of the ready queue for its active priority.

                     _Implementation Requirements_

10/2
An implementation shall allow, for a single partition, both the task
dispatching policy to be specified as FIFO_Within_Priorities and also
the locking policy (see *note D.3::) to be specified as Ceiling_Locking.

                     _Documentation Requirements_

11/2
<Priority inversion> is the duration for which a task remains at the
head of the highest priority nonempty ready queue while the processor
executes a lower priority task.  The implementation shall document:

12/2
   * The maximum priority inversion a user task can experience due to
     activity of the implementation (on behalf of lower priority tasks),
     and

13/2
   * whether execution of a task can be preempted by the implementation
     processing of delay expirations for lower priority tasks, and if
     so, for how long.

     NOTES

14/2
     14  If the active priority of a running task is lowered due to loss
     of inherited priority (as it is on completion of a protected
     operation) and there is a ready task of the same active priority
     that is not running, the running task continues to run (provided
     that there is no higher priority task).

15/2
     15  Setting the base priority of a ready task causes the task to
     move to the tail of the queue for its active priority, regardless
     of whether the active priority of the task actually changes.


File: arm2012.info,  Node: D.2.4,  Next: D.2.5,  Prev: D.2.3,  Up: D.2

D.2.4 Non-Preemptive Dispatching
--------------------------------

1/3
This subclause defines a non-preemptive task dispatching policy.

                          _Static Semantics_

2/2
The <policy_>identifier Non_Preemptive_FIFO_Within_Priorities is a task
dispatching policy.

2.1/3
The following language-defined library package exists:

2.2/3
     package Ada.Dispatching.Non_Preemptive is
       pragma Preelaborate(Non_Preemptive);
       procedure Yield_To_Higher;
       procedure Yield_To_Same_Or_Higher renames Yield;
     end Ada.Dispatching.Non_Preemptive;

2.3/3
A call of Yield_To_Higher is a task dispatching point for this policy.
If the task at the head of the highest priority ready queue has a higher
active priority than the calling task, then the calling task is
preempted.

                           _Legality Rules_

3/2
Non_Preemptive_FIFO_Within_Priorities shall not be specified as the
<policy_>identifier of pragma Priority_Specific_Dispatching (see *note
D.2.2::).

                          _Dynamic Semantics_

4/2
When Non_Preemptive_FIFO_Within_Priorities is in effect, modifications
to the ready queues occur only as follows:

5/2
   * When a blocked task becomes ready, it is added at the tail of the
     ready queue for its active priority.

6/2
   * When the active priority of a ready task that is not running
     changes, or the setting of its base priority takes effect, the task
     is removed from the ready queue for its old active priority and is
     added at the tail of the ready queue for its new active priority.

7/2
   * When the setting of the base priority of a running task takes
     effect, the task is added to the tail of the ready queue for its
     active priority.

8/2
   * When a task executes a delay_statement that does not result in
     blocking, it is added to the tail of the ready queue for its active
     priority.

9/3
For this policy, blocking or termination of a task, a delay_statement, a
call to Yield_To_Higher, and a call to Yield_To_Same_Or_Higher or Yield
are the only task dispatching points (see *note D.2.1::).  

                     _Implementation Requirements_

10/2
An implementation shall allow, for a single partition, both the task
dispatching policy to be specified as
Non_Preemptive_FIFO_Within_Priorities and also the locking policy (see
*note D.3::) to be specified as Ceiling_Locking.

                     _Implementation Permissions_

11/3
Since implementations are allowed to round all ceiling priorities in
subrange System.Priority to System.Priority'Last (see *note D.3::), an
implementation may allow a task of a partition using the
Non_Premptive_FIFO_Within_Priorities policy to execute within a
protected object without raising its active priority provided the
associated protected unit does not contain any subprograms with aspects
Interrupt_Handler or Attach_Handler specified, nor does the unit have
aspect Interrupt_Priority specified.  When the locking policy (see *note
D.3::) is Ceiling_Locking, an implementation taking advantage of this
permission shall ensure that a call to Yield_to_Higher that occurs
within a protected action uses the ceiling priority of the protected
object (rather than the active priority of the task) when determining
whether to preempt the task.


File: arm2012.info,  Node: D.2.5,  Next: D.2.6,  Prev: D.2.4,  Up: D.2

D.2.5 Round Robin Dispatching
-----------------------------

1/3
This subclause defines the task dispatching policy
Round_Robin_Within_Priorities and the package Round_Robin.

                          _Static Semantics_

2/2
The <policy>_identifier Round_Robin_Within_Priorities is a task
dispatching policy.

3/2
The following language-defined library package exists:

4/2
     with System;
     with Ada.Real_Time;
     package Ada.Dispatching.Round_Robin is
       Default_Quantum : constant Ada.Real_Time.Time_Span :=
                  <implementation-defined>;
       procedure Set_Quantum (Pri     : in System.Priority;
                              Quantum : in Ada.Real_Time.Time_Span);
       procedure Set_Quantum (Low, High : in System.Priority;
                              Quantum   : in Ada.Real_Time.Time_Span);
       function Actual_Quantum (Pri : System.Priority)
                  return Ada.Real_Time.Time_Span;
       function Is_Round_Robin (Pri : System.Priority) return Boolean;
     end Ada.Dispatching.Round_Robin;

5/2
When task dispatching policy Round_Robin_Within_Priorities is the single
policy in effect for a partition, each task with priority in the range
of System.Interrupt_Priority is dispatched according to policy
FIFO_Within_Priorities.

                          _Dynamic Semantics_

6/2
The procedures Set_Quantum set the required Quantum value for a single
priority level Pri or a range of priority levels Low ..  High.  If no
quantum is set for a Round Robin priority level, Default_Quantum is
used.

7/2
The function Actual_Quantum returns the actual quantum used by the
implementation for the priority level Pri.

8/3
The function Is_Round_Robin returns True if priority Pri is covered by
task dispatching policy Round_Robin_Within_Priorities; otherwise, it
returns False.

9/2
A call of Actual_Quantum or Set_Quantum raises exception
Dispatching.Dispatching_Policy_Error if a predefined policy other than
Round_Robin_Within_Priorities applies to the specified priority or any
of the priorities in the specified range.

10/2
For Round_Robin_Within_Priorities, the dispatching rules for
FIFO_Within_Priorities apply with the following additional rules:

11/2
   * When a task is added or moved to the tail of the ready queue for
     its base priority, it has an execution time budget equal to the
     quantum for that priority level.  This will also occur when a
     blocked task becomes executable again.

12/2
   * When a task is preempted (by a higher priority task) and is added
     to the head of the ready queue for its priority level, it retains
     its remaining budget.

13/2
   * While a task is executing, its budget is decreased by the amount of
     execution time it uses.  The accuracy of this accounting is the
     same as that for execution time clocks (see *note D.14::).

14/2
   * When a task has exhausted its budget and is without an inherited
     priority (and is not executing within a protected operation), it is
     moved to the tail of the ready queue for its priority level.  This
     is a task dispatching point.

                     _Implementation Requirements_

15/2
An implementation shall allow, for a single partition, both the task
dispatching policy to be specified as Round_Robin_Within_Priorities and
also the locking policy (see *note D.3::) to be specified as
Ceiling_Locking.

                     _Documentation Requirements_

16/2
An implementation shall document the quantum values supported.

17/2
An implementation shall document the accuracy with which it detects the
exhaustion of the budget of a task.

     NOTES

18/2
     16  Due to implementation constraints, the quantum value returned
     by Actual_Quantum might not be identical to that set with
     Set_Quantum.

19/2
     17  A task that executes continuously with an inherited priority
     will not be subject to round robin dispatching.


File: arm2012.info,  Node: D.2.6,  Prev: D.2.5,  Up: D.2

D.2.6 Earliest Deadline First Dispatching
-----------------------------------------

1/2
The deadline of a task is an indication of the urgency of the task; it
represents a point on an ideal physical time line.  The deadline might
affect how resources are allocated to the task.

2/3
This subclause defines a package for representing the deadline of a task
and a dispatching policy that defines Earliest Deadline First (EDF)
dispatching.  An aspect is defined to assign an initial deadline to a
task.

<Paragraphs 3 through 6 were moved to *note Annex J::, "*note Annex J::
Obsolescent Features".>

                          _Static Semantics_

7/2
The <policy_>identifier EDF_Across_Priorities is a task dispatching
policy.

8/2
The following language-defined library package exists:

9/2
     with Ada.Real_Time;
     with Ada.Task_Identification;
     package Ada.Dispatching.EDF is
       subtype Deadline is Ada.Real_Time.Time;
       Default_Deadline : constant Deadline :=
                   Ada.Real_Time.Time_Last;
       procedure Set_Deadline (D : in Deadline;
                   T : in Ada.Task_Identification.Task_Id :=
                   Ada.Task_Identification.Current_Task);
       procedure Delay_Until_And_Set_Deadline (
                   Delay_Until_Time : in Ada.Real_Time.Time;
                   Deadline_Offset : in Ada.Real_Time.Time_Span);
       function Get_Deadline (T : Ada.Task_Identification.Task_Id :=
                   Ada.Task_Identification.Current_Task) return Deadline;
     end Ada.Dispatching.EDF;

9.1/3
For a task type (including the anonymous type of a
single_task_declaration) or subprogram, the following language-defined
representation aspect may be specified:

9.2/3
Relative_Deadline
               The aspect Relative_Deadline is an expression, which
               shall be of type Real_Time.Time_Span.

                           _Legality Rules_

9.3/3
The Relative_Deadline aspect shall not be specified on a task interface
type.

                       _Post-Compilation Rules_

10/2
If the EDF_Across_Priorities policy is specified for a partition, then
the Ceiling_Locking policy (see *note D.3::) shall also be specified for
the partition.

11/2
If the EDF_Across_Priorities policy appears in a
Priority_Specific_Dispatching pragma (see *note D.2.2::) in a partition,
then the Ceiling_Locking policy (see *note D.3::) shall also be
specified for the partition.

                          _Dynamic Semantics_

12/3
The Relative_Deadline aspect has no effect if it is specified for a
subprogram other than the main subprogram.

13/3
The initial absolute deadline of a task for which aspect
Relative_Deadline is specified is the value of Real_Time.Clock + the
expression that is the value of the aspect, where this entire
expression, including the call of Real_Time.Clock, is evaluated between
task creation and the start of its activation.  If the aspect
Relative_Deadline is not specified, then the initial absolute deadline
of a task is the value of Default_Deadline.  The environment task is
also given an initial deadline by this rule, using the value of the
Relative_Deadline aspect of the main subprogram (if any).

14/2
The procedure Set_Deadline changes the absolute deadline of the task to
D. The function Get_Deadline returns the absolute deadline of the task.

15/2
The procedure Delay_Until_And_Set_Deadline delays the calling task until
time Delay_Until_Time.  When the task becomes runnable again it will
have deadline Delay_Until_Time + Deadline_Offset.

16/2
On a system with a single processor, the setting of the deadline of a
task to the new value occurs immediately at the first point that is
outside the execution of a protected action.  If the task is currently
on a ready queue it is removed and re-entered on to the ready queue
determined by the rules defined below.

17/2
When EDF_Across_Priorities is specified for priority range <Low>..<High>
all ready queues in this range are ordered by deadline.  The task at the
head of a queue is the one with the earliest deadline.

18/2
A task dispatching point occurs for the currently running task <T> to
which policy EDF_Across_Priorities applies:

19/2
   * when a change to the deadline of <T> occurs;

20/2
   * there is a task on the ready queue for the active priority of <T>
     with a deadline earlier than the deadline of <T>; or

21/2
   * there is a nonempty ready queue for that processor with a higher
     priority than the active priority of the running task.

22/2
In these cases, the currently running task is said to be preempted and
is returned to the ready queue for its active priority.

23/2
For a task <T> to which policy EDF_Across_Priorities applies, the base
priority is not a source of priority inheritance; the active priority
when first activated or while it is blocked is defined as the maximum of
the following:

24/2
   * the lowest priority in the range specified as EDF_Across_Priorities
     that includes the base priority of <T>;

25/2
   * the priorities, if any, currently inherited by <T>;

26/3
   * the highest priority <P>, if any, less than the base priority of
     <T> such that one or more tasks are executing within a protected
     object with ceiling priority <P> and task <T> has an earlier
     deadline than all such tasks; and furthermore <T> has an earlier
     deadline than all other tasks on ready queues with priorities in
     the given EDF_Across_Priorities range that are strictly less than
     <P>.

27/2
When a task <T> is first activated or becomes unblocked, it is added to
the ready queue corresponding to this active priority.  Until it becomes
blocked again, the active priority of <T> remains no less than this
value; it will exceed this value only while it is inheriting a higher
priority.

28/2
When the setting of the base priority of a ready task takes effect and
the new priority is in a range specified as EDF_Across_Priorities, the
task is added to the ready queue corresponding to its new active
priority, as determined above.

29/2
For all the operations defined in Dispatching.EDF, Tasking_Error is
raised if the task identified by T has terminated.  Program_Error is
raised if the value of T is Null_Task_Id.

                      _Bounded (Run-Time) Errors_

30/2
If EDF_Across_Priorities is specified for priority range <Low>..<High>,
it is a bounded error to declare a protected object with ceiling
priority <Low> or to assign the value <Low> to attribute 'Priority.  In
either case either Program_Error is raised or the ceiling of the
protected object is assigned the value <Low>+1.

                         _Erroneous Execution_

31/2
If a value of Task_Id is passed as a parameter to any of the subprograms
of this package and the corresponding task object no longer exists, the
execution of the program is erroneous.

                     _Documentation Requirements_

32/2
On a multiprocessor, the implementation shall document any conditions
that cause the completion of the setting of the deadline of a task to be
delayed later than what is specified for a single processor.

     NOTES

33/3
     18  If two adjacent priority ranges, <A>..<B> and <B>+1..<C> are
     specified to have policy EDF_Across_Priorities, then this is not
     equivalent to this policy being specified for the single range,
     <A>..<C>.

34/2
     19  The above rules implement the preemption-level protocol (also
     called Stack Resource Policy protocol) for resource sharing under
     EDF dispatching.  The preemption-level for a task is denoted by its
     base priority.  The definition of a ceiling preemption-level for a
     protected object follows the existing rules for ceiling locking.


File: arm2012.info,  Node: D.3,  Next: D.4,  Prev: D.2,  Up: Annex D

D.3 Priority Ceiling Locking
============================

1/3
This subclause specifies the interactions between priority task
scheduling and protected object ceilings.  This interaction is based on
the concept of the <ceiling priority> of a protected object.

                               _Syntax_

2
     The form of a pragma Locking_Policy is as follows:

3
       pragma Locking_Policy(<policy_>identifier);

                           _Legality Rules_

4
The <policy_>identifier shall either be Ceiling_Locking or an
implementation-defined identifier.

                       _Post-Compilation Rules_

5
A Locking_Policy pragma is a configuration pragma.

                          _Dynamic Semantics_

6/2
A locking policy specifies the details of protected object locking.  All
protected objects have a priority.  The locking policy specifies the
meaning of the priority of a protected object, and the relationships
between these priorities and task priorities.  In addition, the policy
specifies the state of a task when it executes a protected action, and
how its active priority is affected by the locking.  The <locking
policy> is specified by a Locking_Policy pragma.  For
implementation-defined locking policies, the meaning of the priority of
a protected object is implementation defined.  If no Locking_Policy
pragma applies to any of the program units comprising a partition, the
locking policy for that partition, as well as the meaning of the
priority of a protected object, are implementation defined.  

6.1/3
The expression specified for the Priority or Interrupt_Priority aspect
(see *note D.1::) is evaluated as part of the creation of the
corresponding protected object and converted to the subtype
System.Any_Priority or System.Interrupt_Priority, respectively.  The
value of the expression is the initial priority of the corresponding
protected object.  If no Priority or Interrupt_Priority aspect is
specified for a protected object, the initial priority is specified by
the locking policy.  

7
There is one predefined locking policy, Ceiling_Locking; this policy is
defined as follows:

8/3
   * Every protected object has a <ceiling priority>, which is
     determined by either a Priority or Interrupt_Priority aspect as
     defined in *note D.1::, or by assignment to the Priority attribute
     as described in *note D.5.2::.  The ceiling priority of a protected
     object (or ceiling, for short) is an upper bound on the active
     priority a task can have when it calls protected operations of that
     protected object.

9/2
   * The initial ceiling priority of a protected object is equal to the
     initial priority for that object.

10/4
   * If an Interrupt_Handler or Attach_Handler aspect (see *note
     C.3.1::) is specified for a protected subprogram of a protected
     type that does not have either the Priority or Interrupt_Priority
     aspect specified, the initial priority of protected objects of that
     type is implementation defined, but in the range of the subtype
     System.Interrupt_Priority.

11/3
   * If neither aspect Priority nor Interrupt_Priority is specified for
     a protected type, and no protected subprogram of the type has
     aspect Interrupt_Handler or Attach_Handler specified, then the
     initial priority of the corresponding protected object is
     System.Priority'Last.

12
   * While a task executes a protected action, it inherits the ceiling
     priority of the corresponding protected object.

13
   * When a task calls a protected operation, a check is made that its
     active priority is not higher than the ceiling of the corresponding
     protected object; Program_Error is raised if this check fails.

                      _Bounded (Run-Time) Errors_

13.1/2
Following any change of priority, it is a bounded error for the active
priority of any task with a call queued on an entry of a protected
object to be higher than the ceiling priority of the protected object.
In this case one of the following applies:

13.2/2
   * at any time prior to executing the entry body Program_Error is
     raised in the calling task; 

13.3/2
   * when the entry is open the entry body is executed at the ceiling
     priority of the protected object;

13.4/2
   * when the entry is open the entry body is executed at the ceiling
     priority of the protected object and then Program_Error is raised
     in the calling task; or 

13.5/2
   * when the entry is open the entry body is executed at the ceiling
     priority of the protected object that was in effect when the entry
     call was queued.

                     _Implementation Permissions_

14
The implementation is allowed to round all ceilings in a certain
subrange of System.Priority or System.Interrupt_Priority up to the top
of that subrange, uniformly.

15/2
Implementations are allowed to define other locking policies, but need
not support more than one locking policy per partition.

16
Since implementations are allowed to place restrictions on code that
runs at an interrupt-level active priority (see *note C.3.1:: and *note
D.2.1::), the implementation may implement a language feature in terms
of a protected object with an implementation-defined ceiling, but the
ceiling shall be no less than Priority'Last.

                        _Implementation Advice_

17
The implementation should use names that end with "_Locking" for
implementation-defined locking policies.

     NOTES

18
     20  While a task executes in a protected action, it can be
     preempted only by tasks whose active priorities are higher than the
     ceiling priority of the protected object.

19
     21  If a protected object has a ceiling priority in the range of
     Interrupt_Priority, certain interrupts are blocked while protected
     actions of that object execute.  In the extreme, if the ceiling is
     Interrupt_Priority'Last, all blockable interrupts are blocked
     during that time.

20
     22  The ceiling priority of a protected object has to be in the
     Interrupt_Priority range if one of its procedures is to be used as
     an interrupt handler (see *note C.3::).

21
     23  When specifying the ceiling of a protected object, one should
     choose a value that is at least as high as the highest active
     priority at which tasks can be executing when they call protected
     operations of that object.  In determining this value the following
     factors, which can affect active priority, should be considered:
     the effect of Set_Priority, nested protected operations, entry
     calls, task activation, and other implementation-defined factors.

22
     24  Attaching a protected procedure whose ceiling is below the
     interrupt hardware priority to an interrupt causes the execution of
     the program to be erroneous (see *note C.3.1::).

23
     25  On a single processor implementation, the ceiling priority
     rules guarantee that there is no possibility of deadlock involving
     only protected subprograms (excluding the case where a protected
     operation calls another protected operation on the same protected
     object).


File: arm2012.info,  Node: D.4,  Next: D.5,  Prev: D.3,  Up: Annex D

D.4 Entry Queuing Policies
==========================

1/3
This subclause specifies a mechanism for a user to choose an entry
<queuing policy>.  It also defines two such policies.  Other policies
are implementation defined.

                               _Syntax_

2
     The form of a pragma Queuing_Policy is as follows:

3
       pragma Queuing_Policy(<policy_>identifier);

                           _Legality Rules_

4
The <policy_>identifier shall be either FIFO_Queuing, Priority_Queuing
or an implementation-defined identifier.

                       _Post-Compilation Rules_

5
A Queuing_Policy pragma is a configuration pragma.

                          _Dynamic Semantics_

6
A <queuing policy> governs the order in which tasks are queued for entry
service, and the order in which different entry queues are considered
for service.  The queuing policy is specified by a Queuing_Policy
pragma.

7/2
Two queuing policies, FIFO_Queuing and Priority_Queuing, are language
defined.  If no Queuing_Policy pragma applies to any of the program
units comprising the partition, the queuing policy for that partition is
FIFO_Queuing.  The rules for this policy are specified in *note 9.5.3::
and *note 9.7.1::.

8
The Priority_Queuing policy is defined as follows:

9
   * The calls to an entry (including a member of an entry family) are
     queued in an order consistent with the priorities of the calls.
     The <priority of an entry call> is initialized from the active
     priority of the calling task at the time the call is made, but can
     change later.  Within the same priority, the order is consistent
     with the calling (or requeuing, or priority setting) time (that is,
     a FIFO order).

10/1
   * After a call is first queued, changes to the active priority of a
     task do not affect the priority of the call, unless the base
     priority of the task is set while the task is blocked on an entry
     call.

11
   * When the base priority of a task is set (see *note D.5::), if the
     task is blocked on an entry call, and the call is queued, the
     priority of the call is updated to the new active priority of the
     calling task.  This causes the call to be removed from and then
     reinserted in the queue at the new active priority.

12
   * When more than one condition of an entry_barrier of a protected
     object becomes True, and more than one of the respective queues is
     nonempty, the call with the highest priority is selected.  If more
     than one such call has the same priority, the call that is queued
     on the entry whose declaration is first in textual order in the
     protected_definition is selected.  For members of the same entry
     family, the one with the lower family index is selected.

13
   * If the expiration time of two or more open delay_alternatives is
     the same and no other accept_alternatives are open, the
     sequence_of_statements of the delay_alternative that is first in
     textual order in the selective_accept is executed.

14
   * When more than one alternative of a selective_accept is open and
     has queued calls, an alternative whose queue has the
     highest-priority call at its head is selected.  If two or more open
     alternatives have equal-priority queued calls, then a call on the
     entry in the accept_alternative that is first in textual order in
     the selective_accept is selected.

                     _Implementation Permissions_

15/2
Implementations are allowed to define other queuing policies, but need
not support more than one queuing policy per partition.

15.1/2
Implementations are allowed to defer the reordering of entry queues
following a change of base priority of a task blocked on the entry call
if it is not practical to reorder the queue immediately.

                        _Implementation Advice_

16
The implementation should use names that end with "_Queuing" for
implementation-defined queuing policies.


File: arm2012.info,  Node: D.5,  Next: D.6,  Prev: D.4,  Up: Annex D

D.5 Dynamic Priorities
======================

1/3
This subclause describes how the priority of an entity can be modified
or queried at run time.

* Menu:

* D.5.1 ::    Dynamic Priorities for Tasks
* D.5.2 ::    Dynamic Priorities for Protected Objects


File: arm2012.info,  Node: D.5.1,  Next: D.5.2,  Up: D.5

D.5.1 Dynamic Priorities for Tasks
----------------------------------

1/3
This subclause describes how the base priority of a task can be modified
or queried at run time.

                          _Static Semantics_

2
The following language-defined library package exists:

3/2
     with System;
     with Ada.Task_Identification; <-- See *note C.7.1::>
     package Ada.Dynamic_Priorities is
         pragma Preelaborate(Dynamic_Priorities);

4
         procedure Set_Priority(Priority : in System.Any_Priority;
                                T : in Ada.Task_Identification.Task_Id :=
                                Ada.Task_Identification.Current_Task);

5
         function Get_Priority (T : Ada.Task_Identification.Task_Id :=
                                Ada.Task_Identification.Current_Task)
                                return System.Any_Priority;

6
     end Ada.Dynamic_Priorities;

                          _Dynamic Semantics_

7
The procedure Set_Priority sets the base priority of the specified task
to the specified Priority value.  Set_Priority has no effect if the task
is terminated.

8
The function Get_Priority returns T's current base priority.
Tasking_Error is raised if the task is terminated.

9
Program_Error is raised by Set_Priority and Get_Priority if T is equal
to Null_Task_Id.

10/2
On a system with a single processor, the setting of the base priority of
a task <T> to the new value occurs immediately at the first point when
<T> is outside the execution of a protected action.

<Paragraph 11 was deleted.>

                         _Erroneous Execution_

12
If any subprogram in this package is called with a parameter T that
specifies a task object that no longer exists, the execution of the
program is erroneous.

                     _Documentation Requirements_

12.1/2
On a multiprocessor, the implementation shall document any conditions
that cause the completion of the setting of the priority of a task to be
delayed later than what is specified for a single processor.

                               _Metrics_

13
The implementation shall document the following metric:

14
   * The execution time of a call to Set_Priority, for the nonpreempting
     case, in processor clock cycles.  This is measured for a call that
     modifies the priority of a ready task that is not running (which
     cannot be the calling one), where the new base priority of the
     affected task is lower than the active priority of the calling
     task, and the affected task is not on any entry queue and is not
     executing a protected operation.

     NOTES

15/2
     26  Setting a task's base priority affects task dispatching.
     First, it can change the task's active priority.  Second, under the
     FIFO_Within_Priorities policy it always causes the task to move to
     the tail of the ready queue corresponding to its active priority,
     even if the new base priority is unchanged.

16
     27  Under the priority queuing policy, setting a task's base
     priority has an effect on a queued entry call if the task is
     blocked waiting for the call.  That is, setting the base priority
     of a task causes the priority of a queued entry call from that task
     to be updated and the call to be removed and then reinserted in the
     entry queue at the new priority (see *note D.4::), unless the call
     originated from the triggering_statement of an asynchronous_select.

17
     28  The effect of two or more Set_Priority calls executed in
     parallel on the same task is defined as executing these calls in
     some serial order.

18/3
     29  The rule for when Tasking_Error is raised for Set_Priority or
     Get_Priority is different from the rule for when Tasking_Error is
     raised on an entry call (see *note 9.5.3::).  In particular,
     querying the priority of a completed or an abnormal task is
     allowed, so long as the task is not yet terminated, and setting the
     priority of a task is allowed for any task state (including for
     terminated tasks).

19
     30  Changing the priorities of a set of tasks can be performed by a
     series of calls to Set_Priority for each task separately.  For this
     to work reliably, it should be done within a protected operation
     that has high enough ceiling priority to guarantee that the
     operation completes without being preempted by any of the affected
     tasks.


File: arm2012.info,  Node: D.5.2,  Prev: D.5.1,  Up: D.5

D.5.2 Dynamic Priorities for Protected Objects
----------------------------------------------

1/3
This subclause specifies how the priority of a protected object can be
modified or queried at run time.

                          _Static Semantics_

2/2
The following attribute is defined for a prefix P that denotes a
protected object:

3/2
P'Priority
               Denotes a non-aliased component of the protected object
               P. This component is of type System.Any_Priority and its
               value is the priority of P. P'Priority denotes a variable
               if and only if P denotes a variable.  A reference to this
               attribute shall appear only within the body of P.

4/2
The initial value of this attribute is the initial value of the priority
of the protected object, and can be changed by an assignment.

                          _Dynamic Semantics_

5/3
If the locking policy Ceiling_Locking (see *note D.3::) is in effect,
then the ceiling priority of a protected object <P> is set to the value
of <P>'Priority at the end of each protected action of <P>.

6/3
If the locking policy Ceiling_Locking is in effect, then for a protected
object <P> with either an Attach_Handler or Interrupt_Handler aspect
specified for one of its procedures, a check is made that the value to
be assigned to <P>'Priority is in the range System.Interrupt_Priority.
If the check fails, Program_Error is raised.

                               _Metrics_

7/2
The implementation shall document the following metric:

8/2
   * The difference in execution time of calls to the following
     procedures in protected object P:

9/2
     protected P is
        procedure Do_Not_Set_Ceiling (Pr : System.Any_Priority);
        procedure Set_Ceiling (Pr : System.Any_Priority);
     end P;

10/2
     protected body P is
        procedure Do_Not_Set_Ceiling (Pr : System.Any_Priority) is
        begin
           null;
        end;
        procedure Set_Ceiling (Pr : System.Any_Priority) is
        begin
           P'Priority := Pr;
        end;
     end P;

     NOTES

11/2
     31  Since P'Priority is a normal variable, the value following an
     assignment to the attribute immediately reflects the new value even
     though its impact on the ceiling priority of P is postponed until
     completion of the protected action in which it is executed.


File: arm2012.info,  Node: D.6,  Next: D.7,  Prev: D.5,  Up: Annex D

D.6 Preemptive Abort
====================

1/3
This subclause specifies requirements on the immediacy with which an
aborted construct is completed.

                          _Dynamic Semantics_

2
On a system with a single processor, an aborted construct is completed
immediately at the first point that is outside the execution of an
abort-deferred operation.

                     _Documentation Requirements_

3
On a multiprocessor, the implementation shall document any conditions
that cause the completion of an aborted construct to be delayed later
than what is specified for a single processor.

                               _Metrics_

4
The implementation shall document the following metrics:

5
   * The execution time, in processor clock cycles, that it takes for an
     abort_statement to cause the completion of the aborted task.  This
     is measured in a situation where a task T2 preempts task T1 and
     aborts T1.  T1 does not have any finalization code.  T2 shall
     verify that T1 has terminated, by means of the Terminated
     attribute.

6
   * On a multiprocessor, an upper bound in seconds, on the time that
     the completion of an aborted task can be delayed beyond the point
     that it is required for a single processor.

7/2
   * An upper bound on the execution time of an asynchronous_select, in
     processor clock cycles.  This is measured between a point
     immediately before a task T1 executes a protected operation Pr.Set
     that makes the condition of an entry_barrier Pr.Wait True, and the
     point where task T2 resumes execution immediately after an entry
     call to Pr.Wait in an asynchronous_select.  T1 preempts T2 while T2
     is executing the abortable part, and then blocks itself so that T2
     can execute.  The execution time of T1 is measured separately, and
     subtracted.

8
   * An upper bound on the execution time of an asynchronous_select, in
     the case that no asynchronous transfer of control takes place.
     This is measured between a point immediately before a task executes
     the asynchronous_select with a nonnull abortable part, and the
     point where the task continues execution immediately after it.  The
     execution time of the abortable part is subtracted.

                        _Implementation Advice_

9
Even though the abort_statement is included in the list of potentially
blocking operations (see *note 9.5.1::), it is recommended that this
statement be implemented in a way that never requires the task executing
the abort_statement to block.

10
On a multi-processor, the delay associated with aborting a task on
another processor should be bounded; the implementation should use
periodic polling, if necessary, to achieve this.

     NOTES

11
     32  Abortion does not change the active or base priority of the
     aborted task.

12
     33  Abortion cannot be more immediate than is allowed by the rules
     for deferral of abortion during finalization and in protected
     actions.


File: arm2012.info,  Node: D.7,  Next: D.8,  Prev: D.6,  Up: Annex D

D.7 Tasking Restrictions
========================

1/3
This subclause defines restrictions that can be used with a pragma
Restrictions (see *note 13.12::) to facilitate the construction of
highly efficient tasking run-time systems.

                          _Static Semantics_

2
The following <restriction_>identifiers are language defined:

3/3
No_Task_Hierarchy
               No task depends on a master other than the library-level
               master.

4/3
No_Nested_Finalization
               Objects of a type that needs finalization (see *note
               7.6::) are declared only at library level.  If an access
               type does not have library-level accessibility, then
               there are no allocators of the type where the type
               determined by the subtype_mark of the subtype_indication
               or qualified_expression needs finalization.

5/3
No_Abort_Statements
               There are no abort_statements, and there is no use of a
               name denoting Task_Identification.Abort_Task.

6
No_Terminate_Alternatives
               There are no selective_accepts with
               terminate_alternatives.

7
No_Task_Allocators
               There are no allocators for task types or types
               containing task subcomponents.

7.1/3
               In the case of an initialized allocator of an access type
               whose designated type is class-wide and limited, a check
               is made that the specific type of the allocated object
               has no task subcomponents.  Program_Error is raised if
               this check fails.

8
No_Implicit_Heap_Allocations
               There are no operations that implicitly require heap
               storage allocation to be performed by the implementation.
               The operations that implicitly require heap storage
               allocation are implementation defined.

9/2
No_Dynamic_Priorities
               There are no semantic dependences on the package
               Dynamic_Priorities, and no occurrences of the attribute
               Priority.  

10/3
No_Dynamic_Attachment
               There is no use of a name denoting any of the operations
               defined in package Interrupts (Is_Reserved, Is_Attached,
               Current_Handler, Attach_Handler, Exchange_Handler,
               Detach_Handler, and Reference).

10.1/4
No_Dynamic_CPU_Assignment
               No task has the CPU aspect specified to be a non-static
               expression.  Each task (including the environment task)
               that has the CPU aspect specified as Not_A_Specific_CPU
               will be assigned to a particular implementation-defined
               CPU. The same is true for the environment task when the
               CPU aspect is not specified.  Any other task without a
               CPU aspect will activate and execute on the same
               processor as its activating task.

10.2/3
No_Local_Protected_Objects
               Protected objects are declared only at library level.

10.3/3
No_Local_Timing_Events
               Timing_Events are declared only at library level.

10.4/2
No_Protected_Type_Allocators
               There are no allocators for protected types or types
               containing protected type subcomponents.

10.5/3
               In the case of an initialized allocator of an access type
               whose designated type is class-wide and limited, a check
               is made that the specific type of the allocated object
               has no protected subcomponents.  Program_Error is raised
               if this check fails.

10.6/3
No_Relative_Delay
               There are no delay_relative_statements, and there is no
               use of a name that denotes the Timing_Events.Set_Handler
               subprogram that has a Time_Span parameter.

10.7/3
No_Requeue_Statements
               There are no requeue_statements.

10.8/3
No_Select_Statements
               There are no select_statements.

10.9/3
No_Specific_Termination_Handlers
               There is no use of a name denoting the
               Set_Specific_Handler and Specific_Handler subprograms in
               Task_Termination.

10.10/4
No_Tasks_Unassigned_To_CPU
               The CPU aspect is specified for the environment task.  No
               CPU aspect is specified to be statically equal to
               Not_A_Specific_CPU. If aspect CPU is specified
               (dynamically) to the value Not_A_Specific_CPU, then
               Program_Error is raised.  If Set_CPU or
               Delay_Until_And_Set_CPU are called with the CPU parameter
               equal to Not_A_Specific_CPU, then Program_Error is
               raised.

10.11/3
Simple_Barriers
               The Boolean expression in each entry barrier is either a
               static expression or a name that statically denotes a
               component of the enclosing protected object.

11
The following <restriction_parameter_>identifiers are language defined:

12
Max_Select_Alternatives
               Specifies the maximum number of alternatives in a
               selective_accept.

13
Max_Task_Entries
               Specifies the maximum number of entries per task.  The
               bounds of every entry family of a task unit shall be
               static, or shall be defined by a discriminant of a
               subtype whose corresponding bound is static.  A value of
               zero indicates that no rendezvous are possible.

14
Max_Protected_Entries
               Specifies the maximum number of entries per protected
               type.  The bounds of every entry family of a protected
               unit shall be static, or shall be defined by a
               discriminant of a subtype whose corresponding bound is
               static.  

                          _Dynamic Semantics_

15/2
The following <restriction_>identifier is language defined:

15.1/2
No_Task_Termination
               All tasks are nonterminating.  It is
               implementation-defined what happens if a task attempts to
               terminate.  If there is a fall-back handler (see C.7.3)
               set for the partition it should be called when the first
               task attempts to terminate.

16
The following <restriction_parameter_>identifiers are language defined:

17/1
Max_Storage_At_Blocking
               Specifies the maximum portion (in storage elements) of a
               task's Storage_Size that can be retained by a blocked
               task.  If an implementation chooses to detect a violation
               of this restriction, Storage_Error should be raised; 
               otherwise, the behavior is implementation defined.

18/1
Max_Asynchronous_Select_Nesting
               Specifies the maximum dynamic nesting level of
               asynchronous_selects.  A value of zero prevents the use
               of any asynchronous_select (*note 9.7.4: S0241.) and, if
               a program contains an asynchronous_select (*note 9.7.4:
               S0241.), it is illegal.  If an implementation chooses to
               detect a violation of this restriction for values other
               than zero, Storage_Error should be raised; otherwise, the
               behavior is implementation defined.

19/1
Max_Tasks
               Specifies the maximum number of task creations that may
               be executed over the lifetime of a partition, not
               counting the creation of the environment task.  A value
               of zero prevents any task creation and, if a program
               contains a task creation, it is illegal.  If an
               implementation chooses to detect a violation of this
               restriction, Storage_Error should be raised; otherwise,
               the behavior is implementation defined.

19.1/2
Max_Entry_Queue_Length
               Max_Entry_Queue_Length defines the maximum number of
               calls that are queued on an entry.  Violation of this
               restriction results in the raising of Program_Error at
               the point of the call or requeue.

19.2/3
No_Standard_Allocators_After_Elaboration
               Specifies that an allocator using a standard storage pool
               (see *note 13.11::) shall not occur within a
               parameterless library subprogram, nor within the
               handled_sequence_of_statements of a task body.  For the
               purposes of this rule, an allocator of a type derived
               from a formal access type does not use a standard storage
               pool.

19.3/3
               At run time, Storage_Error is raised if an allocator
               using a standard storage pool is evaluated after the
               elaboration of the library_items of the partition has
               completed.

20
It is implementation defined whether the use of pragma Restrictions
results in a reduction in executable program size, storage requirements,
or execution time.  If possible, the implementation should provide
quantitative descriptions of such effects for each restriction.

                        _Implementation Advice_

21
When feasible, the implementation should take advantage of the specified
restrictions to produce a more efficient implementation.

     NOTES

22
     34  The above Storage_Checks can be suppressed with pragma
     Suppress.


File: arm2012.info,  Node: D.8,  Next: D.9,  Prev: D.7,  Up: Annex D

D.8 Monotonic Time
==================

1/3
This subclause specifies a high-resolution, monotonic clock package.

                          _Static Semantics_

2
The following language-defined library package exists:

3
     package Ada.Real_Time is

4
       type Time is private;
       Time_First : constant Time;
       Time_Last : constant Time;
       Time_Unit : constant := <implementation-defined-real-number>;

5
       type Time_Span is private;
       Time_Span_First : constant Time_Span;
       Time_Span_Last : constant Time_Span;
       Time_Span_Zero : constant Time_Span;
       Time_Span_Unit : constant Time_Span;

6
       Tick : constant Time_Span;
       function Clock return Time;

7
       function "+" (Left : Time; Right : Time_Span) return Time;
       function "+" (Left : Time_Span; Right : Time) return Time;
       function "-" (Left : Time; Right : Time_Span) return Time;
       function "-" (Left : Time; Right : Time) return Time_Span;

8
       function "<" (Left, Right : Time) return Boolean;
       function "<="(Left, Right : Time) return Boolean;
       function ">" (Left, Right : Time) return Boolean;
       function ">="(Left, Right : Time) return Boolean;

9
       function "+" (Left, Right : Time_Span) return Time_Span;
       function "-" (Left, Right : Time_Span) return Time_Span;
       function "-" (Right : Time_Span) return Time_Span;
       function "*" (Left : Time_Span; Right : Integer) return Time_Span;
       function "*" (Left : Integer; Right : Time_Span) return Time_Span;
       function "/" (Left, Right : Time_Span) return Integer;
       function "/" (Left : Time_Span; Right : Integer) return Time_Span;

10
       function "abs"(Right : Time_Span) return Time_Span;

11/1
     <This paragraph was deleted.>

12
       function "<" (Left, Right : Time_Span) return Boolean;
       function "<="(Left, Right : Time_Span) return Boolean;
       function ">" (Left, Right : Time_Span) return Boolean;
       function ">="(Left, Right : Time_Span) return Boolean;

13
       function To_Duration (TS : Time_Span) return Duration;
       function To_Time_Span (D : Duration) return Time_Span;

14/2
       function Nanoseconds  (NS : Integer) return Time_Span;
       function Microseconds (US : Integer) return Time_Span;
       function Milliseconds (MS : Integer) return Time_Span;
       function Seconds      (S  : Integer) return Time_Span;
       function Minutes      (M  : Integer) return Time_Span;

15
       type Seconds_Count is range <implementation-defined>;

16
       procedure Split(T : in Time; SC : out Seconds_Count; TS : out Time_Span);
       function Time_Of(SC : Seconds_Count; TS : Time_Span) return Time;

17
     private
        ... -- <not specified by the language>
     end Ada.Real_Time;

18
In this Annex, <real time> is defined to be the physical time as
observed in the external environment.  The type Time is a <time type> as
defined by *note 9.6::; values of this type may be used in a
delay_until_statement.  Values of this type represent segments of an
ideal time line.  The set of values of the type Time corresponds
one-to-one with an implementation-defined range of mathematical
integers.

19
The Time value I represents the half-open real time interval that starts
with E+I*Time_Unit and is limited by E+(I+1)*Time_Unit, where Time_Unit
is an implementation-defined real number and E is an unspecified origin
point, the <epoch>, that is the same for all values of the type Time.
It is not specified by the language whether the time values are
synchronized with any standard time reference.  For example, E can
correspond to the time of system initialization or it can correspond to
the epoch of some time standard.

20
Values of the type Time_Span represent length of real time duration.
The set of values of this type corresponds one-to-one with an
implementation-defined range of mathematical integers.  The Time_Span
value corresponding to the integer I represents the real-time duration
I*Time_Unit.

21
Time_First and Time_Last are the smallest and largest values of the Time
type, respectively.  Similarly, Time_Span_First and Time_Span_Last are
the smallest and largest values of the Time_Span type, respectively.

22
A value of type Seconds_Count represents an elapsed time, measured in
seconds, since the epoch.

                          _Dynamic Semantics_

23
Time_Unit is the smallest amount of real time representable by the Time
type; it is expressed in seconds.  Time_Span_Unit is the difference
between two successive values of the Time type.  It is also the smallest
positive value of type Time_Span.  Time_Unit and Time_Span_Unit
represent the same real time duration.  A <clock tick> is a real time
interval during which the clock value (as observed by calling the Clock
function) remains constant.  Tick is the average length of such
intervals.

24/2
The function To_Duration converts the value TS to a value of type
Duration.  Similarly, the function To_Time_Span converts the value D to
a value of type Time_Span.  For To_Duration, the result is rounded to
the nearest value of type Duration (away from zero if exactly halfway
between two values).  If the result is outside the range of Duration,
Constraint_Error is raised.  For To_Time_Span, the value of D is first
rounded to the nearest integral multiple of Time_Unit, away from zero if
exactly halfway between two multiples.  If the rounded value is outside
the range of Time_Span, Constraint_Error is raised.  Otherwise, the
value is converted to the type Time_Span.

25
To_Duration(Time_Span_Zero) returns 0.0, and To_Time_Span(0.0) returns
Time_Span_Zero.

26/2
The functions Nanoseconds, Microseconds, Milliseconds, Seconds, and
Minutes convert the input parameter to a value of the type Time_Span.
NS, US, MS, S, and M are interpreted as a number of nanoseconds,
microseconds, milliseconds, seconds, and minutes respectively.  The
input parameter is first converted to seconds and rounded to the nearest
integral multiple of Time_Unit, away from zero if exactly halfway
between two multiples.  If the rounded value is outside the range of
Time_Span, Constraint_Error is raised.  Otherwise, the rounded value is
converted to the type Time_Span.

27
The effects of the operators on Time and Time_Span are as for the
operators defined for integer types.

28
The function Clock returns the amount of time since the epoch.

29
The effects of the Split and Time_Of operations are defined as follows,
treating values of type Time, Time_Span, and Seconds_Count as
mathematical integers.  The effect of Split(T,SC,TS) is to set SC and TS
to values such that T*Time_Unit = SC*1.0 + TS*Time_Unit, and 0.0 <=
TS*Time_Unit < 1.0.  The value returned by Time_Of(SC,TS) is the value T
such that T*Time_Unit = SC*1.0 + TS*Time_Unit.

                     _Implementation Requirements_

30
The range of Time values shall be sufficient to uniquely represent the
range of real times from program start-up to 50 years later.  Tick shall
be no greater than 1 millisecond.  Time_Unit shall be less than or equal
to 20 microseconds.

31
Time_Span_First shall be no greater than -3600 seconds, and
Time_Span_Last shall be no less than 3600 seconds.

32
A <clock jump> is the difference between two successive distinct values
of the clock (as observed by calling the Clock function).  There shall
be no backward clock jumps.

                     _Documentation Requirements_

33
The implementation shall document the values of Time_First, Time_Last,
Time_Span_First, Time_Span_Last, Time_Span_Unit, and Tick.

34
The implementation shall document the properties of the underlying time
base used for the clock and for type Time, such as the range of values
supported and any relevant aspects of the underlying hardware or
operating system facilities used.

35
The implementation shall document whether or not there is any
synchronization with external time references, and if such
synchronization exists, the sources of synchronization information, the
frequency of synchronization, and the synchronization method applied.

36/3
The implementation shall document any aspects of the external
environment that could interfere with the clock behavior as defined in
this subclause.

                               _Metrics_

37/3
For the purpose of the metrics defined in this subclause, real time is
defined to be the International Atomic Time (TAI).

38
The implementation shall document the following metrics:

39
   * An upper bound on the real-time duration of a clock tick.  This is
     a value D such that if t1 and t2 are any real times such that t1 <
     t2 and Clockt1 = Clockt2 then t2 - t1 <= D.

40
   * An upper bound on the size of a clock jump.

41
   * An upper bound on the <drift rate> of Clock with respect to real
     time.  This is a real number D such that

42
          E*(1-D) <= (Clockt+E - Clockt) <= E*(1+D)
                  provided that: Clockt + E*(1+D) <= Time_Last.

43
   * where Clockt is the value of Clock at time t, and E is a real time
     duration not less than 24 hours.  The value of E used for this
     metric shall be reported.

44
   * An upper bound on the execution time of a call to the Clock
     function, in processor clock cycles.

45
   * Upper bounds on the execution times of the operators of the types
     Time and Time_Span, in processor clock cycles.

                     _Implementation Permissions_

46
Implementations targeted to machines with word size smaller than 32 bits
need not support the full range and granularity of the Time and
Time_Span types.

                        _Implementation Advice_

47
When appropriate, implementations should provide configuration
mechanisms to change the value of Tick.

48
It is recommended that Calendar.Clock and Real_Time.Clock be implemented
as transformations of the same time base.

49
It is recommended that the "best" time base which exists in the
underlying system be available to the application through Clock.  "Best"
may mean highest accuracy or largest range.

     NOTES

50/3
     35  The rules in this subclause do not imply that the
     implementation can protect the user from operator or installation
     errors which could result in the clock being set incorrectly.

51
     36  Time_Unit is the granularity of the Time type.  In contrast,
     Tick represents the granularity of Real_Time.Clock.  There is no
     requirement that these be the same.


File: arm2012.info,  Node: D.9,  Next: D.10,  Prev: D.8,  Up: Annex D

D.9 Delay Accuracy
==================

1/3
This subclause specifies performance requirements for the
delay_statement.  The rules apply both to delay_relative_statement
(*note 9.6: S0229.) and to delay_until_statement (*note 9.6: S0228.).
Similarly, they apply equally to a simple delay_statement (*note 9.6:
S0227.) and to one which appears in a delay_alternative (*note 9.7.1:
S0235.).

                          _Dynamic Semantics_

2
The effect of the delay_statement for Real_Time.Time is defined in terms
of Real_Time.Clock:

3
   * If C1 is a value of Clock read before a task executes a
     delay_relative_statement with duration D, and C2 is a value of
     Clock read after the task resumes execution following that
     delay_statement, then C2 - C1 >= D.

4
   * If C is a value of Clock read after a task resumes execution
     following a delay_until_statement with Real_Time.Time value T, then
     C >= T.

5
A simple delay_statement with a negative or zero value for the
expiration time does not cause the calling task to be blocked; it is
nevertheless a potentially blocking operation (see *note 9.5.1::).

6/3
When a delay_statement appears in a delay_alternative of a
timed_entry_call the selection of the entry call is attempted,
regardless of the specified expiration time.  When a delay_statement
appears in a select_alternative, and a call is queued on one of the open
entries, the selection of that entry call proceeds, regardless of the
value of the delay expression.

                     _Documentation Requirements_

7
The implementation shall document the minimum value of the delay
expression of a delay_relative_statement that causes the task to
actually be blocked.

8
The implementation shall document the minimum difference between the
value of the delay expression of a delay_until_statement and the value
of Real_Time.Clock, that causes the task to actually be blocked.

                               _Metrics_

9
The implementation shall document the following metrics:

10
   * An upper bound on the execution time, in processor clock cycles, of
     a delay_relative_statement whose requested value of the delay
     expression is less than or equal to zero.

11
   * An upper bound on the execution time, in processor clock cycles, of
     a delay_until_statement whose requested value of the delay
     expression is less than or equal to the value of Real_Time.Clock at
     the time of executing the statement.  Similarly, for
     Calendar.Clock.

12
   * An upper bound on the <lateness> of a delay_relative_statement, for
     a positive value of the delay expression, in a situation where the
     task has sufficient priority to preempt the processor as soon as it
     becomes ready, and does not need to wait for any other execution
     resources.  The upper bound is expressed as a function of the value
     of the delay expression.  The lateness is obtained by subtracting
     the value of the delay expression from the <actual duration>.  The
     actual duration is measured from a point immediately before a task
     executes the delay_statement to a point immediately after the task
     resumes execution following this statement.

13
   * An upper bound on the lateness of a delay_until_statement, in a
     situation where the value of the requested expiration time is after
     the time the task begins executing the statement, the task has
     sufficient priority to preempt the processor as soon as it becomes
     ready, and it does not need to wait for any other execution
     resources.  The upper bound is expressed as a function of the
     difference between the requested expiration time and the clock
     value at the time the statement begins execution.  The lateness of
     a delay_until_statement is obtained by subtracting the requested
     expiration time from the real time that the task resumes execution
     following this statement.


File: arm2012.info,  Node: D.10,  Next: D.11,  Prev: D.9,  Up: Annex D

D.10 Synchronous Task Control
=============================

1/3
This subclause describes a language-defined private semaphore
(suspension object), which can be used for <two-stage suspend>
operations and as a simple building block for implementing higher-level
queues.

                          _Static Semantics_

2
The following language-defined package exists:

3/2
     package Ada.Synchronous_Task_Control is
       pragma Preelaborate(Synchronous_Task_Control);

4
       type Suspension_Object is limited private;
       procedure Set_True(S : in out Suspension_Object);
       procedure Set_False(S : in out Suspension_Object);
       function Current_State(S : Suspension_Object) return Boolean;
       procedure Suspend_Until_True(S : in out Suspension_Object);
     private
          ... -- <not specified by the language>
     end Ada.Synchronous_Task_Control;

5
The type Suspension_Object is a by-reference type.

5.1/3
The following language-defined package exists:

5.2/3
     package Ada.Synchronous_Task_Control.EDF is
        procedure Suspend_Until_True_And_Set_Deadline
           (S  : in out Suspension_Object;
            TS : in     Ada.Real_Time.Time_Span);
     end Ada.Synchronous_Task_Control.EDF;

                          _Dynamic Semantics_

6/2
An object of the type Suspension_Object has two visible states: True and
False.  Upon initialization, its value is set to False.

7/2
The operations Set_True and Set_False are atomic with respect to each
other and with respect to Suspend_Until_True; they set the state to True
and False respectively.

8
Current_State returns the current state of the object.

9/2
The procedure Suspend_Until_True blocks the calling task until the state
of the object S is True; at that point the task becomes ready and the
state of the object becomes False.

10
Program_Error is raised upon calling Suspend_Until_True if another task
is already waiting on that suspension object.  Suspend_Until_True is a
potentially blocking operation (see *note 9.5.1::).

10.1/3
The procedure Suspend_Until_True_And_Set_Deadline blocks the calling
task until the state of the object S is True; at that point the task
becomes ready with a deadline of Ada.Real_Time.Clock + TS, and the state
of the object becomes False.  Program_Error is raised upon calling
Suspend_Until_True_And_Set_Deadline if another task is already waiting
on that suspension object.  Suspend_Until_True_And_Set_Deadline is a
potentially blocking operation.

                     _Implementation Requirements_

11
The implementation is required to allow the calling of Set_False and
Set_True during any protected action, even one that has its ceiling
priority in the Interrupt_Priority range.

     NOTES

12/3
     37  More complex schemes, such as setting the deadline relative to
     when Set_True is called, can be programmed using a protected
     object.

* Menu:

* D.10.1 ::   Synchronous Barriers


File: arm2012.info,  Node: D.10.1,  Up: D.10

D.10.1 Synchronous Barriers
---------------------------

1/3
This subclause introduces a language-defined package to synchronously
release a group of tasks after the number of blocked tasks reaches a
specified count value.

                          _Static Semantics_

2/3
The following language-defined library package exists:

3/3
     package Ada.Synchronous_Barriers is
        pragma Preelaborate(Synchronous_Barriers);

4/3
        subtype Barrier_Limit is Positive range 1 .. <implementation-defined>;

5/3
        type Synchronous_Barrier (Release_Threshold : Barrier_Limit) is limited private;

6/3
        procedure Wait_For_Release (The_Barrier : in out Synchronous_Barrier;
                                    Notified    :    out Boolean);

7/3
     private
        -- <not specified by the language>
     end Ada.Synchronous_Barriers;

8/3
Type Synchronous_Barrier needs finalization (see *note 7.6::).

                          _Dynamic Semantics_

9/3
Each call to Wait_For_Release blocks the calling task until the number
of blocked tasks associated with the Synchronous_Barrier object is equal
to Release_Threshold, at which time all blocked tasks are released.
Notified is set to True for one of the released tasks, and set to False
for all other released tasks.

10/3
The mechanism for determining which task sets Notified to True is
implementation defined.

11/3
Once all tasks have been released, a Synchronous_Barrier object may be
reused to block another Release_Threshold number of tasks.

12/3
As the first step of the finalization of a Synchronous_Barrier, each
blocked task is unblocked and Program_Error is raised at the place of
the call to Wait_For_Release.

13/3
It is implementation defined whether an abnormal task which is waiting
on a Synchronous_Barrier object is aborted immediately or aborted when
the tasks waiting on the object are released.

14/3
Wait_For_Release is a potentially blocking operation (see *note
9.5.1::).

                      _Bounded (Run-Time) Errors_

15/3
It is a bounded error to call Wait_For_Release on a Synchronous_Barrier
object after that object is finalized.  If the error is detected,
Program_Error is raised.  Otherwise, the call proceeds normally, which
may leave a task blocked forever.


File: arm2012.info,  Node: D.11,  Next: D.12,  Prev: D.10,  Up: Annex D

D.11 Asynchronous Task Control
==============================

1/3
This subclause introduces a language-defined package to do asynchronous
suspend/resume on tasks.  It uses a conceptual <held priority> value to
represent the task's <held> state.

                          _Static Semantics_

2
The following language-defined library package exists:

3/2
     with Ada.Task_Identification;
     package Ada.Asynchronous_Task_Control is
       pragma Preelaborate(Asynchronous_Task_Control);
       procedure Hold(T : in Ada.Task_Identification.Task_Id);
       procedure Continue(T : in Ada.Task_Identification.Task_Id);
       function Is_Held(T : Ada.Task_Identification.Task_Id)
        return Boolean;
     end Ada.Asynchronous_Task_Control;

                          _Dynamic Semantics_

4/2
After the Hold operation has been applied to a task, the task becomes
<held>.  For each processor there is a conceptual <idle task>, which is
always ready.  The base priority of the idle task is below
System.Any_Priority'First.  The <held priority> is a constant of the
type Integer whose value is below the base priority of the idle task.

4.1/2
For any priority below System.Any_Priority'First, the task dispatching
policy is FIFO_Within_Priorities.

5/2
The Hold operation sets the state of T to held.  For a held task, the
active priority is reevaluated as if the base priority of the task were
the held priority.

6/2
The Continue operation resets the state of T to not-held; its active
priority is then reevaluated as determined by the task dispatching
policy associated with its base priority.

7
The Is_Held function returns True if and only if T is in the held state.

8
As part of these operations, a check is made that the task identified by
T is not terminated.  Tasking_Error is raised if the check fails.
Program_Error is raised if the value of T is Null_Task_Id.

                         _Erroneous Execution_

9
If any operation in this package is called with a parameter T that
specifies a task object that no longer exists, the execution of the
program is erroneous.

                     _Implementation Permissions_

10
An implementation need not support Asynchronous_Task_Control if it is
infeasible to support it in the target environment.

     NOTES

11
     38  It is a consequence of the priority rules that held tasks
     cannot be dispatched on any processor in a partition (unless they
     are inheriting priorities) since their priorities are defined to be
     below the priority of any idle task.

12
     39  The effect of calling Get_Priority and Set_Priority on a Held
     task is the same as on any other task.

13
     40  Calling Hold on a held task or Continue on a non-held task has
     no effect.

14
     41  The rules affecting queuing are derived from the above rules,
     in addition to the normal priority rules:

15
        * When a held task is on the ready queue, its priority is so low
          as to never reach the top of the queue as long as there are
          other tasks on that queue.

16
        * If a task is executing in a protected action, inside a
          rendezvous, or is inheriting priorities from other sources
          (e.g.  when activated), it continues to execute until it is no
          longer executing the corresponding construct.

17
        * If a task becomes held while waiting (as a caller) for a
          rendezvous to complete, the active priority of the accepting
          task is not affected.

18/1
        * If a task becomes held while waiting in a selective_accept,
          and an entry call is issued to one of the open entries, the
          corresponding accept_alternative (*note 9.7.1: S0234.)
          executes.  When the rendezvous completes, the active priority
          of the accepting task is lowered to the held priority (unless
          it is still inheriting from other sources), and the task does
          not execute until another Continue.

19
        * The same holds if the held task is the only task on a
          protected entry queue whose barrier becomes open.  The
          corresponding entry body executes.


File: arm2012.info,  Node: D.12,  Next: D.13,  Prev: D.11,  Up: Annex D

D.12 Other Optimizations and Determinism Rules
==============================================

1/3
This subclause describes various requirements for improving the response
and determinism in a real-time system.

                     _Implementation Requirements_

2
If the implementation blocks interrupts (see *note C.3::) not as a
result of direct user action (e.g.  an execution of a protected action)
there shall be an upper bound on the duration of this blocking.

3
The implementation shall recognize entry-less protected types.  The
overhead of acquiring the execution resource of an object of such a type
(see *note 9.5.1::) shall be minimized.  In particular, there should not
be any overhead due to evaluating entry_barrier conditions.

4
Unchecked_Deallocation shall be supported for terminated tasks that are
designated by access types, and shall have the effect of releasing all
the storage associated with the task.  This includes any run-time system
or heap storage that has been implicitly allocated for the task by the
implementation.

                     _Documentation Requirements_

5
The implementation shall document the upper bound on the duration of
interrupt blocking caused by the implementation.  If this is different
for different interrupts or interrupt priority levels, it should be
documented for each case.

                               _Metrics_

6
The implementation shall document the following metric:

7
   * The overhead associated with obtaining a mutual-exclusive access to
     an entry-less protected object.  This shall be measured in the
     following way:

8
     For a protected object of the form:

9
     protected Lock is
        procedure Set;
        function Read return Boolean;
     private
        Flag : Boolean := False;
     end Lock;

10
     protected body Lock is
        procedure Set is
        begin
           Flag := True;
        end Set;
        function Read return Boolean
        Begin
           return Flag;
        end Read;
     end Lock;

11
     The execution time, in processor clock cycles, of a call to Set.
     This shall be measured between the point just before issuing the
     call, and the point just after the call completes.  The function
     Read shall be called later to verify that Set was indeed called
     (and not optimized away).  The calling task shall have sufficiently
     high priority as to not be preempted during the measurement period.
     The protected object shall have sufficiently high ceiling priority
     to allow the task to call Set.

12
     For a multiprocessor, if supported, the metric shall be reported
     for the case where no contention (on the execution resource) exists
     from tasks executing on other processors.


File: arm2012.info,  Node: D.13,  Next: D.14,  Prev: D.12,  Up: Annex D

D.13 The Ravenscar Profile
==========================

1/3
This subclause defines the Ravenscar profile.

<Paragraphs 2 and 3 were moved to *note 13.12::, "*note 13.12:: Pragma
Restrictions and Pragma Profile".>

                           _Legality Rules_

4/3
The <profile_>identifier Ravenscar is a usage profile (see *note
13.12::).  For usage profile Ravenscar, there shall be no
<profile_>pragma_argument_association (*note 2.8: S0020.)s.

                          _Static Semantics_

5/3
The usage profile Ravenscar is equivalent to the following set of
pragmas:

6/4
     pragma Task_Dispatching_Policy (FIFO_Within_Priorities);
     pragma Locking_Policy (Ceiling_Locking);
     pragma Detect_Blocking;
     pragma Restrictions (
                   No_Abort_Statements,
                   No_Dynamic_Attachment,
                   No_Dynamic_CPU_Assignment,
                   No_Dynamic_Priorities,
                   No_Implicit_Heap_Allocations,
                   No_Local_Protected_Objects,
                   No_Local_Timing_Events,
                   No_Protected_Type_Allocators,
                   No_Relative_Delay,
                   No_Requeue_Statements,
                   No_Select_Statements,
                   No_Specific_Termination_Handlers,
                   No_Task_Allocators,
                   No_Task_Hierarchy,
                   No_Task_Termination,
                   Simple_Barriers,
                   Max_Entry_Queue_Length => 1,
                   Max_Protected_Entries => 1,
                   Max_Task_Entries => 0,
                   No_Dependence => Ada.Asynchronous_Task_Control,
                   No_Dependence => Ada.Calendar,
                   No_Dependence => Ada.Execution_Time.Group_Budgets,
                   No_Dependence => Ada.Execution_Time.Timers,
                   No_Dependence => Ada.Synchronous_Barriers,
                   No_Dependence => Ada.Task_Attributes,
                   No_Dependence => System.Multiprocessors.Dispatching_Domains);

<Paragraph 7 was deleted.>

                     _Implementation Requirements_

8/4
<This paragraph was deleted.>

                        _Implementation Advice_

9/3
On a multiprocessor system, an implementation should support a fully
partitioned approach.  Each processor should have separate and disjoint
ready queues.

     NOTES

10/3
     42  The effect of the Max_Entry_Queue_Length => 1 restriction
     applies only to protected entry queues due to the accompanying
     restriction of Max_Task_Entries => 0.

11/4
     43  When the Ravenscar profile is in effect (via the effect of the
     No_Dynamic_CPU_Assignment restriction), all of the tasks in the
     partition will execute on a single CPU unless the programmer
     explicitly uses aspect CPU to specify the CPU assignments for
     tasks.  The use of multiple CPUs requires care, as many guarantees
     of single CPU scheduling no longer apply.

12/4
     44  It is not recommended to specify the CPU of a task to be
     Not_A_Specific_CPU when the Ravenscar profile is in effect.  How a
     partition executes strongly depends on the assignment of tasks to
     CPUs.


File: arm2012.info,  Node: D.14,  Next: D.15,  Prev: D.13,  Up: Annex D

D.14 Execution Time
===================

1/3
This subclause describes a language-defined package to measure execution
time.

                          _Static Semantics_

2/2
The following language-defined library package exists:

3/2
     with Ada.Task_Identification;
     with Ada.Real_Time; use Ada.Real_Time;
     package Ada.Execution_Time is

4/2
        type CPU_Time is private;
        CPU_Time_First : constant CPU_Time;
        CPU_Time_Last  : constant CPU_Time;
        CPU_Time_Unit  : constant := <implementation-defined-real-number>;
        CPU_Tick : constant Time_Span;

5/2
        function Clock
          (T : Ada.Task_Identification.Task_Id
               := Ada.Task_Identification.Current_Task)
          return CPU_Time;

6/2
        function "+"  (Left : CPU_Time; Right : Time_Span) return CPU_Time;
        function "+"  (Left : Time_Span; Right : CPU_Time) return CPU_Time;
        function "-"  (Left : CPU_Time; Right : Time_Span) return CPU_Time;
        function "-"  (Left : CPU_Time; Right : CPU_Time)  return Time_Span;

7/2
        function "<"  (Left, Right : CPU_Time) return Boolean;
        function "<=" (Left, Right : CPU_Time) return Boolean;
        function ">"  (Left, Right : CPU_Time) return Boolean;
        function ">=" (Left, Right : CPU_Time) return Boolean;

8/2
        procedure Split
          (T : in CPU_Time; SC : out Seconds_Count; TS : out Time_Span);

9/2
        function Time_Of (SC : Seconds_Count;
                          TS : Time_Span := Time_Span_Zero) return CPU_Time;

9.1/3
        Interrupt_Clocks_Supported : constant Boolean := <implementation-defined>;

9.2/3
        Separate_Interrupt_Clocks_Supported : constant Boolean :=
          <implementation-defined>;

9.3/3
        function Clock_For_Interrupts return CPU_Time;

10/2
     private
        ... -- <not specified by the language>
     end Ada.Execution_Time;

11/3
The <execution time> or CPU time of a given task is defined as the time
spent by the system executing that task, including the time spent
executing run-time or system services on its behalf.  The mechanism used
to measure execution time is implementation defined.  The Boolean
constant Interrupt_Clocks_Supported is set to True if the implementation
separately accounts for the execution time of interrupt handlers.  If it
is set to False it is implementation defined which task, if any, is
charged the execution time that is consumed by interrupt handlers.  The
Boolean constant Separate_Interrupt_Clocks_Supported is set to True if
the implementation separately accounts for the execution time of
individual interrupt handlers (see *note D.14.3::).

12/2
The type CPU_Time represents the execution time of a task.  The set of
values of this type corresponds one-to-one with an
implementation-defined range of mathematical integers.

13/2
The CPU_Time value I represents the half-open execution-time interval
that starts with I*CPU_Time_Unit and is limited by (I+1)*CPU_Time_Unit,
where CPU_Time_Unit is an implementation-defined real number.  For each
task, the execution time value is set to zero at the creation of the
task.

14/2
CPU_Time_First and CPU_Time_Last are the smallest and largest values of
the CPU_Time type, respectively.

14.1/3
The execution time value for the function Clock_For_Interrupts is
initialized to zero.

                          _Dynamic Semantics_

15/2
CPU_Time_Unit is the smallest amount of execution time representable by
the CPU_Time type; it is expressed in seconds.  A <CPU clock tick> is an
execution time interval during which the clock value (as observed by
calling the Clock function) remains constant.  CPU_Tick is the average
length of such intervals.

16/2
The effects of the operators on CPU_Time and Time_Span are as for the
operators defined for integer types.

17/2
The function Clock returns the current execution time of the task
identified by T; Tasking_Error is raised if that task has terminated;
Program_Error is raised if the value of T is
Task_Identification.Null_Task_Id.

18/2
The effects of the Split and Time_Of operations are defined as follows,
treating values of type CPU_Time, Time_Span, and Seconds_Count as
mathematical integers.  The effect of Split (T, SC, TS) is to set SC and
TS to values such that T*CPU_Time_Unit = SC*1.0 + TS*CPU_Time_Unit, and
0.0 <= TS*CPU_Time_Unit < 1.0.  The value returned by Time_Of(SC,TS) is
the execution-time value T such that T*CPU_Time_Unit=SC*1.0 +
TS*CPU_Time_Unit.

18.1/3
The function Clock_For_Interrupts returns the total cumulative time
spent executing within all interrupt handlers.  This time is not
allocated to any task execution time clock.  If
Interrupt_Clocks_Supported is set to False the function raises
Program_Error.

                         _Erroneous Execution_

19/2
For a call of Clock, if the task identified by T no longer exists, the
execution of the program is erroneous.

                     _Implementation Requirements_

20/2
The range of CPU_Time values shall be sufficient to uniquely represent
the range of execution times from the task start-up to 50 years of
execution time later.  CPU_Tick shall be no greater than 1 millisecond.

                     _Documentation Requirements_

21/2
The implementation shall document the values of CPU_Time_First,
CPU_Time_Last, CPU_Time_Unit, and CPU_Tick.

22/2
The implementation shall document the properties of the underlying
mechanism used to measure execution times, such as the range of values
supported and any relevant aspects of the underlying hardware or
operating system facilities used.

                               _Metrics_

23/2
The implementation shall document the following metrics:

24/2
   * An upper bound on the execution-time duration of a clock tick.
     This is a value D such that if t1 and t2 are any execution times of
     a given task such that t1 < t2 and Clockt1 = Clockt2 then t2 - t1
     <= D.

25/2
   * An upper bound on the size of a clock jump.  A clock jump is the
     difference between two successive distinct values of an
     execution-time clock (as observed by calling the Clock function
     with the same Task_Id).

26/2
   * An upper bound on the execution time of a call to the Clock
     function, in processor clock cycles.

27/2
   * Upper bounds on the execution times of the operators of the type
     CPU_Time, in processor clock cycles.

                     _Implementation Permissions_

28/2
Implementations targeted to machines with word size smaller than 32 bits
need not support the full range and granularity of the CPU_Time type.

                        _Implementation Advice_

29/2
When appropriate, implementations should provide configuration
mechanisms to change the value of CPU_Tick.

* Menu:

* D.14.1 ::   Execution Time Timers
* D.14.2 ::   Group Execution Time Budgets
* D.14.3 ::   Execution Time of Interrupt Handlers


File: arm2012.info,  Node: D.14.1,  Next: D.14.2,  Up: D.14

D.14.1 Execution Time Timers
----------------------------

1/3
This subclause describes a language-defined package that provides a
facility for calling a handler when a task has used a defined amount of
CPU time.

                          _Static Semantics_

2/2
The following language-defined library package exists:

3/2
     with System;
     package Ada.Execution_Time.Timers is

4/2
        type Timer (T : not null access constant
                            Ada.Task_Identification.Task_Id) is
           tagged limited private;

5/2
        type Timer_Handler is
           access protected procedure (TM : in out Timer);

6/2
        Min_Handler_Ceiling : constant System.Any_Priority :=
        <implementation-defined>;

7/2
        procedure Set_Handler (TM      : in out Timer;
                               In_Time : in Time_Span;
                               Handler : in Timer_Handler);
        procedure Set_Handler (TM      : in out Timer;
                               At_Time : in CPU_Time;
                               Handler : in Timer_Handler);
        function Current_Handler (TM : Timer) return Timer_Handler;
        procedure Cancel_Handler (TM        : in out Timer;
                                  Cancelled :    out Boolean);

8/2
        function Time_Remaining (TM : Timer) return Time_Span;

9/2
        Timer_Resource_Error : exception;

10/2
     private
        ... -- <not specified by the language>
     end Ada.Execution_Time.Timers;

11/2
The type Timer represents an execution-time event for a single task and
is capable of detecting execution-time overruns.  The access
discriminant T identifies the task concerned.  The type Timer needs
finalization (see *note 7.6::).

12/2
An object of type Timer is said to be <set> if it is associated with a
nonnull value of type Timer_Handler and <cleared> otherwise.  All Timer
objects are initially cleared.  

13/2
The type Timer_Handler identifies a protected procedure to be executed
by the implementation when the timer expires.  Such a protected
procedure is called a <handler>.  

                          _Dynamic Semantics_

14/2
When a Timer object is created, or upon the first call of a Set_Handler
procedure with the timer as parameter, the resources required to operate
an execution-time timer based on the associated execution-time clock are
allocated and initialized.  If this operation would exceed the available
resources, Timer_Resource_Error is raised.

15/3
The procedures Set_Handler associate the handler Handler with the timer
TM: if Handler is null, the timer is cleared; otherwise, it is set.  The
first procedure Set_Handler loads the timer TM with an interval
specified by the Time_Span parameter.  In this mode, the timer TM
<expires> when the execution time of the task identified by TM.T.all has
increased by In_Time; if In_Time is less than or equal to zero, the
timer expires immediately.  The second procedure Set_Handler loads the
timer TM with the absolute value specified by At_Time.  In this mode,
the timer TM expires when the execution time of the task identified by
TM.T.all reaches At_Time; if the value of At_Time has already been
reached when Set_Handler is called, the timer expires immediately.

16/2
A call of a procedure Set_Handler for a timer that is already set
replaces the handler and the (absolute or relative) execution time; if
Handler is not null, the timer remains set.

17/2
When a timer expires, the associated handler is executed, passing the
timer as parameter.  The initial action of the execution of the handler
is to clear the event.

18/3
The function Current_Handler returns the handler associated with the
timer TM if that timer is set; otherwise, it returns null.

19/3
The procedure Cancel_Handler clears the timer if it is set.  Cancelled
is assigned True if the timer was set prior to it being cleared;
otherwise, it is assigned False.

20/3
The function Time_Remaining returns the execution time interval that
remains until the timer TM would expire, if that timer is set;
otherwise, it returns Time_Span_Zero.

21/2
The constant Min_Handler_Ceiling is the minimum ceiling priority
required for a protected object with a handler to ensure that no ceiling
violation will occur when that handler is invoked.

22/2
As part of the finalization of an object of type Timer, the timer is
cleared.

23/2
For all the subprograms defined in this package, Tasking_Error is raised
if the task identified by TM.T.all has terminated, and Program_Error is
raised if the value of TM.T.all is Task_Identification.Null_Task_Id.

24/2
An exception propagated from a handler invoked as part of the expiration
of a timer has no effect.

                         _Erroneous Execution_

25/2
For a call of any of the subprograms defined in this package, if the
task identified by TM.T.all no longer exists, the execution of the
program is erroneous.

                     _Implementation Requirements_

26/2
For a given Timer object, the implementation shall perform the
operations declared in this package atomically with respect to any of
these operations on the same Timer object.  The replacement of a handler
by a call of Set_Handler shall be performed atomically with respect to
the execution of the handler.

27/2
When an object of type Timer is finalized, the system resources used by
the timer shall be deallocated.

                     _Implementation Permissions_

28/3
Implementations may limit the number of timers that can be defined for
each task.  If this limit is exceeded, then Timer_Resource_Error is
raised.

     NOTES

29/2
     45  A Timer_Handler can be associated with several Timer objects.


File: arm2012.info,  Node: D.14.2,  Next: D.14.3,  Prev: D.14.1,  Up: D.14

D.14.2 Group Execution Time Budgets
-----------------------------------

1/3
This subclause describes a language-defined package to assign execution
time budgets to groups of tasks.

                          _Static Semantics_

2/2
The following language-defined library package exists:

3/3
     with System;
     with System.Multiprocessors;
     package Ada.Execution_Time.Group_Budgets is

4/3
       type Group_Budget(CPU : System.Multiprocessors.CPU :=
                                  System.Multiprocessors.CPU'First)
         is tagged limited private;

5/2
       type Group_Budget_Handler is access
            protected procedure (GB : in out Group_Budget);

6/2
       type Task_Array is array (Positive range <>) of
                                       Ada.Task_Identification.Task_Id;

7/2
       Min_Handler_Ceiling : constant System.Any_Priority :=
         <implementation-defined>;

8/2
       procedure Add_Task (GB : in out Group_Budget;
                           T  : in Ada.Task_Identification.Task_Id);
       procedure Remove_Task (GB: in out Group_Budget;
                              T  : in Ada.Task_Identification.Task_Id);
       function Is_Member (GB : Group_Budget;
                           T : Ada.Task_Identification.Task_Id) return Boolean;
       function Is_A_Group_Member
          (T : Ada.Task_Identification.Task_Id) return Boolean;
       function Members (GB : Group_Budget) return Task_Array;

9/2
       procedure Replenish (GB : in out Group_Budget; To : in Time_Span);
       procedure Add (GB : in out Group_Budget; Interval : in Time_Span);
       function Budget_Has_Expired (GB : Group_Budget) return Boolean;
       function Budget_Remaining (GB : Group_Budget) return Time_Span;

10/2
       procedure Set_Handler (GB      : in out Group_Budget;
                              Handler : in Group_Budget_Handler);
       function Current_Handler (GB : Group_Budget)
          return Group_Budget_Handler;
       procedure Cancel_Handler (GB        : in out Group_Budget;
                                 Cancelled : out Boolean);

11/2
       Group_Budget_Error : exception;

12/2
     private
         --  <not specified by the language>
     end Ada.Execution_Time.Group_Budgets;

13/2
The type Group_Budget represents an execution time budget to be used by
a group of tasks.  The type Group_Budget needs finalization (see *note
7.6::).  A task can belong to at most one group.  Tasks of any priority
can be added to a group.

14/2
An object of type Group_Budget has an associated nonnegative value of
type Time_Span known as its <budget>, which is initially Time_Span_Zero.
The type Group_Budget_Handler identifies a protected procedure to be
executed by the implementation when the budget is <exhausted>, that is,
reaches zero.  Such a protected procedure is called a <handler>.  

15/2
An object of type Group_Budget also includes a handler, which is a value
of type Group_Budget_Handler.  The handler of the object is said to be
<set> if it is not null and <cleared> otherwise.  The handler of all
Group_Budget objects is initially cleared.  

                          _Dynamic Semantics_

16/2
The procedure Add_Task adds the task identified by T to the group GB; if
that task is already a member of some other group, Group_Budget_Error is
raised.

17/2
The procedure Remove_Task removes the task identified by T from the
group GB; if that task is not a member of the group GB,
Group_Budget_Error is raised.  After successful execution of this
procedure, the task is no longer a member of any group.

18/3
The function Is_Member returns True if the task identified by T is a
member of the group GB; otherwise, it returns False.

19/3
The function Is_A_Group_Member returns True if the task identified by T
is a member of some group; otherwise, it returns False.

20/2
The function Members returns an array of values of type
Task_Identification.Task_Id identifying the members of the group GB. The
order of the components of the array is unspecified.

21/3
The procedure Replenish loads the group budget GB with To as the
Time_Span value.  The exception Group_Budget_Error is raised if the
Time_Span value To is nonpositive.  Any execution on CPU of any member
of the group of tasks results in the budget counting down, unless
exhausted.  When the budget becomes exhausted (reaches Time_Span_Zero),
the associated handler is executed if the handler of group budget GB is
set.  Nevertheless, the tasks continue to execute.

22/2
The procedure Add modifies the budget of the group GB. A positive value
for Interval increases the budget.  A negative value for Interval
reduces the budget, but never below Time_Span_Zero.  A zero value for
Interval has no effect.  A call of procedure Add that results in the
value of the budget going to Time_Span_Zero causes the associated
handler to be executed if the handler of the group budget GB is set.

23/3
The function Budget_Has_Expired returns True if the budget of group GB
is exhausted (equal to Time_Span_Zero); otherwise, it returns False.

24/2
The function Budget_Remaining returns the remaining budget for the group
GB. If the budget is exhausted it returns Time_Span_Zero.  This is the
minimum value for a budget.

25/3
The procedure Set_Handler associates the handler Handler with the
Group_Budget GB: if Handler is null, the handler of Group_Budget is
cleared; otherwise, it is set.

26/2
A call of Set_Handler for a Group_Budget that already has a handler set
replaces the handler; if Handler is not null, the handler for
Group_Budget remains set.

27/3
The function Current_Handler returns the handler associated with the
group budget GB if the handler for that group budget is set; otherwise,
it returns null.

28/3
The procedure Cancel_Handler clears the handler for the group budget if
it is set.  Cancelled is assigned True if the handler for the group
budget was set prior to it being cleared; otherwise, it is assigned
False.

29/2
The constant Min_Handler_Ceiling is the minimum ceiling priority
required for a protected object with a handler to ensure that no ceiling
violation will occur when that handler is invoked.

30/2
The precision of the accounting of task execution time to a Group_Budget
is the same as that defined for execution-time clocks from the parent
package.

31/2
As part of the finalization of an object of type Group_Budget all member
tasks are removed from the group identified by that object.

32/3
If a task is a member of a Group_Budget when it terminates, then as part
of the finalization of the task it is removed from the group.

33/2
For all the operations defined in this package, Tasking_Error is raised
if the task identified by T has terminated, and Program_Error is raised
if the value of T is Task_Identification.Null_Task_Id.

34/2
An exception propagated from a handler invoked when the budget of a
group of tasks becomes exhausted has no effect.

                         _Erroneous Execution_

35/2
For a call of any of the subprograms defined in this package, if the
task identified by T no longer exists, the execution of the program is
erroneous.

                     _Implementation Requirements_

36/2
For a given Group_Budget object, the implementation shall perform the
operations declared in this package atomically with respect to any of
these operations on the same Group_Budget object.  The replacement of a
handler, by a call of Set_Handler, shall be performed atomically with
respect to the execution of the handler.

     NOTES

37/2
     46  Clearing or setting of the handler of a group budget does not
     change the current value of the budget.  Exhaustion or loading of a
     budget does not change whether the handler of the group budget is
     set or cleared.

38/2
     47  A Group_Budget_Handler can be associated with several
     Group_Budget objects.


File: arm2012.info,  Node: D.14.3,  Prev: D.14.2,  Up: D.14

D.14.3 Execution Time of Interrupt Handlers
-------------------------------------------

1/3
This subclause describes a language-defined package to measure the
execution time of interrupt handlers.

                          _Static Semantics_

2/3
The following language-defined library package exists:

3/3
     with Ada.Interrupts;
     package Ada.Execution_Time.Interrupts is
        function Clock (Interrupt : Ada.Interrupts.Interrupt_Id)
             return CPU_Time;
        function Supported (Interrupt : Ada.Interrupts.Interrupt_Id)
             return Boolean;
     end Ada.Execution_Time.Interrupts;

4/3
The execution time or CPU time of a given interrupt Interrupt is defined
as the time spent by the system executing interrupt handlers identified
by Interrupt, including the time spent executing run-time or system
services on its behalf.  The mechanism used to measure execution time is
implementation defined.  Time spent executing interrupt handlers is
distinct from time spent executing any task.

5/3
For each interrupt, the execution time value is initially set to zero.

                          _Dynamic Semantics_

6/3
The function Clock returns the current cumulative execution time of the
interrupt identified by Interrupt.  If
Separate_Interrupt_Clocks_Supported is set to False the function raises
Program_Error.

7/3
The function Supported returns True if the implementation is monitoring
the execution time of the interrupt identified by Interrupt; otherwise,
it returns False.  For any Interrupt_Id Interrupt for which
Supported(Interrupt) returns False, the function Clock(Interrupt) will
return a value equal to Ada.Execution_Time.Time_Of(0).


File: arm2012.info,  Node: D.15,  Next: D.16,  Prev: D.14,  Up: Annex D

D.15 Timing Events
==================

1/3
This subclause describes a language-defined package to allow
user-defined protected procedures to be executed at a specified time
without the need for a task or a delay statement.

                          _Static Semantics_

2/2
The following language-defined library package exists:

3/2
     package Ada.Real_Time.Timing_Events is

4/2
       type Timing_Event is tagged limited private;
       type Timing_Event_Handler
            is access protected procedure (Event : in out Timing_Event);

5/2
       procedure Set_Handler (Event   : in out Timing_Event;
                              At_Time : in Time;
                              Handler : in Timing_Event_Handler);
       procedure Set_Handler (Event   : in out Timing_Event;
                              In_Time : in Time_Span;
                              Handler : in Timing_Event_Handler);
       function Current_Handler (Event : Timing_Event)
            return Timing_Event_Handler;
       procedure Cancel_Handler (Event     : in out Timing_Event;
                                 Cancelled : out Boolean);

6/2
       function Time_Of_Event (Event : Timing_Event) return Time;

7/2
     private
       ... -- <not specified by the language>
     end Ada.Real_Time.Timing_Events;

8/2
The type Timing_Event represents a time in the future when an event is
to occur.  The type Timing_Event needs finalization (see *note 7.6::).

9/2
An object of type Timing_Event is said to be <set> if it is associated
with a nonnull value of type Timing_Event_Handler and <cleared>
otherwise.  All Timing_Event objects are initially cleared.  

10/2
The type Timing_Event_Handler identifies a protected procedure to be
executed by the implementation when the timing event occurs.  Such a
protected procedure is called a <handler>.  

                          _Dynamic Semantics_

11/3
The procedures Set_Handler associate the handler Handler with the event
Event: if Handler is null, the event is cleared; otherwise, it is set.
The first procedure Set_Handler sets the execution time for the event to
be At_Time.  The second procedure Set_Handler sets the execution time
for the event to be Real_Time.Clock + In_Time.

12/2
A call of a procedure Set_Handler for an event that is already set
replaces the handler and the time of execution; if Handler is not null,
the event remains set.

13/2
As soon as possible after the time set for the event, the handler is
executed, passing the event as parameter.  The handler is only executed
if the timing event is in the set state at the time of execution.  The
initial action of the execution of the handler is to clear the event.

14/2
If the Ceiling_Locking policy (see *note D.3::) is in effect when a
procedure Set_Handler is called, a check is made that the ceiling
priority of Handler.all is Interrupt_Priority'Last.  If the check fails,
Program_Error is raised.

15/3
If a procedure Set_Handler is called with zero or negative In_Time or
with At_Time indicating a time in the past, then the handler is executed
as soon as possible after the completion of the call of Set_Handler.

16/3
The function Current_Handler returns the handler associated with the
event Event if that event is set; otherwise, it returns null.

17/3
The procedure Cancel_Handler clears the event if it is set.  Cancelled
is assigned True if the event was set prior to it being cleared;
otherwise, it is assigned False.

18/3
The function Time_Of_Event returns the time of the event if the event is
set; otherwise, it returns Real_Time.Time_First.

19/2
As part of the finalization of an object of type Timing_Event, the
Timing_Event is cleared.

20/2
If several timing events are set for the same time, they are executed in
FIFO order of being set.

21/2
An exception propagated from a handler invoked by a timing event has no
effect.

                     _Implementation Requirements_

22/2
For a given Timing_Event object, the implementation shall perform the
operations declared in this package atomically with respect to any of
these operations on the same Timing_Event object.  The replacement of a
handler by a call of Set_Handler shall be performed atomically with
respect to the execution of the handler.

                               _Metrics_

23/2
The implementation shall document the following metric:

24/3
   * An upper bound on the lateness of the execution of a handler.  That
     is, the maximum time between the time specified for the event and
     when a handler is actually invoked assuming no other handler or
     task is executing during this interval.

                        _Implementation Advice_

25/2
The protected handler procedure should be executed directly by the
real-time clock interrupt mechanism.

     NOTES

26/2
     48  Since a call of Set_Handler is not a potentially blocking
     operation, it can be called from within a handler.

27/2
     49  A Timing_Event_Handler can be associated with several
     Timing_Event objects.


File: arm2012.info,  Node: D.16,  Prev: D.15,  Up: Annex D

D.16 Multiprocessor Implementation
==================================

1/3
This subclause allows implementations on multiprocessor platforms to be
configured.

                          _Static Semantics_

2/3
The following language-defined library package exists:

3/3
     package System.Multiprocessors is
        pragma Preelaborate(Multiprocessors);

4/3
        type CPU_Range is range 0 .. <implementation-defined>;
        Not_A_Specific_CPU : constant CPU_Range := 0;
        subtype CPU is CPU_Range range 1 .. CPU_Range'Last;

5/3
        function Number_Of_CPUs return CPU;
     end System.Multiprocessors;

6/3
A call of Number_Of_CPUs returns the number of processors available to
the program.  Within a given partition, each call on Number_Of_CPUs will
return the same value.

7/3
For a task type (including the anonymous type of a
single_task_declaration) or subprogram, the following language-defined
representation aspect may be specified:

8/3
CPU
               The aspect CPU is an expression, which shall be of type
               System.Multiprocessors.CPU_Range.

                           _Legality Rules_

9/3
If the CPU aspect is specified for a subprogram, the expression shall be
static.

10/3
The CPU aspect shall not be specified on a task interface type.

                          _Dynamic Semantics_

11/4
The expression specified for the CPU aspect of a task type is evaluated
each time an object of the task type is created (see *note 9.1::).  The
CPU value is then associated with the task object.

12/3
The CPU aspect has no effect if it is specified for a subprogram other
than the main subprogram; the CPU value is not associated with any task.

13/3
The CPU value is associated with the environment task if the CPU aspect
is specified for the main subprogram.  If the CPU aspect is not
specified for the main subprogram it is implementation defined on which
processor the environment task executes.

14/3
The CPU value determines the processor on which the task will activate
and execute; the task is said to be assigned to that processor.  If the
CPU value is Not_A_Specific_CPU, then the task is not assigned to a
processor.  A task without a CPU aspect specified will activate and
execute on the same processor as its activating task if the activating
task is assigned a processor.  If the CPU value is not in the range of
System.Multiprocessors.CPU_Range or is greater than Number_Of_CPUs the
task is defined to have failed, and it becomes a completed task (see
*note 9.2::).

* Menu:

* D.16.1 ::   Multiprocessor Dispatching Domains


File: arm2012.info,  Node: D.16.1,  Up: D.16

D.16.1 Multiprocessor Dispatching Domains
-----------------------------------------

1/3
This subclause allows implementations on multiprocessor platforms to be
partitioned into distinct dispatching domains during program startup.

                          _Static Semantics_

2/3
The following language-defined library package exists:

3/3
     with Ada.Real_Time;
     with Ada.Task_Identification;
     package System.Multiprocessors.Dispatching_Domains is

4/3
        Dispatching_Domain_Error : exception;

5/3
        type Dispatching_Domain (<>) is limited private;

6/3
        System_Dispatching_Domain : constant Dispatching_Domain;

7/4
        function Create (First : CPU; Last : CPU_Range) return Dispatching_Domain;

8/3
        function Get_First_CPU (Domain : Dispatching_Domain) return CPU;

9/4
        function Get_Last_CPU  (Domain : Dispatching_Domain) return CPU_Range;

9.1/4
        type CPU_Set is array(CPU range <>) of Boolean;

9.2/4
        function Create (Set : CPU_Set) return Dispatching_Domain;

9.3/4
        function Get_CPU_Set (Domain : Dispatching_Domain) return CPU_Set;

10/3
        function Get_Dispatching_Domain
           (T   : Ada.Task_Identification.Task_Id :=
                      Ada.Task_Identification.Current_Task)
                return Dispatching_Domain;

11/3
        procedure Assign_Task
           (Domain : in out Dispatching_Domain;
            CPU    : in     CPU_Range := Not_A_Specific_CPU;
            T      : in     Ada.Task_Identification.Task_Id :=
                      Ada.Task_Identification.Current_Task);

12/3
        procedure Set_CPU
           (CPU : in CPU_Range;
            T   : in Ada.Task_Identification.Task_Id :=
                      Ada.Task_Identification.Current_Task);

13/3
        function Get_CPU
           (T   : Ada.Task_Identification.Task_Id :=
                      Ada.Task_Identification.Current_Task)
                return CPU_Range;

14/3
        procedure Delay_Until_And_Set_CPU
           (Delay_Until_Time : in Ada.Real_Time.Time; CPU : in CPU_Range);

15/3
     private
        ... -- <not specified by the language>
     end System.Multiprocessors.Dispatching_Domains;

16/4
A <dispatching domain> represents a set of processors on which a task
may execute.  Each processor is contained within exactly one dispatching
domain.  An object of type Dispatching_Domain identifies a dispatching
domain.  System_Dispatching_Domain identifies a domain that contains the
processor or processors on which the environment task executes.  At
program start-up all processors are contained within this domain.

17/3
For a task type (including the anonymous type of a
single_task_declaration), the following language-defined representation
aspect may be specified:

18/3
Dispatching_Domain
               The value of aspect Dispatching_Domain is an expression,
               which shall be of type
               Dispatching_Domains.Dispatching_Domain.  This aspect is
               the domain to which the task (or all objects of the task
               type) are assigned.

                           _Legality Rules_

19/3
The Dispatching_Domain aspect shall not be specified for a task
interface.

                          _Dynamic Semantics_

20/4
The expression specified for the Dispatching_Domain aspect of a task
type is evaluated each time an object of the task type is created (see
*note 9.1::).  If the identified dispatching domain is empty, then
Dispatching_Domain_Error is raised; otherwise the newly created task is
assigned to the domain identified by the value of the expression.

21/3
If a task is not explicitly assigned to any domain, it is assigned to
that of the activating task.  A task always executes on some CPU in its
domain.

22/4
If both the dispatching domain and CPU are specified for a task, and the
CPU value is not contained within the set of processors for the domain
(and is not Not_A_Specific_CPU), the activation of the task is defined
to have failed, and it becomes a completed task (see *note 9.2::).

23/4
The function Create with First and Last parameters creates and returns a
dispatching domain containing all the processors in the range First ..
Last.  The function Create with a Set parameter creates and returns a
dispatching domain containing the processors for which Set(I) is True.
These processors are removed from System_Dispatching_Domain.  A call of
Create will raise Dispatching_Domain_Error if any designated processor
is not currently in System_Dispatching_Domain, or if the system cannot
support a distinct domain over the processors identified, or if a
processor has a task assigned to it, or if the allocation would leave
System_Dispatching_Domain empty.  A call of Create will raise
Dispatching_Domain_Error if the calling task is not the environment
task, or if Create is called after the call to the main subprogram.

24/4
The function Get_First_CPU returns the first CPU in Domain, or CPU'First
if Domain is empty; Get_Last_CPU returns the last CPU in Domain, or
CPU_Range'First if Domain is empty.  The function Get_CPU_Set(D) returns
an array whose low bound is Get_First_CPU(D), whose high bound is
Get_Last_CPU(D), with True values in the Set corresponding to the CPUs
that are in the given Domain.

25/4
The function Get_Dispatching_Domain returns the dispatching domain on
which the task is assigned.

26/4
A call of the procedure Assign_Task assigns task T to the CPU within the
dispatching domain Domain.  Task T can now execute only on CPU, unless
CPU designates Not_A_Specific_CPU in which case it can execute on any
processor within Domain.  The exception Dispatching_Domain_Error is
propagated if Domain is empty, T is already assigned to a dispatching
domain other than System_Dispatching_Domain, or if CPU is not one of the
processors of Domain (and is not Not_A_Specific_CPU). A call of
Assign_Task is a task dispatching point for task T unless T is inside of
a protected action, in which case the effect on task T is delayed until
its next task dispatching point.  If T is the Current_Task the effect is
immediate if T is not inside a protected action, otherwise the effect is
as soon as practical.  Assigning a task already assigned to
System_Dispatching_Domain to that domain has no effect.

27/4
A call of procedure Set_CPU assigns task T to the CPU. Task T can now
execute only on CPU, unless CPU designates Not_A_Specific_CPU, in which
case it can execute on any processor within its dispatching domain.  The
exception Dispatching_Domain_Error is propagated if CPU is not one of
the processors of the dispatching domain on which T is assigned (and is
not Not_A_Specific_CPU). A call of Set_CPU is a task dispatching point
for task T unless T is inside of a protected action, in which case the
effect on task T is delayed until its next task dispatching point.  If T
is the Current_Task the effect is immediate if T is not inside a
protected action, otherwise the effect is as soon as practical.

28/3
The function Get_CPU returns the processor assigned to task T, or
Not_A_Specific_CPU if the task is not assigned to a processor.

29/4
A call of Delay_Until_And_Set_CPU delays the calling task for the
designated time and then assigns the task to the specified processor
when the delay expires.  The exception Dispatching_Domain_Error is
propagated if P is not one of the processors of the calling task's
dispatching domain (and is not Not_A_Specific_CPU).

                     _Implementation Requirements_

30/3
The implementation shall perform the operations Assign_Task, Set_CPU,
Get_CPU and Delay_Until_And_Set_CPU atomically with respect to any of
these operations on the same dispatching_domain, processor or task.

30.1/4
Any task that belongs to the system dispatching domain can execute on
any CPU within that domain, unless the assignment of the task has been
specified.

                        _Implementation Advice_

31/3
Each dispatching domain should have separate and disjoint ready queues.

                     _Documentation Requirements_

32/3
The implementation shall document the processor(s) on which the clock
interrupt is handled and hence where delay queue and ready queue
manipulations occur.  For any Interrupt_Id whose handler can execute on
more than one processor the implementation shall also document this set
of processors.

                     _Implementation Permissions_

33/3
An implementation may limit the number of dispatching domains that can
be created and raise Dispatching_Domain_Error if an attempt is made to
exceed this number.


File: arm2012.info,  Node: Annex E,  Next: Annex F,  Prev: Annex D,  Up: Top

Annex E Distributed Systems
***************************

1
This Annex defines facilities for supporting the implementation of
distributed systems using multiple partitions working cooperatively as
part of a single Ada program.

                       _Post-Compilation Rules_

2
A <distributed system> is an interconnection of one or more <processing
nodes> (a system resource that has both computational and storage
capabilities), and zero or more <storage nodes> (a system resource that
has only storage capabilities, with the storage addressable by one or
more processing nodes).

3
A <distributed program> comprises one or more partitions that execute
independently (except when they communicate) in a distributed system.

4
The process of mapping the partitions of a program to the nodes in a
distributed system is called <configuring the partitions of the
program>.

                     _Implementation Requirements_

5
The implementation shall provide means for explicitly assigning library
units to a partition and for the configuring and execution of a program
consisting of multiple partitions on a distributed system; the means are
implementation defined.

                     _Implementation Permissions_

6
An implementation may require that the set of processing nodes of a
distributed system be homogeneous.

     NOTES

7
     1  The partitions comprising a program may be executed on
     differently configured distributed systems or on a nondistributed
     system without requiring recompilation.  A distributed program may
     be partitioned differently from the same set of library units
     without recompilation.  The resulting execution is semantically
     equivalent.

8
     2  A distributed program retains the same type safety as the
     equivalent single partition program.

* Menu:

* E.1 ::      Partitions
* E.2 ::      Categorization of Library Units
* E.3 ::      Consistency of a Distributed System
* E.4 ::      Remote Subprogram Calls
* E.5 ::      Partition Communication Subsystem


File: arm2012.info,  Node: E.1,  Next: E.2,  Up: Annex E

E.1 Partitions
==============

1
The partitions of a distributed program are classified as either active
or passive.

                       _Post-Compilation Rules_

2
An <active partition> is a partition as defined in *note 10.2::.  A
<passive partition> is a partition that has no thread of control of its
own, whose library units are all preelaborated, and whose data and
subprograms are accessible to one or more active partitions.

3
A passive partition shall include only library_items that either are
declared pure or are shared passive (see *note 10.2.1:: and *note
E.2.1::).

4
An active partition shall be configured on a processing node.  A passive
partition shall be configured either on a storage node or on a
processing node.

5
The configuration of the partitions of a program onto a distributed
system shall be consistent with the possibility for data references or
calls between the partitions implied by their semantic dependences.  Any
reference to data or call of a subprogram across partitions is called a
<remote access>.

                          _Dynamic Semantics_

6
A library_item is elaborated as part of the elaboration of each
partition that includes it.  If a normal library unit (see *note E.2::)
has state, then a separate copy of the state exists in each active
partition that elaborates it.  The state evolves independently in each
such partition.

7
An active partition <terminates> when its environment task terminates.
A partition becomes <inaccessible> if it terminates or if it is
<aborted>.  An active partition is aborted when its environment task is
aborted.  In addition, if a partition fails during its elaboration, it
becomes inaccessible to other partitions.  Other implementation-defined
events can also result in a partition becoming inaccessible.

8/1
For a prefix D that denotes a library-level declaration, excepting a
declaration of or within a declared-pure library unit, the following
attribute is defined:

9
D'Partition_Id
               Denotes a value of the type <universal_integer> that
               identifies the partition in which D was elaborated.  If D
               denotes the declaration of a remote call interface
               library unit (see *note E.2.3::) the given partition is
               the one where the body of D was elaborated.

                      _Bounded (Run-Time) Errors_

10/2
It is a bounded error for there to be cyclic elaboration dependences
between the active partitions of a single distributed program.  The
possible effects, in each of the partitions involved, are deadlock
during elaboration, or the raising of Communication_Error or
Program_Error.

                     _Implementation Permissions_

11
An implementation may allow multiple active or passive partitions to be
configured on a single processing node, and multiple passive partitions
to be configured on a single storage node.  In these cases, the
scheduling policies, treatment of priorities, and management of shared
resources between these partitions are implementation defined.

12
An implementation may allow separate copies of an active partition to be
configured on different processing nodes, and to provide appropriate
interactions between the copies to present a consistent state of the
partition to other active partitions.

13
In an implementation, the partitions of a distributed program need not
be loaded and elaborated all at the same time; they may be loaded and
elaborated one at a time over an extended period of time.  An
implementation may provide facilities to abort and reload a partition
during the execution of a distributed program.

14
An implementation may allow the state of some of the partitions of a
distributed program to persist while other partitions of the program
terminate and are later reinvoked.

     NOTES

15
     3  Library units are grouped into partitions after compile time,
     but before run time.  At compile time, only the relevant library
     unit properties are identified using categorization pragmas.

16
     4  The value returned by the Partition_Id attribute can be used as
     a parameter to implementation-provided subprograms in order to
     query information about the partition.


File: arm2012.info,  Node: E.2,  Next: E.3,  Prev: E.1,  Up: Annex E

E.2 Categorization of Library Units
===================================

1
Library units can be categorized according to the role they play in a
distributed program.  Certain restrictions are associated with each
category to ensure that the semantics of a distributed program remain
close to the semantics for a nondistributed program.

2/3
A <categorization pragma> is a library unit pragma (see *note 10.1.5::)
that specifies a corresponding <categorization aspect>.  A
categorization aspect restricts the declarations, child units, or
semantic dependences of the library unit to which it applies.  A
<categorized library unit> is a library unit that has a categorization
aspect that is True.

3/3
The pragmas Shared_Passive, Remote_Types, and Remote_Call_Interface are
categorization pragmas, and the associated aspects are categorization
aspects.  In addition, for the purposes of this Annex, the aspect Pure
(see *note 10.2.1::) is considered a categorization aspect and the
pragma Pure is considered a categorization pragma.

4/3
A library package or generic library package is called a <shared
passive> library unit if the Shared_Passive aspect of the unit is True.A library package or generic library package is called a <remote types>
library unit if the Remote_Types aspect of the unit is True.   A library
unit is called a <remote call interface> if the Remote_Call_Interface
aspect of the unit is True.  A <normal library unit> is one for which no
categorization aspect is True.

5/3
The various categories of library units and the associated restrictions
are described in this and the following subclauses.  The categories are
related hierarchically in that the library units of one category can
depend semantically only on library units of that category or an earlier
one in the hierarchy, except that the body of a remote types or remote
call interface library unit is unrestricted, the declaration of a remote
types or remote call interface library unit may depend on preelaborated
normal library units that are mentioned only in private with clauses,
and all categories can depend on limited views.

6/3
The overall hierarchy (including declared pure) is as follows, with a
lower-numbered category being "earlier in the hierarchy" in the sense of
the previous paragraph:

6.1/3
     1.  Declared Pure

6.2/3
     2.  Shared Passive

6.3/3
     3.  Remote Types

6.4/3
     4.  Remote Call Interface

6.5/3
     5.  Normal (no restrictions)

<Paragraphs 7 through 11 were deleted.>

12
Declared pure and shared passive library units are preelaborated.  The
declaration of a remote types or remote call interface library unit is
required to be preelaborable.

<Paragraph 13 was deleted.>

                     _Implementation Permissions_

14
Implementations are allowed to define other categorization pragmas.

* Menu:

* E.2.1 ::    Shared Passive Library Units
* E.2.2 ::    Remote Types Library Units
* E.2.3 ::    Remote Call Interface Library Units


File: arm2012.info,  Node: E.2.1,  Next: E.2.2,  Up: E.2

E.2.1 Shared Passive Library Units
----------------------------------

1
A shared passive library unit is used for managing global data shared
between active partitions.  The restrictions on shared passive library
units prevent the data or tasks of one active partition from being
accessible to another active partition through references implicit in
objects declared in the shared passive library unit.

                               _Syntax_

2
     The form of a pragma Shared_Passive is as follows:

3
       pragma Shared_Passive[(<library_unit_>name)];

                           _Legality Rules_

4/3
A pragma Shared_Passive is used to specify that a library unit is a
<shared passive library unit>, namely that the Shared_Passive aspect of
the library unit is True.  The following restrictions apply to such a
library unit:

5
   * it shall be preelaborable (see *note 10.2.1::);

6/3
   * it shall depend semantically only upon declared pure or shared
     passive library_items;

7/4
   * it shall not contain a library-level declaration of an access type
     that designates a class-wide type, nor a type with a part that is
     of a task type or protected type with entry_declarations;

7.1/4
   * it shall not contain a library-level declaration that contains a
     name that denotes a type declared within a declared-pure package,
     if that type has a part that is of an access type; for the purposes
     of this rule, the parts considered include those of the full views
     of any private types or private extensions.

8
Notwithstanding the definition of accessibility given in *note 3.10.2::,
the declaration of a library unit P1 is not accessible from within the
declarative region of a shared passive library unit P2, unless the
shared passive library unit P2 depends semantically on P1.

                          _Static Semantics_

9
A shared passive library unit is preelaborated.

                       _Post-Compilation Rules_

10
A shared passive library unit shall be assigned to at most one partition
within a given program.

11
Notwithstanding the rule given in *note 10.2::, a compilation unit in a
given partition does not <need> (in the sense of *note 10.2::) the
shared passive library units on which it depends semantically to be
included in that same partition; they will typically reside in separate
passive partitions.


File: arm2012.info,  Node: E.2.2,  Next: E.2.3,  Prev: E.2.1,  Up: E.2

E.2.2 Remote Types Library Units
--------------------------------

1
A remote types library unit supports the definition of types intended
for use in communication between active partitions.

                               _Syntax_

2
     The form of a pragma Remote_Types is as follows:

3
       pragma Remote_Types[(<library_unit_>name)];

                           _Legality Rules_

4/3
A pragma Remote_Types is used to specify that a library unit is a
<remote types library unit>, namely that the Remote_Types aspect of the
library unit is True.  The following restrictions apply to the
declaration of such a library unit:

5
   * it shall be preelaborable;

6/3
   * it shall depend semantically only on declared pure library_items,
     shared passive library units, other remote types library units, or
     preelaborated normal library units that are mentioned only in
     private with clauses;

7
   * it shall not contain the declaration of any variable within the
     visible part of the library unit;

8/2
   * the full view of each type declared in the visible part of the
     library unit that has any available stream attributes shall support
     external streaming (see *note 13.13.2::).

9/3
A named access type declared in the visible part of a remote types or
remote call interface library unit is called a <remote access type>.  
Such a type shall be:

9.1/1
   * an access-to-subprogram type, or

9.2/3
   * a general access type that designates a class-wide limited private
     type, a class-wide limited interface type, or a class-wide private
     extension all of whose ancestors are either private extensions,
     limited interface types, or limited private types.

9.3/1
A type that is derived from a remote access type is also a remote access
type.

10
The following restrictions apply to the use of a remote
access-to-subprogram type:

11/2
   * A value of a remote access-to-subprogram type shall be converted
     only to or from another (subtype-conformant) remote
     access-to-subprogram type;

12
   * The prefix of an Access attribute_reference that yields a value of
     a remote access-to-subprogram type shall statically denote a
     (subtype-conformant) remote subprogram.

13
The following restrictions apply to the use of a remote
access-to-class-wide type:

14/3
   * The primitive subprograms of the corresponding specific type shall
     only have access parameters if they are controlling formal
     parameters.  The primitive functions of the corresponding specific
     type shall only have an access result if it is a controlling access
     result.  Each noncontrolling formal parameter and noncontrolling
     result type shall support external streaming (see *note 13.13.2::);

14.1/3
   * The corresponding specific type shall not have a primitive
     procedure with the Synchronization aspect specified unless the
     synchronization_kind is Optional (see *note 9.5::);

15
   * A value of a remote access-to-class-wide type shall be explicitly
     converted only to another remote access-to-class-wide type;

16/4
   * A value of a remote access-to-class-wide type shall be dereferenced
     (or implicitly converted to an anonymous access type) only as part
     of a dispatching call to a primitive operation of the designated
     type where the value designates a controlling operand of the call
     (see *note E.4::, "*note E.4:: Remote Subprogram Calls");

16.1/3
   * A controlling access result value for a primitive function with any
     controlling operands of the corresponding specific type shall
     either be explicitly converted to a remote access-to-class-wide
     type or be part of a dispatching call where the value designates a
     controlling operand of the call;

17/4
   * The Storage_Pool attribute is not defined for a remote
     access-to-class-wide type; the expected type for an allocator shall
     not be a remote access-to-class-wide type.  A remote
     access-to-class-wide type shall not be an actual parameter for a
     generic formal access type.  The Storage_Size attribute of a remote
     access-to-class-wide type yields 0.  The Storage_Pool and
     Storage_Size aspects shall not be specified for a remote
     access-to-class-wide type.

                         _Erroneous Execution_

17.1/4
Execution is erroneous if some operation (other than the initialization
or finalization of the object) modifies the value of a constant object
declared in the visible part of a remote types package.

     NOTES

18
     5  A remote types library unit need not be pure, and the types it
     defines may include levels of indirection implemented by using
     access types.  User-specified Read and Write attributes (see *note
     13.13.2::) provide for sending values of such a type between active
     partitions, with Write marshalling the representation, and Read
     unmarshalling any levels of indirection.

19/3
     6  The value of a remote access-to-class-wide limited interface can
     designate an object of a nonlimited type derived from the
     interface.

20/3
     7  A remote access type may designate a class-wide synchronized,
     protected, or task interface type.


File: arm2012.info,  Node: E.2.3,  Prev: E.2.2,  Up: E.2

E.2.3 Remote Call Interface Library Units
-----------------------------------------

1
A remote call interface library unit can be used as an interface for
remote procedure calls (RPCs) (or remote function calls) between active
partitions.

                               _Syntax_

2
     The form of a pragma Remote_Call_Interface is as follows:

3
       pragma Remote_Call_Interface[(<library_unit_>name)];

4
     The form of a pragma All_Calls_Remote is as follows:

5
       pragma All_Calls_Remote[(<library_unit_>name)];

6
     A pragma All_Calls_Remote is a library unit pragma.

                           _Legality Rules_

7/3
A pragma Remote_Call_Interface is used to specify that a library unit is
a <remote call interface (RCI)>, namely that the Remote_Call_Interface
aspect of the library unit is True.  A subprogram declared in the
visible part of such a library unit, or declared by such a library unit,
is called a <remote subprogram>.

8/3
The declaration of an RCI library unit shall be preelaborable (see *note
10.2.1::), and shall depend semantically only upon declared pure
library_items, shared passive library units, remote types library units,
other remote call interface library units, or preelaborated normal
library units that are mentioned only in private with clauses.

9/1
In addition, the following restrictions apply to an RCI library unit:

10/1
   * its visible part shall not contain the declaration of a variable;

11/1
   * its visible part shall not contain the declaration of a limited
     type;

12/1
   * its visible part shall not contain a nested generic_declaration;

13/3
   * it shall not be, nor shall its visible part contain, the
     declaration of a subprogram for which aspect Inline is True;

14/3
   * it shall not be, nor shall its visible part contain, a subprogram
     (or access-to-subprogram) declaration whose profile has a parameter
     or result of a type that does not support external streaming (see
     *note 13.13.2::);

15
   * any public child of the library unit shall be a remote call
     interface library unit.

16/3
A pragma All_Calls_Remote sets the All_Calls_Remote representation
aspect of the library unit to which the pragma applies to the value
True.  If the All_Calls_Remote aspect of a library unit is True, the
library unit shall be a remote call interface.

                       _Post-Compilation Rules_

17
A remote call interface library unit shall be assigned to at most one
partition of a given program.  A remote call interface library unit
whose parent is also an RCI library unit shall be assigned only to the
same partition as its parent.

18
Notwithstanding the rule given in *note 10.2::, a compilation unit in a
given partition that semantically depends on the declaration of an RCI
library unit, <needs> (in the sense of *note 10.2::) only the
declaration of the RCI library unit, not the body, to be included in
that same partition.  Therefore, the body of an RCI library unit is
included only in the partition to which the RCI library unit is
explicitly assigned.

                     _Implementation Requirements_

19/4
If aspect All_Calls_Remote is True for a given RCI library unit, then
the implementation shall route any of the following calls through the
Partition Communication Subsystem (PCS); see *note E.5:::

19.1/4
   * A direct call to a subprogram of the RCI unit from outside the
     declarative region of the unit;

19.2/4
   * An indirect call through a remote access-to-subprogram value that
     designates a subprogram of the RCI unit;

19.3/4
   * A dispatching call with a controlling operand designated by a
     remote access-to-class-wide value whose tag identifies a type
     declared in the RCI unit.

                     _Implementation Permissions_

20/3
An implementation need not support the Remote_Call_Interface pragma or
aspect nor the All_Calls_Remote pragma.  Explicit message-based
communication between active partitions can be supported as an
alternative to RPC.


File: arm2012.info,  Node: E.3,  Next: E.4,  Prev: E.2,  Up: Annex E

E.3 Consistency of a Distributed System
=======================================

1/3
This subclause defines attributes and rules associated with verifying
the consistency of a distributed program.

                          _Static Semantics_

2/1
For a prefix P that statically denotes a program unit, the following
attributes are defined:

3
P'Version
               Yields a value of the predefined type String that
               identifies the version of the compilation unit that
               contains the declaration of the program unit.

4
P'Body_Version
               Yields a value of the predefined type String that
               identifies the version of the compilation unit that
               contains the body (but not any subunits) of the program
               unit.

5/1
The <version> of a compilation unit changes whenever the compilation
unit changes in a semantically significant way.  This International
Standard does not define the exact meaning of "semantically
significant".  It is unspecified whether there are other events (such as
recompilation) that result in the version of a compilation unit
changing.  

5.1/1
If P is not a library unit, and P has no completion, then P'Body_Version
returns the Body_Version of the innermost program unit enclosing the
declaration of P. If P is a library unit, and P has no completion, then
P'Body_Version returns a value that is different from Body_Version of
any version of P that has a completion.

                      _Bounded (Run-Time) Errors_

6
In a distributed program, a library unit is <consistent> if the same
version of its declaration is used throughout.  It is a bounded error to
elaborate a partition of a distributed program that contains a
compilation unit that depends on a different version of the declaration
of a shared passive or RCI library unit than that included in the
partition to which the shared passive or RCI library unit was assigned.As a result of this error, Program_Error can be raised in one or both
partitions during elaboration; in any case, the partitions become
inaccessible to one another.


File: arm2012.info,  Node: E.4,  Next: E.5,  Prev: E.3,  Up: Annex E

E.4 Remote Subprogram Calls
===========================

1
A <remote subprogram call> is a subprogram call that invokes the
execution of a subprogram in another partition.  The partition that
originates the remote subprogram call is the <calling partition>, and
the partition that executes the corresponding subprogram body is the
<called partition>.  Some remote procedure calls are allowed to return
prior to the completion of subprogram execution.  These are called
<asynchronous remote procedure calls>.

2
There are three different ways of performing a remote subprogram call:

3
   * As a direct call on a (remote) subprogram explicitly declared in a
     remote call interface;

4
   * As an indirect call through a value of a remote
     access-to-subprogram type;

5
   * As a dispatching call with a controlling operand designated by a
     value of a remote access-to-class-wide type.

6
The first way of calling corresponds to a <static> binding between the
calling and the called partition.  The latter two ways correspond to a
<dynamic> binding between the calling and the called partition.

7/3
Remote types library units (see *note E.2.2::) and remote call interface
library units (see *note E.2.3::) define the remote subprograms or
remote access types used for remote subprogram calls.

                           _Legality Rules_

8
In a dispatching call with two or more controlling operands, if one
controlling operand is designated by a value of a remote
access-to-class-wide type, then all shall be.

                          _Dynamic Semantics_

9
For the execution of a remote subprogram call, subprogram parameters
(and later the results, if any) are passed using a stream-oriented
representation (see *note 13.13.1::) which is suitable for transmission
between partitions.  This action is called <marshalling>.
<Unmarshalling> is the reverse action of reconstructing the parameters
or results from the stream-oriented representation.  Marshalling is
performed initially as part of the remote subprogram call in the calling
partition; unmarshalling is done in the called partition.  After the
remote subprogram completes, marshalling is performed in the called
partition, and finally unmarshalling is done in the calling partition.

10
A <calling stub> is the sequence of code that replaces the subprogram
body of a remotely called subprogram in the calling partition.  A
<receiving stub> is the sequence of code (the "wrapper") that receives a
remote subprogram call on the called partition and invokes the
appropriate subprogram body.

11
Remote subprogram calls are executed at most once, that is, if the
subprogram call returns normally, then the called subprogram's body was
executed exactly once.

12
The task executing a remote subprogram call blocks until the subprogram
in the called partition returns, unless the call is asynchronous.  For
an asynchronous remote procedure call, the calling task can become ready
before the procedure in the called partition returns.

13
If a construct containing a remote call is aborted, the remote
subprogram call is <cancelled>.  Whether the execution of the remote
subprogram is immediately aborted as a result of the cancellation is
implementation defined.

14
If a remote subprogram call is received by a called partition before the
partition has completed its elaboration, the call is kept pending until
the called partition completes its elaboration (unless the call is
cancelled by the calling partition prior to that).

15
If an exception is propagated by a remotely called subprogram, and the
call is not an asynchronous call, the corresponding exception is
reraised at the point of the remote subprogram call.  For an
asynchronous call, if the remote procedure call returns prior to the
completion of the remotely called subprogram, any exception is lost.

16
The exception Communication_Error (see *note E.5::) is raised if a
remote call cannot be completed due to difficulties in communicating
with the called partition.

17
All forms of remote subprogram calls are potentially blocking operations
(see *note 9.5.1::).

18/1
In a remote subprogram call with a formal parameter of a class-wide
type, a check is made that the tag of the actual parameter identifies a
tagged type declared in a declared-pure or shared passive library unit,
or in the visible part of a remote types or remote call interface
library unit.  Program_Error is raised if this check fails.  In a remote
function call which returns a class-wide type, the same check is made on
the function result.

19
In a dispatching call with two or more controlling operands that are
designated by values of a remote access-to-class-wide type, a check is
made (in addition to the normal Tag_Check -- see *note 11.5::) that all
the remote access-to-class-wide values originated from Access
attribute_references that were evaluated by tasks of the same active
partition.  Constraint_Error is raised if this check fails.

                     _Implementation Requirements_

20
The implementation of remote subprogram calls shall conform to the PCS
interface as defined by the specification of the language-defined
package System.RPC (see *note E.5::).  The calling stub shall use the
Do_RPC procedure unless the remote procedure call is asynchronous in
which case Do_APC shall be used.  On the receiving side, the
corresponding receiving stub shall be invoked by the RPC-receiver.

20.1/1
With respect to shared variables in shared passive library units, the
execution of the corresponding subprogram body of a synchronous remote
procedure call is considered to be part of the execution of the calling
task.  The execution of the corresponding subprogram body of an
asynchronous remote procedure call proceeds in parallel with the calling
task and does not signal the next action of the calling task (see *note
9.10::).

     NOTES

21
     8  A given active partition can both make and receive remote
     subprogram calls.  Thus, an active partition can act as both a
     client and a server.

22
     9  If a given exception is propagated by a remote subprogram call,
     but the exception does not exist in the calling partition, the
     exception can be handled by an others choice or be propagated to
     and handled by a third partition.

* Menu:

* E.4.1 ::    Asynchronous Remote Calls
* E.4.2 ::    Example of Use of a Remote Access-to-Class-Wide Type


File: arm2012.info,  Node: E.4.1,  Next: E.4.2,  Up: E.4

E.4.1 Asynchronous Remote Calls
-------------------------------

1/3
This subclause introduces the aspect Asynchronous which can be specified
to allow a remote subprogram call to return prior to completion of the
execution of the corresponding remote subprogram body.

<Paragraphs 2 through 7 were deleted.>

                          _Static Semantics_

8/3
For a remote procedure, the following language-defined representation
aspect may be specified:

8.1/3
Asynchronous
               The type of aspect Asynchronous is Boolean.  If directly
               specified, the aspect_definition shall be a static
               expression.  If not specified, the aspect is False.

8.2/3
For a remote access type, the following language-defined representation
aspect may be specified:

8.3/3
Asynchronous
               The type of aspect Asynchronous is Boolean.  If directly
               specified, the aspect_definition shall be a static
               expression.  If not specified (including by inheritance),
               the aspect is False.

                           _Legality Rules_

8.4/3
If aspect Asynchronous is specified for a remote procedure, the formal
parameters of the procedure shall all be of mode in.

8.5/3
If aspect Asynchronous is specified for a remote access type, the type
shall be a remote access-to-class-wide type, or the type shall be a
remote access-to-procedure type with the formal parameters of the
designated profile of the type all of mode in.

                          _Dynamic Semantics_

9/3
A remote call is <asynchronous> if it is a call to a procedure, or a
call through a value of an access-to-procedure type, for which aspect
Asynchronous is True.  In addition, if aspect Asynchronous is True for a
remote access-to-class-wide type, then a dispatching call on a procedure
with a controlling operand designated by a value of the type is
asynchronous if the formal parameters of the procedure are all of mode
in.

                     _Implementation Requirements_

10
Asynchronous remote procedure calls shall be implemented such that the
corresponding body executes at most once as a result of the call.


File: arm2012.info,  Node: E.4.2,  Prev: E.4.1,  Up: E.4

E.4.2 Example of Use of a Remote Access-to-Class-Wide Type
----------------------------------------------------------

                              _Examples_

1
<Example of using a remote access-to-class-wide type to achieve dynamic
binding across active partitions:>

2
     package Tapes is
        pragma Pure(Tapes);
        type Tape is abstract tagged limited private;
        <-- Primitive dispatching operations where>
        <-- Tape is controlling operand>
        procedure Copy (From, To : access Tape; Num_Recs : in Natural) is abstract;
        procedure Rewind (T : access Tape) is abstract;
        <-- More operations>
     private
        type Tape is ...
     end Tapes;

3
     with Tapes;
     package Name_Server is
        pragma Remote_Call_Interface;
        <-- Dynamic binding to remote operations is achieved>
        <-- using the access-to-limited-class-wide type Tape_Ptr>
        type Tape_Ptr is access all Tapes.Tape'Class;
        <-- The following statically bound remote operations>
        <-- allow for a name-server capability in this example>
        function  Find     (Name : String) return Tape_Ptr;
        procedure Register (Name : in String; T : in Tape_Ptr);
        procedure Remove   (T : in Tape_Ptr);
        <-- More operations>
     end Name_Server;

4
     package Tape_Driver is
       <-- Declarations are not shown, they are irrelevant here>
     end Tape_Driver;

5
     with Tapes, Name_Server;
     package body Tape_Driver is
        type New_Tape is new Tapes.Tape with ...
        procedure Copy
         (From, To : access New_Tape; Num_Recs: in Natural) is
        begin
          . . .
        end Copy;
        procedure Rewind (T : access New_Tape) is
        begin
           . . .
        end Rewind;
        <-- Objects remotely accessible through use>
        <-- of Name_Server operations>
        Tape1, Tape2 : aliased New_Tape;
     begin
        Name_Server.Register ("NINE-TRACK",  Tape1'Access);
        Name_Server.Register ("SEVEN-TRACK", Tape2'Access);
     end Tape_Driver;

6
     with Tapes, Name_Server;
     <-- Tape_Driver is not needed and thus not mentioned in the with_clause>
     procedure Tape_Client is
        T1, T2 : Name_Server.Tape_Ptr;
     begin
        T1 := Name_Server.Find ("NINE-TRACK");
        T2 := Name_Server.Find ("SEVEN-TRACK");
        Tapes.Rewind (T1);
        Tapes.Rewind (T2);
        Tapes.Copy (T1, T2, 3);
     end Tape_Client;

7
<Notes on the example>:

8/1
<This paragraph was deleted.>

9
   * The package Tapes provides the necessary declarations of the type
     and its primitive operations.

10
   * Name_Server is a remote call interface package and is elaborated in
     a separate active partition to provide the necessary naming
     services (such as Register and Find) to the entire distributed
     program through remote subprogram calls.

11
   * Tape_Driver is a normal package that is elaborated in a partition
     configured on the processing node that is connected to the tape
     device(s).  The abstract operations are overridden to support the
     locally declared tape devices (Tape1, Tape2).  The package is not
     visible to its clients, but it exports the tape devices (as remote
     objects) through the services of the Name_Server.  This allows for
     tape devices to be dynamically added, removed or replaced without
     requiring the modification of the clients' code.

12
   * The Tape_Client procedure references only declarations in the Tapes
     and Name_Server packages.  Before using a tape for the first time,
     it needs to query the Name_Server for a system-wide identity for
     that tape.  From then on, it can use that identity to access the
     tape device.

13
   * Values of remote access type Tape_Ptr include the necessary
     information to complete the remote dispatching operations that
     result from dereferencing the controlling operands T1 and T2.


File: arm2012.info,  Node: E.5,  Prev: E.4,  Up: Annex E

E.5 Partition Communication Subsystem
=====================================

1/2
The <Partition Communication Subsystem> (PCS) provides facilities for
supporting communication between the active partitions of a distributed
program.  The package System.RPC is a language-defined interface to the
PCS.

                          _Static Semantics_

2
The following language-defined library package exists:

3
     with Ada.Streams; <-- see *note 13.13.1::>
     package System.RPC is

4
        type Partition_Id is range 0 .. <implementation-defined>;

5
        Communication_Error : exception;

6
        type Params_Stream_Type (
           Initial_Size : Ada.Streams.Stream_Element_Count) is new
           Ada.Streams.Root_Stream_Type with private;

7
        procedure Read(
           Stream : in out Params_Stream_Type;
           Item : out Ada.Streams.Stream_Element_Array;
           Last : out Ada.Streams.Stream_Element_Offset);

8
        procedure Write(
           Stream : in out Params_Stream_Type;
           Item : in Ada.Streams.Stream_Element_Array);

9
        <-- Synchronous call>
        procedure Do_RPC(
           Partition  : in Partition_Id;
           Params     : access Params_Stream_Type;
           Result     : access Params_Stream_Type);

10
        <-- Asynchronous call>
        procedure Do_APC(
           Partition  : in Partition_Id;
           Params     : access Params_Stream_Type);

11
        <-- The handler for incoming RPCs>
        type RPC_Receiver is access procedure(
           Params     : access Params_Stream_Type;
           Result     : access Params_Stream_Type);

12
        procedure Establish_RPC_Receiver(
           Partition : in Partition_Id;
           Receiver  : in RPC_Receiver);

13
     private
        ... -- <not specified by the language>
     end System.RPC;

14
A value of the type Partition_Id is used to identify a partition.

15
An object of the type Params_Stream_Type is used for identifying the
particular remote subprogram that is being called, as well as
marshalling and unmarshalling the parameters or result of a remote
subprogram call, as part of sending them between partitions.

16
The Read and Write procedures override the corresponding abstract
operations for the type Params_Stream_Type.

                          _Dynamic Semantics_

17
The Do_RPC and Do_APC procedures send a message to the active partition
identified by the Partition parameter.

18
After sending the message, Do_RPC blocks the calling task until a reply
message comes back from the called partition or some error is detected
by the underlying communication system in which case Communication_Error
is raised at the point of the call to Do_RPC.

19
Do_APC operates in the same way as Do_RPC except that it is allowed to
return immediately after sending the message.

20
Upon normal return, the stream designated by the Result parameter of
Do_RPC contains the reply message.

21
The procedure System.RPC.Establish_RPC_Receiver is called once,
immediately after elaborating the library units of an active partition
(that is, right after the <elaboration of the partition>) if the
partition includes an RCI library unit, but prior to invoking the main
subprogram, if any.  The Partition parameter is the Partition_Id of the
active partition being elaborated.  The Receiver parameter designates an
implementation-provided procedure called the <RPC-receiver> which will
handle all RPCs received by the partition from the PCS.
Establish_RPC_Receiver saves a reference to the RPC-receiver; when a
message is received at the called partition, the RPC-receiver is called
with the Params stream containing the message.  When the RPC-receiver
returns, the contents of the stream designated by Result is placed in a
message and sent back to the calling partition.

22
If a call on Do_RPC is aborted, a cancellation message is sent to the
called partition, to request that the execution of the remotely called
subprogram be aborted.

23
The subprograms declared in System.RPC are potentially blocking
operations.

                     _Implementation Requirements_

24
The implementation of the RPC-receiver shall be reentrant, thereby
allowing concurrent calls on it from the PCS to service concurrent
remote subprogram calls into the partition.

24.1/1
An implementation shall not restrict the replacement of the body of
System.RPC. An implementation shall not restrict children of System.RPC.
The related implementation permissions in the introduction to Annex A do
not apply.

24.2/1
If the implementation of System.RPC is provided by the user, an
implementation shall support remote subprogram calls as specified.

                     _Documentation Requirements_

25
The implementation of the PCS shall document whether the RPC-receiver is
invoked from concurrent tasks.  If there is an upper limit on the number
of such tasks, this limit shall be documented as well, together with the
mechanisms to configure it (if this is supported).

                     _Implementation Permissions_

26
The PCS is allowed to contain implementation-defined interfaces for
explicit message passing, broadcasting, etc.  Similarly, it is allowed
to provide additional interfaces to query the state of some remote
partition (given its partition ID) or of the PCS itself, to set timeouts
and retry parameters, to get more detailed error status, etc.  These
additional interfaces should be provided in child packages of
System.RPC.

27
A body for the package System.RPC need not be supplied by the
implementation.

27.1/3
An alternative declaration is allowed for package System.RPC as long as
it provides a set of operations that is substantially equivalent to the
specification defined in this subclause.

                        _Implementation Advice_

28
Whenever possible, the PCS on the called partition should allow for
multiple tasks to call the RPC-receiver with different messages and
should allow them to block until the corresponding subprogram body
returns.

29
The Write operation on a stream of type Params_Stream_Type should raise
Storage_Error if it runs out of space trying to write the Item into the
stream.

     NOTES

30
     10  The package System.RPC is not designed for direct calls by user
     programs.  It is instead designed for use in the implementation of
     remote subprograms calls, being called by the calling stubs
     generated for a remote call interface library unit to initiate a
     remote call, and in turn calling back to an RPC-receiver that
     dispatches to the receiving stubs generated for the body of a
     remote call interface, to handle a remote call received from
     elsewhere.


File: arm2012.info,  Node: Annex F,  Next: Annex G,  Prev: Annex E,  Up: Top

Annex F Information Systems
***************************

1
This Annex provides a set of facilities relevant to Information Systems
programming.  These fall into several categories:

2
   * an attribute definition clause specifying Machine_Radix for a
     decimal subtype;

3
   * the package Decimal, which declares a set of constants defining the
     implementation's capacity for decimal types, and a generic
     procedure for decimal division; and

4/2
   * the child packages Text_IO.Editing, Wide_Text_IO.Editing, and
     Wide_Wide_Text_IO.Editing, which support formatted and localized
     output of decimal data, based on "picture String" values.

5/2
See also: *note 3.5.9::, "*note 3.5.9:: Fixed Point Types"; *note
3.5.10::, "*note 3.5.10:: Operations of Fixed Point Types"; *note 4.6::,
"*note 4.6:: Type Conversions"; *note 13.3::, "*note 13.3:: Operational
and Representation Attributes"; *note A.10.9::, "*note A.10.9::
Input-Output for Real Types"; *note B.3::, "*note B.3:: Interfacing with
C and C++"; *note B.4::, "*note B.4:: Interfacing with COBOL"; *note
Annex G::, "*note Annex G:: Numerics".

6
The character and string handling packages in *note Annex A::, "*note
Annex A:: Predefined Language Environment" are also relevant for
Information Systems.

                        _Implementation Advice_

7/3
If COBOL (respectively, C) is widely supported in the target
environment, implementations supporting the Information Systems Annex
should provide the child package Interfaces.COBOL (respectively,
Interfaces.C) specified in *note Annex B:: and should support a
<convention_>identifier of COBOL (respectively, C) for the Convention
aspect (see *note Annex B::), thus allowing Ada programs to interface
with programs written in that language.

* Menu:

* F.1 ::      Machine_Radix Attribute Definition Clause
* F.2 ::      The Package Decimal
* F.3 ::      Edited Output for Decimal Types


File: arm2012.info,  Node: F.1,  Next: F.2,  Up: Annex F

F.1 Machine_Radix Attribute Definition Clause
=============================================

                          _Static Semantics_

1
Machine_Radix may be specified for a decimal first subtype (see *note
3.5.9::) via an attribute_definition_clause; the expression of such a
clause shall be static, and its value shall be 2 or 10.  A value of 2
implies a binary base range; a value of 10 implies a decimal base range.

                        _Implementation Advice_

2
Packed decimal should be used as the internal representation for objects
of subtype S when S'Machine_Radix = 10.

                              _Examples_

3
<Example of Machine_Radix attribute definition clause:>

4
     type Money is delta 0.01 digits 15;
     for Money'Machine_Radix use 10;


File: arm2012.info,  Node: F.2,  Next: F.3,  Prev: F.1,  Up: Annex F

F.2 The Package Decimal
=======================

                          _Static Semantics_

1
The library package Decimal has the following declaration:

2
     package Ada.Decimal is
        pragma Pure(Decimal);

3
        Max_Scale : constant := <implementation-defined>;
        Min_Scale : constant := <implementation-defined>;

4
        Min_Delta : constant := 10.0**(-Max_Scale);
        Max_Delta : constant := 10.0**(-Min_Scale);

5
        Max_Decimal_Digits : constant := <implementation-defined>;

6/3
        generic
           type Dividend_Type  is delta <> digits <>;
           type Divisor_Type   is delta <> digits <>;
           type Quotient_Type  is delta <> digits <>;
           type Remainder_Type is delta <> digits <>;
        procedure Divide (Dividend  : in Dividend_Type;
                          Divisor   : in Divisor_Type;
                          Quotient  : out Quotient_Type;
                          Remainder : out Remainder_Type)
           with Convention => Intrinsic;

7
     end Ada.Decimal;

8
Max_Scale is the largest N such that 10.0**(-N) is allowed as a decimal
type's delta.  Its type is <universal_integer>.

9
Min_Scale is the smallest N such that 10.0**(-N) is allowed as a decimal
type's delta.  Its type is <universal_integer>.

10
Min_Delta is the smallest value allowed for <delta> in a
decimal_fixed_point_definition.  Its type is <universal_real>.

11
Max_Delta is the largest value allowed for <delta> in a
decimal_fixed_point_definition.  Its type is <universal_real>.

12
Max_Decimal_Digits is the largest value allowed for <digits> in a
decimal_fixed_point_definition.  Its type is <universal_integer>.

                          _Static Semantics_

13
The effect of Divide is as follows.  The value of Quotient is
Quotient_Type(Dividend/Divisor).  The value of Remainder is
Remainder_Type(Intermediate), where Intermediate is the difference
between Dividend and the product of Divisor and Quotient; this result is
computed exactly.

                     _Implementation Requirements_

14
Decimal.Max_Decimal_Digits shall be at least 18.

15
Decimal.Max_Scale shall be at least 18.

16
Decimal.Min_Scale shall be at most 0.

     NOTES

17
     1  The effect of division yielding a quotient with control over
     rounding versus truncation is obtained by applying either the
     function attribute Quotient_Type'Round or the conversion
     Quotient_Type to the expression Dividend/Divisor.


File: arm2012.info,  Node: F.3,  Prev: F.2,  Up: Annex F

F.3 Edited Output for Decimal Types
===================================

1/2
The child packages Text_IO.Editing, Wide_Text_IO.Editing, and
Wide_Wide_Text_IO.Editing provide localizable formatted text output,
known as <edited output>, for decimal types.  An edited output string is
a function of a numeric value, program-specifiable locale elements, and
a format control value.  The numeric value is of some decimal type.  The
locale elements are:

2
   * the currency string;

3
   * the digits group separator character;

4
   * the radix mark character; and

5
   * the fill character that replaces leading zeros of the numeric
     value.

6/2
For Text_IO.Editing the edited output and currency strings are of type
String, and the locale characters are of type Character.  For
Wide_Text_IO.Editing their types are Wide_String and Wide_Character,
respectively.  For Wide_Wide_Text_IO.Editing their types are
Wide_Wide_String and Wide_Wide_Character, respectively.

7
Each of the locale elements has a default value that can be replaced or
explicitly overridden.

8
A format-control value is of the private type Picture; it determines the
composition of the edited output string and controls the form and
placement of the sign, the position of the locale elements and the
decimal digits, the presence or absence of a radix mark, suppression of
leading zeros, and insertion of particular character values.

9
A Picture object is composed from a String value, known as a <picture
String>, that serves as a template for the edited output string, and a
Boolean value that controls whether a string of all space characters is
produced when the number's value is zero.  A picture String comprises a
sequence of one- or two-Character symbols, each serving as a placeholder
for a character or string at a corresponding position in the edited
output string.  The picture String symbols fall into several categories
based on their effect on the edited output string:

10
        Decimal Digit:    '9'
        Radix Control:    '.'    'V'
        Sign Control:    '+'    '-'    '<'    '>'    "CR"    "DB"
        Currency Control:    '$'    '#'
        Zero Suppression:    'Z'    '*'
        Simple Insertion:    '_'    'B'    '0'    '/'

11
The entries are not case-sensitive.  Mixed- or lower-case forms for "CR"
and "DB", and lower-case forms for 'V', 'Z', and 'B', have the same
effect as the upper-case symbols shown.

12
An occurrence of a '9' Character in the picture String represents a
decimal digit position in the edited output string.

13
A radix control Character in the picture String indicates the position
of the radix mark in the edited output string: an actual character
position for '.', or an assumed position for 'V'.

14
A sign control Character in the picture String affects the form of the
sign in the edited output string.  The '<' and '>' Character values
indicate parentheses for negative values.  A Character '+', '-', or '<'
appears either singly, signifying a fixed-position sign in the edited
output, or repeated, signifying a floating-position sign that is
preceded by zero or more space characters and that replaces a leading 0.

15
A currency control Character in the picture String indicates an
occurrence of the currency string in the edited output string.  The '$'
Character represents the complete currency string; the '#' Character
represents one character of the currency string.  A '$' Character
appears either singly, indicating a fixed-position currency string in
the edited output, or repeated, indicating a floating-position currency
string that occurs in place of a leading 0.  A sequence of '#' Character
values indicates either a fixed- or floating-position currency string,
depending on context.

16
A zero suppression Character in the picture String allows a leading zero
to be replaced by either the space character (for 'Z') or the fill
character (for '*').

17
A simple insertion Character in the picture String represents, in
general, either itself (if '/' or '0'), the space character (if 'B'), or
the digits group separator character (if '_').  In some contexts it is
treated as part of a floating sign, floating currency, or zero
suppression string.

18/2
An example of a picture String is "<###Z_ZZ9.99>".  If the currency
string is "kr", the separator character is ',', and the radix mark is
'.'  then the edited output string values for the decimal values 32.10
and -5432.10 are "bbkrbbb32.10b" and "(bkr5,432.10)", respectively,
where 'b' indicates the space character.

19/2
The generic packages Text_IO.Decimal_IO, Wide_Text_IO.Decimal_IO, and
Wide_Wide_Text_IO.Decimal_IO (see *note A.10.9::, "*note A.10.9::
Input-Output for Real Types") provide text input and nonedited text
output for decimal types.

     NOTES

20/2
     2  A picture String is of type Standard.String, for all of
     Text_IO.Editing, Wide_Text_IO.Editing, and
     Wide_Wide_Text_IO.Editing.

* Menu:

* F.3.1 ::    Picture String Formation
* F.3.2 ::    Edited Output Generation
* F.3.3 ::    The Package Text_IO.Editing
* F.3.4 ::    The Package Wide_Text_IO.Editing
* F.3.5 ::    The Package Wide_Wide_Text_IO.Editing


File: arm2012.info,  Node: F.3.1,  Next: F.3.2,  Up: F.3

F.3.1 Picture String Formation
------------------------------

1/3
A <well-formed picture String>, or simply <picture String>, is a String
value that conforms to the syntactic rules, composition constraints, and
character replication conventions specified in this subclause.

                          _Dynamic Semantics_

2/1
<This paragraph was deleted.>

3
     picture_string ::=
        fixed_$_picture_string
      | fixed_#_picture_string
      | floating_currency_picture_string
      | non_currency_picture_string

4
     fixed_$_picture_string ::=
        [fixed_LHS_sign] fixed_$_char {direct_insertion} [zero_suppression]
          number [RHS_sign]

      | [fixed_LHS_sign {direct_insertion}] [zero_suppression]
          number fixed_$_char {direct_insertion} [RHS_sign]

      | floating_LHS_sign number fixed_$_char {direct_insertion} [RHS_sign]

      | [fixed_LHS_sign] fixed_$_char {direct_insertion}
          all_zero_suppression_number {direct_insertion}  [RHS_sign]

      | [fixed_LHS_sign {direct_insertion}] all_zero_suppression_number {direct_insertion}
          fixed_$_char {direct_insertion} [RHS_sign]

      | all_sign_number {direct_insertion} fixed_$_char {direct_insertion} [RHS_sign]

5
     fixed_#_picture_string ::=
        [fixed_LHS_sign] single_#_currency {direct_insertion}
          [zero_suppression] number [RHS_sign]

      | [fixed_LHS_sign] multiple_#_currency {direct_insertion}
          zero_suppression number [RHS_sign]

      | [fixed_LHS_sign {direct_insertion}] [zero_suppression]
          number fixed_#_currency {direct_insertion} [RHS_sign]

      | floating_LHS_sign number fixed_#_currency {direct_insertion} [RHS_sign]

      | [fixed_LHS_sign] single_#_currency {direct_insertion}
          all_zero_suppression_number {direct_insertion} [RHS_sign]

      | [fixed_LHS_sign] multiple_#_currency {direct_insertion}
          all_zero_suppression_number {direct_insertion} [RHS_sign]

      | [fixed_LHS_sign {direct_insertion}] all_zero_suppression_number {direct_insertion}
          fixed_#_currency {direct_insertion} [RHS_sign]

      | all_sign_number {direct_insertion} fixed_#_currency {direct_insertion} [RHS_sign]

6
     floating_currency_picture_string ::=
        [fixed_LHS_sign] {direct_insertion} floating_$_currency number [RHS_sign]
      | [fixed_LHS_sign] {direct_insertion} floating_#_currency number [RHS_sign]
      | [fixed_LHS_sign] {direct_insertion} all_currency_number {direct_insertion} [RHS_sign]

7
     non_currency_picture_string ::=
        [fixed_LHS_sign {direct_insertion}] zero_suppression number [RHS_sign]
      | [floating_LHS_sign] number [RHS_sign]
      | [fixed_LHS_sign {direct_insertion}] all_zero_suppression_number {direct_insertion}
          [RHS_sign]
      | all_sign_number {direct_insertion}
      | fixed_LHS_sign direct_insertion {direct_insertion} number [RHS_sign]

8
     fixed_LHS_sign ::=  LHS_Sign

9
     LHS_Sign ::=  + | - | <

10
     fixed_$_char ::= $

11
     direct_insertion ::=  simple_insertion

12
     simple_insertion ::=  _ | B | 0 | /

13
     zero_suppression ::=  Z {Z | context_sensitive_insertion} | fill_string

14
     context_sensitive_insertion ::=  simple_insertion

15
     fill_string ::=  * {* | context_sensitive_insertion}

16
     number ::=
        fore_digits [radix [aft_digits] {direct_insertion}]
      | radix aft_digits {direct_insertion}

17
     fore_digits ::= 9 {9 | direct_insertion}

18
     aft_digits ::=  {9 | direct_insertion} 9

19
     radix ::= . | V

20
     RHS_sign ::= + | - | > | CR | DB

21
     floating_LHS_sign ::=
        LHS_Sign {context_sensitive_insertion} LHS_Sign {LHS_Sign | context_sensitive_insertion}

22
     single_#_currency ::= #

23
     multiple_#_currency ::= ## {#}

24
     fixed_#_currency ::= single_#_currency | multiple_#_currency

25
     floating_$_currency ::=
        $ {context_sensitive_insertion} $ {$ | context_sensitive_insertion}

26
     floating_#_currency ::=
        # {context_sensitive_insertion} # {# | context_sensitive_insertion}

27
     all_sign_number ::=  all_sign_fore [radix [all_sign_aft]] [>]

28
     all_sign_fore ::=
        sign_char {context_sensitive_insertion} sign_char {sign_char | context_sensitive_insertion}

29
     all_sign_aft ::= {all_sign_aft_char} sign_char

     all_sign_aft_char ::=  sign_char | context_sensitive_insertion

30
     sign_char ::= + | - | <

31
     all_currency_number ::=  all_currency_fore [radix [all_currency_aft]]

32
     all_currency_fore ::=
        currency_char {context_sensitive_insertion}
          currency_char {currency_char | context_sensitive_insertion}

33
     all_currency_aft ::= {all_currency_aft_char} currency_char

     all_currency_aft_char ::= currency_char | context_sensitive_insertion

34
     currency_char ::= $ | #

35
     all_zero_suppression_number ::=  all_zero_suppression_fore [ radix [all_zero_suppression_aft]]

36
     all_zero_suppression_fore ::=
        zero_suppression_char {zero_suppression_char | context_sensitive_insertion}

37
     all_zero_suppression_aft ::= {all_zero_suppression_aft_char} zero_suppression_char

     all_zero_suppression_aft_char ::=  zero_suppression_char | context_sensitive_insertion

38
     zero_suppression_char ::= Z | *

39
The following composition constraints apply to a picture String:

40
   * A floating_LHS_sign does not have occurrences of different LHS_Sign
     Character values.

41
   * If a picture String has '<' as fixed_LHS_sign, then it has '>' as
     RHS_sign.

42
   * If a picture String has '<' in a floating_LHS_sign or in an
     all_sign_number, then it has an occurrence of '>'.

43/1
   * If a picture String has '+' or '-' as fixed_LHS_sign, in a
     floating_LHS_sign, or in an all_sign_number, then it has no
     RHS_sign or '>' character.

44
   * An instance of all_sign_number does not have occurrences of
     different sign_char Character values.

45
   * An instance of all_currency_number does not have occurrences of
     different currency_char Character values.

46
   * An instance of all_zero_suppression_number does not have
     occurrences of different zero_suppression_char Character values,
     except for possible case differences between 'Z' and 'z'.

47
A <replicable Character> is a Character that, by the above rules, can
occur in two consecutive positions in a picture String.

48
A <Character replication> is a String

49
     <char> & '(' & <spaces> & <count_string> & ')'

50
where <char> is a replicable Character, <spaces> is a String (possibly
empty) comprising only space Character values, and <count_string> is a
String of one or more decimal digit Character values.  A Character
replication in a picture String has the same effect as (and is said to
be <equivalent to>) a String comprising <n> consecutive occurrences of
<char>, where <n>=Integer'Value(<count_string>).

51
An <expanded picture String> is a picture String containing no Character
replications.

     NOTES

52
     3  Although a sign to the left of the number can float, a sign to
     the right of the number is in a fixed position.


File: arm2012.info,  Node: F.3.2,  Next: F.3.3,  Prev: F.3.1,  Up: F.3

F.3.2 Edited Output Generation
------------------------------

                          _Dynamic Semantics_

1
The contents of an edited output string are based on:

2
   * A value, Item, of some decimal type Num,

3
   * An expanded picture String Pic_String,

4
   * A Boolean value, Blank_When_Zero,

5
   * A Currency string,

6
   * A Fill character,

7
   * A Separator character, and

8
   * A Radix_Mark character.

9
The combination of a True value for Blank_When_Zero and a '*' character
in Pic_String is inconsistent; no edited output string is defined.

10
A layout error is identified in the rules below if leading nonzero
digits of Item, character values of the Currency string, or a negative
sign would be truncated; in such cases no edited output string is
defined.

11
The edited output string has lower bound 1 and upper bound N where N =
Pic_String'Length + Currency_Length_Adjustment - Radix_Adjustment, and

12
   * Currency_Length_Adjustment = Currency'Length - 1 if there is some
     occurrence of '$' in Pic_String, and 0 otherwise.

13
   * Radix_Adjustment = 1 if there is an occurrence of 'V' or 'v' in
     Pic_Str, and 0 otherwise.

14
Let the magnitude of Item be expressed as a base-10 number
Ip···I1.F1···Fq, called the <displayed> <magnitude> of Item, where:

15
   * q = Min(Max(Num'Scale, 0), n) where n is 0 if Pic_String has no
     radix and is otherwise the number of digit positions following
     radix in Pic_String, where a digit position corresponds to an
     occurrence of '9', a zero_suppression_char (for an
     all_zero_suppression_number), a currency_char (for an
     all_currency_number), or a sign_char (for an all_sign_number).

16
   * Ip /= 0 if p>0.

17
If n < Num'Scale, then the above number is the result of rounding (away
from 0 if exactly midway between values).

18
If Blank_When_Zero = True and the displayed magnitude of Item is zero,
then the edited output string comprises all space character values.
Otherwise, the picture String is treated as a sequence of instances of
syntactic categories based on the rules in *note F.3.1::, and the edited
output string is the concatenation of string values derived from these
categories according to the following mapping rules.

19
Table F-1 shows the mapping from a sign control symbol to a
corresponding character or string in the edited output.  In the columns
showing the edited output, a lower-case 'b' represents the space
character.  If there is no sign control symbol but the value of Item is
negative, a layout error occurs and no edited output string is produced.

Table F-1: Edited Output for Sign Control Symbols
Sign Control Symbol   Edited Output for    Edited Output for 
                      Nonnegative Number   Negative Number
'+'                   '+'                  '-'
'-'                   'b'                  '-'
'<'                   'b'                  '('
'>'                   'b'                  ')'
"CR"                  "bb"                 "CR"
"DB"                  "bb"                 "DB"
20
An instance of fixed_LHS_sign maps to a character as shown in Table F-1.

21
An instance of fixed_$_char maps to Currency.

22
An instance of direct_insertion maps to Separator if direct_insertion =
'_', and to the direct_insertion Character otherwise.

23
An instance of number maps to a string <integer_part> & <radix_part> &
<fraction_part> where:

24
   * The string for <integer_part> is obtained as follows:

25
          1.  Occurrences of '9' in fore_digits of number are replaced
          from right to left with the decimal digit character values for
          I1, ..., Ip, respectively.

26
          2.  Each occurrence of '9' in fore_digits to the left of the
          leftmost '9' replaced according to rule 1 is replaced with
          '0'.

27
          3.  If p exceeds the number of occurrences of '9' in
          fore_digits of number, then the excess leftmost digits are
          eligible for use in the mapping of an instance of
          zero_suppression, floating_LHS_sign, floating_$_currency, or
          floating_#_currency to the left of number; if there is no such
          instance, then a layout error occurs and no edited output
          string is produced.

28
   * The <radix_part> is:

29
             * "" if number does not include a radix, if radix = 'V', or
               if radix = 'v'

30
             * Radix_Mark if number includes '.'  as radix

31
   * The string for <fraction_part> is obtained as follows:

32
          1.  Occurrences of '9' in aft_digits of number are replaced
          from left to right with the decimal digit character values for
          F1, ...  Fq.

33
          2.  Each occurrence of '9' in aft_digits to the right of the
          rightmost '9' replaced according to rule 1 is replaced by '0'.

34
An instance of zero_suppression maps to the string obtained as follows:

35
     1.  The rightmost 'Z', 'z', or '*' Character values are replaced
     with the excess digits (if any) from the <integer_part> of the
     mapping of the number to the right of the zero_suppression
     instance,

36
     2.  A context_sensitive_insertion Character is replaced as though
     it were a direct_insertion Character, if it occurs to the right of
     some 'Z', 'z', or '*' in zero_suppression that has been mapped to
     an excess digit,

37
     3.  Each Character to the left of the leftmost Character replaced
     according to rule 1 above is replaced by:

38
             * the space character if the zero suppression Character is
               'Z' or 'z', or

39
             * the Fill character if the zero suppression Character is
               '*'.

40
     4.  A layout error occurs if some excess digits remain after all
     'Z', 'z', and '*' Character values in zero_suppression have been
     replaced via rule 1; no edited output string is produced.

41
An instance of RHS_sign maps to a character or string as shown in Table
F-1.

42
An instance of floating_LHS_sign maps to the string obtained as follows.

43
     1.  Up to all but one of the rightmost LHS_Sign Character values
     are replaced by the excess digits (if any) from the <integer_part>
     of the mapping of the number to the right of the floating_LHS_sign
     instance.

44
     2.  The next Character to the left is replaced with the character
     given by the entry in Table F-1 corresponding to the LHS_Sign
     Character.

45
     3.  A context_sensitive_insertion Character is replaced as though
     it were a direct_insertion Character, if it occurs to the right of
     the leftmost LHS_Sign character replaced according to rule 1.

46
     4.  Any other Character is replaced by the space character..

47
     5.  A layout error occurs if some excess digits remain after
     replacement via rule 1; no edited output string is produced.

48
An instance of fixed_#_currency maps to the Currency string with n space
character values concatenated on the left (if the instance does not
follow a radix) or on the right (if the instance does follow a radix),
where n is the difference between the length of the fixed_#_currency
instance and Currency'Length.  A layout error occurs if Currency'Length
exceeds the length of the fixed_#_currency instance; no edited output
string is produced.

49
An instance of floating_$_currency maps to the string obtained as
follows:

50
     1.  Up to all but one of the rightmost '$' Character values are
     replaced with the excess digits (if any) from the <integer_part> of
     the mapping of the number to the right of the floating_$_currency
     instance.

51
     2.  The next Character to the left is replaced by the Currency
     string.

52
     3.  A context_sensitive_insertion Character is replaced as though
     it were a direct_insertion Character, if it occurs to the right of
     the leftmost '$' Character replaced via rule 1.

53
     4.  Each other Character is replaced by the space character.

54
     5.  A layout error occurs if some excess digits remain after
     replacement by rule 1; no edited output string is produced.

55
An instance of floating_#_currency maps to the string obtained as
follows:

56
     1.  Up to all but one of the rightmost '#' Character values are
     replaced with the excess digits (if any) from the <integer_part> of
     the mapping of the number to the right of the floating_#_currency
     instance.

57
     2.  The substring whose last Character occurs at the position
     immediately preceding the leftmost Character replaced via rule 1,
     and whose length is Currency'Length, is replaced by the Currency
     string.

58
     3.  A context_sensitive_insertion Character is replaced as though
     it were a direct_insertion Character, if it occurs to the right of
     the leftmost '#' replaced via rule 1.

59
     4.  Any other Character is replaced by the space character.

60
     5.  A layout error occurs if some excess digits remain after
     replacement rule 1, or if there is no substring with the required
     length for replacement rule 2; no edited output string is produced.

61
An instance of all_zero_suppression_number maps to:

62
   * a string of all spaces if the displayed magnitude of Item is zero,
     the zero_suppression_char is 'Z' or 'z', and the instance of
     all_zero_suppression_number does not have a radix at its last
     character position;

63
   * a string containing the Fill character in each position except for
     the character (if any) corresponding to radix, if
     zero_suppression_char = '*' and the displayed magnitude of Item is
     zero;

64
   * otherwise, the same result as if each zero_suppression_char in
     all_zero_suppression_aft were '9', interpreting the instance of
     all_zero_suppression_number as either zero_suppression number (if a
     radix and all_zero_suppression_aft are present), or as
     zero_suppression otherwise.

65
An instance of all_sign_number maps to:

66
   * a string of all spaces if the displayed magnitude of Item is zero
     and the instance of all_sign_number does not have a radix at its
     last character position;

67
   * otherwise, the same result as if each sign_char in
     all_sign_number_aft were '9', interpreting the instance of
     all_sign_number as either floating_LHS_sign number (if a radix and
     all_sign_number_aft are present), or as floating_LHS_sign
     otherwise.

68
An instance of all_currency_number maps to:

69
   * a string of all spaces if the displayed magnitude of Item is zero
     and the instance of all_currency_number does not have a radix at
     its last character position;

70
   * otherwise, the same result as if each currency_char in
     all_currency_number_aft were '9', interpreting the instance of
     all_currency_number as floating_$_currency number or
     floating_#_currency number (if a radix and all_currency_number_aft
     are present), or as floating_$_currency or floating_#_currency
     otherwise.

                              _Examples_

71
In the result string values shown below, 'b' represents the space
character.

72
     Item:         Picture and Result Strings:

73/3
     123456.78     Picture:  "-###**_***_**9.99"
                   Result:   "bbb$***123,456.78"
                             "bbFF***123.456,78" (currency = "FF",
                                                  separator = '.',
                                                  radix mark = ',')

74/1
     123456.78     Picture:  "-$**_***_**9.99"
                   Result:   "b$***123,456.78"
                            "bFF***123.456,78" (currency = "FF",
                                                separator = '.',
                                                radix mark = ',')

75
     0.0          Picture: "-$$$$$$.$$"
                  Result:  "bbbbbbbbbb"

76
     0.20         Picture: "-$$$$$$.$$"
                  Result:  "bbbbbb$.20"

77
     -1234.565    Picture: "<<<<_<<<.<<###>"
                  Result:  "bb(1,234.57DMb)"  (currency = "DM")

78
     12345.67     Picture: "###_###_##9.99"
                  Result:  "bbCHF12,345.67"   (currency = "CHF")


File: arm2012.info,  Node: F.3.3,  Next: F.3.4,  Prev: F.3.2,  Up: F.3

F.3.3 The Package Text_IO.Editing
---------------------------------

1
The package Text_IO.Editing provides a private type Picture with
associated operations, and a generic package Decimal_Output.  An object
of type Picture is composed from a well-formed picture String (see *note
F.3.1::) and a Boolean item indicating whether a zero numeric value will
result in an edited output string of all space characters.  The package
Decimal_Output contains edited output subprograms implementing the
effects defined in *note F.3.2::.

                          _Static Semantics_

2
The library package Text_IO.Editing has the following declaration:

3
     package Ada.Text_IO.Editing is

4
        type Picture is private;

5
        function Valid (Pic_String      : in String;
                        Blank_When_Zero : in Boolean := False) return Boolean;

6
        function To_Picture (Pic_String      : in String;
                             Blank_When_Zero : in Boolean := False)
           return Picture;

7
        function Pic_String      (Pic : in Picture) return String;
        function Blank_When_Zero (Pic : in Picture) return Boolean;

8
        Max_Picture_Length  : constant := <implementation_defined>;

9
        Picture_Error       : exception;

10
        Default_Currency    : constant String    := "$";
        Default_Fill        : constant Character := '*';
        Default_Separator   : constant Character := ',';
        Default_Radix_Mark  : constant Character := '.';

11
        generic
           type Num is delta <> digits <>;
           Default_Currency   : in String    := Text_IO.Editing.Default_Currency;
           Default_Fill       : in Character := Text_IO.Editing.Default_Fill;
           Default_Separator  : in Character :=
                                   Text_IO.Editing.Default_Separator;
           Default_Radix_Mark : in Character :=
                                   Text_IO.Editing.Default_Radix_Mark;
        package Decimal_Output is
           function Length (Pic      : in Picture;
                            Currency : in String := Default_Currency)
              return Natural;

12
           function Valid (Item     : in Num;
                           Pic      : in Picture;
                           Currency : in String := Default_Currency)
              return Boolean;

13
           function Image (Item       : in Num;
                           Pic        : in Picture;
                           Currency   : in String    := Default_Currency;
                           Fill       : in Character := Default_Fill;
                           Separator  : in Character := Default_Separator;
                           Radix_Mark : in Character := Default_Radix_Mark)
              return String;

14
           procedure Put (File       : in File_Type;
                          Item       : in Num;
                          Pic        : in Picture;
                          Currency   : in String    := Default_Currency;
                          Fill       : in Character := Default_Fill;
                          Separator  : in Character := Default_Separator;
                          Radix_Mark : in Character := Default_Radix_Mark);

15
           procedure Put (Item       : in Num;
                          Pic        : in Picture;
                          Currency   : in String    := Default_Currency;
                          Fill       : in Character := Default_Fill;
                          Separator  : in Character := Default_Separator;
                          Radix_Mark : in Character := Default_Radix_Mark);

16
           procedure Put (To         : out String;
                          Item       : in Num;
                          Pic        : in Picture;
                          Currency   : in String    := Default_Currency;
                          Fill       : in Character := Default_Fill;
                          Separator  : in Character := Default_Separator;
                          Radix_Mark : in Character := Default_Radix_Mark);
        end Decimal_Output;
     private
        ... <-- not specified by the language>
     end Ada.Text_IO.Editing;

17
The exception Constraint_Error is raised if the Image function or any of
the Put procedures is invoked with a null string for Currency.

18
     function Valid (Pic_String      : in String;
                     Blank_When_Zero : in Boolean := False) return Boolean;

19
          Valid returns True if Pic_String is a well-formed picture
          String (see *note F.3.1::) the length of whose expansion does
          not exceed Max_Picture_Length, and if either Blank_When_Zero
          is False or Pic_String contains no '*'.

20
     function To_Picture (Pic_String      : in String;
                          Blank_When_Zero : in Boolean := False)
        return Picture;

21
          To_Picture returns a result Picture such that the application
          of the function Pic_String to this result yields an expanded
          picture String equivalent to Pic_String, and such that
          Blank_When_Zero applied to the result Picture is the same
          value as the parameter Blank_When_Zero.  Picture_Error is
          raised if not Valid(Pic_String, Blank_When_Zero).

22
     function Pic_String      (Pic : in Picture) return String;

     function Blank_When_Zero (Pic : in Picture) return Boolean;

23
          If Pic is To_Picture(String_Item, Boolean_Item) for some
          String_Item and Boolean_Item, then:

24
             * Pic_String(Pic) returns an expanded picture String
               equivalent to String_Item and with any lower-case letter
               replaced with its corresponding upper-case form, and

25
             * Blank_When_Zero(Pic) returns Boolean_Item.

26
          If Pic_1 and Pic_2 are objects of type Picture, then
          "="(Pic_1, Pic_2) is True when

27
             * Pic_String(Pic_1) = Pic_String(Pic_2), and

28
             * Blank_When_Zero(Pic_1) = Blank_When_Zero(Pic_2).

29
     function Length (Pic      : in Picture;
                      Currency : in String := Default_Currency)
        return Natural;

30
          Length returns Pic_String(Pic)'Length +
          Currency_Length_Adjustment - Radix_Adjustment where

31
             * Currency_Length_Adjustment =

32
                       * Currency'Length - 1 if there is some occurrence
                         of '$' in Pic_String(Pic), and

33
                       * 0 otherwise.

34
             * Radix_Adjustment =

35
                       * 1 if there is an occurrence of 'V' or 'v' in
                         Pic_Str(Pic), and

36
                       * 0 otherwise.

37
     function Valid (Item     : in Num;
                     Pic      : in Picture;
                     Currency : in String := Default_Currency)
        return Boolean;

38
          Valid returns True if Image(Item, Pic, Currency) does not
          raise Layout_Error, and returns False otherwise.

39
     function Image (Item       : in Num;
                     Pic        : in Picture;
                     Currency   : in String    := Default_Currency;
                     Fill       : in Character := Default_Fill;
                     Separator  : in Character := Default_Separator;
                     Radix_Mark : in Character := Default_Radix_Mark)
        return String;

40
          Image returns the edited output String as defined in *note
          F.3.2:: for Item, Pic_String(Pic), Blank_When_Zero(Pic),
          Currency, Fill, Separator, and Radix_Mark.  If these rules
          identify a layout error, then Image raises the exception
          Layout_Error.

41
     procedure Put (File       : in File_Type;
                    Item       : in Num;
                    Pic        : in Picture;
                    Currency   : in String    := Default_Currency;
                    Fill       : in Character := Default_Fill;
                    Separator  : in Character := Default_Separator;
                    Radix_Mark : in Character := Default_Radix_Mark);

     procedure Put (Item       : in Num;
                    Pic        : in Picture;
                    Currency   : in String    := Default_Currency;
                    Fill       : in Character := Default_Fill;
                    Separator  : in Character := Default_Separator;
                    Radix_Mark : in Character := Default_Radix_Mark);

42
          Each of these Put procedures outputs Image(Item, Pic,
          Currency, Fill, Separator, Radix_Mark) consistent with the
          conventions for Put for other real types in case of bounded
          line length (see *note A.10.6::, "*note A.10.6:: Get and Put
          Procedures").

43
     procedure Put (To         : out String;
                    Item       : in Num;
                    Pic        : in Picture;
                    Currency   : in String    := Default_Currency;
                    Fill       : in Character := Default_Fill;
                    Separator  : in Character := Default_Separator;
                    Radix_Mark : in Character := Default_Radix_Mark);

44/3
          Put copies Image(Item, Pic, Currency, Fill, Separator,
          Radix_Mark) to the given string, right justified.  Otherwise,
          unassigned Character values in To are assigned the space
          character.  If To'Length is less than the length of the string
          resulting from Image, then Layout_Error is raised.

                     _Implementation Requirements_

45
Max_Picture_Length shall be at least 30.  The implementation shall
support currency strings of length up to at least 10, both for
Default_Currency in an instantiation of Decimal_Output, and for Currency
in an invocation of Image or any of the Put procedures.

     NOTES

46
     4  The rules for edited output are based on COBOL (ANSI X3.23:1985,
     endorsed by ISO as ISO 1989-1985), with the following differences:

47
        * The COBOL provisions for picture string localization and for
          'P' format are absent from Ada.

48
        * The following Ada facilities are not in COBOL:

49
                  * currency symbol placement after the number,

50
                  * localization of edited output string for
                    multi-character currency string values, including
                    support for both length-preserving and
                    length-expanding currency symbols in picture strings

51
                  * localization of the radix mark, digits separator,
                    and fill character, and

52
                  * parenthesization of negative values.

52.1
     The value of 30 for Max_Picture_Length is the same limit as in
     COBOL.


File: arm2012.info,  Node: F.3.4,  Next: F.3.5,  Prev: F.3.3,  Up: F.3

F.3.4 The Package Wide_Text_IO.Editing
--------------------------------------

                          _Static Semantics_

1
The child package Wide_Text_IO.Editing has the same contents as
Text_IO.Editing, except that:

2
   * each occurrence of Character is replaced by Wide_Character,

3
   * each occurrence of Text_IO is replaced by Wide_Text_IO,

4
   * the subtype of Default_Currency is Wide_String rather than String,
     and

5
   * each occurrence of String in the generic package Decimal_Output is
     replaced by Wide_String.

     NOTES

6
     5  Each of the functions Wide_Text_IO.Editing.Valid, To_Picture,
     and Pic_String has String (versus Wide_String) as its parameter or
     result subtype, since a picture String is not localizable.


File: arm2012.info,  Node: F.3.5,  Prev: F.3.4,  Up: F.3

F.3.5 The Package Wide_Wide_Text_IO.Editing
-------------------------------------------

                          _Static Semantics_

1/2
The child package Wide_Wide_Text_IO.Editing has the same contents as
Text_IO.Editing, except that:

2/2
   * each occurrence of Character is replaced by Wide_Wide_Character,

3/2
   * each occurrence of Text_IO is replaced by Wide_Wide_Text_IO,

4/2
   * the subtype of Default_Currency is Wide_Wide_String rather than
     String, and

5/2
   * each occurrence of String in the generic package Decimal_Output is
     replaced by Wide_Wide_String.

     NOTES

6/2
     6  Each of the functions Wide_Wide_Text_IO.Editing.Valid,
     To_Picture, and Pic_String has String (versus Wide_Wide_String) as
     its parameter or result subtype, since a picture String is not
     localizable.


File: arm2012.info,  Node: Annex G,  Next: Annex H,  Prev: Annex F,  Up: Top

Annex G Numerics
****************

1
The Numerics Annex specifies

2
   * features for complex arithmetic, including complex I/O;

3
   * a mode ("strict mode"), in which the predefined arithmetic
     operations of floating point and fixed point types and the
     functions and operations of various predefined packages have to
     provide guaranteed accuracy or conform to other numeric performance
     requirements, which the Numerics Annex also specifies;

4
   * a mode ("relaxed mode"), in which no accuracy or other numeric
     performance requirements need be satisfied, as for implementations
     not conforming to the Numerics Annex;

5/2
   * models of floating point and fixed point arithmetic on which the
     accuracy requirements of strict mode are based;

6/2
   * the definitions of the model-oriented attributes of floating point
     types that apply in the strict mode; and

6.1/2
   * features for the manipulation of real and complex vectors and
     matrices.

                        _Implementation Advice_

7/3
If Fortran (respectively, C) is widely supported in the target
environment, implementations supporting the Numerics Annex should
provide the child package Interfaces.Fortran (respectively,
Interfaces.C) specified in *note Annex B:: and should support a
<convention_>identifier of Fortran (respectively, C) for the Convention
aspect (see *note Annex B::), thus allowing Ada programs to interface
with programs written in that language.

* Menu:

* G.1 ::      Complex Arithmetic
* G.2 ::      Numeric Performance Requirements
* G.3 ::      Vector and Matrix Manipulation


File: arm2012.info,  Node: G.1,  Next: G.2,  Up: Annex G

G.1 Complex Arithmetic
======================

1
Types and arithmetic operations for complex arithmetic are provided in
Generic_Complex_Types, which is defined in *note G.1.1::.
Implementation-defined approximations to the complex analogs of the
mathematical functions known as the "elementary functions" are provided
by the subprograms in Generic_Complex_Elementary_Functions, which is
defined in *note G.1.2::.  Both of these library units are generic
children of the predefined package Numerics (see *note A.5::).
Nongeneric equivalents of these generic packages for each of the
predefined floating point types are also provided as children of
Numerics.

* Menu:

* G.1.1 ::    Complex Types
* G.1.2 ::    Complex Elementary Functions
* G.1.3 ::    Complex Input-Output
* G.1.4 ::    The Package Wide_Text_IO.Complex_IO
* G.1.5 ::    The Package Wide_Wide_Text_IO.Complex_IO


File: arm2012.info,  Node: G.1.1,  Next: G.1.2,  Up: G.1

G.1.1 Complex Types
-------------------

                          _Static Semantics_

1
The generic library package Numerics.Generic_Complex_Types has the
following declaration:

2/1
     generic
        type Real is digits <>;
     package Ada.Numerics.Generic_Complex_Types is
        pragma Pure(Generic_Complex_Types);

3
        type Complex is
           record
              Re, Im : Real'Base;
           end record;

4/2
        type Imaginary is private;
        pragma Preelaborable_Initialization(Imaginary);

5
        i : constant Imaginary;
        j : constant Imaginary;

6
        function Re (X : Complex)   return Real'Base;
        function Im (X : Complex)   return Real'Base;
        function Im (X : Imaginary) return Real'Base;

7
        procedure Set_Re (X  : in out Complex;
                          Re : in     Real'Base);
        procedure Set_Im (X  : in out Complex;
                          Im : in     Real'Base);
        procedure Set_Im (X  :    out Imaginary;
                          Im : in     Real'Base);

8
        function Compose_From_Cartesian (Re, Im : Real'Base) return Complex;
        function Compose_From_Cartesian (Re     : Real'Base) return Complex;
        function Compose_From_Cartesian (Im     : Imaginary) return Complex;

9
        function Modulus (X     : Complex) return Real'Base;
        function "abs"   (Right : Complex) return Real'Base renames Modulus;

10
        function Argument (X     : Complex)   return Real'Base;
        function Argument (X     : Complex;
                           Cycle : Real'Base) return Real'Base;

11
        function Compose_From_Polar (Modulus, Argument        : Real'Base)
           return Complex;
        function Compose_From_Polar (Modulus, Argument, Cycle : Real'Base)
           return Complex;

12
        function "+"       (Right : Complex) return Complex;
        function "-"       (Right : Complex) return Complex;
        function Conjugate (X     : Complex) return Complex;

13
        function "+" (Left, Right : Complex) return Complex;
        function "-" (Left, Right : Complex) return Complex;
        function "*" (Left, Right : Complex) return Complex;
        function "/" (Left, Right : Complex) return Complex;

14
        function "**" (Left : Complex; Right : Integer) return Complex;

15
        function "+"       (Right : Imaginary) return Imaginary;
        function "-"       (Right : Imaginary) return Imaginary;
        function Conjugate (X     : Imaginary) return Imaginary renames "-";
        function "abs"     (Right : Imaginary) return Real'Base;

16
        function "+" (Left, Right : Imaginary) return Imaginary;
        function "-" (Left, Right : Imaginary) return Imaginary;
        function "*" (Left, Right : Imaginary) return Real'Base;
        function "/" (Left, Right : Imaginary) return Real'Base;

17
        function "**" (Left : Imaginary; Right : Integer) return Complex;

18
        function "<"  (Left, Right : Imaginary) return Boolean;
        function "<=" (Left, Right : Imaginary) return Boolean;
        function ">"  (Left, Right : Imaginary) return Boolean;
        function ">=" (Left, Right : Imaginary) return Boolean;

19
        function "+" (Left : Complex;   Right : Real'Base) return Complex;
        function "+" (Left : Real'Base; Right : Complex)   return Complex;
        function "-" (Left : Complex;   Right : Real'Base) return Complex;
        function "-" (Left : Real'Base; Right : Complex)   return Complex;
        function "*" (Left : Complex;   Right : Real'Base) return Complex;
        function "*" (Left : Real'Base; Right : Complex)   return Complex;
        function "/" (Left : Complex;   Right : Real'Base) return Complex;
        function "/" (Left : Real'Base; Right : Complex)   return Complex;

20
        function "+" (Left : Complex;   Right : Imaginary) return Complex;
        function "+" (Left : Imaginary; Right : Complex)   return Complex;
        function "-" (Left : Complex;   Right : Imaginary) return Complex;
        function "-" (Left : Imaginary; Right : Complex)   return Complex;
        function "*" (Left : Complex;   Right : Imaginary) return Complex;
        function "*" (Left : Imaginary; Right : Complex)   return Complex;
        function "/" (Left : Complex;   Right : Imaginary) return Complex;
        function "/" (Left : Imaginary; Right : Complex)   return Complex;

21
        function "+" (Left : Imaginary; Right : Real'Base) return Complex;
        function "+" (Left : Real'Base; Right : Imaginary) return Complex;
        function "-" (Left : Imaginary; Right : Real'Base) return Complex;
        function "-" (Left : Real'Base; Right : Imaginary) return Complex;
        function "*" (Left : Imaginary; Right : Real'Base) return Imaginary;
        function "*" (Left : Real'Base; Right : Imaginary) return Imaginary;
        function "/" (Left : Imaginary; Right : Real'Base) return Imaginary;
        function "/" (Left : Real'Base; Right : Imaginary) return Imaginary;

22
     private

23
        type Imaginary is new Real'Base;
        i : constant Imaginary := 1.0;
        j : constant Imaginary := 1.0;

24
     end Ada.Numerics.Generic_Complex_Types;

25/1
The library package Numerics.Complex_Types is declared pure and defines
the same types, constants, and subprograms as
Numerics.Generic_Complex_Types, except that the predefined type Float is
systematically substituted for Real'Base throughout.  Nongeneric
equivalents of Numerics.Generic_Complex_Types for each of the other
predefined floating point types are defined similarly, with the names
Numerics.Short_Complex_Types, Numerics.Long_Complex_Types, etc.

26/2
Complex is a visible type with Cartesian components.

27
Imaginary is a private type; its full type is derived from Real'Base.

28
The arithmetic operations and the Re, Im, Modulus, Argument, and
Conjugate functions have their usual mathematical meanings.  When
applied to a parameter of pure-imaginary type, the "imaginary-part"
function Im yields the value of its parameter, as the corresponding real
value.  The remaining subprograms have the following meanings:

29
   * The Set_Re and Set_Im procedures replace the designated component
     of a complex parameter with the given real value; applied to a
     parameter of pure-imaginary type, the Set_Im procedure replaces the
     value of that parameter with the imaginary value corresponding to
     the given real value.

30
   * The Compose_From_Cartesian function constructs a complex value from
     the given real and imaginary components.  If only one component is
     given, the other component is implicitly zero.

31
   * The Compose_From_Polar function constructs a complex value from the
     given modulus (radius) and argument (angle).  When the value of the
     parameter Modulus is positive (resp., negative), the result is the
     complex value represented by the point in the complex plane lying
     at a distance from the origin given by the absolute value of
     Modulus and forming an angle measured counterclockwise from the
     positive (resp., negative) real axis given by the value of the
     parameter Argument.

32
When the Cycle parameter is specified, the result of the Argument
function and the parameter Argument of the Compose_From_Polar function
are measured in units such that a full cycle of revolution has the given
value; otherwise, they are measured in radians.

33
The computed results of the mathematically multivalued functions are
rendered single-valued by the following conventions, which are meant to
imply the principal branch:

34
   * The result of the Modulus function is nonnegative.

35
   * The result of the Argument function is in the quadrant containing
     the point in the complex plane represented by the parameter X. This
     may be any quadrant (I through IV); thus, the range of the Argument
     function is approximately -PI to PI (-Cycle/2.0 to Cycle/2.0, if
     the parameter Cycle is specified).  When the point represented by
     the parameter X lies on the negative real axis, the result
     approximates

36
             * PI (resp., -PI) when the sign of the imaginary component
               of X is positive (resp., negative), if Real'Signed_Zeros
               is True;

37
             * PI, if Real'Signed_Zeros is False.

38
   * Because a result lying on or near one of the axes may not be
     exactly representable, the approximation inherent in computing the
     result may place it in an adjacent quadrant, close to but on the
     wrong side of the axis.

                          _Dynamic Semantics_

39
The exception Numerics.Argument_Error is raised by the Argument and
Compose_From_Polar functions with specified cycle, signaling a parameter
value outside the domain of the corresponding mathematical function,
when the value of the parameter Cycle is zero or negative.

40
The exception Constraint_Error is raised by the division operator when
the value of the right operand is zero, and by the exponentiation
operator when the value of the left operand is zero and the value of the
exponent is negative, provided that Real'Machine_Overflows is True; when
Real'Machine_Overflows is False, the result is unspecified.
Constraint_Error can also be raised when a finite result overflows (see
*note G.2.6::).

                     _Implementation Requirements_

41
In the implementation of Numerics.Generic_Complex_Types, the range of
intermediate values allowed during the calculation of a final result
shall not be affected by any range constraint of the subtype Real.

42
In the following cases, evaluation of a complex arithmetic operation
shall yield the <prescribed result>, provided that the preceding rules
do not call for an exception to be raised:

43
   * The results of the Re, Im, and Compose_From_Cartesian functions are
     exact.

44
   * The real (resp., imaginary) component of the result of a binary
     addition operator that yields a result of complex type is exact
     when either of its operands is of pure-imaginary (resp., real)
     type.

45
   * The real (resp., imaginary) component of the result of a binary
     subtraction operator that yields a result of complex type is exact
     when its right operand is of pure-imaginary (resp., real) type.

46
   * The real component of the result of the Conjugate function for the
     complex type is exact.

47
   * When the point in the complex plane represented by the parameter X
     lies on the nonnegative real axis, the Argument function yields a
     result of zero.

48
   * When the value of the parameter Modulus is zero, the
     Compose_From_Polar function yields a result of zero.

49
   * When the value of the parameter Argument is equal to a multiple of
     the quarter cycle, the result of the Compose_From_Polar function
     with specified cycle lies on one of the axes.  In this case, one of
     its components is zero, and the other has the magnitude of the
     parameter Modulus.

50
   * Exponentiation by a zero exponent yields the value one.
     Exponentiation by a unit exponent yields the value of the left
     operand.  Exponentiation of the value one yields the value one.
     Exponentiation of the value zero yields the value zero, provided
     that the exponent is nonzero.  When the left operand is of
     pure-imaginary type, one component of the result of the
     exponentiation operator is zero.

51
When the result, or a result component, of any operator of
Numerics.Generic_Complex_Types has a mathematical definition in terms of
a single arithmetic or relational operation, that result or result
component exhibits the accuracy of the corresponding operation of the
type Real.

52
Other accuracy requirements for the Modulus, Argument, and
Compose_From_Polar functions, and accuracy requirements for the
multiplication of a pair of complex operands or for division by a
complex operand, all of which apply only in the strict mode, are given
in *note G.2.6::.

53
The sign of a zero result or zero result component yielded by a complex
arithmetic operation or function is implementation defined when
Real'Signed_Zeros is True.

                     _Implementation Permissions_

54
The nongeneric equivalent packages may, but need not, be actual
instantiations of the generic package for the appropriate predefined
type.

55/2
Implementations may obtain the result of exponentiation of a complex or
pure-imaginary operand by repeated complex multiplication, with
arbitrary association of the factors and with a possible final complex
reciprocation (when the exponent is negative).  Implementations are also
permitted to obtain the result of exponentiation of a complex operand,
but not of a pure-imaginary operand, by converting the left operand to a
polar representation; exponentiating the modulus by the given exponent;
multiplying the argument by the given exponent; and reconverting to a
Cartesian representation.  Because of this implementation freedom, no
accuracy requirement is imposed on complex exponentiation (except for
the prescribed results given above, which apply regardless of the
implementation method chosen).

                        _Implementation Advice_

56
Because the usual mathematical meaning of multiplication of a complex
operand and a real operand is that of the scaling of both components of
the former by the latter, an implementation should not perform this
operation by first promoting the real operand to complex type and then
performing a full complex multiplication.  In systems that, in the
future, support an Ada binding to IEC 559:1989, the latter technique
will not generate the required result when one of the components of the
complex operand is infinite.  (Explicit multiplication of the infinite
component by the zero component obtained during promotion yields a NaN
that propagates into the final result.)  Analogous advice applies in the
case of multiplication of a complex operand and a pure-imaginary
operand, and in the case of division of a complex operand by a real or
pure-imaginary operand.

57
Likewise, because the usual mathematical meaning of addition of a
complex operand and a real operand is that the imaginary operand remains
unchanged, an implementation should not perform this operation by first
promoting the real operand to complex type and then performing a full
complex addition.  In implementations in which the Signed_Zeros
attribute of the component type is True (and which therefore conform to
IEC 559:1989 in regard to the handling of the sign of zero in predefined
arithmetic operations), the latter technique will not generate the
required result when the imaginary component of the complex operand is a
negatively signed zero.  (Explicit addition of the negative zero to the
zero obtained during promotion yields a positive zero.)  Analogous
advice applies in the case of addition of a complex operand and a
pure-imaginary operand, and in the case of subtraction of a complex
operand and a real or pure-imaginary operand.

58
Implementations in which Real'Signed_Zeros is True should attempt to
provide a rational treatment of the signs of zero results and result
components.  As one example, the result of the Argument function should
have the sign of the imaginary component of the parameter X when the
point represented by that parameter lies on the positive real axis; as
another, the sign of the imaginary component of the Compose_From_Polar
function should be the same as (resp., the opposite of) that of the
Argument parameter when that parameter has a value of zero and the
Modulus parameter has a nonnegative (resp., negative) value.


File: arm2012.info,  Node: G.1.2,  Next: G.1.3,  Prev: G.1.1,  Up: G.1

G.1.2 Complex Elementary Functions
----------------------------------

                          _Static Semantics_

1
The generic library package
Numerics.Generic_Complex_Elementary_Functions has the following
declaration:

2/2
     with Ada.Numerics.Generic_Complex_Types;
     generic
        with package Complex_Types is
              new Ada.Numerics.Generic_Complex_Types (<>);
        use Complex_Types;
     package Ada.Numerics.Generic_Complex_Elementary_Functions is
        pragma Pure(Generic_Complex_Elementary_Functions);

3
        function Sqrt (X : Complex)   return Complex;
        function Log  (X : Complex)   return Complex;
        function Exp  (X : Complex)   return Complex;
        function Exp  (X : Imaginary) return Complex;
        function "**" (Left : Complex;   Right : Complex)   return Complex;
        function "**" (Left : Complex;   Right : Real'Base) return Complex;
        function "**" (Left : Real'Base; Right : Complex)   return Complex;

4
        function Sin (X : Complex) return Complex;
        function Cos (X : Complex) return Complex;
        function Tan (X : Complex) return Complex;
        function Cot (X : Complex) return Complex;

5
        function Arcsin (X : Complex) return Complex;
        function Arccos (X : Complex) return Complex;
        function Arctan (X : Complex) return Complex;
        function Arccot (X : Complex) return Complex;

6
        function Sinh (X : Complex) return Complex;
        function Cosh (X : Complex) return Complex;
        function Tanh (X : Complex) return Complex;
        function Coth (X : Complex) return Complex;

7
        function Arcsinh (X : Complex) return Complex;
        function Arccosh (X : Complex) return Complex;
        function Arctanh (X : Complex) return Complex;
        function Arccoth (X : Complex) return Complex;

8
     end Ada.Numerics.Generic_Complex_Elementary_Functions;

9/1
The library package Numerics.Complex_Elementary_Functions is declared
pure and defines the same subprograms as
Numerics.Generic_Complex_Elementary_Functions, except that the
predefined type Float is systematically substituted for Real'Base, and
the Complex and Imaginary types exported by Numerics.Complex_Types are
systematically substituted for Complex and Imaginary, throughout.
Nongeneric equivalents of Numerics.Generic_Complex_Elementary_Functions
corresponding to each of the other predefined floating point types are
defined similarly, with the names
Numerics.Short_Complex_Elementary_Functions,
Numerics.Long_Complex_Elementary_Functions, etc.

10
The overloading of the Exp function for the pure-imaginary type is
provided to give the user an alternate way to compose a complex value
from a given modulus and argument.  In addition to
Compose_From_Polar(Rho, Theta) (see *note G.1.1::), the programmer may
write Rho * Exp(i * Theta).

11
The imaginary (resp., real) component of the parameter X of the forward
hyperbolic (resp., trigonometric) functions and of the Exp function (and
the parameter X, itself, in the case of the overloading of the Exp
function for the pure-imaginary type) represents an angle measured in
radians, as does the imaginary (resp., real) component of the result of
the Log and inverse hyperbolic (resp., trigonometric) functions.

12
The functions have their usual mathematical meanings.  However, the
arbitrariness inherent in the placement of branch cuts, across which
some of the complex elementary functions exhibit discontinuities, is
eliminated by the following conventions:

13
   * The imaginary component of the result of the Sqrt and Log functions
     is discontinuous as the parameter X crosses the negative real axis.

14
   * The result of the exponentiation operator when the left operand is
     of complex type is discontinuous as that operand crosses the
     negative real axis.

15/2
   * The imaginary component of the result of the Arcsin, Arccos, and
     Arctanh functions is discontinuous as the parameter X crosses the
     real axis to the left of -1.0 or the right of 1.0.

16/2
   * The real component of the result of the Arctan and Arcsinh
     functions is discontinuous as the parameter X crosses the imaginary
     axis below -<i> or above <i>.

17/2
   * The real component of the result of the Arccot function is
     discontinuous as the parameter X crosses the imaginary axis below
     -<i> or above <i>.

18
   * The imaginary component of the Arccosh function is discontinuous as
     the parameter X crosses the real axis to the left of 1.0.

19
   * The imaginary component of the result of the Arccoth function is
     discontinuous as the parameter X crosses the real axis between -1.0
     and 1.0.

20/2
The computed results of the mathematically multivalued functions are
rendered single-valued by the following conventions, which are meant to
imply that the principal branch is an analytic continuation of the
corresponding real-valued function in
Numerics.Generic_Elementary_Functions.  (For Arctan and Arccot, the
single-argument function in question is that obtained from the
two-argument version by fixing the second argument to be its default
value.)

21
   * The real component of the result of the Sqrt and Arccosh functions
     is nonnegative.

22
   * The same convention applies to the imaginary component of the
     result of the Log function as applies to the result of the
     natural-cycle version of the Argument function of
     Numerics.Generic_Complex_Types (see *note G.1.1::).

23
   * The range of the real (resp., imaginary) component of the result of
     the Arcsin and Arctan (resp., Arcsinh and Arctanh) functions is
     approximately -PI/2.0 to PI/2.0.

24
   * The real (resp., imaginary) component of the result of the Arccos
     and Arccot (resp., Arccoth) functions ranges from 0.0 to
     approximately PI.

25
   * The range of the imaginary component of the result of the Arccosh
     function is approximately -PI to PI.

26
In addition, the exponentiation operator inherits the single-valuedness
of the Log function.

                          _Dynamic Semantics_

27
The exception Numerics.Argument_Error is raised by the exponentiation
operator, signaling a parameter value outside the domain of the
corresponding mathematical function, when the value of the left operand
is zero and the real component of the exponent (or the exponent itself,
when it is of real type) is zero.

28
The exception Constraint_Error is raised, signaling a pole of the
mathematical function (analogous to dividing by zero), in the following
cases, provided that Complex_Types.Real'Machine_Overflows is True:

29
   * by the Log, Cot, and Coth functions, when the value of the
     parameter X is zero;

30
   * by the exponentiation operator, when the value of the left operand
     is zero and the real component of the exponent (or the exponent
     itself, when it is of real type) is negative;

31
   * by the Arctan and Arccot functions, when the value of the parameter
     X is ± <i>;

32
   * by the Arctanh and Arccoth functions, when the value of the
     parameter X is ± 1.0.

33
Constraint_Error can also be raised when a finite result overflows (see
*note G.2.6::); this may occur for parameter values sufficiently <near>
poles, and, in the case of some of the functions, for parameter values
having components of sufficiently large magnitude.  When
Complex_Types.Real'Machine_Overflows is False, the result at poles is
unspecified.

                     _Implementation Requirements_

34
In the implementation of Numerics.Generic_Complex_Elementary_Functions,
the range of intermediate values allowed during the calculation of a
final result shall not be affected by any range constraint of the
subtype Complex_Types.Real.

35
In the following cases, evaluation of a complex elementary function
shall yield the <prescribed result> (or a result having the prescribed
component), provided that the preceding rules do not call for an
exception to be raised:

36
   * When the parameter X has the value zero, the Sqrt, Sin, Arcsin,
     Tan, Arctan, Sinh, Arcsinh, Tanh, and Arctanh functions yield a
     result of zero; the Exp, Cos, and Cosh functions yield a result of
     one; the Arccos and Arccot functions yield a real result; and the
     Arccoth function yields an imaginary result.

37
   * When the parameter X has the value one, the Sqrt function yields a
     result of one; the Log, Arccos, and Arccosh functions yield a
     result of zero; and the Arcsin function yields a real result.

38
   * When the parameter X has the value -1.0, the Sqrt function yields
     the result

39
             * <i> (resp., -<i>), when the sign of the imaginary
               component of X is positive (resp., negative), if
               Complex_Types.Real'Signed_Zeros is True;

40
             * <i>, if Complex_Types.Real'Signed_Zeros is False;

41/2
   * When the parameter X has the value -1.0, the Log function yields an
     imaginary result; and the Arcsin and Arccos functions yield a real
     result.

42
   * When the parameter X has the value ± <i>, the Log function yields
     an imaginary result.

43
   * Exponentiation by a zero exponent yields the value one.
     Exponentiation by a unit exponent yields the value of the left
     operand (as a complex value).  Exponentiation of the value one
     yields the value one.  Exponentiation of the value zero yields the
     value zero.

44
Other accuracy requirements for the complex elementary functions, which
apply only in the strict mode, are given in *note G.2.6::.

45
The sign of a zero result or zero result component yielded by a complex
elementary function is implementation defined when
Complex_Types.Real'Signed_Zeros is True.

                     _Implementation Permissions_

46
The nongeneric equivalent packages may, but need not, be actual
instantiations of the generic package with the appropriate predefined
nongeneric equivalent of Numerics.Generic_Complex_Types; if they are,
then the latter shall have been obtained by actual instantiation of
Numerics.Generic_Complex_Types.

47
The exponentiation operator may be implemented in terms of the Exp and
Log functions.  Because this implementation yields poor accuracy in some
parts of the domain, no accuracy requirement is imposed on complex
exponentiation.

48
The implementation of the Exp function of a complex parameter X is
allowed to raise the exception Constraint_Error, signaling overflow,
when the real component of X exceeds an unspecified threshold that is
approximately log(Complex_Types.Real'Safe_Last).  This permission
recognizes the impracticality of avoiding overflow in the marginal case
that the exponential of the real component of X exceeds the safe range
of Complex_Types.Real but both components of the final result do not.
Similarly, the Sin and Cos (resp., Sinh and Cosh) functions are allowed
to raise the exception Constraint_Error, signaling overflow, when the
absolute value of the imaginary (resp., real) component of the parameter
X exceeds an unspecified threshold that is approximately
log(Complex_Types.Real'Safe_Last) + log(2.0).  This permission
recognizes the impracticality of avoiding overflow in the marginal case
that the hyperbolic sine or cosine of the imaginary (resp., real)
component of X exceeds the safe range of Complex_Types.Real but both
components of the final result do not.

                        _Implementation Advice_

49
Implementations in which Complex_Types.Real'Signed_Zeros is True should
attempt to provide a rational treatment of the signs of zero results and
result components.  For example, many of the complex elementary
functions have components that are odd functions of one of the parameter
components; in these cases, the result component should have the sign of
the parameter component at the origin.  Other complex elementary
functions have zero components whose sign is opposite that of a
parameter component at the origin, or is always positive or always
negative.


File: arm2012.info,  Node: G.1.3,  Next: G.1.4,  Prev: G.1.2,  Up: G.1

G.1.3 Complex Input-Output
--------------------------

1
The generic package Text_IO.Complex_IO defines procedures for the
formatted input and output of complex values.  The generic actual
parameter in an instantiation of Text_IO.Complex_IO is an instance of
Numerics.Generic_Complex_Types for some floating point subtype.
Exceptional conditions are reported by raising the appropriate exception
defined in Text_IO.

                          _Static Semantics_

2
The generic library package Text_IO.Complex_IO has the following
declaration:

3
     with Ada.Numerics.Generic_Complex_Types;
     generic
        with package Complex_Types is
              new Ada.Numerics.Generic_Complex_Types (<>);
     package Ada.Text_IO.Complex_IO is

4
        use Complex_Types;

5
        Default_Fore : Field := 2;
        Default_Aft  : Field := Real'Digits - 1;
        Default_Exp  : Field := 3;

6
        procedure Get (File  : in  File_Type;
                       Item  : out Complex;
                       Width : in  Field := 0);
        procedure Get (Item  : out Complex;
                       Width : in  Field := 0);

7
        procedure Put (File : in File_Type;
                       Item : in Complex;
                       Fore : in Field := Default_Fore;
                       Aft  : in Field := Default_Aft;
                       Exp  : in Field := Default_Exp);
        procedure Put (Item : in Complex;
                       Fore : in Field := Default_Fore;
                       Aft  : in Field := Default_Aft;
                       Exp  : in Field := Default_Exp);

8
        procedure Get (From : in  String;
                       Item : out Complex;
                       Last : out Positive);
        procedure Put (To   : out String;
                       Item : in  Complex;
                       Aft  : in  Field := Default_Aft;
                       Exp  : in  Field := Default_Exp);

9
     end Ada.Text_IO.Complex_IO;

9.1/2
The library package Complex_Text_IO defines the same subprograms as
Text_IO.Complex_IO, except that the predefined type Float is
systematically substituted for Real, and the type
Numerics.Complex_Types.Complex is systematically substituted for Complex
throughout.  Nongeneric equivalents of Text_IO.Complex_IO corresponding
to each of the other predefined floating point types are defined
similarly, with the names Short_Complex_Text_IO, Long_Complex_Text_IO,
etc.

10
The semantics of the Get and Put procedures are as follows:

11
     procedure Get (File  : in  File_Type;
                    Item  : out Complex;
                    Width : in  Field := 0);
     procedure Get (Item  : out Complex;
                    Width : in  Field := 0);

12/1
          The input sequence is a pair of optionally signed real
          literals representing the real and imaginary components of a
          complex value.  These components have the format defined for
          the corresponding Get procedure of an instance of
          Text_IO.Float_IO (see *note A.10.9::) for the base subtype of
          Complex_Types.Real.  The pair of components may be separated
          by a comma or surrounded by a pair of parentheses or both.
          Blanks are freely allowed before each of the components and
          before the parentheses and comma, if either is used.  If the
          value of the parameter Width is zero, then

13
             * line and page terminators are also allowed in these
               places;

14
             * the components shall be separated by at least one blank
               or line terminator if the comma is omitted; and

15
             * reading stops when the right parenthesis has been read,
               if the input sequence includes a left parenthesis, or
               when the imaginary component has been read, otherwise.

15.1
          If a nonzero value of Width is supplied, then

16
             * the components shall be separated by at least one blank
               if the comma is omitted; and

17
             * exactly Width characters are read, or the characters
               (possibly none) up to a line terminator, whichever comes
               first (blanks are included in the count).

18
          Returns, in the parameter Item, the value of type Complex that
          corresponds to the input sequence.

19
          The exception Text_IO.Data_Error is raised if the input
          sequence does not have the required syntax or if the
          components of the complex value obtained are not of the base
          subtype of Complex_Types.Real.

20
     procedure Put (File : in File_Type;
                    Item : in Complex;
                    Fore : in Field := Default_Fore;
                    Aft  : in Field := Default_Aft;
                    Exp  : in Field := Default_Exp);
     procedure Put (Item : in Complex;
                    Fore : in Field := Default_Fore;
                    Aft  : in Field := Default_Aft;
                    Exp  : in Field := Default_Exp);

21
          Outputs the value of the parameter Item as a pair of decimal
          literals representing the real and imaginary components of the
          complex value, using the syntax of an aggregate.  More
          specifically,

22
             * outputs a left parenthesis;

23
             * outputs the value of the real component of the parameter
               Item with the format defined by the corresponding Put
               procedure of an instance of Text_IO.Float_IO for the base
               subtype of Complex_Types.Real, using the given values of
               Fore, Aft, and Exp;

24
             * outputs a comma;

25
             * outputs the value of the imaginary component of the
               parameter Item with the format defined by the
               corresponding Put procedure of an instance of
               Text_IO.Float_IO for the base subtype of
               Complex_Types.Real, using the given values of Fore, Aft,
               and Exp;

26
             * outputs a right parenthesis.

27
     procedure Get (From : in  String;
                    Item : out Complex;
                    Last : out Positive);

28/2
          Reads a complex value from the beginning of the given string,
          following the same rule as the Get procedure that reads a
          complex value from a file, but treating the end of the string
          as a file terminator.  Returns, in the parameter Item, the
          value of type Complex that corresponds to the input sequence.
          Returns in Last the index value such that From(Last) is the
          last character read.

29
          The exception Text_IO.Data_Error is raised if the input
          sequence does not have the required syntax or if the
          components of the complex value obtained are not of the base
          subtype of Complex_Types.Real.

30
     procedure Put (To   : out String;
                    Item : in  Complex;
                    Aft  : in  Field := Default_Aft;
                    Exp  : in  Field := Default_Exp);

31
          Outputs the value of the parameter Item to the given string as
          a pair of decimal literals representing the real and imaginary
          components of the complex value, using the syntax of an
          aggregate.  More specifically,

32
             * a left parenthesis, the real component, and a comma are
               left justified in the given string, with the real
               component having the format defined by the Put procedure
               (for output to a file) of an instance of Text_IO.Float_IO
               for the base subtype of Complex_Types.Real, using a value
               of zero for Fore and the given values of Aft and Exp;

33
             * the imaginary component and a right parenthesis are right
               justified in the given string, with the imaginary
               component having the format defined by the Put procedure
               (for output to a file) of an instance of Text_IO.Float_IO
               for the base subtype of Complex_Types.Real, using a value
               for Fore that completely fills the remainder of the
               string, together with the given values of Aft and Exp.

34
          The exception Text_IO.Layout_Error is raised if the given
          string is too short to hold the formatted output.

                     _Implementation Permissions_

35
Other exceptions declared (by renaming) in Text_IO may be raised by the
preceding procedures in the appropriate circumstances, as for the
corresponding procedures of Text_IO.Float_IO.


File: arm2012.info,  Node: G.1.4,  Next: G.1.5,  Prev: G.1.3,  Up: G.1

G.1.4 The Package Wide_Text_IO.Complex_IO
-----------------------------------------

                          _Static Semantics_

1
Implementations shall also provide the generic library package
Wide_Text_IO.Complex_IO. Its declaration is obtained from that of
Text_IO.Complex_IO by systematically replacing Text_IO by Wide_Text_IO
and String by Wide_String; the description of its behavior is obtained
by additionally replacing references to particular characters (commas,
parentheses, etc.)  by those for the corresponding wide characters.


File: arm2012.info,  Node: G.1.5,  Prev: G.1.4,  Up: G.1

G.1.5 The Package Wide_Wide_Text_IO.Complex_IO
----------------------------------------------

                          _Static Semantics_

1/2
Implementations shall also provide the generic library package
Wide_Wide_Text_IO.Complex_IO. Its declaration is obtained from that of
Text_IO.Complex_IO by systematically replacing Text_IO by
Wide_Wide_Text_IO and String by Wide_Wide_String; the description of its
behavior is obtained by additionally replacing references to particular
characters (commas, parentheses, etc.)  by those for the corresponding
wide wide characters.


File: arm2012.info,  Node: G.2,  Next: G.3,  Prev: G.1,  Up: Annex G

G.2 Numeric Performance Requirements
====================================

                     _Implementation Requirements_

1
Implementations shall provide a user-selectable mode in which the
accuracy and other numeric performance requirements detailed in the
following subclauses are observed.  This mode, referred to as the
<strict mode>, may or may not be the default mode; it directly affects
the results of the predefined arithmetic operations of real types and
the results of the subprograms in children of the Numerics package, and
indirectly affects the operations in other language defined packages.
Implementations shall also provide the opposing mode, which is known as
the <relaxed mode>.

                     _Implementation Permissions_

2
Either mode may be the default mode.

3
The two modes need not actually be different.

* Menu:

* G.2.1 ::    Model of Floating Point Arithmetic
* G.2.2 ::    Model-Oriented Attributes of Floating Point Types
* G.2.3 ::    Model of Fixed Point Arithmetic
* G.2.4 ::    Accuracy Requirements for the Elementary Functions
* G.2.5 ::    Performance Requirements for Random Number Generation
* G.2.6 ::    Accuracy Requirements for Complex Arithmetic


File: arm2012.info,  Node: G.2.1,  Next: G.2.2,  Up: G.2

G.2.1 Model of Floating Point Arithmetic
----------------------------------------

1
In the strict mode, the predefined operations of a floating point type
shall satisfy the accuracy requirements specified here and shall avoid
or signal overflow in the situations described.  This behavior is
presented in terms of a model of floating point arithmetic that builds
on the concept of the canonical form (see *note A.5.3::).

                          _Static Semantics_

2
Associated with each floating point type is an infinite set of model
numbers.  The model numbers of a type are used to define the accuracy
requirements that have to be satisfied by certain predefined operations
of the type; through certain attributes of the model numbers, they are
also used to explain the meaning of a user-declared floating point type
declaration.  The model numbers of a derived type are those of the
parent type; the model numbers of a subtype are those of its type.

3
The <model numbers> of a floating point type T are zero and all the
values expressible in the canonical form (for the type T), in which
<mantissa> has T'Model_Mantissa digits and <exponent> has a value
greater than or equal to T'Model_Emin.  (These attributes are defined in
*note G.2.2::.)

4
A <model interval> of a floating point type is any interval whose bounds
are model numbers of the type.  The <model interval> of a type T
<associated with a value> <v> is the smallest model interval of T that
includes <v>.  (The model interval associated with a model number of a
type consists of that number only.)

                     _Implementation Requirements_

5
The accuracy requirements for the evaluation of certain predefined
operations of floating point types are as follows.

6
An <operand interval> is the model interval, of the type specified for
the operand of an operation, associated with the value of the operand.

7
For any predefined arithmetic operation that yields a result of a
floating point type T, the required bounds on the result are given by a
model interval of T (called the <result interval>) defined in terms of
the operand values as follows:

8
   * The result interval is the smallest model interval of T that
     includes the minimum and the maximum of all the values obtained by
     applying the (exact) mathematical operation to values arbitrarily
     selected from the respective operand intervals.

9
The result interval of an exponentiation is obtained by applying the
above rule to the sequence of multiplications defined by the exponent,
assuming arbitrary association of the factors, and to the final division
in the case of a negative exponent.

10
The result interval of a conversion of a numeric value to a floating
point type T is the model interval of T associated with the operand
value, except when the source expression is of a fixed point type with a
<small> that is not a power of T'Machine_Radix or is a fixed point
multiplication or division either of whose operands has a <small> that
is not a power of T'Machine_Radix; in these cases, the result interval
is implementation defined.

11
For any of the foregoing operations, the implementation shall deliver a
value that belongs to the result interval when both bounds of the result
interval are in the safe range of the result type T, as determined by
the values of T'Safe_First and T'Safe_Last; otherwise,

12
   * if T'Machine_Overflows is True, the implementation shall either
     deliver a value that belongs to the result interval or raise
     Constraint_Error;

13
   * if T'Machine_Overflows is False, the result is implementation
     defined.

14
For any predefined relation on operands of a floating point type T, the
implementation may deliver any value (i.e., either True or False)
obtained by applying the (exact) mathematical comparison to values
arbitrarily chosen from the respective operand intervals.

15
The result of a membership test is defined in terms of comparisons of
the operand value with the lower and upper bounds of the given range or
type mark (the usual rules apply to these comparisons).

                     _Implementation Permissions_

16
If the underlying floating point hardware implements division as
multiplication by a reciprocal, the result interval for division (and
exponentiation by a negative exponent) is implementation defined.


File: arm2012.info,  Node: G.2.2,  Next: G.2.3,  Prev: G.2.1,  Up: G.2

G.2.2 Model-Oriented Attributes of Floating Point Types
-------------------------------------------------------

1
In implementations that support the Numerics Annex, the model-oriented
attributes of floating point types shall yield the values defined here,
in both the strict and the relaxed modes.  These definitions add
conditions to those in *note A.5.3::.

                          _Static Semantics_

2
For every subtype S of a floating point type <T>:

3/2
S'Model_Mantissa
               Yields the number of digits in the mantissa of the
               canonical form of the model numbers of <T> (see *note
               A.5.3::).  The value of this attribute shall be greater
               than or equal to

3.1/2
                    'ceiling(<d> · log(10) / log(<T>'Machine_Radix))' + <g>

3.2/2
               where <d> is the requested decimal precision of <T>, and
               <g> is 0 if <T>'Machine_Radix is a positive power of 10
               and 1 otherwise.  In addition, <T>'Model_Mantissa shall
               be less than or equal to the value of
               <T>'Machine_Mantissa.  This attribute yields a value of
               the type <universal_integer>.

4
S'Model_Emin
               Yields the minimum exponent of the canonical form of the
               model numbers of <T> (see *note A.5.3::).  The value of
               this attribute shall be greater than or equal to the
               value of <T>'Machine_Emin.  This attribute yields a value
               of the type <universal_integer>.

5
S'Safe_First
               Yields the lower bound of the safe range of <T>.  The
               value of this attribute shall be a model number of <T>
               and greater than or equal to the lower bound of the base
               range of <T>.  In addition, if <T> is declared by a
               floating_point_definition or is derived from such a type,
               and the floating_point_definition includes a
               real_range_specification specifying a lower bound of
               <lb>, then the value of this attribute shall be less than
               or equal to <lb>; otherwise, it shall be less than or
               equal to -10.0 4 · <d>, where <d> is the requested
               decimal precision of <T>.  This attribute yields a value
               of the type <universal_real>.

6
S'Safe_Last
               Yields the upper bound of the safe range of <T>.  The
               value of this attribute shall be a model number of <T>
               and less than or equal to the upper bound of the base
               range of <T>.  In addition, if <T> is declared by a
               floating_point_definition or is derived from such a type,
               and the floating_point_definition includes a
               real_range_specification specifying an upper bound of
               <ub>, then the value of this attribute shall be greater
               than or equal to <ub>; otherwise, it shall be greater
               than or equal to 10.0 4 · <d>, where d is the requested
               decimal precision of <T>.  This attribute yields a value
               of the type <universal_real>.

7
S'Model
               Denotes a function (of a parameter <X>) whose
               specification is given in *note A.5.3::.  If <X> is a
               model number of <T>, the function yields <X>; otherwise,
               it yields the value obtained by rounding or truncating
               <X> to either one of the adjacent model numbers of <T>.  
               Constraint_Error is raised if the resulting model number
               is outside the safe range of S. A zero result has the
               sign of <X> when S'Signed_Zeros is True.

8
Subject to the constraints given above, the values of S'Model_Mantissa
and S'Safe_Last are to be maximized, and the values of S'Model_Emin and
S'Safe_First minimized, by the implementation as follows:

9
   * First, S'Model_Mantissa is set to the largest value for which
     values of S'Model_Emin, S'Safe_First, and S'Safe_Last can be chosen
     so that the implementation satisfies the strict-mode requirements
     of *note G.2.1:: in terms of the model numbers and safe range
     induced by these attributes.

10
   * Next, S'Model_Emin is set to the smallest value for which values of
     S'Safe_First and S'Safe_Last can be chosen so that the
     implementation satisfies the strict-mode requirements of *note
     G.2.1:: in terms of the model numbers and safe range induced by
     these attributes and the previously determined value of
     S'Model_Mantissa.

11/3
   * Finally, S'Safe_First and S'Safe_Last are set (in either order) to
     the smallest and largest values, respectively, for which the
     implementation satisfies the strict-mode requirements of *note
     G.2.1:: in terms of the model numbers and safe range induced by
     these attributes and the previously determined values of
     S'Model_Mantissa and S'Model_Emin.


File: arm2012.info,  Node: G.2.3,  Next: G.2.4,  Prev: G.2.2,  Up: G.2

G.2.3 Model of Fixed Point Arithmetic
-------------------------------------

1
In the strict mode, the predefined arithmetic operations of a fixed
point type shall satisfy the accuracy requirements specified here and
shall avoid or signal overflow in the situations described.

                     _Implementation Requirements_

2
The accuracy requirements for the predefined fixed point arithmetic
operations and conversions, and the results of relations on fixed point
operands, are given below.

3
The operands of the fixed point adding operators, absolute value, and
comparisons have the same type.  These operations are required to yield
exact results, unless they overflow.

4
Multiplications and divisions are allowed between operands of any two
fixed point types; the result has to be (implicitly or explicitly)
converted to some other numeric type.  For purposes of defining the
accuracy rules, the multiplication or division and the conversion are
treated as a single operation whose accuracy depends on three types
(those of the operands and the result).  For decimal fixed point types,
the attribute T'Round may be used to imply explicit conversion with
rounding (see *note 3.5.10::).

5
When the result type is a floating point type, the accuracy is as given
in *note G.2.1::.  For some combinations of the operand and result types
in the remaining cases, the result is required to belong to a small set
of values called the <perfect result set>; for other combinations, it is
required merely to belong to a generally larger and
implementation-defined set of values called the <close result set>.
When the result type is a decimal fixed point type, the perfect result
set contains a single value; thus, operations on decimal types are
always fully specified.

6
When one operand of a fixed-fixed multiplication or division is of type
<universal_real>, that operand is not implicitly converted in the usual
sense, since the context does not determine a unique target type, but
the accuracy of the result of the multiplication or division (i.e.,
whether the result has to belong to the perfect result set or merely the
close result set) depends on the value of the operand of type
<universal_real> and on the types of the other operand and of the
result.

7
For a fixed point multiplication or division whose (exact) mathematical
result is <v>, and for the conversion of a value <v> to a fixed point
type, the perfect result set and close result set are defined as
follows:

8
   * If the result type is an ordinary fixed point type with a <small>
     of <s>,

9
             * if <v> is an integer multiple of <s>, then the perfect
               result set contains only the value <v>;

10
             * otherwise, it contains the integer multiple of <s> just
               below <v> and the integer multiple of <s> just above <v>.

11
     The close result set is an implementation-defined set of
     consecutive integer multiples of <s> containing the perfect result
     set as a subset.

12
   * If the result type is a decimal type with a <small> of <s>,

13
             * if <v> is an integer multiple of <s>, then the perfect
               result set contains only the value <v>;

14/3
             * otherwise, if truncation applies, then it contains only
               the integer multiple of <s> in the direction toward zero,
               whereas if rounding applies, then it contains only the
               nearest integer multiple of <s> (with ties broken by
               rounding away from zero).

15
     The close result set is an implementation-defined set of
     consecutive integer multiples of <s> containing the perfect result
     set as a subset.

16
   * If the result type is an integer type,

17
             * if <v> is an integer, then the perfect result set
               contains only the value <v>;

18
             * otherwise, it contains the integer nearest to the value
               <v> (if <v> lies equally distant from two consecutive
               integers, the perfect result set contains the one that is
               further from zero).

19
     The close result set is an implementation-defined set of
     consecutive integers containing the perfect result set as a subset.

20
The result of a fixed point multiplication or division shall belong
either to the perfect result set or to the close result set, as
described below, if overflow does not occur.  In the following cases, if
the result type is a fixed point type, let <s> be its <small>;
otherwise, i.e.  when the result type is an integer type, let <s> be
1.0.

21
   * For a multiplication or division neither of whose operands is of
     type <universal_real>, let <l> and <r> be the <smalls> of the left
     and right operands.  For a multiplication, if (<l> · <r>) / <s> is
     an integer or the reciprocal of an integer (the <smalls> are said
     to be "compatible" in this case), the result shall belong to the
     perfect result set; otherwise, it belongs to the close result set.
     For a division, if <l> / (<r> · <s>) is an integer or the
     reciprocal of an integer (i.e., the <smalls> are compatible), the
     result shall belong to the perfect result set; otherwise, it
     belongs to the close result set.

22
   * For a multiplication or division having one <universal_real>
     operand with a value of <v>, note that it is always possible to
     factor <v> as an integer multiple of a "compatible" <small>, but
     the integer multiple may be "too big."  If there exists a
     factorization in which that multiple is less than some
     implementation-defined limit, the result shall belong to the
     perfect result set; otherwise, it belongs to the close result set.

23
A multiplication P * Q of an operand of a fixed point type F by an
operand of an integer type I, or vice-versa, and a division P / Q of an
operand of a fixed point type F by an operand of an integer type I, are
also allowed.  In these cases, the result has a type of F; explicit
conversion of the result is never required.  The accuracy required in
these cases is the same as that required for a multiplication F(P * Q)
or a division F(P / Q) obtained by interpreting the operand of the
integer type to have a fixed point type with a <small> of 1.0.

24
The accuracy of the result of a conversion from an integer or fixed
point type to a fixed point type, or from a fixed point type to an
integer type, is the same as that of a fixed point multiplication of the
source value by a fixed point operand having a <small> of 1.0 and a
value of 1.0, as given by the foregoing rules.  The result of a
conversion from a floating point type to a fixed point type shall belong
to the close result set.  The result of a conversion of a
<universal_real> operand to a fixed point type shall belong to the
perfect result set.

25
The possibility of overflow in the result of a predefined arithmetic
operation or conversion yielding a result of a fixed point type T is
analogous to that for floating point types, except for being related to
the base range instead of the safe range.  If all of the permitted
results belong to the base range of T, then the implementation shall
deliver one of the permitted results; otherwise,

26
   * if T'Machine_Overflows is True, the implementation shall either
     deliver one of the permitted results or raise Constraint_Error;

27
   * if T'Machine_Overflows is False, the result is implementation
     defined.


File: arm2012.info,  Node: G.2.4,  Next: G.2.5,  Prev: G.2.3,  Up: G.2

G.2.4 Accuracy Requirements for the Elementary Functions
--------------------------------------------------------

1
In the strict mode, the performance of
Numerics.Generic_Elementary_Functions shall be as specified here.

                     _Implementation Requirements_

2
When an exception is not raised, the result of evaluating a function in
an instance <EF> of Numerics.Generic_Elementary_Functions belongs to a
<result interval>, defined as the smallest model interval of
<EF>.Float_Type that contains all the values of the form <f> · (1.0 +
<d>), where <f> is the exact value of the corresponding mathematical
function at the given parameter values, <d> is a real number, and |<d>|
is less than or equal to the function's <maximum relative error>.  The
function delivers a value that belongs to the result interval when both
of its bounds belong to the safe range of <EF>.Float_Type; otherwise,

3
   * if <EF>.Float_Type'Machine_Overflows is True, the function either
     delivers a value that belongs to the result interval or raises
     Constraint_Error, signaling overflow;

4
   * if <EF>.Float_Type'Machine_Overflows is False, the result is
     implementation defined.

5
The maximum relative error exhibited by each function is as follows:

6
   * 2.0 · <EF>.Float_Type'Model_Epsilon, in the case of the Sqrt, Sin,
     and Cos functions;

7
   * 4.0 · <EF>.Float_Type'Model_Epsilon, in the case of the Log, Exp,
     Tan, Cot, and inverse trigonometric functions; and

8
   * 8.0 · <EF>.Float_Type'Model_Epsilon, in the case of the forward and
     inverse hyperbolic functions.

9
The maximum relative error exhibited by the exponentiation operator,
which depends on the values of the operands, is (4.0 + |Right ·
log(Left)| / 32.0) · <EF>.Float_Type'Model_Epsilon.

10
The maximum relative error given above applies throughout the domain of
the forward trigonometric functions when the Cycle parameter is
specified.  When the Cycle parameter is omitted, the maximum relative
error given above applies only when the absolute value of the angle
parameter X is less than or equal to some implementation-defined <angle
threshold>, which shall be at least <EF>.Float_Type'Machine_Radix
'floor(<EF>.Float_Type'Machine_Mantissa/2)'.  Beyond the angle
threshold, the accuracy of the forward trigonometric functions is
implementation defined.

11/2
The prescribed results specified in *note A.5.1:: for certain functions
at particular parameter values take precedence over the maximum relative
error bounds; effectively, they narrow to a single value the result
interval allowed by the maximum relative error bounds.  Additional rules
with a similar effect are given by table G-1 for the inverse
trigonometric functions, at particular parameter values for which the
mathematical result is possibly not a model number of <EF>.Float_Type
(or is, indeed, even transcendental).  In each table entry, the values
of the parameters are such that the result lies on the axis between two
quadrants; the corresponding accuracy rule, which takes precedence over
the maximum relative error bounds, is that the result interval is the
model interval of <EF>.Float_Type associated with the exact mathematical
result given in the table.

12/1
<This paragraph was deleted.>

13
The last line of the table is meant to apply when
<EF>.Float_Type'Signed_Zeros is False; the two lines just above it, when
<EF>.Float_Type'Signed_Zeros is True and the parameter Y has a zero
value with the indicated sign.

Table G-1: Tightly Approximated Elementary Function Results
Function   Value of X   Value of Y   Exact Result Exact Result 
                                     when Cycle  when Cycle 
                                     Specified   Omitted
Arcsin     1.0          n.a.         Cycle/4.0   PI/2.0
Arcsin     -1.0         n.a.         -Cycle/4.0  -PI/2.0
Arccos     0.0          n.a.         Cycle/4.0   PI/2.0
Arccos     -1.0         n.a.         Cycle/2.0   PI
Arctan     0.0          positive     Cycle/4.0   PI/2.0
and
Arccot
Arctan     0.0          negative     -Cycle/4.0  -PI/2.0
and
Arccot
Arctan     negative     +0.0         Cycle/2.0   PI
and
Arccot
Arctan     negative     -0.0         -Cycle/2.0  -PI
and
Arccot
Arctan     negative     0.0          Cycle/2.0   PI
and
Arccot
14
The amount by which the result of an inverse trigonometric function is
allowed to spill over into a quadrant adjacent to the one corresponding
to the principal branch, as given in *note A.5.1::, is limited.  The
rule is that the result belongs to the smallest model interval of
<EF>.Float_Type that contains both boundaries of the quadrant
corresponding to the principal branch.  This rule also takes precedence
over the maximum relative error bounds, effectively narrowing the result
interval allowed by them.

15
Finally, the following specifications also take precedence over the
maximum relative error bounds:

16
   * The absolute value of the result of the Sin, Cos, and Tanh
     functions never exceeds one.

17
   * The absolute value of the result of the Coth function is never less
     than one.

18
   * The result of the Cosh function is never less than one.

                        _Implementation Advice_

19
The versions of the forward trigonometric functions without a Cycle
parameter should not be implemented by calling the corresponding version
with a Cycle parameter of 2.0*Numerics.Pi, since this will not provide
the required accuracy in some portions of the domain.  For the same
reason, the version of Log without a Base parameter should not be
implemented by calling the corresponding version with a Base parameter
of Numerics.e.


File: arm2012.info,  Node: G.2.5,  Next: G.2.6,  Prev: G.2.4,  Up: G.2

G.2.5 Performance Requirements for Random Number Generation
-----------------------------------------------------------

1
In the strict mode, the performance of Numerics.Float_Random and
Numerics.Discrete_Random shall be as specified here.

                     _Implementation Requirements_

2
Two different calls to the time-dependent Reset procedure shall reset
the generator to different states, provided that the calls are separated
in time by at least one second and not more than fifty years.

3
The implementation's representations of generator states and its
algorithms for generating random numbers shall yield a period of at
least 231-2; much longer periods are desirable but not required.

4
The implementations of Numerics.Float_Random.Random and
Numerics.Discrete_Random.Random shall pass at least 85% of the
individual trials in a suite of statistical tests.  For
Numerics.Float_Random, the tests are applied directly to the floating
point values generated (i.e., they are not converted to integers first),
while for Numerics.Discrete_Random they are applied to the generated
values of various discrete types.  Each test suite performs 6 different
tests, with each test repeated 10 times, yielding a total of 60
individual trials.  An individual trial is deemed to pass if the
chi-square value (or other statistic) calculated for the observed counts
or distribution falls within the range of values corresponding to the
2.5 and 97.5 percentage points for the relevant degrees of freedom
(i.e., it shall be neither too high nor too low).  For the purpose of
determining the degrees of freedom, measurement categories are combined
whenever the expected counts are fewer than 5.


File: arm2012.info,  Node: G.2.6,  Prev: G.2.5,  Up: G.2

G.2.6 Accuracy Requirements for Complex Arithmetic
--------------------------------------------------

1
In the strict mode, the performance of Numerics.Generic_Complex_Types
and Numerics.Generic_Complex_Elementary_Functions shall be as specified
here.

                     _Implementation Requirements_

2
When an exception is not raised, the result of evaluating a real
function of an instance <CT> of Numerics.Generic_Complex_Types (i.e., a
function that yields a value of subtype <CT>.Real'Base or
<CT>.Imaginary) belongs to a result interval defined as for a real
elementary function (see *note G.2.4::).

3
When an exception is not raised, each component of the result of
evaluating a complex function of such an instance, or of an instance of
Numerics.Generic_Complex_Elementary_Functions obtained by instantiating
the latter with <CT> (i.e., a function that yields a value of subtype
<CT>.Complex), also belongs to a <result interval>.  The result
intervals for the components of the result are either defined by a
<maximum relative error> bound or by a <maximum box error> bound.  When
the result interval for the real (resp., imaginary) component is defined
by maximum relative error, it is defined as for that of a real function,
relative to the exact value of the real (resp., imaginary) part of the
result of the corresponding mathematical function.  When defined by
maximum box error, the result interval for a component of the result is
the smallest model interval of <CT>.Real that contains all the values of
the corresponding part of <f> · (1.0 + <d>), where <f> is the exact
complex value of the corresponding mathematical function at the given
parameter values, <d> is complex, and |<d>| is less than or equal to the
given maximum box error.  The function delivers a value that belongs to
the result interval (or a value both of whose components belong to their
respective result intervals) when both bounds of the result interval(s)
belong to the safe range of <CT>.Real; otherwise,

4
   * if <CT>.Real'Machine_Overflows is True, the function either
     delivers a value that belongs to the result interval (or a value
     both of whose components belong to their respective result
     intervals) or raises Constraint_Error, signaling overflow;

5
   * if <CT>.Real'Machine_Overflows is False, the result is
     implementation defined.

6/2
The error bounds for particular complex functions are tabulated in table
G-2.  In the table, the error bound is given as the coefficient of
<CT>.Real'Model_Epsilon.

7/1
<This paragraph was deleted.>

Table G-2: Error Bounds for Particular Complex Functions
Function or Operator   Nature of Nature of Error Bound
                       Result   Bound    
Modulus                real     max.    3.0
                                rel.
                                error
Argument               real     max.    4.0
                                rel.
                                error
Compose_From_Polar     complex  max.    3.0
                                rel.
                                error
"*" (both operands     complex  max.    5.0
complex)                        box
                                error
"/" (right operand     complex  max.    13.0
complex)                        box
                                error
Sqrt                   complex  max.    6.0
                                rel.
                                error
Log                    complex  max.    13.0
                                box
                                error
Exp (complex           complex  max.    7.0
parameter)                      rel.
                                error
Exp (imaginary         complex  max.    2.0
parameter)                      rel.
                                error
Sin, Cos, Sinh, and    complex  max.    11.0
Cosh                            rel.
                                error
Tan, Cot, Tanh, and    complex  max.    35.0
Coth                            rel.
                                error
inverse                complex  max.    14.0
trigonometric                   rel.
                                error
inverse hyperbolic     complex  max.    14.0
                                rel.
                                error
8
The maximum relative error given above applies throughout the domain of
the Compose_From_Polar function when the Cycle parameter is specified.
When the Cycle parameter is omitted, the maximum relative error applies
only when the absolute value of the parameter Argument is less than or
equal to the angle threshold (see *note G.2.4::).  For the Exp function,
and for the forward hyperbolic (resp., trigonometric) functions, the
maximum relative error given above likewise applies only when the
absolute value of the imaginary (resp., real) component of the parameter
X (or the absolute value of the parameter itself, in the case of the Exp
function with a parameter of pure-imaginary type) is less than or equal
to the angle threshold.  For larger angles, the accuracy is
implementation defined.

9
The prescribed results specified in *note G.1.2:: for certain functions
at particular parameter values take precedence over the error bounds;
effectively, they narrow to a single value the result interval allowed
by the error bounds for a component of the result.  Additional rules
with a similar effect are given below for certain inverse trigonometric
and inverse hyperbolic functions, at particular parameter values for
which a component of the mathematical result is transcendental.  In each
case, the accuracy rule, which takes precedence over the error bounds,
is that the result interval for the stated result component is the model
interval of <CT>.Real associated with the component's exact mathematical
value.  The cases in question are as follows:

10
   * When the parameter X has the value zero, the real (resp.,
     imaginary) component of the result of the Arccot (resp., Arccoth)
     function is in the model interval of <CT>.Real associated with the
     value PI/2.0.

11
   * When the parameter X has the value one, the real component of the
     result of the Arcsin function is in the model interval of <CT>.Real
     associated with the value PI/2.0.

12
   * When the parameter X has the value -1.0, the real component of the
     result of the Arcsin (resp., Arccos) function is in the model
     interval of <CT>.Real associated with the value -PI/2.0 (resp.,
     PI).

13/2
The amount by which a component of the result of an inverse
trigonometric or inverse hyperbolic function is allowed to spill over
into a quadrant adjacent to the one corresponding to the principal
branch, as given in *note G.1.2::, is limited.  The rule is that the
result belongs to the smallest model interval of <CT>.Real that contains
both boundaries of the quadrant corresponding to the principal branch.
This rule also takes precedence over the maximum error bounds,
effectively narrowing the result interval allowed by them.

14
Finally, the results allowed by the error bounds are narrowed by one
further rule: The absolute value of each component of the result of the
Exp function, for a pure-imaginary parameter, never exceeds one.

                        _Implementation Advice_

15
The version of the Compose_From_Polar function without a Cycle parameter
should not be implemented by calling the corresponding version with a
Cycle parameter of 2.0*Numerics.Pi, since this will not provide the
required accuracy in some portions of the domain.


File: arm2012.info,  Node: G.3,  Prev: G.2,  Up: Annex G

G.3 Vector and Matrix Manipulation
==================================

1/2
Types and operations for the manipulation of real vectors and matrices
are provided in Generic_Real_Arrays, which is defined in *note G.3.1::.
Types and operations for the manipulation of complex vectors and
matrices are provided in Generic_Complex_Arrays, which is defined in
*note G.3.2::.  Both of these library units are generic children of the
predefined package Numerics (see *note A.5::).  Nongeneric equivalents
of these packages for each of the predefined floating point types are
also provided as children of Numerics.

* Menu:

* G.3.1 ::    Real Vectors and Matrices
* G.3.2 ::    Complex Vectors and Matrices


File: arm2012.info,  Node: G.3.1,  Next: G.3.2,  Up: G.3

G.3.1 Real Vectors and Matrices
-------------------------------

                          _Static Semantics_

1/2
The generic library package Numerics.Generic_Real_Arrays has the
following declaration:

2/2
     generic
        type Real is digits <>;
     package Ada.Numerics.Generic_Real_Arrays is
        pragma Pure(Generic_Real_Arrays);

3/2
        -- <Types>

4/2
        type Real_Vector is array (Integer range <>) of Real'Base;
        type Real_Matrix is array (Integer range <>, Integer range <>)
                                                        of Real'Base;

5/2
        -- <Subprograms for Real_Vector types>

6/2
        -- <Real_Vector arithmetic operations>

7/2
        function "+"   (Right : Real_Vector)       return Real_Vector;
        function "-"   (Right : Real_Vector)       return Real_Vector;
        function "abs" (Right : Real_Vector)       return Real_Vector;

8/2
        function "+"   (Left, Right : Real_Vector) return Real_Vector;
        function "-"   (Left, Right : Real_Vector) return Real_Vector;

9/2
        function "*"   (Left, Right : Real_Vector) return Real'Base;

10/2
        function "abs" (Right : Real_Vector)       return Real'Base;

11/2
        -- <Real_Vector scaling operations>

12/2
        function "*" (Left : Real'Base;   Right : Real_Vector)
           return Real_Vector;
        function "*" (Left : Real_Vector; Right : Real'Base)
           return Real_Vector;
        function "/" (Left : Real_Vector; Right : Real'Base)
           return Real_Vector;

13/2
        -- <Other Real_Vector operations>

14/2
        function Unit_Vector (Index : Integer;
                              Order : Positive;
                              First : Integer := 1) return Real_Vector;

15/2
        -- <Subprograms for Real_Matrix types>

16/2
        -- <Real_Matrix arithmetic operations>

17/2
        function "+"       (Right : Real_Matrix) return Real_Matrix;
        function "-"       (Right : Real_Matrix) return Real_Matrix;
        function "abs"     (Right : Real_Matrix) return Real_Matrix;
        function Transpose (X     : Real_Matrix) return Real_Matrix;

18/2
        function "+" (Left, Right : Real_Matrix) return Real_Matrix;
        function "-" (Left, Right : Real_Matrix) return Real_Matrix;
        function "*" (Left, Right : Real_Matrix) return Real_Matrix;

19/2
        function "*" (Left, Right : Real_Vector) return Real_Matrix;

20/2
        function "*" (Left : Real_Vector; Right : Real_Matrix)
           return Real_Vector;
        function "*" (Left : Real_Matrix; Right : Real_Vector)
           return Real_Vector;

21/2
        -- <Real_Matrix scaling operations>

22/2
        function "*" (Left : Real'Base;   Right : Real_Matrix)
           return Real_Matrix;
        function "*" (Left : Real_Matrix; Right : Real'Base)
           return Real_Matrix;
        function "/" (Left : Real_Matrix; Right : Real'Base)
           return Real_Matrix;

23/2
        -- <Real_Matrix inversion and related operations>

24/2
        function Solve (A : Real_Matrix; X : Real_Vector) return Real_Vector;
        function Solve (A, X : Real_Matrix) return Real_Matrix;
        function Inverse (A : Real_Matrix) return Real_Matrix;
        function Determinant (A : Real_Matrix) return Real'Base;

25/2
        -- <Eigenvalues and vectors of a real symmetric matrix>

26/2
        function Eigenvalues (A : Real_Matrix) return Real_Vector;

27/2
        procedure Eigensystem (A       : in  Real_Matrix;
                               Values  : out Real_Vector;
                               Vectors : out Real_Matrix);

28/2
        -- <Other Real_Matrix operations>

29/2
        function Unit_Matrix (Order            : Positive;
                              First_1, First_2 : Integer := 1)
                                                 return Real_Matrix;

30/2
     end Ada.Numerics.Generic_Real_Arrays;

31/2
The library package Numerics.Real_Arrays is declared pure and defines
the same types and subprograms as Numerics.Generic_Real_Arrays, except
that the predefined type Float is systematically substituted for
Real'Base throughout.  Nongeneric equivalents for each of the other
predefined floating point types are defined similarly, with the names
Numerics.Short_Real_Arrays, Numerics.Long_Real_Arrays, etc.

32/2
Two types are defined and exported by Numerics.Generic_Real_Arrays.  The
composite type Real_Vector is provided to represent a vector with
components of type Real; it is defined as an unconstrained,
one-dimensional array with an index of type Integer.  The composite type
Real_Matrix is provided to represent a matrix with components of type
Real; it is defined as an unconstrained, two-dimensional array with
indices of type Integer.

33/2
The effect of the various subprograms is as described below.  In most
cases the subprograms are described in terms of corresponding scalar
operations of the type Real; any exception raised by those operations is
propagated by the array operation.  Moreover, the accuracy of the result
for each individual component is as defined for the scalar operation
unless stated otherwise.

34/2
In the case of those operations which are defined to <involve an inner
product>, Constraint_Error may be raised if an intermediate result is
outside the range of Real'Base even though the mathematical final result
would not be.

35/2
     function "+"   (Right : Real_Vector) return Real_Vector;
     function "-"   (Right : Real_Vector) return Real_Vector;
     function "abs" (Right : Real_Vector) return Real_Vector;

36/2
          Each operation returns the result of applying the
          corresponding operation of the type Real to each component of
          Right.  The index range of the result is Right'Range.

37/2
     function "+" (Left, Right : Real_Vector) return Real_Vector;
     function "-" (Left, Right : Real_Vector) return Real_Vector;

38/2
          Each operation returns the result of applying the
          corresponding operation of the type Real to each component of
          Left and the matching component of Right.  The index range of
          the result is Left'Range.  Constraint_Error is raised if
          Left'Length is not equal to Right'Length.

39/2
     function "*" (Left, Right : Real_Vector) return Real'Base;

40/2
          This operation returns the inner product of Left and Right.
          Constraint_Error is raised if Left'Length is not equal to
          Right'Length.  This operation involves an inner product.

41/2
     function "abs" (Right : Real_Vector) return Real'Base;

42/2
          This operation returns the L2-norm of Right (the square root
          of the inner product of the vector with itself).

43/2
     function "*" (Left : Real'Base; Right : Real_Vector) return Real_Vector;

44/2
          This operation returns the result of multiplying each
          component of Right by the scalar Left using the "*" operation
          of the type Real.  The index range of the result is
          Right'Range.

45/2
     function "*" (Left : Real_Vector; Right : Real'Base) return Real_Vector;
     function "/" (Left : Real_Vector; Right : Real'Base) return Real_Vector;

46/2
          Each operation returns the result of applying the
          corresponding operation of the type Real to each component of
          Left and to the scalar Right.  The index range of the result
          is Left'Range.

47/2
     function Unit_Vector (Index : Integer;
                           Order : Positive;
                           First : Integer := 1) return Real_Vector;

48/2
          This function returns a <unit vector> with Order components
          and a lower bound of First.  All components are set to 0.0
          except for the Index component which is set to 1.0.
          Constraint_Error is raised if Index < First, Index > First +
          Order - 1 or if First + Order - 1 > Integer'Last.

49/2
     function "+"   (Right : Real_Matrix) return Real_Matrix;
     function "-"   (Right : Real_Matrix) return Real_Matrix;
     function "abs" (Right : Real_Matrix) return Real_Matrix;

50/2
          Each operation returns the result of applying the
          corresponding operation of the type Real to each component of
          Right.  The index ranges of the result are those of Right.

51/2
     function Transpose (X : Real_Matrix) return Real_Matrix;

52/2
          This function returns the transpose of a matrix X. The first
          and second index ranges of the result are X'Range(2) and
          X'Range(1) respectively.

53/2
     function "+" (Left, Right : Real_Matrix) return Real_Matrix;
     function "-" (Left, Right : Real_Matrix) return Real_Matrix;

54/2
          Each operation returns the result of applying the
          corresponding operation of the type Real to each component of
          Left and the matching component of Right.  The index ranges of
          the result are those of Left.  Constraint_Error is raised if
          Left'Length(1) is not equal to Right'Length(1) or
          Left'Length(2) is not equal to Right'Length(2).

55/2
     function "*" (Left, Right : Real_Matrix) return Real_Matrix;

56/2
          This operation provides the standard mathematical operation
          for matrix multiplication.  The first and second index ranges
          of the result are Left'Range(1) and Right'Range(2)
          respectively.  Constraint_Error is raised if Left'Length(2) is
          not equal to Right'Length(1).  This operation involves inner
          products.

57/2
     function "*" (Left, Right : Real_Vector) return Real_Matrix;

58/2
          This operation returns the outer product of a (column) vector
          Left by a (row) vector Right using the operation "*" of the
          type Real for computing the individual components.  The first
          and second index ranges of the result are Left'Range and
          Right'Range respectively.

59/2
     function "*" (Left : Real_Vector; Right : Real_Matrix) return Real_Vector;

60/2
          This operation provides the standard mathematical operation
          for multiplication of a (row) vector Left by a matrix Right.
          The index range of the (row) vector result is Right'Range(2).
          Constraint_Error is raised if Left'Length is not equal to
          Right'Length(1).  This operation involves inner products.

61/2
     function "*" (Left : Real_Matrix; Right : Real_Vector) return Real_Vector;

62/2
          This operation provides the standard mathematical operation
          for multiplication of a matrix Left by a (column) vector
          Right.  The index range of the (column) vector result is
          Left'Range(1).  Constraint_Error is raised if Left'Length(2)
          is not equal to Right'Length.  This operation involves inner
          products.

63/2
     function "*" (Left : Real'Base; Right : Real_Matrix) return Real_Matrix;

64/2
          This operation returns the result of multiplying each
          component of Right by the scalar Left using the "*" operation
          of the type Real.  The index ranges of the result are those of
          Right.

65/2
     function "*" (Left : Real_Matrix; Right : Real'Base) return Real_Matrix;
     function "/" (Left : Real_Matrix; Right : Real'Base) return Real_Matrix;

66/2
          Each operation returns the result of applying the
          corresponding operation of the type Real to each component of
          Left and to the scalar Right.  The index ranges of the result
          are those of Left.

67/2
     function Solve (A : Real_Matrix; X : Real_Vector) return Real_Vector;

68/2
          This function returns a vector Y such that X is (nearly) equal
          to A * Y. This is the standard mathematical operation for
          solving a single set of linear equations.  The index range of
          the result is A'Range(2).  Constraint_Error is raised if
          A'Length(1), A'Length(2), and X'Length are not equal.
          Constraint_Error is raised if the matrix A is ill-conditioned.

69/2
     function Solve (A, X : Real_Matrix) return Real_Matrix;

70/2
          This function returns a matrix Y such that X is (nearly) equal
          to A * Y. This is the standard mathematical operation for
          solving several sets of linear equations.  The index ranges of
          the result are A'Range(2) and X'Range(2).  Constraint_Error is
          raised if A'Length(1), A'Length(2), and X'Length(1) are not
          equal.  Constraint_Error is raised if the matrix A is
          ill-conditioned.

71/2
     function Inverse (A : Real_Matrix) return Real_Matrix;

72/2
          This function returns a matrix B such that A * B is (nearly)
          equal to the unit matrix.  The index ranges of the result are
          A'Range(2) and A'Range(1).  Constraint_Error is raised if
          A'Length(1) is not equal to A'Length(2).  Constraint_Error is
          raised if the matrix A is ill-conditioned.

73/2
     function Determinant (A : Real_Matrix) return Real'Base;

74/2
          This function returns the determinant of the matrix A.
          Constraint_Error is raised if A'Length(1) is not equal to
          A'Length(2).

75/2
     function Eigenvalues(A : Real_Matrix) return Real_Vector;

76/2
          This function returns the eigenvalues of the symmetric matrix
          A as a vector sorted into order with the largest first.
          Constraint_Error is raised if A'Length(1) is not equal to
          A'Length(2).  The index range of the result is A'Range(1).
          Argument_Error is raised if the matrix A is not symmetric.

77/2
     procedure Eigensystem(A       : in  Real_Matrix;
                           Values  : out Real_Vector;
                           Vectors : out Real_Matrix);

78/3
          This procedure computes both the eigenvalues and eigenvectors
          of the symmetric matrix A. The out parameter Values is the
          same as that obtained by calling the function Eigenvalues.
          The out parameter Vectors is a matrix whose columns are the
          eigenvectors of the matrix A. The order of the columns
          corresponds to the order of the eigenvalues.  The eigenvectors
          are normalized and mutually orthogonal (they are orthonormal),
          including when there are repeated eigenvalues.
          Constraint_Error is raised if A'Length(1) is not equal to
          A'Length(2), or if Values'Range is not equal to A'Range(1), or
          if the index ranges of the parameter Vectors are not equal to
          those of A. Argument_Error is raised if the matrix A is not
          symmetric.  Constraint_Error is also raised in
          implementation-defined circumstances if the algorithm used
          does not converge quickly enough.

79/2
     function Unit_Matrix (Order            : Positive;
                           First_1, First_2 : Integer := 1) return Real_Matrix;

80/2
          This function returns a square <unit matrix> with Order**2
          components and lower bounds of First_1 and First_2 (for the
          first and second index ranges respectively).  All components
          are set to 0.0 except for the main diagonal, whose components
          are set to 1.0.  Constraint_Error is raised if First_1 + Order
          - 1 > Integer'Last or First_2 + Order - 1 > Integer'Last.

                     _Implementation Requirements_

81/2
Accuracy requirements for the subprograms Solve, Inverse, Determinant,
Eigenvalues and Eigensystem are implementation defined.

82/2
For operations not involving an inner product, the accuracy requirements
are those of the corresponding operations of the type Real in both the
strict mode and the relaxed mode (see *note G.2::).

83/2
For operations involving an inner product, no requirements are specified
in the relaxed mode.  In the strict mode the modulus of the absolute
error of the inner product <X>*<Y> shall not exceed
<g>*abs(<X>)*abs(<Y>) where <g> is defined as

84/2
     <g> = <X>'Length * Real'Machine_Radix**(1 - Real'Model_Mantissa)

85/2
For the L2-norm, no accuracy requirements are specified in the relaxed
mode.  In the strict mode the relative error on the norm shall not
exceed <g> / 2.0 + 3.0 * Real'Model_Epsilon where <g> is defined as
above.

                     _Documentation Requirements_

86/2
Implementations shall document any techniques used to reduce
cancellation errors such as extended precision arithmetic.

                     _Implementation Permissions_

87/2
The nongeneric equivalent packages may, but need not, be actual
instantiations of the generic package for the appropriate predefined
type.

                        _Implementation Advice_

88/3
Implementations should implement the Solve and Inverse functions using
established techniques such as LU decomposition with row interchanges
followed by back and forward substitution.  Implementations are
recommended to refine the result by performing an iteration on the
residuals; if this is done, then it should be documented.

89/2
It is not the intention that any special provision should be made to
determine whether a matrix is ill-conditioned or not.  The naturally
occurring overflow (including division by zero) which will result from
executing these functions with an ill-conditioned matrix and thus raise
Constraint_Error is sufficient.

90/2
The test that a matrix is symmetric should be performed by using the
equality operator to compare the relevant components.

91/3
An implementation should minimize the circumstances under which the
algorithm used for Eigenvalues and Eigensystem fails to converge.


File: arm2012.info,  Node: G.3.2,  Prev: G.3.1,  Up: G.3

G.3.2 Complex Vectors and Matrices
----------------------------------

                          _Static Semantics_

1/2
The generic library package Numerics.Generic_Complex_Arrays has the
following declaration:

2/2
     with Ada.Numerics.Generic_Real_Arrays, Ada.Numerics.Generic_Complex_Types;
     generic
        with package Real_Arrays   is new
           Ada.Numerics.Generic_Real_Arrays   (<>);
        use Real_Arrays;
        with package Complex_Types is new
           Ada.Numerics.Generic_Complex_Types (Real);
        use Complex_Types;
     package Ada.Numerics.Generic_Complex_Arrays is
        pragma Pure(Generic_Complex_Arrays);

3/2
        -- <Types>

4/2
        type Complex_Vector is array (Integer range <>) of Complex;
        type Complex_Matrix is array (Integer range <>,
                                      Integer range <>) of Complex;

5/2
        -- <Subprograms for Complex_Vector types>

6/2
        -- <Complex_Vector selection, conversion and composition operations>

7/2
        function Re (X : Complex_Vector) return Real_Vector;
        function Im (X : Complex_Vector) return Real_Vector;

8/2
        procedure Set_Re (X  : in out Complex_Vector;
                          Re : in     Real_Vector);
        procedure Set_Im (X  : in out Complex_Vector;
                          Im : in     Real_Vector);

9/2
        function Compose_From_Cartesian (Re     : Real_Vector)
           return Complex_Vector;
        function Compose_From_Cartesian (Re, Im : Real_Vector)
           return Complex_Vector;

10/2
        function Modulus  (X     : Complex_Vector) return Real_Vector;
        function "abs"    (Right : Complex_Vector) return Real_Vector
                                                      renames Modulus;
        function Argument (X     : Complex_Vector) return Real_Vector;
        function Argument (X     : Complex_Vector;
                           Cycle : Real'Base)      return Real_Vector;

11/2
        function Compose_From_Polar (Modulus, Argument : Real_Vector)
           return Complex_Vector;
        function Compose_From_Polar (Modulus, Argument : Real_Vector;
                                     Cycle             : Real'Base)
           return Complex_Vector;

12/2
        -- <Complex_Vector arithmetic operations>

13/2
        function "+"       (Right  : Complex_Vector) return Complex_Vector;
        function "-"       (Right  : Complex_Vector) return Complex_Vector;
        function Conjugate (X      : Complex_Vector) return Complex_Vector;

14/2
        function "+"  (Left, Right : Complex_Vector) return Complex_Vector;
        function "-"  (Left, Right : Complex_Vector) return Complex_Vector;

15/2
        function "*"  (Left, Right : Complex_Vector) return Complex;

16/3
        function "abs"     (Right : Complex_Vector) return Real'Base;

17/2
        -- <Mixed Real_Vector and Complex_Vector arithmetic operations>

18/2
        function "+" (Left  : Real_Vector;
                      Right : Complex_Vector) return Complex_Vector;
        function "+" (Left  : Complex_Vector;
                      Right : Real_Vector)    return Complex_Vector;
        function "-" (Left  : Real_Vector;
                      Right : Complex_Vector) return Complex_Vector;
        function "-" (Left  : Complex_Vector;
                      Right : Real_Vector)    return Complex_Vector;

19/2
        function "*" (Left  : Real_Vector;    Right : Complex_Vector)
           return Complex;
        function "*" (Left  : Complex_Vector; Right : Real_Vector)
           return Complex;

20/2
        -- <Complex_Vector scaling operations>

21/2
        function "*" (Left  : Complex;
                      Right : Complex_Vector) return Complex_Vector;
        function "*" (Left  : Complex_Vector;
                      Right : Complex)        return Complex_Vector;
        function "/" (Left  : Complex_Vector;
                      Right : Complex)        return Complex_Vector;

22/2
        function "*" (Left  : Real'Base;
                      Right : Complex_Vector) return Complex_Vector;
        function "*" (Left  : Complex_Vector;
                      Right : Real'Base)      return Complex_Vector;
        function "/" (Left  : Complex_Vector;
                      Right : Real'Base)      return Complex_Vector;

23/2
        -- <Other Complex_Vector operations>

24/2
        function Unit_Vector (Index : Integer;
                              Order : Positive;
                              First : Integer := 1) return Complex_Vector;

25/2
        -- <Subprograms for Complex_Matrix types>

26/2
        -- <Complex_Matrix selection, conversion and composition operations>

27/2
        function Re (X : Complex_Matrix) return Real_Matrix;
        function Im (X : Complex_Matrix) return Real_Matrix;

28/2
        procedure Set_Re (X  : in out Complex_Matrix;
                          Re : in     Real_Matrix);
        procedure Set_Im (X  : in out Complex_Matrix;
                          Im : in     Real_Matrix);

29/2
        function Compose_From_Cartesian (Re     : Real_Matrix)
           return Complex_Matrix;
        function Compose_From_Cartesian (Re, Im : Real_Matrix)
           return Complex_Matrix;

30/2
        function Modulus  (X     : Complex_Matrix) return Real_Matrix;
        function "abs"    (Right : Complex_Matrix) return Real_Matrix
                                                      renames Modulus;

31/2
        function Argument (X     : Complex_Matrix) return Real_Matrix;
        function Argument (X     : Complex_Matrix;
                           Cycle : Real'Base)      return Real_Matrix;

32/2
        function Compose_From_Polar (Modulus, Argument : Real_Matrix)
           return Complex_Matrix;
        function Compose_From_Polar (Modulus, Argument : Real_Matrix;
                                     Cycle             : Real'Base)
           return Complex_Matrix;

33/2
        -- <Complex_Matrix arithmetic operations>

34/2
        function "+"       (Right : Complex_Matrix) return Complex_Matrix;
        function "-"       (Right : Complex_Matrix) return Complex_Matrix;
        function Conjugate (X     : Complex_Matrix) return Complex_Matrix;
        function Transpose (X     : Complex_Matrix) return Complex_Matrix;

35/2
        function "+" (Left, Right : Complex_Matrix) return Complex_Matrix;
        function "-" (Left, Right : Complex_Matrix) return Complex_Matrix;
        function "*" (Left, Right : Complex_Matrix) return Complex_Matrix;

36/2
        function "*" (Left, Right : Complex_Vector) return Complex_Matrix;

37/2
        function "*" (Left  : Complex_Vector;
                      Right : Complex_Matrix) return Complex_Vector;
        function "*" (Left  : Complex_Matrix;
                      Right : Complex_Vector) return Complex_Vector;

38/2
        -- <Mixed Real_Matrix and Complex_Matrix arithmetic operations>

39/2
        function "+" (Left  : Real_Matrix;
                      Right : Complex_Matrix) return Complex_Matrix;
        function "+" (Left  : Complex_Matrix;
                      Right : Real_Matrix)    return Complex_Matrix;
        function "-" (Left  : Real_Matrix;
                      Right : Complex_Matrix) return Complex_Matrix;
        function "-" (Left  : Complex_Matrix;
                      Right : Real_Matrix)    return Complex_Matrix;
        function "*" (Left  : Real_Matrix;
                      Right : Complex_Matrix) return Complex_Matrix;
        function "*" (Left  : Complex_Matrix;
                      Right : Real_Matrix)    return Complex_Matrix;

40/2
        function "*" (Left  : Real_Vector;
                      Right : Complex_Vector) return Complex_Matrix;
        function "*" (Left  : Complex_Vector;
                      Right : Real_Vector)    return Complex_Matrix;

41/2
        function "*" (Left  : Real_Vector;
                      Right : Complex_Matrix) return Complex_Vector;
        function "*" (Left  : Complex_Vector;
                      Right : Real_Matrix)    return Complex_Vector;
        function "*" (Left  : Real_Matrix;
                      Right : Complex_Vector) return Complex_Vector;
        function "*" (Left  : Complex_Matrix;
                      Right : Real_Vector)    return Complex_Vector;

42/2
        -- <Complex_Matrix scaling operations>

43/2
        function "*" (Left  : Complex;
                      Right : Complex_Matrix) return Complex_Matrix;
        function "*" (Left  : Complex_Matrix;
                      Right : Complex)        return Complex_Matrix;
        function "/" (Left  : Complex_Matrix;
                      Right : Complex)        return Complex_Matrix;

44/2
        function "*" (Left  : Real'Base;
                      Right : Complex_Matrix) return Complex_Matrix;
        function "*" (Left  : Complex_Matrix;
                      Right : Real'Base)      return Complex_Matrix;
        function "/" (Left  : Complex_Matrix;
                      Right : Real'Base)      return Complex_Matrix;

45/2
        -- <Complex_Matrix inversion and related operations>

46/2
        function Solve (A : Complex_Matrix; X : Complex_Vector)
           return Complex_Vector;
        function Solve (A, X : Complex_Matrix) return Complex_Matrix;
        function Inverse (A : Complex_Matrix) return Complex_Matrix;
        function Determinant (A : Complex_Matrix) return Complex;

47/2
        -- <Eigenvalues and vectors of a Hermitian matrix>

48/2
        function Eigenvalues(A : Complex_Matrix) return Real_Vector;

49/2
        procedure Eigensystem(A       : in  Complex_Matrix;
                              Values  : out Real_Vector;
                              Vectors : out Complex_Matrix);

50/2
        -- <Other Complex_Matrix operations>

51/2
        function Unit_Matrix (Order            : Positive;
                              First_1, First_2 : Integer := 1)
                                                 return Complex_Matrix;

52/2
     end Ada.Numerics.Generic_Complex_Arrays;

53/2
The library package Numerics.Complex_Arrays is declared pure and defines
the same types and subprograms as Numerics.Generic_Complex_Arrays,
except that the predefined type Float is systematically substituted for
Real'Base, and the Real_Vector and Real_Matrix types exported by
Numerics.Real_Arrays are systematically substituted for Real_Vector and
Real_Matrix, and the Complex type exported by Numerics.Complex_Types is
systematically substituted for Complex, throughout.  Nongeneric
equivalents for each of the other predefined floating point types are
defined similarly, with the names Numerics.Short_Complex_Arrays,
Numerics.Long_Complex_Arrays, etc.

54/2
Two types are defined and exported by Numerics.Generic_Complex_Arrays.
The composite type Complex_Vector is provided to represent a vector with
components of type Complex; it is defined as an unconstrained
one-dimensional array with an index of type Integer.  The composite type
Complex_Matrix is provided to represent a matrix with components of type
Complex; it is defined as an unconstrained, two-dimensional array with
indices of type Integer.

55/2
The effect of the various subprograms is as described below.  In many
cases they are described in terms of corresponding scalar operations in
Numerics.Generic_Complex_Types.  Any exception raised by those
operations is propagated by the array subprogram.  Moreover, any
constraints on the parameters and the accuracy of the result for each
individual component are as defined for the scalar operation.

56/2
In the case of those operations which are defined to <involve an inner
product>, Constraint_Error may be raised if an intermediate result has a
component outside the range of Real'Base even though the final
mathematical result would not.

57/2
     function Re (X : Complex_Vector) return Real_Vector;
     function Im (X : Complex_Vector) return Real_Vector;

58/2
          Each function returns a vector of the specified Cartesian
          components of X. The index range of the result is X'Range.

59/2
     procedure Set_Re (X  : in out Complex_Vector; Re : in Real_Vector);
     procedure Set_Im (X  : in out Complex_Vector; Im : in Real_Vector);

60/2
          Each procedure replaces the specified (Cartesian) component of
          each of the components of X by the value of the matching
          component of Re or Im; the other (Cartesian) component of each
          of the components is unchanged.  Constraint_Error is raised if
          X'Length is not equal to Re'Length or Im'Length.

61/2
     function Compose_From_Cartesian (Re     : Real_Vector)
        return Complex_Vector;
     function Compose_From_Cartesian (Re, Im : Real_Vector)
        return Complex_Vector;

62/2
          Each function constructs a vector of Complex results (in
          Cartesian representation) formed from given vectors of
          Cartesian components; when only the real components are given,
          imaginary components of zero are assumed.  The index range of
          the result is Re'Range.  Constraint_Error is raised if
          Re'Length is not equal to Im'Length.

63/2
     function Modulus  (X     : Complex_Vector) return Real_Vector;
     function "abs"    (Right : Complex_Vector) return Real_Vector
                                                   renames Modulus;
     function Argument (X     : Complex_Vector) return Real_Vector;
     function Argument (X     : Complex_Vector;
                        Cycle : Real'Base)      return Real_Vector;

64/2
          Each function calculates and returns a vector of the specified
          polar components of X or Right using the corresponding
          function in numerics.generic_complex_types.  The index range
          of the result is X'Range or Right'Range.

65/2
     function Compose_From_Polar (Modulus, Argument : Real_Vector)
        return Complex_Vector;
     function Compose_From_Polar (Modulus, Argument : Real_Vector;
                                  Cycle             : Real'Base)
        return Complex_Vector;

66/2
          Each function constructs a vector of Complex results (in
          Cartesian representation) formed from given vectors of polar
          components using the corresponding function in
          numerics.generic_complex_types on matching components of
          Modulus and Argument.  The index range of the result is
          Modulus'Range.  Constraint_Error is raised if Modulus'Length
          is not equal to Argument'Length.

67/2
     function "+" (Right : Complex_Vector) return Complex_Vector;
     function "-" (Right : Complex_Vector) return Complex_Vector;

68/2
          Each operation returns the result of applying the
          corresponding operation in numerics.generic_complex_types to
          each component of Right.  The index range of the result is
          Right'Range.

69/2
     function Conjugate (X : Complex_Vector) return Complex_Vector;

70/2
          This function returns the result of applying the appropriate
          function Conjugate in numerics.generic_complex_types to each
          component of X. The index range of the result is X'Range.

71/2
     function "+" (Left, Right : Complex_Vector) return Complex_Vector;
     function "-" (Left, Right : Complex_Vector) return Complex_Vector;

72/2
          Each operation returns the result of applying the
          corresponding operation in numerics.generic_complex_types to
          each component of Left and the matching component of Right.
          The index range of the result is Left'Range.  Constraint_Error
          is raised if Left'Length is not equal to Right'Length.

73/2
     function "*" (Left, Right : Complex_Vector) return Complex;

74/2
          This operation returns the inner product of Left and Right.
          Constraint_Error is raised if Left'Length is not equal to
          Right'Length.  This operation involves an inner product.

75/3
     function "abs" (Right : Complex_Vector) return Real'Base;

76/2
          This operation returns the Hermitian L2-norm of Right (the
          square root of the inner product of the vector with its
          conjugate).

77/2
     function "+" (Left  : Real_Vector;
                   Right : Complex_Vector) return Complex_Vector;
     function "+" (Left  : Complex_Vector;
                   Right : Real_Vector)    return Complex_Vector;
     function "-" (Left  : Real_Vector;
                   Right : Complex_Vector) return Complex_Vector;
     function "-" (Left  : Complex_Vector;
                   Right : Real_Vector)    return Complex_Vector;

78/2
          Each operation returns the result of applying the
          corresponding operation in numerics.generic_complex_types to
          each component of Left and the matching component of Right.
          The index range of the result is Left'Range.  Constraint_Error
          is raised if Left'Length is not equal to Right'Length.

79/2
     function "*" (Left : Real_Vector;    Right : Complex_Vector) return Complex;
     function "*" (Left : Complex_Vector; Right : Real_Vector)    return Complex;

80/2
          Each operation returns the inner product of Left and Right.
          Constraint_Error is raised if Left'Length is not equal to
          Right'Length.  These operations involve an inner product.

81/2
     function "*" (Left : Complex; Right : Complex_Vector) return Complex_Vector;

82/2
          This operation returns the result of multiplying each
          component of Right by the complex number Left using the
          appropriate operation "*" in numerics.generic_complex_types.
          The index range of the result is Right'Range.

83/2
     function "*" (Left : Complex_Vector; Right : Complex) return Complex_Vector;
     function "/" (Left : Complex_Vector; Right : Complex) return Complex_Vector;

84/2
          Each operation returns the result of applying the
          corresponding operation in numerics.generic_complex_types to
          each component of the vector Left and the complex number
          Right.  The index range of the result is Left'Range.

85/2
     function "*" (Left : Real'Base;
                   Right : Complex_Vector) return Complex_Vector;

86/2
          This operation returns the result of multiplying each
          component of Right by the real number Left using the
          appropriate operation "*" in numerics.generic_complex_types.
          The index range of the result is Right'Range.

87/2
     function "*" (Left : Complex_Vector;
                   Right : Real'Base) return Complex_Vector;
     function "/" (Left : Complex_Vector;
                   Right : Real'Base) return Complex_Vector;

88/2
          Each operation returns the result of applying the
          corresponding operation in numerics.generic_complex_types to
          each component of the vector Left and the real number Right.
          The index range of the result is Left'Range.

89/2
     function Unit_Vector (Index : Integer;
                           Order : Positive;
                           First : Integer := 1) return Complex_Vector;

90/2
          This function returns a <unit vector> with Order components
          and a lower bound of First.  All components are set to (0.0,
          0.0) except for the Index component which is set to (1.0,
          0.0).  Constraint_Error is raised if Index < First, Index >
          First + Order - 1, or if First + Order - 1 > Integer'Last.

91/2
     function Re (X : Complex_Matrix) return Real_Matrix;
     function Im (X : Complex_Matrix) return Real_Matrix;

92/2
          Each function returns a matrix of the specified Cartesian
          components of X. The index ranges of the result are those of
          X.

93/2
     procedure Set_Re (X : in out Complex_Matrix; Re : in Real_Matrix);
     procedure Set_Im (X : in out Complex_Matrix; Im : in Real_Matrix);

94/2
          Each procedure replaces the specified (Cartesian) component of
          each of the components of X by the value of the matching
          component of Re or Im; the other (Cartesian) component of each
          of the components is unchanged.  Constraint_Error is raised if
          X'Length(1) is not equal to Re'Length(1) or Im'Length(1) or if
          X'Length(2) is not equal to Re'Length(2) or Im'Length(2).

95/2
     function Compose_From_Cartesian (Re     : Real_Matrix)
        return Complex_Matrix;
     function Compose_From_Cartesian (Re, Im : Real_Matrix)
        return Complex_Matrix;

96/2
          Each function constructs a matrix of Complex results (in
          Cartesian representation) formed from given matrices of
          Cartesian components; when only the real components are given,
          imaginary components of zero are assumed.  The index ranges of
          the result are those of Re.  Constraint_Error is raised if
          Re'Length(1) is not equal to Im'Length(1) or Re'Length(2) is
          not equal to Im'Length(2).

97/2
     function Modulus  (X     : Complex_Matrix) return Real_Matrix;
     function "abs"    (Right : Complex_Matrix) return Real_Matrix
                                                   renames Modulus;
     function Argument (X     : Complex_Matrix) return Real_Matrix;
     function Argument (X     : Complex_Matrix;
                        Cycle : Real'Base)      return Real_Matrix;

98/2
          Each function calculates and returns a matrix of the specified
          polar components of X or Right using the corresponding
          function in numerics.generic_complex_types.  The index ranges
          of the result are those of X or Right.

99/2
     function Compose_From_Polar (Modulus, Argument : Real_Matrix)
        return Complex_Matrix;
     function Compose_From_Polar (Modulus, Argument : Real_Matrix;
                                  Cycle             : Real'Base)
        return Complex_Matrix;

100/2
          Each function constructs a matrix of Complex results (in
          Cartesian representation) formed from given matrices of polar
          components using the corresponding function in
          numerics.generic_complex_types on matching components of
          Modulus and Argument.  The index ranges of the result are
          those of Modulus.  Constraint_Error is raised if
          Modulus'Length(1) is not equal to Argument'Length(1) or
          Modulus'Length(2) is not equal to Argument'Length(2).

101/2
     function "+" (Right : Complex_Matrix) return Complex_Matrix;
     function "-" (Right : Complex_Matrix) return Complex_Matrix;

102/2
          Each operation returns the result of applying the
          corresponding operation in numerics.generic_complex_types to
          each component of Right.  The index ranges of the result are
          those of Right.

103/2
     function Conjugate (X : Complex_Matrix) return Complex_Matrix;

104/2
          This function returns the result of applying the appropriate
          function Conjugate in numerics.generic_complex_types to each
          component of X. The index ranges of the result are those of X.

105/2
     function Transpose (X : Complex_Matrix) return Complex_Matrix;

106/2
          This function returns the transpose of a matrix X. The first
          and second index ranges of the result are X'Range(2) and
          X'Range(1) respectively.

107/2
     function "+" (Left, Right : Complex_Matrix) return Complex_Matrix;
     function "-" (Left, Right : Complex_Matrix) return Complex_Matrix;

108/2
          Each operation returns the result of applying the
          corresponding operation in numerics.generic_complex_types to
          each component of Left and the matching component of Right.
          The index ranges of the result are those of Left.
          Constraint_Error is raised if Left'Length(1) is not equal to
          Right'Length(1) or Left'Length(2) is not equal to
          Right'Length(2).

109/2
     function "*" (Left, Right : Complex_Matrix) return Complex_Matrix;

110/2
          This operation provides the standard mathematical operation
          for matrix multiplication.  The first and second index ranges
          of the result are Left'Range(1) and Right'Range(2)
          respectively.  Constraint_Error is raised if Left'Length(2) is
          not equal to Right'Length(1).  This operation involves inner
          products.

111/2
     function "*" (Left, Right : Complex_Vector) return Complex_Matrix;

112/2
          This operation returns the outer product of a (column) vector
          Left by a (row) vector Right using the appropriate operation
          "*" in numerics.generic_complex_types for computing the
          individual components.  The first and second index ranges of
          the result are Left'Range and Right'Range respectively.

113/2
     function "*" (Left  : Complex_Vector;
                   Right : Complex_Matrix) return Complex_Vector;

114/2
          This operation provides the standard mathematical operation
          for multiplication of a (row) vector Left by a matrix Right.
          The index range of the (row) vector result is Right'Range(2).
          Constraint_Error is raised if Left'Length is not equal to
          Right'Length(1).  This operation involves inner products.

115/2
     function "*" (Left  : Complex_Matrix;
                   Right : Complex_Vector) return Complex_Vector;

116/2
          This operation provides the standard mathematical operation
          for multiplication of a matrix Left by a (column) vector
          Right.  The index range of the (column) vector result is
          Left'Range(1).  Constraint_Error is raised if Left'Length(2)
          is not equal to Right'Length.  This operation involves inner
          products.

117/2
     function "+" (Left  : Real_Matrix;
                   Right : Complex_Matrix) return Complex_Matrix;
     function "+" (Left  : Complex_Matrix;
                   Right : Real_Matrix)    return Complex_Matrix;
     function "-" (Left  : Real_Matrix;
                   Right : Complex_Matrix) return Complex_Matrix;
     function "-" (Left  : Complex_Matrix;
                   Right : Real_Matrix)    return Complex_Matrix;

118/2
          Each operation returns the result of applying the
          corresponding operation in numerics.generic_complex_types to
          each component of Left and the matching component of Right.
          The index ranges of the result are those of Left.
          Constraint_Error is raised if Left'Length(1) is not equal to
          Right'Length(1) or Left'Length(2) is not equal to
          Right'Length(2).

119/2
     function "*" (Left  : Real_Matrix;
                   Right : Complex_Matrix) return Complex_Matrix;
     function "*" (Left  : Complex_Matrix;
                   Right : Real_Matrix)    return Complex_Matrix;

120/2
          Each operation provides the standard mathematical operation
          for matrix multiplication.  The first and second index ranges
          of the result are Left'Range(1) and Right'Range(2)
          respectively.  Constraint_Error is raised if Left'Length(2) is
          not equal to Right'Length(1).  These operations involve inner
          products.

121/2
     function "*" (Left  : Real_Vector;
                   Right : Complex_Vector) return Complex_Matrix;
     function "*" (Left  : Complex_Vector;
                   Right : Real_Vector)    return Complex_Matrix;

122/2
          Each operation returns the outer product of a (column) vector
          Left by a (row) vector Right using the appropriate operation
          "*" in numerics.generic_complex_types for computing the
          individual components.  The first and second index ranges of
          the result are Left'Range and Right'Range respectively.

123/2
     function "*" (Left  : Real_Vector;
                   Right : Complex_Matrix) return Complex_Vector;
     function "*" (Left  : Complex_Vector;
                   Right : Real_Matrix)    return Complex_Vector;

124/2
          Each operation provides the standard mathematical operation
          for multiplication of a (row) vector Left by a matrix Right.
          The index range of the (row) vector result is Right'Range(2).
          Constraint_Error is raised if Left'Length is not equal to
          Right'Length(1).  These operations involve inner products.

125/2
     function "*" (Left  : Real_Matrix;
                   Right : Complex_Vector) return Complex_Vector;
     function "*" (Left  : Complex_Matrix;
                   Right : Real_Vector)    return Complex_Vector;

126/2
          Each operation provides the standard mathematical operation
          for multiplication of a matrix Left by a (column) vector
          Right.  The index range of the (column) vector result is
          Left'Range(1).  Constraint_Error is raised if Left'Length(2)
          is not equal to Right'Length.  These operations involve inner
          products.

127/2
     function "*" (Left : Complex; Right : Complex_Matrix) return Complex_Matrix;

128/2
          This operation returns the result of multiplying each
          component of Right by the complex number Left using the
          appropriate operation "*" in numerics.generic_complex_types.
          The index ranges of the result are those of Right.

129/2
     function "*" (Left : Complex_Matrix; Right : Complex) return Complex_Matrix;
     function "/" (Left : Complex_Matrix; Right : Complex) return Complex_Matrix;

130/2
          Each operation returns the result of applying the
          corresponding operation in numerics.generic_complex_types to
          each component of the matrix Left and the complex number
          Right.  The index ranges of the result are those of Left.

131/2
     function "*" (Left : Real'Base;
                   Right : Complex_Matrix) return Complex_Matrix;

132/2
          This operation returns the result of multiplying each
          component of Right by the real number Left using the
          appropriate operation "*" in numerics.generic_complex_types.
          The index ranges of the result are those of Right.

133/2
     function "*" (Left : Complex_Matrix;
                   Right : Real'Base) return Complex_Matrix;
     function "/" (Left : Complex_Matrix;
                   Right : Real'Base) return Complex_Matrix;

134/2
          Each operation returns the result of applying the
          corresponding operation in numerics.generic_complex_types to
          each component of the matrix Left and the real number Right.
          The index ranges of the result are those of Left.

135/2
     function Solve (A : Complex_Matrix; X : Complex_Vector) return Complex_Vector;

136/2
          This function returns a vector Y such that X is (nearly) equal
          to A * Y. This is the standard mathematical operation for
          solving a single set of linear equations.  The index range of
          the result is A'Range(2).  Constraint_Error is raised if
          A'Length(1), A'Length(2), and X'Length are not equal.
          Constraint_Error is raised if the matrix A is ill-conditioned.

137/2
     function Solve (A, X : Complex_Matrix) return Complex_Matrix;

138/2
          This function returns a matrix Y such that X is (nearly) equal
          to A * Y. This is the standard mathematical operation for
          solving several sets of linear equations.  The index ranges of
          the result are A'Range(2) and X'Range(2).  Constraint_Error is
          raised if A'Length(1), A'Length(2), and X'Length(1) are not
          equal.  Constraint_Error is raised if the matrix A is
          ill-conditioned.

139/2
     function Inverse (A : Complex_Matrix) return Complex_Matrix;

140/2
          This function returns a matrix B such that A * B is (nearly)
          equal to the unit matrix.  The index ranges of the result are
          A'Range(2) and A'Range(1).  Constraint_Error is raised if
          A'Length(1) is not equal to A'Length(2).  Constraint_Error is
          raised if the matrix A is ill-conditioned.

141/2
     function Determinant (A : Complex_Matrix) return Complex;

142/2
          This function returns the determinant of the matrix A.
          Constraint_Error is raised if A'Length(1) is not equal to
          A'Length(2).

143/2
     function Eigenvalues(A : Complex_Matrix) return Real_Vector;

144/2
          This function returns the eigenvalues of the Hermitian matrix
          A as a vector sorted into order with the largest first.
          Constraint_Error is raised if A'Length(1) is not equal to
          A'Length(2).  The index range of the result is A'Range(1).
          Argument_Error is raised if the matrix A is not Hermitian.

145/2
     procedure Eigensystem(A       : in  Complex_Matrix;
                           Values  :  out Real_Vector;
                           Vectors :  out Complex_Matrix);

146/3
          This procedure computes both the eigenvalues and eigenvectors
          of the Hermitian matrix A. The out parameter Values is the
          same as that obtained by calling the function Eigenvalues.
          The out parameter Vectors is a matrix whose columns are the
          eigenvectors of the matrix A. The order of the columns
          corresponds to the order of the eigenvalues.  The eigenvectors
          are mutually orthonormal, including when there are repeated
          eigenvalues.  Constraint_Error is raised if A'Length(1) is not
          equal to A'Length(2), or if Values'Range is not equal to
          A'Range(1), or if the index ranges of the parameter Vectors
          are not equal to those of A. Argument_Error is raised if the
          matrix A is not Hermitian.  Constraint_Error is also raised in
          implementation-defined circumstances if the algorithm used
          does not converge quickly enough.

147/2
     function Unit_Matrix (Order            : Positive;
                           First_1, First_2 : Integer := 1)
                                              return Complex_Matrix;

148/2
          This function returns a square <unit matrix> with Order**2
          components and lower bounds of First_1 and First_2 (for the
          first and second index ranges respectively).  All components
          are set to (0.0, 0.0) except for the main diagonal, whose
          components are set to (1.0, 0.0).  Constraint_Error is raised
          if First_1 + Order - 1 > Integer'Last or First_2 + Order - 1 >
          Integer'Last.

                     _Implementation Requirements_

149/2
Accuracy requirements for the subprograms Solve, Inverse, Determinant,
Eigenvalues and Eigensystem are implementation defined.

150/2
For operations not involving an inner product, the accuracy requirements
are those of the corresponding operations of the type Real'Base and
Complex in both the strict mode and the relaxed mode (see *note G.2::).

151/2
For operations involving an inner product, no requirements are specified
in the relaxed mode.  In the strict mode the modulus of the absolute
error of the inner product <X>*<Y> shall not exceed
<g>*abs(<X>)*abs(<Y>) where <g> is defined as

152/2
     <g> = <X>'Length * Real'Machine_Radix**(1 - Real'Model_Mantissa)
         for mixed complex and real operands

153/2
     <g> = sqrt(2.0) * <X>'Length * Real'Machine_Radix**(1 - Real'Model_Mantissa)
         for two complex operands

154/2
For the L2-norm, no accuracy requirements are specified in the relaxed
mode.  In the strict mode the relative error on the norm shall not
exceed <g> / 2.0 + 3.0 * Real'Model_Epsilon where <g> has the definition
appropriate for two complex operands.

                     _Documentation Requirements_

155/2
Implementations shall document any techniques used to reduce
cancellation errors such as extended precision arithmetic.

                     _Implementation Permissions_

156/2
The nongeneric equivalent packages may, but need not, be actual
instantiations of the generic package for the appropriate predefined
type.

157/2
Although many operations are defined in terms of operations from
numerics.generic_complex_types, they need not be implemented by calling
those operations provided that the effect is the same.

                        _Implementation Advice_

158/3
Implementations should implement the Solve and Inverse functions using
established techniques.  Implementations are recommended to refine the
result by performing an iteration on the residuals; if this is done,
then it should be documented.

159/2
It is not the intention that any special provision should be made to
determine whether a matrix is ill-conditioned or not.  The naturally
occurring overflow (including division by zero) which will result from
executing these functions with an ill-conditioned matrix and thus raise
Constraint_Error is sufficient.

160/2
The test that a matrix is Hermitian should use the equality operator to
compare the real components and negation followed by equality to compare
the imaginary components (see *note G.2.1::).

160.1/3
An implementation should minimize the circumstances under which the
algorithm used for Eigenvalues and Eigensystem fails to converge.

161/2
Implementations should not perform operations on mixed complex and real
operands by first converting the real operand to complex.  See *note
G.1.1::.


File: arm2012.info,  Node: Annex H,  Next: Annex J,  Prev: Annex G,  Up: Top

Annex H High Integrity Systems
******************************

1/2
This Annex addresses requirements for high integrity systems (including
safety-critical systems and security-critical systems).  It provides
facilities and specifies documentation requirements that relate to
several needs:

2
   * Understanding program execution;

3
   * Reviewing object code;

4
   * Restricting language constructs whose usage might complicate the
     demonstration of program correctness

4.1
Execution understandability is supported by pragma Normalize_Scalars,
and also by requirements for the implementation to document the effect
of a program in the presence of a bounded error or where the language
rules leave the effect unspecified.  

5
The pragmas Reviewable and Restrictions relate to the other requirements
addressed by this Annex.

     NOTES

6
     1  The Valid attribute (see *note 13.9.2::) is also useful in
     addressing these needs, to avoid problems that could otherwise
     arise from scalars that have values outside their declared range
     constraints.

* Menu:

* H.1 ::      Pragma Normalize_Scalars
* H.2 ::      Documentation of Implementation Decisions
* H.3 ::      Reviewable Object Code
* H.4 ::      High Integrity Restrictions
* H.5 ::      Pragma Detect_Blocking
* H.6 ::      Pragma Partition_Elaboration_Policy


File: arm2012.info,  Node: H.1,  Next: H.2,  Up: Annex H

H.1 Pragma Normalize_Scalars
============================

1
This pragma ensures that an otherwise uninitialized scalar object is set
to a predictable value, but out of range if possible.

                               _Syntax_

2
     The form of a pragma Normalize_Scalars is as follows:

3
       pragma Normalize_Scalars;

                       _Post-Compilation Rules_

4
Pragma Normalize_Scalars is a configuration pragma.  It applies to all
compilation_units included in a partition.

                     _Documentation Requirements_

5/2
If a pragma Normalize_Scalars applies, the implementation shall document
the implicit initial values for scalar subtypes, and shall identify each
case in which such a value is used and is not an invalid representation.

                        _Implementation Advice_

6/2
Whenever possible, the implicit initial values for a scalar subtype
should be an invalid representation (see *note 13.9.1::).

     NOTES

7
     2  The initialization requirement applies to uninitialized scalar
     objects that are subcomponents of composite objects, to allocated
     objects, and to stand-alone objects.  It also applies to scalar out
     parameters.  Scalar subcomponents of composite out parameters are
     initialized to the corresponding part of the actual, by virtue of
     *note 6.4.1::.

8
     3  The initialization requirement does not apply to a scalar for
     which pragma Import has been specified, since initialization of an
     imported object is performed solely by the foreign language
     environment (see *note B.1::).

9
     4  The use of pragma Normalize_Scalars in conjunction with Pragma
     Restrictions(No_Exceptions) may result in erroneous execution (see
     *note H.4::).


File: arm2012.info,  Node: H.2,  Next: H.3,  Prev: H.1,  Up: Annex H

H.2 Documentation of Implementation Decisions
=============================================

                     _Documentation Requirements_

1
The implementation shall document the range of effects for each
situation that the language rules identify as either a bounded error or
as having an unspecified effect.  If the implementation can constrain
the effects of erroneous execution for a given construct, then it shall
document such constraints.  The documentation might be provided either
independently of any compilation unit or partition, or as part of an
annotated listing for a given unit or partition.  See also *note
1.1.3::, and *note 1.1.2::.

     NOTES

2
     5  Among the situations to be documented are the conventions chosen
     for parameter passing, the methods used for the management of
     run-time storage, and the method used to evaluate numeric
     expressions if this involves extended range or extra precision.


File: arm2012.info,  Node: H.3,  Next: H.4,  Prev: H.2,  Up: Annex H

H.3 Reviewable Object Code
==========================

1
Object code review and validation are supported by pragmas Reviewable
and Inspection_Point.

* Menu:

* H.3.1 ::    Pragma Reviewable
* H.3.2 ::    Pragma Inspection_Point


File: arm2012.info,  Node: H.3.1,  Next: H.3.2,  Up: H.3

H.3.1 Pragma Reviewable
-----------------------

1
This pragma directs the implementation to provide information to
facilitate analysis and review of a program's object code, in particular
to allow determination of execution time and storage usage and to
identify the correspondence between the source and object programs.

                               _Syntax_

2
     The form of a pragma Reviewable is as follows:

3
       pragma Reviewable;

                       _Post-Compilation Rules_

4
Pragma Reviewable is a configuration pragma.  It applies to all
compilation_units included in a partition.

                     _Implementation Requirements_

5
The implementation shall provide the following information for any
compilation unit to which such a pragma applies:

6
   * Where compiler-generated run-time checks remain;

7
   * An identification of any construct with a language-defined check
     that is recognized prior to run time as certain to fail if executed
     (even if the generation of run-time checks has been suppressed);

8/2
   * For each read of a scalar object, an identification of the read as
     either "known to be initialized," or "possibly uninitialized,"
     independent of whether pragma Normalize_Scalars applies;

9
   * Where run-time support routines are implicitly invoked;

10
   * An object code listing, including:

11
             * Machine instructions, with relative offsets;

12
             * Where each data object is stored during its lifetime;

13
             * Correspondence with the source program, including an
               identification of the code produced per declaration and
               per statement.

14
   * An identification of each construct for which the implementation
     detects the possibility of erroneous execution;

15
   * For each subprogram, block, task, or other construct implemented by
     reserving and subsequently freeing an area on a run-time stack, an
     identification of the length of the fixed-size portion of the area
     and an indication of whether the non-fixed size portion is reserved
     on the stack or in a dynamically-managed storage region.

16
The implementation shall provide the following information for any
partition to which the pragma applies:

17
   * An object code listing of the entire partition, including
     initialization and finalization code as well as run-time system
     components, and with an identification of those instructions and
     data that will be relocated at load time;

18
   * A description of the run-time model relevant to the partition.

18.1
The implementation shall provide control- and data-flow information,
both within each compilation unit and across the compilation units of
the partition.

                        _Implementation Advice_

19
The implementation should provide the above information in both a
human-readable and machine-readable form, and should document the latter
so as to ease further processing by automated tools.

20
Object code listings should be provided both in a symbolic format and
also in an appropriate numeric format (such as hexadecimal or octal).

     NOTES

21
     6  The order of elaboration of library units will be documented
     even in the absence of pragma Reviewable (see *note 10.2::).


File: arm2012.info,  Node: H.3.2,  Prev: H.3.1,  Up: H.3

H.3.2 Pragma Inspection_Point
-----------------------------

1
An occurrence of a pragma Inspection_Point identifies a set of objects
each of whose values is to be available at the point(s) during program
execution corresponding to the position of the pragma in the compilation
unit.  The purpose of such a pragma is to facilitate code validation.

                               _Syntax_

2
     The form of a pragma Inspection_Point is as follows:

3
       pragma Inspection_Point[(<object_>name {, <object_>name})];

                           _Legality Rules_

4
A pragma Inspection_Point is allowed wherever a declarative_item or
statement is allowed.  Each <object_>name shall statically denote the
declaration of an object.

                          _Static Semantics_

5/2
An <inspection point> is a point in the object code corresponding to the
occurrence of a pragma Inspection_Point in the compilation unit.  An
object is <inspectable> at an inspection point if the corresponding
pragma Inspection_Point either has an argument denoting that object, or
has no arguments and the declaration of the object is visible at the
inspection point.

                          _Dynamic Semantics_

6
Execution of a pragma Inspection_Point has no effect.

                     _Implementation Requirements_

7
Reaching an inspection point is an external interaction with respect to
the values of the inspectable objects at that point (see *note 1.1.3::).

                     _Documentation Requirements_

8
For each inspection point, the implementation shall identify a mapping
between each inspectable object and the machine resources (such as
memory locations or registers) from which the object's value can be
obtained.

     NOTES

9/2
     7  The implementation is not allowed to perform "dead store
     elimination" on the last assignment to a variable prior to a point
     where the variable is inspectable.  Thus an inspection point has
     the effect of an implicit read of each of its inspectable objects.

10
     8  Inspection points are useful in maintaining a correspondence
     between the state of the program in source code terms, and the
     machine state during the program's execution.  Assertions about the
     values of program objects can be tested in machine terms at
     inspection points.  Object code between inspection points can be
     processed by automated tools to verify programs mechanically.

11
     9  The identification of the mapping from source program objects to
     machine resources is allowed to be in the form of an annotated
     object listing, in human-readable or tool-processable form.


File: arm2012.info,  Node: H.4,  Next: H.5,  Prev: H.3,  Up: Annex H

H.4 High Integrity Restrictions
===============================

1/3
This subclause defines restrictions that can be used with pragma
Restrictions (see *note 13.12::); these facilitate the demonstration of
program correctness by allowing tailored versions of the run-time
system.

                          _Static Semantics_

2/2
<This paragraph was deleted.>

3/2
The following <restriction_>identifiers are language defined:

4
Tasking-related restriction:

5
No_Protected_Types
               There are no declarations of protected types or protected
               objects.

6
Memory-management related restrictions:

7
No_Allocators
               There are no occurrences of an allocator.

8/1
No_Local_Allocators
               Allocators are prohibited in subprograms, generic
               subprograms, tasks, and entry bodies.

8.1/3
No_Anonymous_Allocators
               There are no allocators of anonymous access types.

8.2/3
No_Coextensions
               There are no coextensions.  See *note 3.10.2::.

8.3/3
No_Access_Parameter_Allocators
               Allocators are not permitted as the actual parameter to
               an access parameter.  See *note 6.1::.

9/2

               <This paragraph was deleted.>

10
Immediate_Reclamation
               Except for storage occupied by objects created by
               allocators and not deallocated via unchecked
               deallocation, any storage reserved at run time for an
               object is immediately reclaimed when the object no longer
               exists.  

11
Exception-related restriction:

12
No_Exceptions
               Raise_statements and exception_handlers are not allowed.
               No language-defined run-time checks are generated;
               however, a run-time check performed automatically by the
               hardware is permitted.

13
Other restrictions:

14
No_Floating_Point
               Uses of predefined floating point types and operations,
               and declarations of new floating point types, are not
               allowed.

15
No_Fixed_Point
               Uses of predefined fixed point types and operations, and
               declarations of new fixed point types, are not allowed.

16/2

               <This paragraph was deleted.>

17
No_Access_Subprograms
               The declaration of access-to-subprogram types is not
               allowed.  

18
No_Unchecked_Access
               The Unchecked_Access attribute is not allowed.

19
No_Dispatch
               Occurrences of T'Class are not allowed, for any (tagged)
               subtype T.

20/2
No_IO
               Semantic dependence on any of the library units
               Sequential_IO, Direct_IO, Text_IO, Wide_Text_IO,
               Wide_Wide_Text_IO, or Stream_IO is not allowed.

21
No_Delay
               Delay_Statements and semantic dependence on package
               Calendar are not allowed.

22
No_Recursion
               As part of the execution of a subprogram, the same
               subprogram is not invoked.

23
No_Reentrancy
               During the execution of a subprogram by a task, no other
               task invokes the same subprogram.

                     _Implementation Requirements_

23.1/2
An implementation of this Annex shall support:

23.2/2
   * the restrictions defined in this subclause; and

23.3/3
   * the following restrictions defined in *note D.7:::
     No_Task_Hierarchy, No_Abort_Statement, No_Implicit_Heap_Allocation,
     No_Standard_Allocators_After_Elaboration; and

23.4/2
   * the pragma Profile(Ravenscar); and

23.5/2
   * the following uses of <restriction_parameter_>identifiers defined
     in *note D.7::, which are checked prior to program execution:

23.6/2
             * Max_Task_Entries => 0,

23.7/2
             * Max_Asynchronous_Select_Nesting => 0, and

23.8/2
             * Max_Tasks => 0.

24/3
If an implementation supports pragma Restrictions for a particular
argument, then except for the restrictions No_Unchecked_Deallocation,
No_Unchecked_Conversion, No_Access_Subprograms, No_Unchecked_Access,
No_Specification_of_Aspect, No_Use_of_Attribute, No_Use_of_Pragma, and
the equivalent use of No_Dependence, the associated restriction applies
to the run-time system.

                     _Documentation Requirements_

25
If a pragma Restrictions(No_Exceptions) is specified, the implementation
shall document the effects of all constructs where language-defined
checks are still performed automatically (for example, an overflow check
performed by the processor).

                         _Erroneous Execution_

26
Program execution is erroneous if pragma Restrictions(No_Exceptions) has
been specified and the conditions arise under which a generated
language-defined run-time check would fail.

27
Program execution is erroneous if pragma Restrictions(No_Recursion) has
been specified and a subprogram is invoked as part of its own execution,
or if pragma Restrictions(No_Reentrancy) has been specified and during
the execution of a subprogram by a task, another task invokes the same
subprogram.

     NOTES

28/2
     10  Uses of <restriction_parameter_>identifier No_Dependence
     defined in *note 13.12.1::: No_Dependence =>
     Ada.Unchecked_Deallocation and No_Dependence =>
     Ada.Unchecked_Conversion may be appropriate for high-integrity
     systems.  Other uses of No_Dependence can also be appropriate for
     high-integrity systems.


File: arm2012.info,  Node: H.5,  Next: H.6,  Prev: H.4,  Up: Annex H

H.5 Pragma Detect_Blocking
==========================

1/2
The following pragma forces an implementation to detect potentially
blocking operations within a protected operation.

                               _Syntax_

2/2
     The form of a pragma Detect_Blocking is as follows:

3/2
       pragma Detect_Blocking;

                       _Post-Compilation Rules_

4/2
A pragma Detect_Blocking is a configuration pragma.

                          _Dynamic Semantics_

5/2
An implementation is required to detect a potentially blocking operation
within a protected operation, and to raise Program_Error (see *note
9.5.1::).

                     _Implementation Permissions_

6/2
An implementation is allowed to reject a compilation_unit if a
potentially blocking operation is present directly within an entry_body
or the body of a protected subprogram.

     NOTES

7/2
     11  An operation that causes a task to be blocked within a foreign
     language domain is not defined to be potentially blocking, and need
     not be detected.


File: arm2012.info,  Node: H.6,  Prev: H.5,  Up: Annex H

H.6 Pragma Partition_Elaboration_Policy
=======================================

1/3
This subclause defines a pragma for user control over elaboration
policy.

                               _Syntax_

2/2
     The form of a pragma Partition_Elaboration_Policy is as follows:

3/2
       pragma Partition_Elaboration_Policy (<policy_>identifier);

4/2
     The <policy_>identifier shall be either Sequential, Concurrent or
     an implementation-defined identifier.

                       _Post-Compilation Rules_

5/2
A pragma Partition_Elaboration_Policy is a configuration pragma.  It
specifies the elaboration policy for a partition.  At most one
elaboration policy shall be specified for a partition.

6/3
If the Sequential policy is specified for a partition, then pragma
Restrictions (No_Task_Hierarchy) shall also be specified for the
partition.

                          _Dynamic Semantics_

7/2
Notwithstanding what this International Standard says elsewhere, this
pragma allows partition elaboration rules concerning task activation and
interrupt attachment to be changed.  If the <policy_>identifier is
Concurrent, or if there is no pragma Partition_Elaboration_Policy
defined for the partition, then the rules defined elsewhere in this
Standard apply.

8/2
If the partition elaboration policy is Sequential, then task activation
and interrupt attachment are performed in the following sequence of
steps:

9/2
   * The activation of all library-level tasks and the attachment of
     interrupt handlers are deferred until all library units are
     elaborated.

10/2
   * The interrupt handlers are attached by the environment task.

11/2
   * The environment task is suspended while the library-level tasks are
     activated.

12/2
   * The environment task executes the main subprogram (if any)
     concurrently with these executing tasks.

13/2
If several dynamic interrupt handler attachments for the same interrupt
are deferred, then the most recent call of Attach_Handler or
Exchange_Handler determines which handler is attached.

14/2
If any deferred task activation fails, Tasking_Error is raised at the
beginning of the sequence of statements of the body of the environment
task prior to calling the main subprogram.

                        _Implementation Advice_

15/3
If the partition elaboration policy is Sequential and the Environment
task becomes permanently blocked during elaboration, then the partition
is deadlocked and it is recommended that the partition be immediately
terminated.

                     _Implementation Permissions_

16/3
If the partition elaboration policy is Sequential and any task
activation fails, then an implementation may immediately terminate the
active partition to mitigate the hazard posed by continuing to execute
with a subset of the tasks being active.

     NOTES

17/2
     12  If any deferred task activation fails, the environment task is
     unable to handle the Tasking_Error exception and completes
     immediately.  By contrast, if the partition elaboration policy is
     Concurrent, then this exception could be handled within a library
     unit.


File: arm2012.info,  Node: Annex J,  Next: Annex K,  Prev: Annex H,  Up: Top

Annex J Obsolescent Features
****************************

1/2
This Annex contains descriptions of features of the language whose
functionality is largely redundant with other features defined by this
International Standard.  Use of these features is not recommended in
newly written programs.  Use of these features can be prevented by using
pragma Restrictions (No_Obsolescent_Features), see *note 13.12.1::.

* Menu:

* J.1 ::      Renamings of Library Units
* J.2 ::      Allowed Replacements of Characters
* J.3 ::      Reduced Accuracy Subtypes
* J.4 ::      The Constrained Attribute
* J.5 ::      ASCII
* J.6 ::      Numeric_Error
* J.7 ::      At Clauses
* J.8 ::      Mod Clauses
* J.9 ::      The Storage_Size Attribute
* J.10 ::     Specific Suppression of Checks
* J.11 ::     The Class Attribute of Untagged Incomplete Types
* J.12 ::     Pragma Interface
* J.13 ::     Dependence Restriction Identifiers
* J.14 ::     Character and Wide_Character Conversion Functions
* J.15 ::     Aspect-related Pragmas


File: arm2012.info,  Node: J.1,  Next: J.2,  Up: Annex J

J.1 Renamings of Library Units
==============================

                          _Static Semantics_

1
The following library_unit_renaming_declarations exist:

2
     with Ada.Unchecked_Conversion;
     generic function Unchecked_Conversion renames Ada.Unchecked_Conversion;

3
     with Ada.Unchecked_Deallocation;
     generic procedure Unchecked_Deallocation renames Ada.Unchecked_Deallocation;

4
     with Ada.Sequential_IO;
     generic package Sequential_IO renames Ada.Sequential_IO;

5
     with Ada.Direct_IO;
     generic package Direct_IO renames Ada.Direct_IO;

6
     with Ada.Text_IO;
     package Text_IO renames Ada.Text_IO;

7
     with Ada.IO_Exceptions;
     package IO_Exceptions renames Ada.IO_Exceptions;

8
     with Ada.Calendar;
     package Calendar renames Ada.Calendar;

9
     with System.Machine_Code;
     package Machine_Code renames System.Machine_Code; --< If supported.>

                     _Implementation Requirements_

10
The implementation shall allow the user to replace these renamings.


File: arm2012.info,  Node: J.2,  Next: J.3,  Prev: J.1,  Up: Annex J

J.2 Allowed Replacements of Characters
======================================

                               _Syntax_

1
     The following replacements are allowed for the vertical line,
     number sign, and quotation mark characters:

2
        * A vertical line character (|) can be replaced by an
          exclamation mark (!)  where used as a delimiter.

3
        * The number sign characters (#) of a based_literal can be
          replaced by colons (:) provided that the replacement is done
          for both occurrences.

4
        * The quotation marks (") used as string brackets at both ends
          of a string literal can be replaced by percent signs (%)
          provided that the enclosed sequence of characters contains no
          quotation mark, and provided that both string brackets are
          replaced.  Any percent sign within the sequence of characters
          shall then be doubled and each such doubled percent sign is
          interpreted as a single percent sign character value.

5
     These replacements do not change the meaning of the program.


File: arm2012.info,  Node: J.3,  Next: J.4,  Prev: J.2,  Up: Annex J

J.3 Reduced Accuracy Subtypes
=============================

1
A digits_constraint may be used to define a floating point subtype with
a new value for its requested decimal precision, as reflected by its
Digits attribute.  Similarly, a delta_constraint may be used to define
an ordinary fixed point subtype with a new value for its <delta>, as
reflected by its Delta attribute.

                               _Syntax_

2/4
     delta_constraint ::= delta <static_>simple_expression [
     range_constraint]

                        _Name Resolution Rules_

3/4
The simple_expression of a delta_constraint is expected to be of any
real type.

                           _Legality Rules_

4/4
The simple_expression of a delta_constraint shall be static.

5
For a subtype_indication with a delta_constraint, the subtype_mark shall
denote an ordinary fixed point subtype.

6
For a subtype_indication with a digits_constraint, the subtype_mark
shall denote either a decimal fixed point subtype or a floating point
subtype (notwithstanding the rule given in *note 3.5.9:: that only
allows a decimal fixed point subtype).

                          _Static Semantics_

7/4
A subtype_indication with a subtype_mark that denotes an ordinary fixed
point subtype and a delta_constraint defines an ordinary fixed point
subtype with a <delta> given by the value of the simple_expression of
the delta_constraint.  If the delta_constraint includes a
range_constraint (*note 3.5: S0036.), then the ordinary fixed point
subtype is constrained by the range_constraint (*note 3.5: S0036.).

8/4
A subtype_indication with a subtype_mark that denotes a floating point
subtype and a digits_constraint defines a floating point subtype with a
requested decimal precision (as reflected by its Digits attribute) given
by the value of the simple_expression of the digits_constraint.  If the
digits_constraint includes a range_constraint (*note 3.5: S0036.), then
the floating point subtype is constrained by the range_constraint (*note
3.5: S0036.).

                          _Dynamic Semantics_

9/4
A delta_constraint is <compatible> with an ordinary fixed point subtype
if the value of the simple_expression is no less than the <delta> of the
subtype, and the range_constraint, if any, is compatible with the
subtype.

10/4
A digits_constraint is <compatible> with a floating point subtype if the
value of the simple_expression is no greater than the requested decimal
precision of the subtype, and the range_constraint, if any, is
compatible with the subtype.

11
The elaboration of a delta_constraint consists of the elaboration of the
range_constraint, if any.


File: arm2012.info,  Node: J.4,  Next: J.5,  Prev: J.3,  Up: Annex J

J.4 The Constrained Attribute
=============================

                          _Static Semantics_

1
For every private subtype S, the following attribute is defined:

2
S'Constrained
               Yields the value False if S denotes an unconstrained
               nonformal private subtype with discriminants; also yields
               the value False if S denotes a generic formal private
               subtype, and the associated actual subtype is either an
               unconstrained subtype with discriminants or an
               unconstrained array subtype; yields the value True
               otherwise.  The value of this attribute is of the
               predefined subtype Boolean.


File: arm2012.info,  Node: J.5,  Next: J.6,  Prev: J.4,  Up: Annex J

J.5 ASCII
=========

                          _Static Semantics_

1
The following declaration exists in the declaration of package Standard:

2
     package ASCII is

3
       --<  Control characters:>

4
       NUL   : constant Character := <nul>;    SOH   : constant Character := <soh>;
       STX   : constant Character := <stx>;    ETX   : constant Character := <etx>;
       EOT   : constant Character := <eot>;    ENQ   : constant Character := <enq>;
       ACK   : constant Character := <ack>;    BEL   : constant Character := <bel>;
       BS    : constant Character := <bs>;    HT    : constant Character := <ht>;
       LF    : constant Character := <lf>;    VT    : constant Character := <vt>;
       FF    : constant Character := <ff>;    CR    : constant Character := <cr>;
       SO    : constant Character := <so>;    SI    : constant Character := <si>;
       DLE   : constant Character := <dle>;    DC1   : constant Character := <dc1>;
       DC2   : constant Character := <dc2>;    DC3   : constant Character := <dc3>;
       DC4   : constant Character := <dc4>;    NAK   : constant Character := <nak>;
       SYN   : constant Character := <syn>;    ETB   : constant Character := <etb>;
       CAN   : constant Character := <can>;    EM    : constant Character := <em>;
       SUB   : constant Character := <sub>;    ESC   : constant Character := <esc>;
       FS    : constant Character := <fs>;    GS    : constant Character := <gs>;
       RS    : constant Character := <rs>;    US    : constant Character := <us>;
       DEL   : constant Character := <del>;

5
       --< Other characters:>

6
       Exclam   : constant Character:= '!';   Quotation : constant Character:= '"';
       Sharp    : constant Character:= '#';   Dollar    : constant Character:= '$';
       Percent  : constant Character:= '%';   Ampersand : constant Character:= '&';
       Colon    : constant Character:= ':';   Semicolon : constant Character:= ';';
       Query    : constant Character:= '?';   At_Sign   : constant Character:= '@';
       L_Bracket: constant Character:= '[';   Back_Slash: constant Character:= '\';
       R_Bracket: constant Character:= ']';   Circumflex: constant Character:= '^';
       Underline: constant Character:= '_';   Grave     : constant Character:= '`';
       L_Brace  : constant Character:= '{';   Bar       : constant Character:= '|';
       R_Brace  : constant Character:= '}';   Tilde     : constant Character:= '~';

7
       --< Lower case letters:>

8
       LC_A: constant Character:= 'a';
       ...
       LC_Z: constant Character:= 'z';

9
     end ASCII;


File: arm2012.info,  Node: J.6,  Next: J.7,  Prev: J.5,  Up: Annex J

J.6 Numeric_Error
=================

                          _Static Semantics_

1
The following declaration exists in the declaration of package Standard:

2
     Numeric_Error : exception renames Constraint_Error;


File: arm2012.info,  Node: J.7,  Next: J.8,  Prev: J.6,  Up: Annex J

J.7 At Clauses
==============

                               _Syntax_

1
     at_clause ::= for direct_name use at expression;

                          _Static Semantics_

2
An at_clause of the form "for <x> use at <y>;" is equivalent to an
attribute_definition_clause of the form "for <x>'Address use <y>;".

* Menu:

* J.7.1 ::    Interrupt Entries


File: arm2012.info,  Node: J.7.1,  Up: J.7

J.7.1 Interrupt Entries
-----------------------

1
Implementations are permitted to allow the attachment of task entries to
interrupts via the address clause.  Such an entry is referred to as an
<interrupt entry>.

2
The address of the task entry corresponds to a hardware interrupt in an
implementation-defined manner.  (See Ada.Interrupts.Reference in *note
C.3.2::.)

                          _Static Semantics_

3
The following attribute is defined:

4
For any task entry X:

5
X'Address
               For a task entry whose address is specified (an
               <interrupt entry>), the value refers to the corresponding
               hardware interrupt.  For such an entry, as for any other
               task entry, the meaning of this value is implementation
               defined.  The value of this attribute is of the type of
               the subtype System.Address.

6
               Address may be specified for single entries via an
               attribute_definition_clause.

                          _Dynamic Semantics_

7
As part of the initialization of a task object, the address clause for
an interrupt entry is elaborated, which evaluates the expression of the
address clause.  A check is made that the address specified is
associated with some interrupt to which a task entry may be attached.
If this check fails, Program_Error is raised.  Otherwise, the interrupt
entry is attached to the interrupt associated with the specified
address.

8
Upon finalization of the task object, the interrupt entry, if any, is
detached from the corresponding interrupt and the default treatment is
restored.

9
While an interrupt entry is attached to an interrupt, the interrupt is
reserved (see *note C.3::).

10
An interrupt delivered to a task entry acts as a call to the entry
issued by a hardware task whose priority is in the
System.Interrupt_Priority range.  It is implementation defined whether
the call is performed as an ordinary entry call, a timed entry call, or
a conditional entry call; which kind of call is performed can depend on
the specific interrupt.

                      _Bounded (Run-Time) Errors_

11
It is a bounded error to evaluate E'Caller (see *note C.7.1::) in an
accept_statement for an interrupt entry.  The possible effects are the
same as for calling Current_Task from an entry body.

                     _Documentation Requirements_

12
The implementation shall document to which interrupts a task entry may
be attached.

13
The implementation shall document whether the invocation of an interrupt
entry has the effect of an ordinary entry call, conditional call, or a
timed call, and whether the effect varies in the presence of pending
interrupts.

                     _Implementation Permissions_

14
The support for this subclause is optional.

15
Interrupts to which the implementation allows a task entry to be
attached may be designated as reserved for the entire duration of
program execution; that is, not just when they have an interrupt entry
attached to them.

16/1
Interrupt entry calls may be implemented by having the hardware execute
directly the appropriate accept_statement.  Alternatively, the
implementation is allowed to provide an internal interrupt handler to
simulate the effect of a normal task calling the entry.

17
The implementation is allowed to impose restrictions on the
specifications and bodies of tasks that have interrupt entries.

18
It is implementation defined whether direct calls (from the program) to
interrupt entries are allowed.

19
If a select_statement contains both a terminate_alternative and an
accept_alternative for an interrupt entry, then an implementation is
allowed to impose further requirements for the selection of the
terminate_alternative in addition to those given in *note 9.3::.

     NOTES

20/1
     1  Queued interrupts correspond to ordinary entry calls.
     Interrupts that are lost if not immediately processed correspond to
     conditional entry calls.  It is a consequence of the priority rules
     that an accept_statement executed in response to an interrupt can
     be executed with the active priority at which the hardware
     generates the interrupt, taking precedence over lower priority
     tasks, without a scheduling action.

21
     2  Control information that is supplied upon an interrupt can be
     passed to an associated interrupt entry as one or more parameters
     of mode in.

                              _Examples_

22
<Example of an interrupt entry:>

23
     task Interrupt_Handler is
       entry Done;
       for Done'Address use Ada.Interrupts.Reference(Ada.Interrupts.Names.Device_Done);
     end Interrupt_Handler;


File: arm2012.info,  Node: J.8,  Next: J.9,  Prev: J.7,  Up: Annex J

J.8 Mod Clauses
===============

                               _Syntax_

1
     mod_clause ::= at mod <static_>expression;

                          _Static Semantics_

2
A record_representation_clause of the form:

3/3
     for <r> use
         record at mod <a>;
             ...
         end record;

4
is equivalent to:

5
     for <r>'Alignment use <a>;
     for <r> use
         record
             ...
         end record;


File: arm2012.info,  Node: J.9,  Next: J.10,  Prev: J.8,  Up: Annex J

J.9 The Storage_Size Attribute
==============================

                          _Static Semantics_

1
For any task subtype T, the following attribute is defined:

2
T'Storage_Size
               Denotes an implementation-defined value of type
               <universal_integer> representing the number of storage
               elements reserved for a task of the subtype T.

3/3
               Storage_Size may be specified for a task first subtype
               that is not an interface via an
               attribute_definition_clause.  When the attribute is
               specified, the Storage_Size aspect is specified to be the
               value of the given expression.


File: arm2012.info,  Node: J.10,  Next: J.11,  Prev: J.9,  Up: Annex J

J.10 Specific Suppression of Checks
===================================

1/2
Pragma Suppress can be used to suppress checks on specific entities.

                               _Syntax_

2/2
     The form of a specific Suppress pragma is as follows:

3/2
       pragma Suppress(identifier, [On =>] name);

                           _Legality Rules_

4/2
The identifier shall be the name of a check (see *note 11.5::).  The
name shall statically denote some entity.

5/2
For a specific Suppress pragma that is immediately within a
package_specification, the name shall denote an entity (or several
overloaded subprograms) declared immediately within the
package_specification (*note 7.1: S0191.).

                          _Static Semantics_

6/2
A specific Suppress pragma applies to the named check from the place of
the pragma to the end of the innermost enclosing declarative region, or,
if the pragma is given in a package_specification, to the end of the
scope of the named entity.  The pragma applies only to the named entity,
or, for a subtype, on objects and values of its type.  A specific
Suppress pragma suppresses the named check for any entities to which it
applies (see *note 11.5::).  Which checks are associated with a specific
entity is not defined by this International Standard.

                     _Implementation Permissions_

7/2
An implementation is allowed to place restrictions on specific Suppress
pragmas.

     NOTES

8/2
     3  An implementation may support a similar On parameter on pragma
     Unsuppress (see *note 11.5::).


File: arm2012.info,  Node: J.11,  Next: J.12,  Prev: J.10,  Up: Annex J

J.11 The Class Attribute of Untagged Incomplete Types
=====================================================

                          _Static Semantics_

1/2
For the first subtype S of a type <T> declared by an
incomplete_type_declaration that is not tagged, the following attribute
is defined:

2/2
S'Class
               Denotes the first subtype of the incomplete class-wide
               type rooted at <T>.  The completion of <T> shall declare
               a tagged type.  Such an attribute reference shall occur
               in the same library unit as the
               incomplete_type_declaration.


File: arm2012.info,  Node: J.12,  Next: J.13,  Prev: J.11,  Up: Annex J

J.12 Pragma Interface
=====================

                               _Syntax_

1/2
     In addition to an identifier, the reserved word interface is
     allowed as a pragma name, to provide compatibility with a prior
     edition of this International Standard.


File: arm2012.info,  Node: J.13,  Next: J.14,  Prev: J.12,  Up: Annex J

J.13 Dependence Restriction Identifiers
=======================================

1/2
The following restrictions involve dependence on specific
language-defined units.  The more general restriction No_Dependence (see
*note 13.12.1::) should be used for this purpose.

                          _Static Semantics_

2/2
The following <restriction_>identifiers exist:

3/2
No_Asynchronous_Control
               Semantic dependence on the predefined package
               Asynchronous_Task_Control is not allowed.

4/2
No_Unchecked_Conversion
               Semantic dependence on the predefined generic function
               Unchecked_Conversion is not allowed.

5/2
No_Unchecked_Deallocation
               Semantic dependence on the predefined generic procedure
               Unchecked_Deallocation is not allowed.


File: arm2012.info,  Node: J.14,  Next: J.15,  Prev: J.13,  Up: Annex J

J.14 Character and Wide_Character Conversion Functions
======================================================

                          _Static Semantics_

1/2
The following declarations exist in the declaration of package
Ada.Characters.Handling:

2/2
        function Is_Character (Item : in Wide_Character) return Boolean
           renames Conversions.Is_Character;
        function Is_String    (Item : in Wide_String)    return Boolean
           renames Conversions.Is_String;

3/2
        function To_Character (Item       : in Wide_Character;
                              Substitute : in Character := ' ')
                              return Character
           renames Conversions.To_Character;

4/2
        function To_String    (Item       : in Wide_String;
                               Substitute : in Character := ' ')
                               return String
           renames Conversions.To_String;

5/2
        function To_Wide_Character (Item : in Character) return Wide_Character
           renames Conversions.To_Wide_Character;

6/2
        function To_Wide_String    (Item : in String)    return Wide_String
           renames Conversions.To_Wide_String;


File: arm2012.info,  Node: J.15,  Prev: J.14,  Up: Annex J

J.15 Aspect-related Pragmas
===========================

1/3
Pragmas can be used as an alternative to aspect_specifications to
specify certain aspects.

* Menu:

* J.15.1 ::   Pragma Inline
* J.15.2 ::   Pragma No_Return
* J.15.3 ::   Pragma Pack
* J.15.4 ::   Pragma Storage_Size
* J.15.5 ::   Interfacing Pragmas
* J.15.6 ::   Pragma Unchecked_Union
* J.15.7 ::   Pragmas Interrupt_Handler and Attach_Handler
* J.15.8 ::   Shared Variable Pragmas
* J.15.9 ::   Pragma CPU
* J.15.10 ::  Pragma Dispatching_Domain
* J.15.11 ::  Pragmas Priority and Interrupt_Priority
* J.15.12 ::  Pragma Relative_Deadline
* J.15.13 ::  Pragma Asynchronous


File: arm2012.info,  Node: J.15.1,  Next: J.15.2,  Up: J.15

J.15.1 Pragma Inline
--------------------

                               _Syntax_

1/3
     The form of a pragma Inline, which is a program unit pragma (see
     *note 10.1.5::), is as follows: 

2/3
       pragma Inline (name{, name});

                           _Legality Rules_

3/3
The pragma shall apply to one or more callable entities or generic
subprograms.

                          _Static Semantics_

4/3
Pragma Inline specifies that the Inline aspect (see *note 6.3.2::) for
each entity denoted by each name given in the pragma has the value True.

                     _Implementation Permissions_

5/3
An implementation may allow a pragma Inline that has an argument which
is a direct_name denoting a subprogram_body of the same
declarative_part.

     NOTES

6/3
     4  The name in a pragma Inline may denote more than one entity in
     the case of overloading.  Such a pragma applies to all of the
     denoted entities.


File: arm2012.info,  Node: J.15.2,  Next: J.15.3,  Prev: J.15.1,  Up: J.15

J.15.2 Pragma No_Return
-----------------------

                               _Syntax_

1/3
     The form of a pragma No_Return, which is a representation pragma
     (see *note 13.1::), is as follows: 

2/3
       pragma No_Return (<procedure_>local_name{, <procedure_>
     local_name});

                           _Legality Rules_

3/3
Each <procedure_>local_name shall denote one or more procedures or
generic procedures.  The <procedure_>local_name shall not denote a null
procedure nor an instance of a generic unit.

                          _Static Semantics_

4/3
Pragma No_Return specifies that the No_Return aspect (see *note 6.5.1::)
for each procedure denoted by each local_name given in the pragma has
the value True.


File: arm2012.info,  Node: J.15.3,  Next: J.15.4,  Prev: J.15.2,  Up: J.15

J.15.3 Pragma Pack
------------------

                               _Syntax_

1/3
     The form of a pragma Pack, which is a representation pragma (see
     *note 13.1::), is as follows: 

2/3
       pragma Pack (<first_subtype_>local_name);

                           _Legality Rules_

3/3
The <first_subtype_>local_name of a pragma Pack shall denote a composite
subtype.

                          _Static Semantics_

4/3
Pragma Pack specifies that the Pack aspect (see *note 13.2::) for the
type denoted by <first_subtype_>local_name has the value True.


File: arm2012.info,  Node: J.15.4,  Next: J.15.5,  Prev: J.15.3,  Up: J.15

J.15.4 Pragma Storage_Size
--------------------------

                               _Syntax_

1/3
     The form of a pragma Storage_Size is as follows:

2/3
       pragma Storage_Size (expression);

3/3
     A pragma Storage_Size is allowed only immediately within a
     task_definition.

                        _Name Resolution Rules_

4/3
The expression of a pragma Storage_Size is expected to be of any integer
type.

                          _Static Semantics_

5/3
The pragma Storage_Size sets the Storage_Size aspect (see *note 13.3::)
of the type defined by the immediately enclosing task_definition to the
value of the expression of the pragma.


File: arm2012.info,  Node: J.15.5,  Next: J.15.6,  Prev: J.15.4,  Up: J.15

J.15.5 Interfacing Pragmas
--------------------------

                               _Syntax_

1/3
     An <interfacing pragma> is a representation pragma that is one of
     the pragmas Import, Export, or Convention.  Their forms are as
     follows:

2/3
       pragma Import(
          [Convention =>] <convention_>identifier, [Entity =>]
     local_name
       [, [External_Name =>] <external_name_string_>expression]
       [, [Link_Name =>] <link_name_string_>expression]);

3/3
       pragma Export(
          [Convention =>] <convention_>identifier, [Entity =>]
     local_name
       [, [External_Name =>] <external_name_string_>expression]
       [, [Link_Name =>] <link_name_string_>expression]);

4/3
       pragma Convention([Convention =>] <convention_>identifier,[Entity
     =>] local_name);

5/3
     For pragmas Import and Export, the argument for Link_Name shall not
     be given without the <pragma_argument_>identifier unless the
     argument for External_Name is given.

                        _Name Resolution Rules_

6/3
The expected type for an <external_name_string_>expression and a
<link_name_string_>expression in an interfacing pragma is String.

                           _Legality Rules_

7/3
The <convention_>identifier of an interfacing pragma shall be the name
of a convention (see *note B.1::).

8/3
A pragma Import shall be the completion of a declaration.
Notwithstanding any rule to the contrary, a pragma Import may serve as
the completion of any kind of (explicit) declaration if supported by an
implementation for that kind of declaration.  If a completion is a
pragma Import, then it shall appear in the same declarative_part,
package_specification, task_definition, or protected_definition as the
declaration.  For a library unit, it shall appear in the same
compilation, before any subsequent compilation_units other than pragmas.
If the local_name denotes more than one entity, then the pragma Import
is the completion of all of them.

9/3
The <external_name_string_>expression and <link_name_string_>expression
of a pragma Import or Export shall be static.

10/3
The local_name of each of these pragmas shall denote a declaration that
may have the similarly named aspect specified.

                          _Static Semantics_

11/3
An interfacing pragma specifies various aspects of the entity denoted by
the local_name as follows:

12/3
   * The Convention aspect (see *note B.1::) is <convention_>identifier.

13/3
   * A pragma Import specifies that the Import aspect (see *note B.1::)
     is True.

14/3
   * A pragma Export specifies that the Export aspect (see *note B.1::)
     is True.

15/3
   * For both pragma Import and Export, if an external name is given in
     the pragma, the External_Name aspect (see *note B.1::) is specified
     to be <external_name_string_>expression.  If a link name is given
     in the pragma, the Link_Name aspect (see *note B.1::) is specified
     to be the <link_name_string_>expression.


File: arm2012.info,  Node: J.15.6,  Next: J.15.7,  Prev: J.15.5,  Up: J.15

J.15.6 Pragma Unchecked_Union
-----------------------------

                               _Syntax_

1/3
     The form of a pragma Unchecked_Union, which is a representation
     pragma (see *note 13.1::), is as follows: 

2/3
       pragma Unchecked_Union (<first_subtype_>local_name);

                           _Legality Rules_

3/3
The <first_subtype_>local_name of a pragma Unchecked_Union shall denote
an unconstrained discriminated record subtype having a variant_part.

                          _Static Semantics_

4/3
A pragma Unchecked_Union specifies that the Unchecked_Union aspect (see
*note B.3.3::) for the type denoted by <first_subtype_>local_name has
the value True.


File: arm2012.info,  Node: J.15.7,  Next: J.15.8,  Prev: J.15.6,  Up: J.15

J.15.7 Pragmas Interrupt_Handler and Attach_Handler
---------------------------------------------------

                               _Syntax_

1/3
     The form of a pragma Interrupt_Handler is as follows:

2/3
       pragma Interrupt_Handler (<handler_>name);

3/3
     The form of a pragma Attach_Handler is as follows:

4/3
       pragma Attach_Handler (<handler_>name, expression);

                        _Name Resolution Rules_

5/3
For the Interrupt_Handler and Attach_Handler pragmas, the <handler_>name
shall resolve to denote a protected procedure with a parameterless
profile.

6/3
For the Attach_Handler pragma, the expected type for the expression is
Interrupts.Interrupt_Id (see *note C.3.2::).  

                           _Legality Rules_

7/3
The Attach_Handler and Interrupt_Handler pragmas are only allowed
immediately within the protected_definition where the corresponding
subprogram is declared.  The corresponding protected_type_declaration or
single_protected_declaration shall be a library-level declaration, and
shall not be declared within a generic body.  In addition to the places
where Legality Rules normally apply (see *note 12.3::), these rules also
apply in the private part of an instance of a generic unit.

                          _Static Semantics_

8/3
For an implementation that supports Annex C, a pragma Interrupt_Handler
specifies the Interrupt_Handler aspect (see *note C.3.1::) for the
protected procedure <handler_>name to have the value True.  For an
implementation that supports Annex C, a pragma Attach_Handler specifies
the Attach_Handler aspect (see *note C.3.1::) for the protected
procedure <handler_>name to have the value of the given expression as
evaluated at object creation time.


File: arm2012.info,  Node: J.15.8,  Next: J.15.9,  Prev: J.15.7,  Up: J.15

J.15.8 Shared Variable Pragmas
------------------------------

                               _Syntax_

1/3
     The form for pragmas Atomic, Volatile, Independent,
     Atomic_Components, and Volatile_Components, and
     Independent_Components is as follows:

2/3
       pragma Atomic (local_name);

3/3
       pragma Volatile (local_name);

4/3
       pragma Independent (<component_>local_name);

5/3
       pragma Atomic_Components (<array_>local_name);

6/3
       pragma Volatile_Components (<array_>local_name);

7/3
       pragma Independent_Components (local_name);

                        _Name Resolution Rules_

8/3
The local_name in an Atomic or Volatile pragma shall resolve to denote
either an object_declaration, a noninherited component_declaration, or a
full_type_declaration.  The <component_>local_name in an Independent
pragma shall resolve to denote a noninherited component_declaration.
The <array_>local_name in an Atomic_Components or Volatile_Components
pragma shall resolve to denote the declaration of an array type or an
array object of an anonymous type.  The local_name in an
Independent_Components pragma shall resolve to denote the declaration of
an array or record type or an array object of an anonymous type.

                          _Static Semantics_

9/3
These pragmas are representation pragmas (see *note 13.1::).  Each of
these pragmas specifies that the similarly named aspect (see *note
C.6::) of the type, object, or component denoted by its argument is
True.  

                           _Legality Rules_

10/3
The local_name of each of these pragmas shall denote a declaration that
may have the similarly named aspect specified.


File: arm2012.info,  Node: J.15.9,  Next: J.15.10,  Prev: J.15.8,  Up: J.15

J.15.9 Pragma CPU
-----------------

                               _Syntax_

1/3
     The form of a pragma CPU is as follows:

2/3
       pragma CPU (expression);

                        _Name Resolution Rules_

3/3
The expected type for the expression of a pragma CPU is
System.Multiprocessors.CPU_Range.

                           _Legality Rules_

4/3
A CPU pragma is allowed only immediately within a task_definition, or
the declarative_part of a subprogram_body.

5/3
For a CPU pragma that appears in the declarative_part of a
subprogram_body, the expression shall be static.

                          _Static Semantics_

6/3
For an implementation that supports Annex D, a pragma CPU specifies the
value of the CPU aspect (see *note D.16::).  If the pragma appears in a
task_definition, the expression is associated with the aspect for the
task type or single_task_declaration that contains the pragma;
otherwise, the expression is associated with the aspect for the
subprogram that contains the pragma.


File: arm2012.info,  Node: J.15.10,  Next: J.15.11,  Prev: J.15.9,  Up: J.15

J.15.10 Pragma Dispatching_Domain
---------------------------------

                               _Syntax_

1/3
     The form of a pragma Dispatching_Domain is as follows:

2/3
       pragma Dispatching_Domain (expression);

                        _Name Resolution Rules_

3/3
The expected type for the expression is
System.Multiprocessors.Dispatching_Domains.Dispatching_Domain.  

                           _Legality Rules_

4/3
A Dispatching_Domain pragma is allowed only immediately within a
task_definition.

                          _Static Semantics_

5/3
For an implementation that supports Annex D, a pragma Dispatching_Domain
specifies the value of the Dispatching_Domain aspect (see *note
D.16.1::).  The expression is associated with the aspect for the task
type or single_task_declaration that contains the pragma.


File: arm2012.info,  Node: J.15.11,  Next: J.15.12,  Prev: J.15.10,  Up: J.15

J.15.11 Pragmas Priority and Interrupt_Priority
-----------------------------------------------

                               _Syntax_

1/3
     The form of a pragma Priority is as follows:

2/3
       pragma Priority (expression);

3/3
     The form of a pragma Interrupt_Priority is as follows:

4/3
       pragma Interrupt_Priority [(expression);]

                        _Name Resolution Rules_

5/3
The expected type for the expression in a Priority or Interrupt_Priority
pragma is Integer.  

                           _Legality Rules_

6/3
A Priority pragma is allowed only immediately within a task_definition,
a protected_definition, or the declarative_part of a subprogram_body.
An Interrupt_Priority pragma is allowed only immediately within a
task_definition or a protected_definition.

7/3
For a Priority pragma that appears in the declarative_part of a
subprogram_body, the expression shall be static, and its value shall be
in the range of System.Priority.

                          _Static Semantics_

8/3
For an implementation that supports Annex D, a pragma Priority specifies
the value of the Priority aspect (see *note D.1::) and a pragma
Interrupt_Priority specifies the value of the Interrupt_Priority aspect
as follows:

9/3
   * If the pragma appears in a task_definition, the expression is
     associated with the aspect for the task type or
     single_task_declaration that contains the pragma;

10/3
   * If the pragma appears in a protected_definition, the expression is
     associated with the aspect for the protected type or
     single_protected_declaration that contains the pragma;

11/3
   * If the pragma appears in the declarative_part of a subprogram_body,
     the expression is associated with the aspect for the subprogram
     that contains the pragma.

12/3
If there is no expression in an Interrupt_Priority pragma, the
Interrupt_Priority aspect has the value Interrupt_Priority'Last.


File: arm2012.info,  Node: J.15.12,  Next: J.15.13,  Prev: J.15.11,  Up: J.15

J.15.12 Pragma Relative_Deadline
--------------------------------

                               _Syntax_

1/3
     The form of a pragma Relative_Deadline is as follows:

2/3
       pragma Relative_Deadline (<relative_deadline_>expression);

                        _Name Resolution Rules_

3/3
The expected type for a <relative_deadline_>expression is
Real_Time.Time_Span.

                           _Legality Rules_

4/3
A Relative_Deadline pragma is allowed only immediately within a
task_definition or the declarative_part of a subprogram_body.

                          _Static Semantics_

5/3
For an implementation that supports Annex D, a pragma Relative_Deadline
specifies the value of the Relative_Deadline aspect (see *note D.2.6::).
If the pragma appears in a task_definition, the expression is associated
with the aspect for the task type or single_task_declaration that
contains the pragma; otherwise, the expression is associated with the
aspect for the subprogram that contains the pragma.


File: arm2012.info,  Node: J.15.13,  Prev: J.15.12,  Up: J.15

J.15.13 Pragma Asynchronous
---------------------------

                               _Syntax_

1/3
     The form of a pragma Asynchronous, which is a representation pragma
     (see *note 13.1::), is as follows: 

2/3
       pragma Asynchronous (local_name);

                          _Static Semantics_

3/3
For an implementation that supports Annex E, a pragma Asynchronous
specifies that the Asynchronous aspect (see *note E.4.1::) for the
procedure or type denoted by local_name has the value True.

                           _Legality Rules_

4/3
The local_name of a pragma Asynchronous shall denote a declaration that
may have aspect Asynchronous specified.


File: arm2012.info,  Node: Annex K,  Next: Annex L,  Prev: Annex J,  Up: Top

Annex K Language-Defined Aspects and Attributes
***********************************************

1/3
This annex summarizes the definitions given elsewhere of the
language-defined aspects and attributes.  Some aspects have
corresponding attributes, as noted.

* Menu:

* K.1 ::      Language-Defined Aspects
* K.2 ::      Language-Defined Attributes


File: arm2012.info,  Node: K.1,  Next: K.2,  Up: Annex K

K.1 Language-Defined Aspects
============================

1/3
This subclause summarizes the definitions given elsewhere of the
language-defined aspects.  Aspects are properties of entities that can
be specified by the Ada program; unless otherwise specified below,
aspects can be specified using an aspect_specification.

2/3
Address
               Machine address of an entity.  See *note 13.3::.

3/3
Alignment (object)
               Alignment of an object.  See *note 13.3::.

4/3
Alignment (subtype)
               Alignment of a subtype.  See *note 13.3::.

5/4
All_Calls_Remote
               All indirect or dispatching remote subprogram calls and
               all direct remote subprogram calls should use the
               Partition Communication Subsystem.  See *note E.2.3::.

6/3
Asynchronous
               Remote procedure calls are asynchronous; the caller
               continues without waiting for the call to return.  See
               *note E.4.1::.

7/3
Atomic
               Declare that a type, object, or component is atomic.  See
               *note C.6::.

8/3
Atomic_Components
               Declare that the components of an array type or object
               are atomic.  See *note C.6::.

9/3
Attach_Handler
               Protected procedure is attached to an interrupt.  See
               *note C.3.1::.

10/3
Bit_Order
               Order of bit numbering in a record_representation_clause.
               See *note 13.5.3::.

11/3
Coding
               Internal representation of enumeration literals.
               Specified by an enumeration_representation_clause, not by
               an aspect_specification.  See *note 13.4::.

12/3
Component_Size
               Size in bits of a component of an array type.  See *note
               13.3::.

13/3
Constant_Indexing
               Defines function(s) to implement user-defined
               indexed_components.  See *note 4.1.6::.

14/3
Convention
               Calling convention or other convention used for
               interfacing to other languages.  See *note B.1::.

15/3
CPU
               Processor on which a given task should run.  See *note
               D.16::.

16/3
Default_Component_Value
               Default value for the components of an array-of-scalar
               subtype.  See *note 3.6::.

17/3
Default_Iterator
               Default iterator to be used in for loops.  See *note
               5.5.1::.

18/3
Default_Storage_Pool
               Default storage pool for a generic instance.  See *note
               13.11.3::.

19/3
Default_Value
               Default value for a scalar subtype.  See *note 3.5::.

19.1/4
Discard_Names
               Requests a reduction in storage for names associated with
               an entity.  See *note C.5::.

20/3
Dispatching_Domain
               Domain (group of processors) on which a given task should
               run.  See *note D.16.1::.

21/3
Dynamic_Predicate
               Condition that must hold true for objects of a given
               subtype; the subtype is not static.  See *note 3.2.4::.

22/3
Elaborate_Body
               A given package must have a body, and that body is
               elaborated immediately after the declaration.  See *note
               10.2.1::.

22.1/4
Exclusive_Functions
               Specifies mutual exclusion behavior of protected
               functions in a protected type.  See *note 9.5.1::.

23/3
Export
               Entity is exported to another language.  See *note B.1::.

24/3
External_Name
               Name used to identify an imported or exported entity.
               See *note B.1::.

25/3
External_Tag
               Unique identifier for a tagged type in streams.  See
               *note 13.3::.

26/3
Implicit_Dereference
               Mechanism for user-defined implicit .all.  See *note
               4.1.5::.

27/3
Import
               Entity is imported from another language.  See *note
               B.1::.

28/3
Independent
               Declare that a type, object, or component is
               independently addressable.  See *note C.6::.

29/3
Independent_Components
               Declare that the components of an array or record type,
               or an array object, are independently addressable.  See
               *note C.6::.

30/3
Inline
               For efficiency, Inline calls are requested for a
               subprogram.  See *note 6.3.2::.

31/3
Input
               Function to read a value from a stream for a given type,
               including any bounds and discriminants.  See *note
               13.13.2::.

31.1/4
Input'Class
               Function to read a value from a stream for a the
               class-wide type associated with a given type, including
               any bounds and discriminants.  See *note 13.13.2::.

32/3
Interrupt_Handler
               Protected procedure may be attached to interrupts.  See
               *note C.3.1::.

33/3
Interrupt_Priority
               Priority of a task object or type, or priority of a
               protected object or type; the priority is in the
               interrupt range.  See *note D.1::.

34/3
Iterator_Element
               Element type to be used for user-defined iterators.  See
               *note 5.5.1::.

35/3
Layout (record)
               Layout of record components.  Specified by a
               record_representation_clause, not by an
               aspect_specification.  See *note 13.5.1::.

36/3
Link_Name
               Linker symbol used to identify an imported or exported
               entity.  See *note B.1::.

37/3
Machine_Radix
               Radix (2 or 10) that is used to represent a decimal fixed
               point type.  See *note F.1::.

38/3
No_Return
               A procedure will not return normally.  See *note 6.5.1::.

39/3
Output
               Procedure to write a value to a stream for a given type,
               including any bounds and discriminants.  See *note
               13.13.2::.

39.1/4
Output'Class
               Procedure to write a value to a stream for a the
               class-wide type associated with a given type, including
               any bounds and discriminants.  See *note 13.13.2::.

40/3
Pack
               Minimize storage when laying out records and arrays.  See
               *note 13.2::.

41/3
Post
               Postcondition; a condition that must hold true after a
               call.  See *note 6.1.1::.

42/3
Post'Class
               Postcondition inherited on type derivation.  See *note
               6.1.1::.

43/3
Pre
               Precondition; a condition that must hold true before a
               call.  See *note 6.1.1::.

44/3
Pre'Class
               Precondition inherited on type derivation.  See *note
               6.1.1::.

44.1/4
Predicate_Failure
               Action to be performed when a predicate check fails.  See
               *note 3.2.4::.

45/3
Preelaborate
               Code execution during elaboration is avoided for a given
               package.  See *note 10.2.1::.

46/3
Priority
               Priority of a task object or type, or priority of a
               protected object or type; the priority is not in the
               interrupt range.  See *note D.1::.

47/3
Pure
               Side effects are avoided in the subprograms of a given
               package.  See *note 10.2.1::.

48/3
Read
               Procedure to read a value from a stream for a given type.
               See *note 13.13.2::.

48.1/4
Read'Class
               Procedure to read a value from a stream for the
               class-wide type associated with a given type.  See *note
               13.13.2::.

49/3
Record layout
               See Layout.  See *note 13.5.1::.

50/3
Relative_Deadline
               Task parameter used in Earliest Deadline First
               Dispatching.  See *note D.2.6::.

51/3
Remote_Call_Interface
               Subprograms in a given package may be used in remote
               procedure calls.  See *note E.2.3::.

52/3
Remote_Types
               Types in a given package may be used in remote procedure
               calls.  See *note E.2.2::.

53/3
Shared_Passive
               A given package is used to represent shared memory in a
               distributed system.  See *note E.2.1::.

54/3
Size (object)
               Size in bits of an object.  See *note 13.3::.

55/3
Size (subtype)
               Size in bits of a subtype.  See *note 13.3::.

56/3
Small
               Scale factor for a fixed point type.  See *note 3.5.10::.

57/3
Static_Predicate
               Condition that must hold true for objects of a given
               subtype; the subtype may be static.  See *note 3.2.4::.

58/3
Storage_Pool
               Pool of memory from which new will allocate for a given
               access type.  See *note 13.11::.

59/3
Storage_Size (access)
               Sets memory size for allocations for an access type.  See
               *note 13.11::.

60/3
Storage_Size (task)
               Size in storage elements reserved for a task type or
               single task object.  See *note 13.3::.

61/3
Stream_Size
               Size in bits used to represent elementary objects in a
               stream.  See *note 13.13.2::.

62/3
Synchronization
               Defines whether a given primitive operation of a
               synchronized interface must be implemented by an entry or
               protected procedure.  See *note 9.5::.

63/3
Type_Invariant
               A condition that must hold true for all objects of a
               type.  See *note 7.3.2::.

64/3
Type_Invariant'Class
               A condition that must hold true for all objects in a
               class of types.  See *note 7.3.2::.

65/3
Unchecked_Union
               Type is used to interface to a C union type.  See *note
               B.3.3::.

66/3
Variable_Indexing
               Defines function(s) to implement user-defined
               indexed_components.  See *note 4.1.6::.

67/3
Volatile
               Declare that a type, object, or component is volatile.
               See *note C.6::.

68/3
Volatile_Components
               Declare that the components of an array type or object
               are volatile.  See *note C.6::.

69/3
Write
               Procedure to write a value to a stream for a given type.
               See *note 13.13.2::.

69.1/4
Write'Class
               Procedure to write a value to a stream for a the
               class-wide type associated with a given type.  See *note
               13.13.2::.


File: arm2012.info,  Node: K.2,  Prev: K.1,  Up: Annex K

K.2 Language-Defined Attributes
===============================

1/3
This subclause summarizes the definitions given elsewhere of the
language-defined attributes.  Attributes are properties of entities that
can be queried by an Ada program.

2
P'Access
               For a prefix P that denotes a subprogram:

3
               P'Access yields an access value that designates the
               subprogram denoted by P. The type of P'Access is an
               access-to-subprogram type (<S>), as determined by the
               expected type.  See *note 3.10.2::.

4
X'Access
               For a prefix X that denotes an aliased view of an object:

5
               X'Access yields an access value that designates the
               object denoted by X. The type of X'Access is an
               access-to-object type, as determined by the expected
               type.  The expected type shall be a general access type.
               See *note 3.10.2::.

6/1
X'Address
               For a prefix X that denotes an object, program unit, or
               label:

7
               Denotes the address of the first of the storage elements
               allocated to X. For a program unit or label, this value
               refers to the machine code associated with the
               corresponding body or statement.  The value of this
               attribute is of type System.Address.  See *note 13.3::.

8
S'Adjacent
               For every subtype S of a floating point type <T>:

9
               S'Adjacent denotes a function with the following
               specification:

10
                    function S'Adjacent (<X>, <Towards> : <T>)
                      return <T>

11
               If <Towards> = <X>, the function yields <X>; otherwise,
               it yields the machine number of the type <T> adjacent to
               <X> in the direction of <Towards>, if that machine number
               exists.  If the result would be outside the base range of
               S, Constraint_Error is raised.  When <T>'Signed_Zeros is
               True, a zero result has the sign of <X>.  When <Towards>
               is zero, its sign has no bearing on the result.  See
               *note A.5.3::.

12
S'Aft
               For every fixed point subtype S:

13
               S'Aft yields the number of decimal digits needed after
               the decimal point to accommodate the <delta> of the
               subtype S, unless the <delta> of the subtype S is greater
               than 0.1, in which case the attribute yields the value
               one.  (S'Aft is the smallest positive integer N for which
               (10**N)*S'Delta is greater than or equal to one.)  The
               value of this attribute is of the type
               <universal_integer>.  See *note 3.5.10::.

13.1/2
S'Alignment
               For every subtype S:

13.2/2
               The value of this attribute is of type
               <universal_integer>, and nonnegative.

13.3/2
               For an object X of subtype S, if S'Alignment is not zero,
               then X'Alignment is a nonzero integral multiple of
               S'Alignment unless specified otherwise by a
               representation item.  See *note 13.3::.

14/1
X'Alignment
               For a prefix X that denotes an object:

15/2
               The value of this attribute is of type
               <universal_integer>, and nonnegative; zero means that the
               object is not necessarily aligned on a storage element
               boundary.  If X'Alignment is not zero, then X is aligned
               on a storage unit boundary and X'Address is an integral
               multiple of X'Alignment (that is, the Address modulo the
               Alignment is zero).

16/2

               <This paragraph was deleted.> See *note 13.3::.

17
S'Base
               For every scalar subtype S:

18
               S'Base denotes an unconstrained subtype of the type of S.
               This unconstrained subtype is called the <base subtype>
               of the type.  See *note 3.5::.

19
S'Bit_Order
               For every specific record subtype S:

20
               Denotes the bit ordering for the type of S. The value of
               this attribute is of type System.Bit_Order.  See *note
               13.5.3::.

21/1
P'Body_Version
               For a prefix P that statically denotes a program unit:

22
               Yields a value of the predefined type String that
               identifies the version of the compilation unit that
               contains the body (but not any subunits) of the program
               unit.  See *note E.3::.

23
T'Callable
               For a prefix T that is of a task type (after any implicit
               dereference):

24
               Yields the value True when the task denoted by T is
               <callable>, and False otherwise; See *note 9.9::.

25
E'Caller
               For a prefix E that denotes an entry_declaration:

26/3
               Yields a value of the type Task_Id that identifies the
               task whose call is now being serviced.  Use of this
               attribute is allowed only inside an accept_statement, or
               entry_body after the entry_barrier, corresponding to the
               entry_declaration denoted by E. See *note C.7.1::.

27
S'Ceiling
               For every subtype S of a floating point type <T>:

28
               S'Ceiling denotes a function with the following
               specification:

29
                    function S'Ceiling (<X> : <T>)
                      return <T>

30
               The function yields the value 'ceiling(<X>)', i.e., the
               smallest (most negative) integral value greater than or
               equal to <X>.  When <X> is zero, the result has the sign
               of <X>; a zero result otherwise has a negative sign when
               S'Signed_Zeros is True.  See *note A.5.3::.

31
S'Class
               For every subtype S of a tagged type <T> (specific or
               class-wide):

32
               S'Class denotes a subtype of the class-wide type (called
               <T>'Class in this International Standard) for the class
               rooted at <T> (or if S already denotes a class-wide
               subtype, then S'Class is the same as S).

33
               S'Class is unconstrained.  However, if S is constrained,
               then the values of S'Class are only those that when
               converted to the type <T> belong to S. See *note 3.9::.

34
S'Class
               For every subtype S of an untagged private type whose
               full view is tagged:

35
               Denotes the class-wide subtype corresponding to the full
               view of S. This attribute is allowed only from the
               beginning of the private part in which the full view is
               declared, until the declaration of the full view.  After
               the full view, the Class attribute of the full view can
               be used.  See *note 7.3.1::.

36/1
X'Component_Size
               For a prefix X that denotes an array subtype or array
               object (after any implicit dereference):

37
               Denotes the size in bits of components of the type of X.
               The value of this attribute is of type
               <universal_integer>.  See *note 13.3::.

38
S'Compose
               For every subtype S of a floating point type <T>:

39
               S'Compose denotes a function with the following
               specification:

40
                    function S'Compose (<Fraction> : <T>;
                                        <Exponent> : <universal_integer>)
                      return <T>

41
               Let <v> be the value <Fraction> ·
               <T>'Machine_Radix<Exponent>-<k>, where <k> is the
               normalized exponent of <Fraction>.  If <v> is a machine
               number of the type <T>, or if |<v>| >= <T>'Model_Small,
               the function yields <v>; otherwise, it yields either one
               of the machine numbers of the type <T> adjacent to <v>.  
               Constraint_Error is optionally raised if <v> is outside
               the base range of S. A zero result has the sign of
               <Fraction> when S'Signed_Zeros is True.  See *note
               A.5.3::.

42
A'Constrained
               For a prefix A that is of a discriminated type (after any
               implicit dereference):

43/3
               Yields the value True if A denotes a constant, a value, a
               tagged object, or a constrained variable, and False
               otherwise.  See *note 3.7.2::.

44
S'Copy_Sign
               For every subtype S of a floating point type <T>:

45
               S'Copy_Sign denotes a function with the following
               specification:

46
                    function S'Copy_Sign (<Value>, <Sign> : <T>)
                      return <T>

47
               If the value of <Value> is nonzero, the function yields a
               result whose magnitude is that of <Value> and whose sign
               is that of <Sign>; otherwise, it yields the value zero.  
               Constraint_Error is optionally raised if the result is
               outside the base range of S. A zero result has the sign
               of <Sign> when S'Signed_Zeros is True.  See *note
               A.5.3::.

48
E'Count
               For a prefix E that denotes an entry of a task or
               protected unit:

49
               Yields the number of calls presently queued on the entry
               E of the current instance of the unit.  The value of this
               attribute is of the type <universal_integer>.  See *note
               9.9::.

50/1
S'Definite
               For a prefix S that denotes a formal indefinite subtype:

51/3
               S'Definite yields True if the actual subtype
               corresponding to S is definite; otherwise, it yields
               False.  The value of this attribute is of the predefined
               type Boolean.  See *note 12.5.1::.

52
S'Delta
               For every fixed point subtype S:

53
               S'Delta denotes the <delta> of the fixed point subtype S.
               The value of this attribute is of the type
               <universal_real>.  See *note 3.5.10::.

54
S'Denorm
               For every subtype S of a floating point type <T>:

55
               Yields the value True if every value expressible in the
               form
                   ± <mantissa> · <T>'Machine_Radix<T>'Machine_Emin
               where <mantissa> is a nonzero <T>'Machine_Mantissa-digit
               fraction in the number base <T>'Machine_Radix, the first
               digit of which is zero, is a machine number (see *note
               3.5.7::) of the type <T>; yields the value False
               otherwise.  The value of this attribute is of the
               predefined type Boolean.  See *note A.5.3::.

56
S'Digits
               For every floating point subtype S:

57
               S'Digits denotes the requested decimal precision for the
               subtype S. The value of this attribute is of the type
               <universal_integer>.  See *note 3.5.8::.

58
S'Digits
               For every decimal fixed point subtype S:

59
               S'Digits denotes the <digits> of the decimal fixed point
               subtype S, which corresponds to the number of decimal
               digits that are representable in objects of the subtype.
               The value of this attribute is of the type
               <universal_integer>.  See *note 3.5.10::.

60
S'Exponent
               For every subtype S of a floating point type <T>:

61
               S'Exponent denotes a function with the following
               specification:

62
                    function S'Exponent (<X> : <T>)
                      return <universal_integer>

63
               The function yields the normalized exponent of <X>.  See
               *note A.5.3::.

64
S'External_Tag
               For every subtype S of a tagged type <T> (specific or
               class-wide):

65
               S'External_Tag denotes an external string representation
               for S'Tag; it is of the predefined type String.
               External_Tag may be specified for a specific tagged type
               via an attribute_definition_clause; the expression of
               such a clause shall be static.  The default external tag
               representation is implementation defined.  See *note
               13.13.2::.  See *note 13.3::.

66/1
A'First
               For a prefix A that is of an array type (after any
               implicit dereference), or denotes a constrained array
               subtype:

67
               A'First denotes the lower bound of the first index range;
               its type is the corresponding index type.  See *note
               3.6.2::.

68
S'First
               For every scalar subtype S:

69
               S'First denotes the lower bound of the range of S. The
               value of this attribute is of the type of S. See *note
               3.5::.

70/1
A'First(N)
               For a prefix A that is of an array type (after any
               implicit dereference), or denotes a constrained array
               subtype:

71
               A'First(N) denotes the lower bound of the N-th index
               range; its type is the corresponding index type.  See
               *note 3.6.2::.

72
R.C'First_Bit
               For a component C of a composite, non-array object R:

73/2
               If the nondefault bit ordering applies to the composite
               type, and if a component_clause specifies the placement
               of C, denotes the value given for the first_bit of the
               component_clause; otherwise, denotes the offset, from the
               start of the first of the storage elements occupied by C,
               of the first bit occupied by C. This offset is measured
               in bits.  The first bit of a storage element is numbered
               zero.  The value of this attribute is of the type
               <universal_integer>.  See *note 13.5.2::.

73.1/4
S'First_Valid
               For every static discrete subtype S for which there
               exists at least one value belonging to S that satisfies
               the predicates of S:

73.2/4
               S'First_Valid denotes the smallest value that belongs to
               S and satisfies the predicates of S. The value of this
               attribute is of the type of S. See *note 3.5.5::.

74
S'Floor
               For every subtype S of a floating point type <T>:

75
               S'Floor denotes a function with the following
               specification:

76
                    function S'Floor (<X> : <T>)
                      return <T>

77
               The function yields the value 'floor(<X>)', i.e., the
               largest (most positive) integral value less than or equal
               to <X>.  When <X> is zero, the result has the sign of
               <X>; a zero result otherwise has a positive sign.  See
               *note A.5.3::.

78
S'Fore
               For every fixed point subtype S:

79
               S'Fore yields the minimum number of characters needed
               before the decimal point for the decimal representation
               of any value of the subtype S, assuming that the
               representation does not include an exponent, but includes
               a one-character prefix that is either a minus sign or a
               space.  (This minimum number does not include superfluous
               zeros or underlines, and is at least 2.)  The value of
               this attribute is of the type <universal_integer>.  See
               *note 3.5.10::.

80
S'Fraction
               For every subtype S of a floating point type <T>:

81
               S'Fraction denotes a function with the following
               specification:

82
                    function S'Fraction (<X> : <T>)
                      return <T>

83
               The function yields the value <X> ·
               <T>'Machine_Radix-<k>, where <k> is the normalized
               exponent of <X>.  A zero result, which can only occur
               when <X> is zero, has the sign of <X>.  See *note
               A.5.3::.

83.1/3
X'Has_Same_Storage
               For a prefix X that denotes an object:

83.2/4
               X'Has_Same_Storage denotes a function with the following
               specification:

83.3/3
                    function X'Has_Same_Storage (<Arg> : <any_type>)
                      return Boolean

83.4/4
               The actual parameter shall be a name that denotes an
               object.  The object denoted by the actual parameter can
               be of any type.  This function evaluates the names of the
               objects involved.  It returns True if the representation
               of the object denoted by the actual parameter occupies
               exactly the same bits as the representation of the object
               denoted by X and the objects occupy at least one bit;
               otherwise, it returns False.  See *note 13.3::.

84/1
E'Identity
               For a prefix E that denotes an exception:

85
               E'Identity returns the unique identity of the exception.
               The type of this attribute is Exception_Id.  See *note
               11.4.1::.

86
T'Identity
               For a prefix T that is of a task type (after any implicit
               dereference):

87
               Yields a value of the type Task_Id that identifies the
               task denoted by T. See *note C.7.1::.

88
S'Image
               For every scalar subtype S:

89
               S'Image denotes a function with the following
               specification:

90
                    function S'Image(<Arg> : S'Base)
                      return String

91/3
               The function returns an image of the value of <Arg> as a
               String.  See *note 3.5::.

91.1/4
X'Image
               For a prefix X that denotes an object of a scalar type
               (after any implicit dereference):

91.2/4
               X'Image denotes the result of calling function S'Image
               with <Arg> being X, where S is the nominal subtype of X.
               See *note 3.5::.

92
S'Class'Input
               For every subtype S'Class of a class-wide type <T>'Class:

93
               S'Class'Input denotes a function with the following
               specification:

94/2
                    function S'Class'Input(
                       <Stream> : not null access Ada.Streams.Root_Stream_Type'Class)
                       return <T>'Class

95/3
               First reads the external tag from <Stream> and determines
               the corresponding internal tag (by calling
               Tags.Descendant_Tag(String'Input(<Stream>), S'Tag) which
               might raise Tag_Error -- see *note 3.9::) and then
               dispatches to the subprogram denoted by the Input
               attribute of the specific type identified by the internal
               tag; returns that result.  If the specific type
               identified by the internal tag is abstract,
               Constraint_Error is raised.  See *note 13.13.2::.

96
S'Input
               For every subtype S of a specific type <T>:

97
               S'Input denotes a function with the following
               specification:

98/2
                    function S'Input(
                       <Stream> : not null access Ada.Streams.Root_Stream_Type'Class)
                       return <T>

99
               S'Input reads and returns one value from <Stream>, using
               any bounds or discriminants written by a corresponding
               S'Output to determine how much to read.  See *note
               13.13.2::.

100/1
A'Last
               For a prefix A that is of an array type (after any
               implicit dereference), or denotes a constrained array
               subtype:

101
               A'Last denotes the upper bound of the first index range;
               its type is the corresponding index type.  See *note
               3.6.2::.

102
S'Last
               For every scalar subtype S:

103
               S'Last denotes the upper bound of the range of S. The
               value of this attribute is of the type of S. See *note
               3.5::.

104/1
A'Last(N)
               For a prefix A that is of an array type (after any
               implicit dereference), or denotes a constrained array
               subtype:

105
               A'Last(N) denotes the upper bound of the N-th index
               range; its type is the corresponding index type.  See
               *note 3.6.2::.

106
R.C'Last_Bit
               For a component C of a composite, non-array object R:

107/2
               If the nondefault bit ordering applies to the composite
               type, and if a component_clause specifies the placement
               of C, denotes the value given for the last_bit of the
               component_clause; otherwise, denotes the offset, from the
               start of the first of the storage elements occupied by C,
               of the last bit occupied by C. This offset is measured in
               bits.  The value of this attribute is of the type
               <universal_integer>.  See *note 13.5.2::.

107.1/4
S'Last_Valid
               For every static discrete subtype S for which there
               exists at least one value belonging to S that satisfies
               the predicates of S:

107.2/4
               S'Last_Valid denotes the largest value that belongs to S
               and satisfies the predicates of S. The value of this
               attribute is of the type of S. See *note 3.5.5::.

108
S'Leading_Part
               For every subtype S of a floating point type <T>:

109
               S'Leading_Part denotes a function with the following
               specification:

110
                    function S'Leading_Part (<X> : <T>;
                                             <Radix_Digits> : <universal_integer>)
                      return <T>

111
               Let <v> be the value <T>'Machine_Radix<k>-<Radix_Digits>,
               where <k> is the normalized exponent of <X>.  The
               function yields the value

112
                  * 'floor(<X>/<v>)' · <v>, when <X> is nonnegative and
                    <Radix_Digits> is positive;

113
                  * 'ceiling(<X>/<v>)' · <v>, when <X> is negative and
                    <Radix_Digits> is positive.

114
               Constraint_Error is raised when <Radix_Digits> is zero or
               negative.  A zero result, which can only occur when <X>
               is zero, has the sign of <X>.  See *note A.5.3::.

115/1
A'Length
               For a prefix A that is of an array type (after any
               implicit dereference), or denotes a constrained array
               subtype:

116
               A'Length denotes the number of values of the first index
               range (zero for a null range); its type is
               <universal_integer>.  See *note 3.6.2::.

117/1
A'Length(N)
               For a prefix A that is of an array type (after any
               implicit dereference), or denotes a constrained array
               subtype:

118
               A'Length(N) denotes the number of values of the N-th
               index range (zero for a null range); its type is
               <universal_integer>.  See *note 3.6.2::.

119
S'Machine
               For every subtype S of a floating point type <T>:

120
               S'Machine denotes a function with the following
               specification:

121
                    function S'Machine (<X> : <T>)
                      return <T>

122
               If <X> is a machine number of the type <T>, the function
               yields <X>; otherwise, it yields the value obtained by
               rounding or truncating <X> to either one of the adjacent
               machine numbers of the type <T>.  Constraint_Error is
               raised if rounding or truncating <X> to the precision of
               the machine numbers results in a value outside the base
               range of S. A zero result has the sign of <X> when
               S'Signed_Zeros is True.  See *note A.5.3::.

123
S'Machine_Emax
               For every subtype S of a floating point type <T>:

124
               Yields the largest (most positive) value of <exponent>
               such that every value expressible in the canonical form
               (for the type <T>), having a <mantissa> of
               <T>'Machine_Mantissa digits, is a machine number (see
               *note 3.5.7::) of the type <T>.  This attribute yields a
               value of the type <universal_integer>.  See *note
               A.5.3::.

125
S'Machine_Emin
               For every subtype S of a floating point type <T>:

126
               Yields the smallest (most negative) value of <exponent>
               such that every value expressible in the canonical form
               (for the type <T>), having a <mantissa> of
               <T>'Machine_Mantissa digits, is a machine number (see
               *note 3.5.7::) of the type <T>.  This attribute yields a
               value of the type <universal_integer>.  See *note
               A.5.3::.

127
S'Machine_Mantissa
               For every subtype S of a floating point type <T>:

128
               Yields the largest value of <p> such that every value
               expressible in the canonical form (for the type <T>),
               having a <p>-digit <mantissa> and an <exponent> between
               <T>'Machine_Emin and <T>'Machine_Emax, is a machine
               number (see *note 3.5.7::) of the type <T>.  This
               attribute yields a value of the type <universal_integer>.
               See *note A.5.3::.

129
S'Machine_Overflows
               For every subtype S of a floating point type <T>:

130
               Yields the value True if overflow and divide-by-zero are
               detected and reported by raising Constraint_Error for
               every predefined operation that yields a result of the
               type <T>; yields the value False otherwise.  The value of
               this attribute is of the predefined type Boolean.  See
               *note A.5.3::.

131
S'Machine_Overflows
               For every subtype S of a fixed point type <T>:

132
               Yields the value True if overflow and divide-by-zero are
               detected and reported by raising Constraint_Error for
               every predefined operation that yields a result of the
               type <T>; yields the value False otherwise.  The value of
               this attribute is of the predefined type Boolean.  See
               *note A.5.4::.

133
S'Machine_Radix
               For every subtype S of a floating point type <T>:

134
               Yields the radix of the hardware representation of the
               type <T>.  The value of this attribute is of the type
               <universal_integer>.  See *note A.5.3::.

135
S'Machine_Radix
               For every subtype S of a fixed point type <T>:

136
               Yields the radix of the hardware representation of the
               type <T>.  The value of this attribute is of the type
               <universal_integer>.  See *note A.5.4::.

136.1/2
S'Machine_Rounding
               For every subtype S of a floating point type <T>:

136.2/2
               S'Machine_Rounding denotes a function with the following
               specification:

136.3/2
                    function S'Machine_Rounding (<X> : <T>)
                      return <T>

136.4/2
               The function yields the integral value nearest to <X>.
               If <X> lies exactly halfway between two integers, one of
               those integers is returned, but which of them is returned
               is unspecified.  A zero result has the sign of <X> when
               S'Signed_Zeros is True.  This function provides access to
               the rounding behavior which is most efficient on the
               target processor.  See *note A.5.3::.

137
S'Machine_Rounds
               For every subtype S of a floating point type <T>:

138
               Yields the value True if rounding is performed on inexact
               results of every predefined operation that yields a
               result of the type <T>; yields the value False otherwise.
               The value of this attribute is of the predefined type
               Boolean.  See *note A.5.3::.

139
S'Machine_Rounds
               For every subtype S of a fixed point type <T>:

140
               Yields the value True if rounding is performed on inexact
               results of every predefined operation that yields a
               result of the type <T>; yields the value False otherwise.
               The value of this attribute is of the predefined type
               Boolean.  See *note A.5.4::.

141
S'Max
               For every scalar subtype S:

142
               S'Max denotes a function with the following
               specification:

143
                    function S'Max(<Left>, <Right> : S'Base)
                      return S'Base

144
               The function returns the greater of the values of the two
               parameters.  See *note 3.5::.

144.1/3
S'Max_Alignment_For_Allocation
               For every subtype S:

144.2/3
               Denotes the maximum value for Alignment that could be
               requested by the implementation via Allocate for an
               access type whose designated subtype is S. The value of
               this attribute is of type <universal_integer>.  See *note
               13.11.1::.

145
S'Max_Size_In_Storage_Elements
               For every subtype S:

146/3
               Denotes the maximum value for Size_In_Storage_Elements
               that could be requested by the implementation via
               Allocate for an access type whose designated subtype is
               S. The value of this attribute is of type
               <universal_integer>.  See *note 13.11.1::.

147
S'Min
               For every scalar subtype S:

148
               S'Min denotes a function with the following
               specification:

149
                    function S'Min(<Left>, <Right> : S'Base)
                      return S'Base

150
               The function returns the lesser of the values of the two
               parameters.  See *note 3.5::.

150.1/2
S'Mod
               For every modular subtype S:

150.2/2
               S'Mod denotes a function with the following
               specification:

150.3/2
                    function S'Mod (<Arg> : <universal_integer>)
                      return S'Base

150.4/2
               This function returns <Arg> mod S'Modulus, as a value of
               the type of S. See *note 3.5.4::.

151
S'Model
               For every subtype S of a floating point type <T>:

152
               S'Model denotes a function with the following
               specification:

153
                    function S'Model (<X> : <T>)
                      return <T>

154
               If the Numerics Annex is not supported, the meaning of
               this attribute is implementation defined; see *note
               G.2.2:: for the definition that applies to
               implementations supporting the Numerics Annex.  See *note
               A.5.3::.

155
S'Model_Emin
               For every subtype S of a floating point type <T>:

156
               If the Numerics Annex is not supported, this attribute
               yields an implementation defined value that is greater
               than or equal to the value of <T>'Machine_Emin.  See
               *note G.2.2:: for further requirements that apply to
               implementations supporting the Numerics Annex.  The value
               of this attribute is of the type <universal_integer>.
               See *note A.5.3::.

157
S'Model_Epsilon
               For every subtype S of a floating point type <T>:

158
               Yields the value <T>'Machine_Radix1 - <T>'Model_Mantissa.
               The value of this attribute is of the type
               <universal_real>.  See *note A.5.3::.

159
S'Model_Mantissa
               For every subtype S of a floating point type <T>:

160
               If the Numerics Annex is not supported, this attribute
               yields an implementation defined value that is greater
               than or equal to 'ceiling(<d> · log(10) /
               log(<T>'Machine_Radix))' + 1, where <d> is the requested
               decimal precision of <T>, and less than or equal to the
               value of <T>'Machine_Mantissa.  See *note G.2.2:: for
               further requirements that apply to implementations
               supporting the Numerics Annex.  The value of this
               attribute is of the type <universal_integer>.  See *note
               A.5.3::.

161
S'Model_Small
               For every subtype S of a floating point type <T>:

162
               Yields the value <T>'Machine_Radix<T>'Model_Emin - 1.
               The value of this attribute is of the type
               <universal_real>.  See *note A.5.3::.

163
S'Modulus
               For every modular subtype S:

164
               S'Modulus yields the modulus of the type of S, as a value
               of the type <universal_integer>.  See *note 3.5.4::.

164.1/3
X'Old
               For a prefix X that denotes an object of a nonlimited
               type:

164.2/4
               Each X'Old in a postcondition expression that is enabled
               denotes a constant that is implicitly declared at the
               beginning of the subprogram body, entry body, or accept
               statement.  See *note 6.1.1::.

165
S'Class'Output
               For every subtype S'Class of a class-wide type <T>'Class:

166
               S'Class'Output denotes a procedure with the following
               specification:

167/2
                    procedure S'Class'Output(
                       <Stream> : not null access Ada.Streams.Root_Stream_Type'Class;
                       <Item>   : in <T>'Class)

168/2
               First writes the external tag of <Item> to <Stream> (by
               calling String'Output(<Stream>,
               Tags.External_Tag(<Item>'Tag)) -- see *note 3.9::) and
               then dispatches to the subprogram denoted by the Output
               attribute of the specific type identified by the tag.
               Tag_Error is raised if the tag of Item identifies a type
               declared at an accessibility level deeper than that of S.
               See *note 13.13.2::.

169
S'Output
               For every subtype S of a specific type <T>:

170
               S'Output denotes a procedure with the following
               specification:

171/2
                    procedure S'Output(
                       <Stream> : not null access Ada.Streams.Root_Stream_Type'Class;
                       <Item> : in <T>)

172
               S'Output writes the value of <Item> to <Stream>,
               including any bounds or discriminants.  See *note
               13.13.2::.

172.1/3
X'Overlaps_Storage
               For a prefix X that denotes an object:

172.2/3
               X'Overlaps_Storage denotes a function with the following
               specification:

172.3/3
                    function X'Overlaps_Storage (<Arg> : <any_type>)
                      return Boolean

172.4/3
               The actual parameter shall be a name that denotes an
               object.  The object denoted by the actual parameter can
               be of any type.  This function evaluates the names of the
               objects involved and returns True if the representation
               of the object denoted by the actual parameter shares at
               least one bit with the representation of the object
               denoted by X; otherwise, it returns False.  See *note
               13.3::.

173/1
D'Partition_Id
               For a prefix D that denotes a library-level declaration,
               excepting a declaration of or within a declared-pure
               library unit:

174
               Denotes a value of the type <universal_integer> that
               identifies the partition in which D was elaborated.  If D
               denotes the declaration of a remote call interface
               library unit (see *note E.2.3::) the given partition is
               the one where the body of D was elaborated.  See *note
               E.1::.

175
S'Pos
               For every discrete subtype S:

176
               S'Pos denotes a function with the following
               specification:

177
                    function S'Pos(<Arg> : S'Base)
                      return <universal_integer>

178
               This function returns the position number of the value of
               <Arg>, as a value of type <universal_integer>.  See *note
               3.5.5::.

179
R.C'Position
               For a component C of a composite, non-array object R:

180/2
               If the nondefault bit ordering applies to the composite
               type, and if a component_clause specifies the placement
               of C, denotes the value given for the position of the
               component_clause; otherwise, denotes the same value as
               R.C'Address - R'Address.  The value of this attribute is
               of the type <universal_integer>.  See *note 13.5.2::.

181
S'Pred
               For every scalar subtype S:

182
               S'Pred denotes a function with the following
               specification:

183
                    function S'Pred(<Arg> : S'Base)
                      return S'Base

184
               For an enumeration type, the function returns the value
               whose position number is one less than that of the value
               of <Arg>; Constraint_Error is raised if there is no such
               value of the type.  For an integer type, the function
               returns the result of subtracting one from the value of
               <Arg>.  For a fixed point type, the function returns the
               result of subtracting <small> from the value of <Arg>.
               For a floating point type, the function returns the
               machine number (as defined in *note 3.5.7::) immediately
               below the value of <Arg>; Constraint_Error is raised if
               there is no such machine number.  See *note 3.5::.

184.1/2
P'Priority
               For a prefix P that denotes a protected object:

184.2/2
               Denotes a non-aliased component of the protected object
               P. This component is of type System.Any_Priority and its
               value is the priority of P. P'Priority denotes a variable
               if and only if P denotes a variable.  A reference to this
               attribute shall appear only within the body of P. See
               *note D.5.2::.

185/1
A'Range
               For a prefix A that is of an array type (after any
               implicit dereference), or denotes a constrained array
               subtype:

186
               A'Range is equivalent to the range A'First ..  A'Last,
               except that the prefix A is only evaluated once.  See
               *note 3.6.2::.

187
S'Range
               For every scalar subtype S:

188
               S'Range is equivalent to the range S'First ..  S'Last.
               See *note 3.5::.

189/1
A'Range(N)
               For a prefix A that is of an array type (after any
               implicit dereference), or denotes a constrained array
               subtype:

190
               A'Range(N) is equivalent to the range A'First(N) ..
               A'Last(N), except that the prefix A is only evaluated
               once.  See *note 3.6.2::.

191
S'Class'Read
               For every subtype S'Class of a class-wide type <T>'Class:

192
               S'Class'Read denotes a procedure with the following
               specification:

193/2
                    procedure S'Class'Read(
                       <Stream> : not null access Ada.Streams.Root_Stream_Type'Class;
                       <Item> : out <T>'Class)

194
               Dispatches to the subprogram denoted by the Read
               attribute of the specific type identified by the tag of
               Item.  See *note 13.13.2::.

195
S'Read
               For every subtype S of a specific type <T>:

196
               S'Read denotes a procedure with the following
               specification:

197/2
                    procedure S'Read(
                       <Stream> : not null access Ada.Streams.Root_Stream_Type'Class;
                       <Item> : out <T>)

198
               S'Read reads the value of <Item> from <Stream>.  See
               *note 13.13.2::.

199
S'Remainder
               For every subtype S of a floating point type <T>:

200
               S'Remainder denotes a function with the following
               specification:

201
                    function S'Remainder (<X>, <Y> : <T>)
                      return <T>

202
               For nonzero <Y>, let <v> be the value <X> - <n> · <Y>,
               where <n> is the integer nearest to the exact value of
               <X>/<Y>; if |<n> - <X>/<Y>| = 1/2, then <n> is chosen to
               be even.  If <v> is a machine number of the type <T>, the
               function yields <v>; otherwise, it yields zero.  
               Constraint_Error is raised if <Y> is zero.  A zero result
               has the sign of <X> when S'Signed_Zeros is True.  See
               *note A.5.3::.

202.1/3
F'Result
               For a prefix F that denotes a function declaration:

202.2/3
               Within a postcondition expression for function F, denotes
               the result object of the function.  The type of this
               attribute is that of the function result except within a
               Post'Class postcondition expression for a function with a
               controlling result or with a controlling access result.
               For a controlling result, the type of the attribute is
               <T>'Class, where <T> is the function result type.  For a
               controlling access result, the type of the attribute is
               an anonymous access type whose designated type is
               <T>'Class, where <T> is the designated type of the
               function result type.  See *note 6.1.1::.

203
S'Round
               For every decimal fixed point subtype S:

204
               S'Round denotes a function with the following
               specification:

205
                    function S'Round(<X> : <universal_real>)
                      return S'Base

206
               The function returns the value obtained by rounding X
               (away from 0, if X is midway between two values of the
               type of S). See *note 3.5.10::.

207
S'Rounding
               For every subtype S of a floating point type <T>:

208
               S'Rounding denotes a function with the following
               specification:

209
                    function S'Rounding (<X> : <T>)
                      return <T>

210
               The function yields the integral value nearest to <X>,
               rounding away from zero if <X> lies exactly halfway
               between two integers.  A zero result has the sign of <X>
               when S'Signed_Zeros is True.  See *note A.5.3::.

211
S'Safe_First
               For every subtype S of a floating point type <T>:

212
               Yields the lower bound of the safe range (see *note
               3.5.7::) of the type <T>.  If the Numerics Annex is not
               supported, the value of this attribute is implementation
               defined; see *note G.2.2:: for the definition that
               applies to implementations supporting the Numerics Annex.
               The value of this attribute is of the type
               <universal_real>.  See *note A.5.3::.

213
S'Safe_Last
               For every subtype S of a floating point type <T>:

214
               Yields the upper bound of the safe range (see *note
               3.5.7::) of the type <T>.  If the Numerics Annex is not
               supported, the value of this attribute is implementation
               defined; see *note G.2.2:: for the definition that
               applies to implementations supporting the Numerics Annex.
               The value of this attribute is of the type
               <universal_real>.  See *note A.5.3::.

215
S'Scale
               For every decimal fixed point subtype S:

216
               S'Scale denotes the <scale> of the subtype S, defined as
               the value N such that S'Delta = 10.0**(-N). The scale
               indicates the position of the point relative to the
               rightmost significant digits of values of subtype S. The
               value of this attribute is of the type
               <universal_integer>.  See *note 3.5.10::.

217
S'Scaling
               For every subtype S of a floating point type <T>:

218
               S'Scaling denotes a function with the following
               specification:

219
                    function S'Scaling (<X> : <T>;
                                        <Adjustment> : <universal_integer>)
                      return <T>

220
               Let <v> be the value <X> · <T>'Machine_Radix<Adjustment>.
               If <v> is a machine number of the type <T>, or if |<v>|
               >= <T>'Model_Small, the function yields <v>; otherwise,
               it yields either one of the machine numbers of the type
               <T> adjacent to <v>.  Constraint_Error is optionally
               raised if <v> is outside the base range of S. A zero
               result has the sign of <X> when S'Signed_Zeros is True.
               See *note A.5.3::.

221
S'Signed_Zeros
               For every subtype S of a floating point type <T>:

222
               Yields the value True if the hardware representation for
               the type <T> has the capability of representing both
               positively and negatively signed zeros, these being
               generated and used by the predefined operations of the
               type <T> as specified in IEC 559:1989; yields the value
               False otherwise.  The value of this attribute is of the
               predefined type Boolean.  See *note A.5.3::.

223
S'Size
               For every subtype S:

224
               If S is definite, denotes the size (in bits) that the
               implementation would choose for the following objects of
               subtype S:

225
                  * A record component of subtype S when the record type
                    is packed.

226
                  * The formal parameter of an instance of
                    Unchecked_Conversion that converts from subtype S to
                    some other subtype.

227
               If S is indefinite, the meaning is implementation
               defined.  The value of this attribute is of the type
               <universal_integer>.  See *note 13.3::.

228/1
X'Size
               For a prefix X that denotes an object:

229
               Denotes the size in bits of the representation of the
               object.  The value of this attribute is of the type
               <universal_integer>.  See *note 13.3::.

230
S'Small
               For every fixed point subtype S:

231
               S'Small denotes the <small> of the type of S. The value
               of this attribute is of the type <universal_real>.  See
               *note 3.5.10::.

232
S'Storage_Pool
               For every access-to-object subtype S:

233
               Denotes the storage pool of the type of S. The type of
               this attribute is Root_Storage_Pool'Class.  See *note
               13.11::.

234
S'Storage_Size
               For every access-to-object subtype S:

235
               Yields the result of calling
               Storage_Size(S'Storage_Pool), which is intended to be a
               measure of the number of storage elements reserved for
               the pool.  The type of this attribute is
               <universal_integer>.  See *note 13.11::.

236/1
T'Storage_Size
               For a prefix T that denotes a task object (after any
               implicit dereference):

237
               Denotes the number of storage elements reserved for the
               task.  The value of this attribute is of the type
               <universal_integer>.  The Storage_Size includes the size
               of the task's stack, if any.  The language does not
               specify whether or not it includes other storage
               associated with the task (such as the "task control
               block" used by some implementations.)  See *note 13.3::.

237.1/2
S'Stream_Size
               For every subtype S of an elementary type <T>:

237.2/3
               Denotes the number of bits read from or written to a
               stream by the default implementations of S'Read and
               S'Write.  Hence, the number of stream elements required
               per item of elementary type <T> is:

237.3/2
                    <T>'Stream_Size / Ada.Streams.Stream_Element'Size

237.4/2
               The value of this attribute is of type
               <universal_integer> and is a multiple of
               Stream_Element'Size.  See *note 13.13.2::.

238
S'Succ
               For every scalar subtype S:

239
               S'Succ denotes a function with the following
               specification:

240
                    function S'Succ(<Arg> : S'Base)
                      return S'Base

241
               For an enumeration type, the function returns the value
               whose position number is one more than that of the value
               of <Arg>; Constraint_Error is raised if there is no such
               value of the type.  For an integer type, the function
               returns the result of adding one to the value of <Arg>.
               For a fixed point type, the function returns the result
               of adding <small> to the value of <Arg>.  For a floating
               point type, the function returns the machine number (as
               defined in *note 3.5.7::) immediately above the value of
               <Arg>; Constraint_Error is raised if there is no such
               machine number.  See *note 3.5::.

242
S'Tag
               For every subtype S of a tagged type <T> (specific or
               class-wide):

243
               S'Tag denotes the tag of the type <T> (or if <T> is
               class-wide, the tag of the root type of the corresponding
               class).  The value of this attribute is of type Tag.  See
               *note 3.9::.

244
X'Tag
               For a prefix X that is of a class-wide tagged type (after
               any implicit dereference):

245
               X'Tag denotes the tag of X. The value of this attribute
               is of type Tag.  See *note 3.9::.

246
T'Terminated
               For a prefix T that is of a task type (after any implicit
               dereference):

247
               Yields the value True if the task denoted by T is
               terminated, and False otherwise.  The value of this
               attribute is of the predefined type Boolean.  See *note
               9.9::.

248
S'Truncation
               For every subtype S of a floating point type <T>:

249
               S'Truncation denotes a function with the following
               specification:

250
                    function S'Truncation (<X> : <T>)
                      return <T>

251
               The function yields the value 'ceiling(<X>)' when <X> is
               negative, and 'floor(<X>)' otherwise.  A zero result has
               the sign of <X> when S'Signed_Zeros is True.  See *note
               A.5.3::.

252
S'Unbiased_Rounding
               For every subtype S of a floating point type <T>:

253
               S'Unbiased_Rounding denotes a function with the following
               specification:

254
                    function S'Unbiased_Rounding (<X> : <T>)
                      return <T>

255
               The function yields the integral value nearest to <X>,
               rounding toward the even integer if <X> lies exactly
               halfway between two integers.  A zero result has the sign
               of <X> when S'Signed_Zeros is True.  See *note A.5.3::.

256
X'Unchecked_Access
               For a prefix X that denotes an aliased view of an object:

257
               All rules and semantics that apply to X'Access (see *note
               3.10.2::) apply also to X'Unchecked_Access, except that,
               for the purposes of accessibility rules and checks, it is
               as if X were declared immediately within a library
               package.  See *note 13.10::.

258
S'Val
               For every discrete subtype S:

259
               S'Val denotes a function with the following
               specification:

260
                    function S'Val(<Arg> : <universal_integer>)
                      return S'Base

261
               This function returns a value of the type of S whose
               position number equals the value of <Arg>.  See *note
               3.5.5::.

262
X'Valid
               For a prefix X that denotes a scalar object (after any
               implicit dereference):

263/4
               Yields True if and only if the object denoted by X is
               normal, has a valid representation, and then, if the
               preceding conditions hold, the value of X also satisfies
               the predicates of the nominal subtype of X. The value of
               this attribute is of the predefined type Boolean.  See
               *note 13.9.2::.

264
S'Value
               For every scalar subtype S:

265
               S'Value denotes a function with the following
               specification:

266
                    function S'Value(<Arg> : String)
                      return S'Base

267
               This function returns a value given an image of the value
               as a String, ignoring any leading or trailing spaces.
               See *note 3.5::.

268/1
P'Version
               For a prefix P that statically denotes a program unit:

269
               Yields a value of the predefined type String that
               identifies the version of the compilation unit that
               contains the declaration of the program unit.  See *note
               E.3::.

270
S'Wide_Image
               For every scalar subtype S:

271
               S'Wide_Image denotes a function with the following
               specification:

272
                    function S'Wide_Image(<Arg> : S'Base)
                      return Wide_String

273/3
               The function returns an image of the value of <Arg> as a
               Wide_String.  See *note 3.5::.

273.1/4
X'Wide_Image
               For a prefix X that denotes an object of a scalar type
               (after any implicit dereference):

273.2/4
               X'Wide_Image denotes the result of calling function
               S'Wide_Image with <Arg> being X, where S is the nominal
               subtype of X. See *note 3.5::.

274
S'Wide_Value
               For every scalar subtype S:

275
               S'Wide_Value denotes a function with the following
               specification:

276
                    function S'Wide_Value(<Arg> : Wide_String)
                      return S'Base

277
               This function returns a value given an image of the value
               as a Wide_String, ignoring any leading or trailing
               spaces.  See *note 3.5::.

277.1/2
S'Wide_Wide_Image
               For every scalar subtype S:

277.2/2
               S'Wide_Wide_Image denotes a function with the following
               specification:

277.3/2
                    function S'Wide_Wide_Image(<Arg> : S'Base)
                      return Wide_Wide_String

277.4/2
               The function returns an <image> of the value of <Arg>,
               that is, a sequence of characters representing the value
               in display form.  See *note 3.5::.

277.5/4
X'Wide_Wide_Image
               For a prefix X that denotes an object of a scalar type
               (after any implicit dereference):

277.6/4
               X'Wide_Wide_Image denotes the result of calling function
               S'Wide_Wide_Image with <Arg> being X, where S is the
               nominal subtype of X. See *note 3.5::.

277.7/2
S'Wide_Wide_Value
               For every scalar subtype S:

277.8/2
               S'Wide_Wide_Value denotes a function with the following
               specification:

277.9/2
                    function S'Wide_Wide_Value(<Arg> : Wide_Wide_String)
                      return S'Base

277.10/2
               This function returns a value given an image of the value
               as a Wide_Wide_String, ignoring any leading or trailing
               spaces.  See *note 3.5::.

277.11/2
S'Wide_Wide_Width
               For every scalar subtype S:

277.12/2
               S'Wide_Wide_Width denotes the maximum length of a
               Wide_Wide_String returned by S'Wide_Wide_Image over all
               values of the subtype S. It denotes zero for a subtype
               that has a null range.  Its type is <universal_integer>.
               See *note 3.5::.

278
S'Wide_Width
               For every scalar subtype S:

279
               S'Wide_Width denotes the maximum length of a Wide_String
               returned by S'Wide_Image over all values of the subtype
               S. It denotes zero for a subtype that has a null range.
               Its type is <universal_integer>.  See *note 3.5::.

280
S'Width
               For every scalar subtype S:

281
               S'Width denotes the maximum length of a String returned
               by S'Image over all values of the subtype S. It denotes
               zero for a subtype that has a null range.  Its type is
               <universal_integer>.  See *note 3.5::.

282
S'Class'Write
               For every subtype S'Class of a class-wide type <T>'Class:

283
               S'Class'Write denotes a procedure with the following
               specification:

284/2
                    procedure S'Class'Write(
                       <Stream> : not null access Ada.Streams.Root_Stream_Type'Class;
                       <Item>   : in <T>'Class)

285
               Dispatches to the subprogram denoted by the Write
               attribute of the specific type identified by the tag of
               Item.  See *note 13.13.2::.

286
S'Write
               For every subtype S of a specific type <T>:

287
               S'Write denotes a procedure with the following
               specification:

288/2
                    procedure S'Write(
                       <Stream> : not null access Ada.Streams.Root_Stream_Type'Class;
                       <Item> : in <T>)

289
               S'Write writes the value of <Item> to <Stream>.  See
               *note 13.13.2::.


File: arm2012.info,  Node: Annex L,  Next: Annex M,  Prev: Annex K,  Up: Top

Annex L Language-Defined Pragmas
********************************

1
This Annex summarizes the definitions given elsewhere of the
language-defined pragmas.

2
pragma All_Calls_Remote[(<library_unit_>name)]; -- See *note E.2.3::.

2.1/2
pragma Assert([Check =>] <boolean_>expression[, [Message =>] <string_>
expression]); -- See *note 11.4.2::.

2.2/2
pragma Assertion_Policy(<policy_>identifier); -- See *note 11.4.2::.

2.3/3
pragma Assertion_Policy(
         <assertion_>aspect_mark => <policy_>identifier
     {, <assertion_>aspect_mark => <policy_>identifier}); -- See *note
11.4.2::.

3/3
<This paragraph was deleted.> 

3.1/3
pragma Asynchronous (local_name); -- See *note J.15.13::.

4/3
<This paragraph was deleted.> 

4.1/3
pragma Atomic (local_name); -- See *note J.15.8::.

5/3
<This paragraph was deleted.> 

5.1/3
pragma Atomic_Components (<array_>local_name); -- See *note J.15.8::.

6/3
<This paragraph was deleted.> 

6.1/3
pragma Attach_Handler (<handler_>name, expression); -- See *note
J.15.7::.

7/3
<This paragraph was deleted.> 

8/3
<This paragraph was deleted.> 

8.1/3
pragma Convention([Convention =>] <convention_>identifier,[Entity =>]
local_name); -- See *note J.15.5::.

8.2/3
pragma CPU (expression); -- See *note J.15.9::.

8.3/3
pragma Default_Storage_Pool (storage_pool_indicator); -- See *note
13.11.3::.

8.4/2
pragma Detect_Blocking; -- See *note H.5::.

9
pragma Discard_Names[([On => ] local_name)]; -- See *note C.5::.

9.1/3
pragma Dispatching_Domain (expression); -- See *note J.15.10::.

10
pragma Elaborate(<library_unit_>name{, <library_unit_>name}); -- See
*note 10.2.1::.

11
pragma Elaborate_All(<library_unit_>name{, <library_unit_>name}); -- See
*note 10.2.1::.

12
pragma Elaborate_Body[(<library_unit_>name)]; -- See *note 10.2.1::.

13/3
<This paragraph was deleted.> 

13.1/3
pragma Export(
     [Convention =>] <convention_>identifier, [Entity =>] local_name
  [, [External_Name =>] <external_name_string_>expression]
  [, [Link_Name =>] <link_name_string_>expression]); -- See *note
J.15.5::.

14/3
<This paragraph was deleted.> 

14.1/3
pragma Import(
     [Convention =>] <convention_>identifier, [Entity =>] local_name
  [, [External_Name =>] <external_name_string_>expression]
  [, [Link_Name =>] <link_name_string_>expression]); -- See *note
J.15.5::.

14.2/3
pragma Independent (<component_>local_name); -- See *note J.15.8::.

14.3/3
pragma Independent_Components (local_name); -- See *note J.15.8::.

15/3
<This paragraph was deleted.> 

15.1/3
pragma Inline (name{, name}); -- See *note J.15.1::.

16
pragma Inspection_Point[(<object_>name {, <object_>name})]; -- See *note
H.3.2::.

17/3
<This paragraph was deleted.> 

17.1/3
pragma Interrupt_Handler (<handler_>name); -- See *note J.15.7::.

18/3
<This paragraph was deleted.> 

18.1/3
pragma Interrupt_Priority [(expression);] -- See *note J.15.11::.

19
pragma Linker_Options(<string_>expression); -- See *note B.1::.

20
pragma List(identifier); -- See *note 2.8::.

21
pragma Locking_Policy(<policy_>identifier); -- See *note D.3::.

21.1/3
<This paragraph was deleted.> 

21.2/3
pragma No_Return (<procedure_>local_name{, <procedure_>local_name}); --
See *note J.15.2::.

22
pragma Normalize_Scalars; -- See *note H.1::.

23
pragma Optimize(identifier); -- See *note 2.8::.

24/3
<This paragraph was deleted.> 

24.1/3
pragma Pack (<first_subtype_>local_name); -- See *note J.15.3::.

25
pragma Page; -- See *note 2.8::.

25.1/2
pragma Partition_Elaboration_Policy (<policy_>identifier); -- See *note
H.6::.

25.2/2
pragma Preelaborable_Initialization(direct_name); -- See *note 10.2.1::.

26
pragma Preelaborate[(<library_unit_>name)]; -- See *note 10.2.1::.

27/3
<This paragraph was deleted.> 

27.1/3
pragma Priority (expression); -- See *note J.15.11::.

27.2/2
pragma Priority_Specific_Dispatching (
     <policy_>identifier, <first_priority_>expression, <last_priority_>
expression); -- See *note D.2.2::.

27.3/3
pragma Profile (<profile_>identifier {, <profile_>
pragma_argument_association}); -- See *note 13.12::.

27.4/3
<This paragraph was deleted.> 

28
pragma Pure[(<library_unit_>name)]; -- See *note 10.2.1::.

29
pragma Queuing_Policy(<policy_>identifier); -- See *note D.4::.

29.1/3
<This paragraph was deleted.> 

29.2/3
pragma Relative_Deadline (<relative_deadline_>expression); -- See *note
J.15.12::.

30
pragma Remote_Call_Interface[(<library_unit_>name)]; -- See *note
E.2.3::.

31
pragma Remote_Types[(<library_unit_>name)]; -- See *note E.2.2::.

32
pragma Restrictions(restriction{, restriction}); -- See *note 13.12::.

33
pragma Reviewable; -- See *note H.3.1::.

34
pragma Shared_Passive[(<library_unit_>name)]; -- See *note E.2.1::.

35/3
<This paragraph was deleted.> 

35.1/3
pragma Storage_Size (expression); -- See *note J.15.4::.

36
pragma Suppress(identifier); -- See *note 11.5::.

37
pragma Task_Dispatching_Policy(<policy_>identifier); -- See *note
D.2.2::.

37.1/3
<This paragraph was deleted.> 

37.2/3
pragma Unchecked_Union (<first_subtype_>local_name); -- See *note
J.15.6::.

37.3/2
pragma Unsuppress(identifier); -- See *note 11.5::.

38/3
<This paragraph was deleted.> 

38.1/3
pragma Volatile (local_name); -- See *note J.15.8::.

39/3
<This paragraph was deleted.> 

39.1/3
pragma Volatile_Components (<array_>local_name); -- See *note J.15.8::.


File: arm2012.info,  Node: Annex M,  Next: Annex N,  Prev: Annex L,  Up: Top

Annex M Summary of Documentation Requirements
*********************************************

1/3
The Ada language allows for certain target machine dependences in a
controlled manner.  Each Ada implementation must document many
characteristics and properties of the target system.  This International
Standard contains specific documentation requirements.  In addition,
many characteristics that require documentation are identified
throughout this International Standard as being implementation defined.
Finally, this International Standard requires documentation of whether
implementation advice is followed.  The following subclauses provide
summaries of these documentation requirements.

* Menu:

* M.1 ::      Specific Documentation Requirements
* M.2 ::      Implementation-Defined Characteristics
* M.3 ::      Implementation Advice


File: arm2012.info,  Node: M.1,  Next: M.2,  Up: Annex M

M.1 Specific Documentation Requirements
=======================================

1/2
In addition to implementation-defined characteristics, each Ada
implementation must document various properties of the implementation:

2/2
   * The behavior of implementations in implementation-defined
     situations shall be documented -- see *note M.2::, "*note M.2::
     Implementation-Defined Characteristics" for a listing.  See *note
     1.1.3::(19).

3/2
   * The set of values that a user-defined Allocate procedure needs to
     accept for the Alignment parameter.  How the standard storage pool
     is chosen, and how storage is allocated by standard storage pools.
     See *note 13.11::(22).

4/2
   * The algorithm used for random number generation, including a
     description of its period.  See *note A.5.2::(44).

5/2
   * The minimum time interval between calls to the time-dependent Reset
     procedure that is guaranteed to initiate different random number
     sequences.  See *note A.5.2::(45).

6/2
   * The conditions under which Io_Exceptions.Name_Error,
     Io_Exceptions.Use_Error, and Io_Exceptions.Device_Error are
     propagated.  See *note A.13::(15).

7/2
   * The behavior of package Environment_Variables when environment
     variables are changed by external mechanisms.  See *note
     A.17::(30/2).

8/2
   * The overhead of calling machine-code or intrinsic subprograms.  See
     *note C.1::(6).

9/2
   * The types and attributes used in machine code insertions.  See
     *note C.1::(7).

10/2
   * The subprogram calling conventions for all supported convention
     identifiers.  See *note C.1::(8/3).

11/2
   * The mapping between the Link_Name or Ada designator and the
     external link name.  See *note C.1::(9).

12/2
   * The treatment of interrupts.  See *note C.3::(22).

13/2
   * The metrics for interrupt handlers.  See *note C.3.1::(16).

14/3
   * If the Ceiling_Locking policy is in effect, the default ceiling
     priority for a protected object that specifies an interrupt handler
     aspect.  See *note C.3.2::(24/3).

15/2
   * Any circumstances when the elaboration of a preelaborated package
     causes code to be executed.  See *note C.4::(12).

16/2
   * Whether a partition can be restarted without reloading.  See *note
     C.4::(13).

17/2
   * The effect of calling Current_Task from an entry body or interrupt
     handler.  See *note C.7.1::(19).

18/2
   * For package Task_Attributes, limits on the number and size of task
     attributes, and how to configure any limits.  See *note
     C.7.2::(19).

19/2
   * The metrics for the Task_Attributes package.  See *note
     C.7.2::(27).

20/2
   * The details of the configuration used to generate the values of all
     metrics.  See *note D::(2).

21/2
   * The maximum priority inversion a user task can experience from the
     implementation.  See *note D.2.3::(12/2).

22/2
   * The amount of time that a task can be preempted for processing on
     behalf of lower-priority tasks.  See *note D.2.3::(13/2).

23/2
   * The quantum values supported for round robin dispatching.  See
     *note D.2.5::(16/2).

24/2
   * The accuracy of the detection of the exhaustion of the budget of a
     task for round robin dispatching.  See *note D.2.5::(17/2).

25/2
   * Any conditions that cause the completion of the setting of the
     deadline of a task to be delayed for a multiprocessor.  See *note
     D.2.6::(32/2).

26/2
   * Any conditions that cause the completion of the setting of the
     priority of a task to be delayed for a multiprocessor.  See *note
     D.5.1::(12.1/2).

27/2
   * The metrics for Set_Priority.  See *note D.5.1::(14).

28/2
   * The metrics for setting the priority of a protected object.  See
     *note D.5.2::(10).

29/2
   * On a multiprocessor, any conditions that cause the completion of an
     aborted construct to be delayed later than what is specified for a
     single processor.  See *note D.6::(3).

30/2
   * The metrics for aborts.  See *note D.6::(8).

31/2
   * The values of Time_First, Time_Last, Time_Span_First,
     Time_Span_Last, Time_Span_Unit, and Tick for package Real_Time.
     See *note D.8::(33).

32/2
   * The properties of the underlying time base used in package
     Real_Time.  See *note D.8::(34).

33/2
   * Any synchronization of package Real_Time with external time
     references.  See *note D.8::(35).

34/2
   * Any aspects of the external environment that could interfere with
     package Real_Time.  See *note D.8::(36/3).

35/2
   * The metrics for package Real_Time.  See *note D.8::(45).

36/2
   * The minimum value of the delay expression of a
     delay_relative_statement that causes a task to actually be blocked.
     See *note D.9::(7).

37/2
   * The minimum difference between the value of the delay expression of
     a delay_until_statement and the value of Real_Time.Clock, that
     causes the task to actually be blocked.  See *note D.9::(8).

38/2
   * The metrics for delay statements.  See *note D.9::(13).

39/2
   * The upper bound on the duration of interrupt blocking caused by the
     implementation.  See *note D.12::(5).

40/2
   * The metrics for entry-less protected objects.  See *note
     D.12::(12).

41/2
   * The values of CPU_Time_First, CPU_Time_Last, CPU_Time_Unit, and
     CPU_Tick of package Execution_Time.  See *note D.14::(21/2).

42/3
   * The properties of the mechanism used to implement package
     Execution_Time, including the values of the constants defined in
     the package.  See *note D.14::(22/2).

43/2
   * The metrics for execution time.  See *note D.14::(27).

44/2
   * The metrics for timing events.  See *note D.15::(24).

44.1/3
   * The processor(s) on which the clock interrupt is handled; the
     processors on which each Interrupt_Id can be handled.  See *note
     D.16.1::(32).

45/2
   * Whether the RPC-receiver is invoked from concurrent tasks, and if
     so, the number of such tasks.  See *note E.5::(25).

46/2
   * Any techniques used to reduce cancellation errors in
     Numerics.Generic_Real_Arrays shall be documented.  See *note
     G.3.1::(86/2).

47/2
   * Any techniques used to reduce cancellation errors in
     Numerics.Generic_Complex_Arrays shall be documented.  See *note
     G.3.2::(155/2).

48/2
   * If a pragma Normalize_Scalars applies, the implicit initial values
     of scalar subtypes shall be documented.  Such a value should be an
     invalid representation when possible; any cases when is it not
     shall be documented.  See *note H.1::(5/2).

49/2
   * The range of effects for each bounded error and each unspecified
     effect.  If the effects of a given erroneous construct are
     constrained, the constraints shall be documented.  See *note
     H.2::(1).

50/2
   * For each inspection point, a mapping between each inspectable
     object and the machine resources where the object's value can be
     obtained shall be provided.  See *note H.3.2::(8).

51/2
   * If a pragma Restrictions(No_Exceptions) is specified, the effects
     of all constructs where language-defined checks are still
     performed.  See *note H.4::(25).

52/2
   * The interrupts to which a task entry may be attached.  See *note
     J.7.1::(12).

53/2
   * The type of entry call invoked for an interrupt entry.  See *note
     J.7.1::(13).


File: arm2012.info,  Node: M.2,  Next: M.3,  Prev: M.1,  Up: Annex M

M.2 Implementation-Defined Characteristics
==========================================

1/2
The Ada language allows for certain machine dependences in a controlled
manner.  Each Ada implementation must document all
implementation-defined characteristics:

2/2
   * Whether or not each recommendation given in Implementation Advice
     is followed -- see *note M.3::, "*note M.3:: Implementation Advice"
     for a listing.  See *note 1.1.2::(37).

3
   * Capacity limitations of the implementation.  See *note 1.1.3::(3).

4
   * Variations from the standard that are impractical to avoid given
     the implementation's execution environment.  See *note 1.1.3::(6).

5
   * Which code_statements cause external interactions.  See *note
     1.1.3::(10).

6
   * The coded representation for the text of an Ada program.  See *note
     2.1::(4/3).

6.1/2
   * The semantics of an Ada program whose text is not in Normalization
     Form KC. See *note 2.1::(4.1/3).

7/2
   * <This paragraph was deleted.>

8
   * The representation for an end of line.  See *note 2.2::(2/3).

9
   * Maximum supported line length and lexical element length.  See
     *note 2.2::(14).

10
   * Implementation-defined pragmas.  See *note 2.8::(14).

11
   * Effect of pragma Optimize.  See *note 2.8::(27).

11.1/4
   * The message string associated with the Assertion_Error exception
     raised by the failure of a predicate check if there is no
     applicable Predicate_Failure aspect.  See *note 3.2.4::(31).

11.2/2
   * The sequence of characters of the value returned by S'Wide_Image
     when some of the graphic characters of S'Wide_Wide_Image are not
     defined in Wide_Character.  See *note 3.5::(30/3).

12/2
   * The sequence of characters of the value returned by S'Image when
     some of the graphic characters of S'Wide_Wide_Image are not defined
     in Character.  See *note 3.5::(37/3).

13
   * The predefined integer types declared in Standard.  See *note
     3.5.4::(25).

14
   * Any nonstandard integer types and the operators defined for them.
     See *note 3.5.4::(26).

15
   * Any nonstandard real types and the operators defined for them.  See
     *note 3.5.6::(8).

16
   * What combinations of requested decimal precision and range are
     supported for floating point types.  See *note 3.5.7::(7).

17
   * The predefined floating point types declared in Standard.  See
     *note 3.5.7::(16).

18
   * The <small> of an ordinary fixed point type.  See *note
     3.5.9::(8/2).

19
   * What combinations of <small>, range, and <digits> are supported for
     fixed point types.  See *note 3.5.9::(10).

20/2
   * The result of Tags.Wide_Wide_Expanded_Name for types declared
     within an unnamed block_statement.  See *note 3.9::(10).

20.1/2
   * The sequence of characters of the value returned by
     Tags.Expanded_Name (respectively, Tags.Wide_Expanded_Name) when
     some of the graphic characters of Tags.Wide_Wide_Expanded_Name are
     not defined in Character (respectively, Wide_Character).  See *note
     3.9::(10.1/2).

21
   * Implementation-defined attributes.  See *note 4.1.4::(12/1).

21.1/2
   * Rounding of real static expressions which are exactly half-way
     between two machine numbers.  See *note 4.9::(38/2).

22
   * Any implementation-defined time types.  See *note 9.6::(6/3).

23
   * The time base associated with relative delays.  See *note
     9.6::(20).

24
   * The time base of the type Calendar.Time.  See *note 9.6::(23).

25/2
   * The time zone used for package Calendar operations.  See *note
     9.6::(24/2).

26
   * Any limit on delay_until_statements of select_statements.  See
     *note 9.6::(29).

26.1/2
   * The result of Calendar.Formating.Image if its argument represents
     more than 100 hours.  See *note 9.6.1::(86/2).

27/3
   * <This paragraph was deleted.>

28
   * The representation for a compilation.  See *note 10.1::(2).

29
   * Any restrictions on compilations that contain multiple
     compilation_units.  See *note 10.1::(4).

30
   * The mechanisms for creating an environment and for adding and
     replacing compilation units.  See *note 10.1.4::(3/2).

30.1/2
   * The mechanisms for adding a compilation unit mentioned in a
     limited_with_clause to an environment.  See *note 10.1.4::(3/2).

31
   * The manner of explicitly assigning library units to a partition.
     See *note 10.2::(2).

32
   * The implementation-defined means, if any, of specifying which
     compilation units are needed by a given compilation unit.  See
     *note 10.2::(2).

33
   * The manner of designating the main subprogram of a partition.  See
     *note 10.2::(7).

34
   * The order of elaboration of library_items.  See *note 10.2::(18).

35
   * Parameter passing and function return for the main subprogram.  See
     *note 10.2::(21).

36
   * The mechanisms for building and running partitions.  See *note
     10.2::(24).

37
   * The details of program execution, including program termination.
     See *note 10.2::(25).

38
   * The semantics of any nonactive partitions supported by the
     implementation.  See *note 10.2::(28/3).

39
   * The information returned by Exception_Message.  See *note
     11.4.1::(10.1/4).

40/2
   * The result of Exceptions.Wide_Wide_Exception_Name for exceptions
     declared within an unnamed block_statement.  See *note
     11.4.1::(12).

40.1/2
   * The sequence of characters of the value returned by
     Exceptions.Exception_Name (respectively,
     Exceptions.Wide_Exception_Name) when some of the graphic characters
     of Exceptions.Wide_Wide_Exception_Name are not defined in Character
     (respectively, Wide_Character).  See *note 11.4.1::(12.1/2).

41
   * The information returned by Exception_Information.  See *note
     11.4.1::(13/2).

41.1/3
   * Implementation-defined <policy_>identifiers and
     <assertion_>aspect_marks allowed in a pragma Assertion_Policy.  See
     *note 11.4.2::(9/3).

41.2/2
   * The default assertion policy.  See *note 11.4.2::(10).

42
   * Implementation-defined check names.  See *note 11.5::(27).

42.1/2
   * Existence and meaning of second parameter of pragma Unsuppress.
     See *note 11.5::(27.1/2).

42.2/2
   * The cases that cause conflicts between the representation of the
     ancestors of a type_declaration.  See *note 13.1::(13.1/3).

43/3
   * The interpretation of each representation aspect.  See *note
     13.1::(20).

44/3
   * Any restrictions placed upon the specification of representation
     aspects.  See *note 13.1::(20).

44.1/3
   * Implementation-defined aspects, inluding the syntax for specifying
     such aspects and the legality rules for such aspects.  See *note
     13.1.1::(38).

44.2/2
   * The set of machine scalars.  See *note 13.3::(8.1/3).

45
   * The meaning of Size for indefinite subtypes.  See *note 13.3::(48).

46
   * The default external representation for a type tag.  See *note
     13.3::(75/3).

47
   * What determines whether a compilation unit is the same in two
     different partitions.  See *note 13.3::(76).

48
   * Implementation-defined components.  See *note 13.5.1::(15).

49
   * If Word_Size = Storage_Unit, the default bit ordering.  See *note
     13.5.3::(5).

50/2
   * The contents of the visible part of package System.  See *note
     13.7::(2).

50.1/2
   * The range of Storage_Elements.Storage_Offset, the modulus of
     Storage_Elements.Storage_Element, and the declaration of
     Storage_Elements.Integer_Address..  See *note 13.7.1::(11).

51
   * The contents of the visible part of package System.Machine_Code,
     and the meaning of code_statements.  See *note 13.8::(7).

51.1/2
   * The result of unchecked conversion for instances with scalar result
     types whose result is not defined by the language.  See *note
     13.9::(11).

52/2
   * The effect of unchecked conversion for instances with nonscalar
     result types whose effect is not defined by the language.  See
     *note 13.9::(11).

53/2
   * <This paragraph was deleted.>

54
   * Whether or not the implementation provides user-accessible names
     for the standard pool type(s).  See *note 13.11::(17).

55/2
   * The meaning of Storage_Size when neither the Storage_Size nor the
     Storage_Pool is specified for an access type.  See *note
     13.11::(18).

56/2
   * <This paragraph was deleted.>

56.1/4
   * The effect of specifying aspect Default_Storage_Pool on an instance
     of a language-defined generic unit.  See *note 13.11.3::(5).

57/3
   * <This paragraph was deleted.>

57.1/3
   * Implementation-defined restrictions allowed in a pragma
     Restrictions.  See *note 13.12::(8.7/3).

58
   * The consequences of violating limitations on Restrictions pragmas.
     See *note 13.12::(9).

58.1/3
   * Implementation-defined usage profiles allowed in a pragma Profile.
     See *note 13.12::(15).

59/2
   * The contents of the stream elements read and written by the Read
     and Write attributes of elementary types.  See *note 13.13.2::(9).

60
   * The names and characteristics of the numeric subtypes declared in
     the visible part of package Standard.  See *note A.1::(3).

60.1/2
   * The values returned by Strings.Hash.  See *note A.4.9::(3/2).

61
   * The accuracy actually achieved by the elementary functions.  See
     *note A.5.1::(1).

62
   * The sign of a zero result from some of the operators or functions
     in Numerics.Generic_Elementary_Functions, when
     Float_Type'Signed_Zeros is True.  See *note A.5.1::(46).

63
   * The value of Numerics.Float_Random.Max_Image_Width.  See *note
     A.5.2::(27).

64
   * The value of Numerics.Discrete_Random.Max_Image_Width.  See *note
     A.5.2::(27).

65/2
   * <This paragraph was deleted.>

66
   * The string representation of a random number generator's state.
     See *note A.5.2::(38).

67/2
   * <This paragraph was deleted.>

68
   * The values of the Model_Mantissa, Model_Emin, Model_Epsilon, Model,
     Safe_First, and Safe_Last attributes, if the Numerics Annex is not
     supported.  See *note A.5.3::(72).

69/2
   * <This paragraph was deleted.>

70
   * The value of Buffer_Size in Storage_IO. See *note A.9::(10).

71/2
   * The external files associated with the standard input, standard
     output, and standard error files.  See *note A.10::(5).

72
   * The accuracy of the value produced by Put.  See *note A.10.9::(36).

72.1/1
   * Current size for a stream file for which positioning is not
     supported.  See *note A.12.1::(1.1/1).

73/2
   * The meaning of Argument_Count, Argument, and Command_Name for
     package Command_Line.  The bounds of type Command_Line.Exit_Status.
     See *note A.15::(1).

73.1/2
   * The interpretation of file names and directory names.  See *note
     A.16::(46/2).

73.2/2
   * The maximum value for a file size in Directories.  See *note
     A.16::(87/2).

73.3/2
   * The result for Directories.Size for a directory or special file See
     *note A.16::(93/2).

73.4/2
   * The result for Directories.Modification_Time for a directory or
     special file.  See *note A.16::(95/2).

73.5/2
   * The interpretation of a nonnull search pattern in Directories.  See
     *note A.16::(104/3).

73.6/2
   * The results of a Directories search if the contents of the
     directory are altered while a search is in progress.  See *note
     A.16::(110/3).

73.7/2
   * The definition and meaning of an environment variable.  See *note
     A.17::(1/2).

73.8/2
   * The circumstances where an environment variable cannot be defined.
     See *note A.17::(16/2).

73.9/2
   * Environment names for which Set has the effect of Clear.  See *note
     A.17::(17/2).

73.10/2
   * The value of Containers.Hash_Type'Modulus.  The value of
     Containers.Count_Type'Last.  See *note A.18.1::(7/2).

74
   * Implementation-defined convention names.  See *note B.1::(11/3).

75
   * The meaning of link names.  See *note B.1::(36).

76
   * The manner of choosing link names when neither the link name nor
     the address of an imported or exported entity is specified.  See
     *note B.1::(36).

77
   * The effect of pragma Linker_Options.  See *note B.1::(37).

78
   * The contents of the visible part of package Interfaces and its
     language-defined descendants.  See *note B.2::(1).

79/2
   * Implementation-defined children of package Interfaces.  See *note
     B.2::(11).

79.1/2
   * The definitions of certain types and constants in Interfaces.C. See
     *note B.3::(41).

80/1
   * The types Floating, Long_Floating, Binary, Long_Binary,
     Decimal_Element, and COBOL_Character; and the initializations of
     the variables Ada_To_COBOL and COBOL_To_Ada, in Interfaces.COBOL.
     See *note B.4::(50).

80.1/1
   * The types Fortran_Integer, Real, Double_Precision, and
     Character_Set in Interfaces.Fortran.  See *note B.5::(17).

81/2
   * Implementation-defined intrinsic subprograms.  See *note
     C.1::(1/3).

82/2
   * <This paragraph was deleted.>

83/2
   * <This paragraph was deleted.>

83.1/3
   * Any restrictions on a protected procedure or its containing type
     when an aspect Attach_handler or Interrupt_Handler is specified.
     See *note C.3.1::(17).

83.2/3
   * Any other forms of interrupt handler supported by the
     Attach_Handler and Interrupt_Handler aspects.  See *note
     C.3.1::(19).

84/2
   * <This paragraph was deleted.>

85/4
   * The semantics of some attributes and functions of an entity for
     which aspect Discard_Names is True.  See *note C.5::(7).

86
   * The result of the Task_Identification.Image attribute.  See *note
     C.7.1::(7).

87/2
   * The value of Current_Task when in a protected entry, interrupt
     handler, or finalization of a task attribute.  See *note
     C.7.1::(17/3).

88/2
   * <This paragraph was deleted.>

88.1/1
   * Granularity of locking for Task_Attributes.  See *note
     C.7.2::(16/1).

89/2
   * <This paragraph was deleted.>

90/2
   * <This paragraph was deleted.>

91
   * The declarations of Any_Priority and Priority.  See *note
     D.1::(11).

92
   * Implementation-defined execution resources.  See *note D.1::(15).

93
   * Whether, on a multiprocessor, a task that is waiting for access to
     a protected object keeps its processor busy.  See *note D.2.1::(3).

94/2
   * The effect of implementation-defined execution resources on task
     dispatching.  See *note D.2.1::(9/2).

95/2
   * <This paragraph was deleted.>

96/2
   * <This paragraph was deleted.>

97/2
   * Implementation defined task dispatching policies.  See *note
     D.2.2::(19).

97.1/2
   * The value of Default_Quantum in Dispatching.Round_Robin.  See *note
     D.2.5::(4).

98
   * Implementation-defined <policy_>identifiers allowed in a pragma
     Locking_Policy.  See *note D.3::(4).

98.1/2
   * The locking policy if no Locking_Policy pragma applies to any unit
     of a partition.  See *note D.3::(6).

99
   * Default ceiling priorities.  See *note D.3::(10/4).

100
   * The ceiling of any protected object used internally by the
     implementation.  See *note D.3::(16).

101
   * Implementation-defined queuing policies.  See *note D.4::(1/3).

102/2
   * <This paragraph was deleted.>

103
   * Any operations that implicitly require heap storage allocation.
     See *note D.7::(8).

103.1/4
   * When restriction No_Dynamic_CPU_Assignment applies to a partition,
     the processor on which a task with a CPU value of a
     Not_A_Specific_CPU will execute.  See *note D.7::(10).

103.2/2
   * When restriction No_Task_Termination applies to a partition, what
     happens when a task terminates.  See *note D.7::(15.1/2).

103.3/2
   * The behavior when restriction Max_Storage_At_Blocking is violated.
     See *note D.7::(17/1).

103.4/2
   * The behavior when restriction Max_Asynchronous_Select_Nesting is
     violated.  See *note D.7::(18/1).

103.5/2
   * The behavior when restriction Max_Tasks is violated.  See *note
     D.7::(19).

104/2
   * Whether the use of pragma Restrictions results in a reduction in
     program code or data size or execution time.  See *note D.7::(20).

105/2
   * <This paragraph was deleted.>

106/2
   * <This paragraph was deleted.>

106.1/3
   * The value of Barrier_Limit'Last in Synchronous_Barriers.  See *note
     D.10.1::(4/3).

106.2/3
   * When an aborted task that is waiting on a Synchronous_Barrier is
     aborted.  See *note D.10.1::(13/3).

107/2
   * <This paragraph was deleted.>

107.1/3
   * The value of Min_Handler_Ceiling in Execution_Time.Group_Budgets.
     See *note D.14.2::(7/2).

107.2/3
   * The value of CPU_Range'Last in System.Multiprocessors.  See *note
     D.16::(4/3).

107.3/3
   * The processor on which the environment task executes in the absence
     of a value for the aspect CPU. See *note D.16::(13/3).

108
   * The means for creating and executing distributed programs.  See
     *note E::(5).

109
   * Any events that can result in a partition becoming inaccessible.
     See *note E.1::(7).

110
   * The scheduling policies, treatment of priorities, and management of
     shared resources between partitions in certain cases.  See *note
     E.1::(11).

111/1
   * <This paragraph was deleted.>

112
   * Whether the execution of the remote subprogram is immediately
     aborted as a result of cancellation.  See *note E.4::(13).

112.1/2
   * The range of type System.RPC.Partition_Id.  See *note E.5::(14).

113/2
   * <This paragraph was deleted.>

114
   * Implementation-defined interfaces in the PCS. See *note E.5::(26).

115
   * The values of named numbers in the package Decimal.  See *note
     F.2::(7).

116
   * The value of Max_Picture_Length in the package Text_IO.Editing See
     *note F.3.3::(16).

117
   * The value of Max_Picture_Length in the package Wide_Text_IO.Editing
     See *note F.3.4::(5).

117.1/2
   * The value of Max_Picture_Length in the package
     Wide_Wide_Text_IO.Editing See *note F.3.5::(5).

118
   * The accuracy actually achieved by the complex elementary functions
     and by other complex arithmetic operations.  See *note G.1::(1).

119
   * The sign of a zero result (or a component thereof) from any
     operator or function in Numerics.Generic_Complex_Types, when
     Real'Signed_Zeros is True.  See *note G.1.1::(53).

120
   * The sign of a zero result (or a component thereof) from any
     operator or function in
     Numerics.Generic_Complex_Elementary_Functions, when
     Complex_Types.Real'Signed_Zeros is True.  See *note G.1.2::(45).

121
   * Whether the strict mode or the relaxed mode is the default.  See
     *note G.2::(2).

122
   * The result interval in certain cases of fixed-to-float conversion.
     See *note G.2.1::(10).

123
   * The result of a floating point arithmetic operation in overflow
     situations, when the Machine_Overflows attribute of the result type
     is False.  See *note G.2.1::(13).

124
   * The result interval for division (or exponentiation by a negative
     exponent), when the floating point hardware implements division as
     multiplication by a reciprocal.  See *note G.2.1::(16).

125
   * The definition of <close result set>, which determines the accuracy
     of certain fixed point multiplications and divisions.  See *note
     G.2.3::(5).

126
   * Conditions on a <universal_real> operand of a fixed point
     multiplication or division for which the result shall be in the
     <perfect result set>.  See *note G.2.3::(22).

127
   * The result of a fixed point arithmetic operation in overflow
     situations, when the Machine_Overflows attribute of the result type
     is False.  See *note G.2.3::(27).

128
   * The result of an elementary function reference in overflow
     situations, when the Machine_Overflows attribute of the result type
     is False.  See *note G.2.4::(4).

129
   * The value of the <angle threshold>, within which certain elementary
     functions, complex arithmetic operations, and complex elementary
     functions yield results conforming to a maximum relative error
     bound.  See *note G.2.4::(10).

130
   * The accuracy of certain elementary functions for parameters beyond
     the angle threshold.  See *note G.2.4::(10).

131
   * The result of a complex arithmetic operation or complex elementary
     function reference in overflow situations, when the
     Machine_Overflows attribute of the corresponding real type is
     False.  See *note G.2.6::(5).

132
   * The accuracy of certain complex arithmetic operations and certain
     complex elementary functions for parameters (or components thereof)
     beyond the angle threshold.  See *note G.2.6::(8).

132.1/2
   * The accuracy requirements for the subprograms Solve, Inverse,
     Determinant, Eigenvalues and Eigensystem for type Real_Matrix.  See
     *note G.3.1::(81/2).

132.2/2
   * The accuracy requirements for the subprograms Solve, Inverse,
     Determinant, Eigenvalues and Eigensystem for type Complex_Matrix.
     See *note G.3.2::(149/2).

133/2
   * <This paragraph was deleted.>

134/2
   * <This paragraph was deleted.>

135/2
   * <This paragraph was deleted.>

136/2
   * <This paragraph was deleted.>

136.1/2
   * Implementation-defined <policy_>identifiers allowed in a pragma
     Partition_Elaboration_Policy.  See *note H.6::(4/2).


File: arm2012.info,  Node: M.3,  Prev: M.2,  Up: Annex M

M.3 Implementation Advice
=========================

1/2
This International Standard sometimes gives advice about handling
certain target machine dependences.  Each Ada implementation must
document whether that advice is followed:

2/2
   * Program_Error should be raised when an unsupported Specialized
     Needs Annex feature is used at run time.  See *note 1.1.3::(20).

3/2
   * Implementation-defined extensions to the functionality of a
     language-defined library unit should be provided by adding children
     to the library unit.  See *note 1.1.3::(21).

4/2
   * If a bounded error or erroneous execution is detected,
     Program_Error should be raised.  See *note 1.1.5::(12).

5/2
   * Implementation-defined pragmas should have no semantic effect for
     error-free programs.  See *note 2.8::(16/3).

6/2
   * Implementation-defined pragmas should not make an illegal program
     legal, unless they complete a declaration or configure the
     library_items in an environment.  See *note 2.8::(19).

7/2
   * Long_Integer should be declared in Standard if the target supports
     32-bit arithmetic.  No other named integer subtypes should be
     declared in Standard.  See *note 3.5.4::(28).

8/2
   * For a two's complement target, modular types with a binary modulus
     up to System.Max_Int*2+2 should be supported.  A nonbinary modulus
     up to Integer'Last should be supported.  See *note 3.5.4::(29).

9/2
   * Program_Error should be raised for the evaluation of S'Pos for an
     enumeration type, if the value of the operand does not correspond
     to the internal code for any enumeration literal of the type.  See
     *note 3.5.5::(8).

10/2
   * Long_Float should be declared in Standard if the target supports 11
     or more digits of precision.  No other named float subtypes should
     be declared in Standard.  See *note 3.5.7::(17).

11/2
   * Multidimensional arrays should be represented in row-major order,
     unless the array has convention Fortran.  See *note 3.6.2::(11/3).

12/3
   * Tags.Internal_Tag should return the tag of a type, if one exists,
     whose innermost master is a master of the point of the function
     call..  See *note 3.9::(26.1/3).

13/2
   * A real static expression with a nonformal type that is not part of
     a larger static expression should be rounded the same as the target
     system.  See *note 4.9::(38.1/2).

14/2
   * The value of Duration'Small should be no greater than 100
     microseconds.  See *note 9.6::(30).

15/2
   * The time base for delay_relative_statements should be monotonic.
     See *note 9.6::(31).

16/2
   * Leap seconds should be supported if the target system supports
     them.  Otherwise, operations in Calendar.Formatting should return
     results consistent with no leap seconds.  See *note 9.6.1::(89/2).

17/2
   * When applied to a generic unit, a program unit pragma that is not a
     library unit pragma should apply to each instance of the generic
     unit for which there is not an overriding pragma applied directly
     to the instance.  See *note 10.1.5::(10/1).

18/2
   * A type declared in a preelaborated package should have the same
     representation in every elaboration of a given version of the
     package.  See *note 10.2.1::(12).

19/2
   * Exception_Information should provide information useful for
     debugging, and should include the Exception_Name and
     Exception_Message.  See *note 11.4.1::(19).

20/2
   * Exception_Message by default should be short, provide information
     useful for debugging, and should not include the Exception_Name.
     See *note 11.4.1::(19).

21/2
   * Code executed for checks that have been suppressed should be
     minimized.  See *note 11.5::(28).

22/2
   * The recommended level of support for all representation items
     should be followed.  See *note 13.1::(28/3).

23/2
   * Storage allocated to objects of a packed type should be minimized.
     See *note 13.2::(6).

24/3
   * The recommended level of support for the Pack aspect should be
     followed.  See *note 13.2::(9).

25/2
   * For an array X, X'Address should point at the first component of
     the array rather than the array bounds.  See *note 13.3::(14).

26/2
   * The recommended level of support for the Address attribute should
     be followed.  See *note 13.3::(19).

26.1/3
   * For any tagged specific subtype <S>, <S>'Class'Alignment should
     equal <S>'Alignment.  See *note 13.3::(28).

27/2
   * The recommended level of support for the Alignment attribute should
     be followed.  See *note 13.3::(35).

28/2
   * The Size of an array object should not include its bounds.  See
     *note 13.3::(41.1/2).

29/2
   * If the Size of a subtype allows for efficient independent
     addressability, then the Size of most objects of the subtype should
     equal the Size of the subtype.  See *note 13.3::(52).

30/2
   * A Size clause on a composite subtype should not affect the internal
     layout of components.  See *note 13.3::(53).

31/2
   * The recommended level of support for the Size attribute should be
     followed.  See *note 13.3::(56).

32/2
   * The recommended level of support for the Component_Size attribute
     should be followed.  See *note 13.3::(73).

33/2
   * The recommended level of support for
     enumeration_representation_clauses should be followed.  See *note
     13.4::(10).

34/2
   * The recommended level of support for record_representation_clauses
     should be followed.  See *note 13.5.1::(22).

35/2
   * If a component is represented using a pointer to the actual data of
     the component which is contiguous with the rest of the object, then
     the storage place attributes should reflect the place of the actual
     data.  If a component is allocated discontiguously from the rest of
     the object, then a warning should be generated upon reference to
     one of its storage place attributes.  See *note 13.5.2::(5).

36/2
   * The recommended level of support for the nondefault bit ordering
     should be followed.  See *note 13.5.3::(8).

37/2
   * Type System.Address should be a private type.  See *note
     13.7::(37).

38/2
   * Operations in System and its children should reflect the target
     environment; operations that do not make sense should raise
     Program_Error.  See *note 13.7.1::(16).

39/2
   * Since the Size of an array object generally does not include its
     bounds, the bounds should not be part of the converted data in an
     instance of Unchecked_Conversion.  See *note 13.9::(14/2).

40/2
   * There should not be unnecessary run-time checks on the result of an
     Unchecked_Conversion; the result should be returned by reference
     when possible.  Restrictions on Unchecked_Conversions should be
     avoided.  See *note 13.9::(15).

41/2
   * The recommended level of support for Unchecked_Conversion should be
     followed.  See *note 13.9::(17).

42/2
   * Any cases in which heap storage is dynamically allocated other than
     as part of the evaluation of an allocator should be documented.
     See *note 13.11::(23).

43/2
   * A default storage pool for an access-to-constant type should not
     have overhead to support deallocation of individual objects.  See
     *note 13.11::(24).

44/2
   * Usually, a storage pool for an access discriminant or access
     parameter should be created at the point of an allocator, and be
     reclaimed when the designated object becomes inaccessible.  For
     other anonymous access types, the pool should be created at the
     point where the type is elaborated and need not support
     deallocation of individual objects.  See *note 13.11::(25).

45/2
   * For a standard storage pool, an instance of Unchecked_Deallocation
     should actually reclaim the storage.  See *note 13.11.2::(17).

45.1/3
   * A call on an instance of Unchecked_Deallocation with a nonnull
     access value should raise Program_Error if the actual access type
     of the instance is a type for which the Storage_Size has been
     specified to be zero or is defined by the language to be zero.  See
     *note 13.11.2::(17.1/3).

46/2
   * If not specified, the value of Stream_Size for an elementary type
     should be the number of bits that corresponds to the minimum number
     of stream elements required by the first subtype of the type,
     rounded up to the nearest factor or multiple of the word size that
     is also a multiple of the stream element size.  See *note
     13.13.2::(1.6/2).

47/2
   * The recommended level of support for the Stream_Size attribute
     should be followed.  See *note 13.13.2::(1.8/2).

48/2
   * If an implementation provides additional named predefined integer
     types, then the names should end with "Integer".  If an
     implementation provides additional named predefined floating point
     types, then the names should end with "Float".  See *note
     A.1::(52).

49/2
   * Implementation-defined operations on Wide_Character, Wide_String,
     Wide_Wide_Character, and Wide_Wide_String should be child units of
     Wide_Characters or Wide_Wide_Characters.  See *note A.3.1::(7/3).

49.1/3
   * The string returned by
     Wide_Characters.Handling.Character_Set_Version should include
     either "10646:" or "Unicode".  See *note A.3.5::(62).

50/2
   * Bounded string objects should not be implemented by implicit
     pointers and dynamic allocation.  See *note A.4.4::(106).

51/2
   * Strings.Hash should be good a hash function, returning a wide
     spread of values for different string values, and similar strings
     should rarely return the same value.  See *note A.4.9::(12/2).

51.1/3
   * If an implementation supports other string encoding schemes, a
     child of Ada.Strings similar to UTF_Encoding should be defined.
     See *note A.4.11::(107/3).

52/2
   * Any storage associated with an object of type Generator of the
     random number packages should be reclaimed on exit from the scope
     of the object.  See *note A.5.2::(46).

53/2
   * Each value of Initiator passed to Reset for the random number
     packages should initiate a distinct sequence of random numbers, or,
     if that is not possible, be at least a rapidly varying function of
     the initiator value.  See *note A.5.2::(47).

54/2
   * Get_Immediate should be implemented with unbuffered input; input
     should be available immediately; line-editing should be disabled.
     See *note A.10.7::(23).

55/2
   * Package Directories.Information should be provided to retrieve
     other information about a file.  See *note A.16::(124/2).

56/3
   * Directories.Start_Search and Directories.Search should raise
     Name_Error for malformed patterns.  See *note A.16::(125).

57/2
   * Directories.Rename should be supported at least when both New_Name
     and Old_Name are simple names and New_Name does not identify an
     existing external file.  See *note A.16::(126/2).

57.1/3
   * Directories.Hierarchical_File_Names should be provided for systems
     with hierarchical file naming, and should not be provided on other
     systems.  See *note A.16.1::(36/3).

58/2
   * If the execution environment supports subprocesses, the current
     environment variables should be used to initialize the environment
     variables of a subprocess.  See *note A.17::(32/2).

59/2
   * Changes to the environment variables made outside the control of
     Environment_Variables should be reflected immediately.  See *note
     A.17::(33/2).

60/2
   * Containers.Hash_Type'Modulus should be at least 2**32.
     Containers.Count_Type'Last should be at least 2**31-1.  See *note
     A.18.1::(8/2).

61/2
   * The worst-case time complexity of Element for Containers.Vector
     should be <O>(log <N>).  See *note A.18.2::(256/2).

62/2
   * The worst-case time complexity of Append with Count = 1 when <N> is
     less than the capacity for Containers.Vector should be <O>(log
     <N>).  See *note A.18.2::(257/2).

63/2
   * The worst-case time complexity of Prepend with Count = 1 and
     Delete_First with Count=1 for Containers.Vectors should be <O>(<N>
     log <N>).  See *note A.18.2::(258/2).

64/2
   * The worst-case time complexity of a call on procedure Sort of an
     instance of Containers.Vectors.Generic_Sorting should be
     <O>(<N>**2), and the average time complexity should be better than
     <O>(<N>**2).  See *note A.18.2::(259/2).

65/2
   * Containers.Vectors.Generic_Sorting.Sort and
     Containers.Vectors.Generic_Sorting.Merge should minimize copying of
     elements.  See *note A.18.2::(260/2).

66/2
   * Containers.Vectors.Move should not copy elements, and should
     minimize copying of internal data structures.  See *note
     A.18.2::(261/2).

67/2
   * If an exception is propagated from a vector operation, no storage
     should be lost, nor any elements removed from a vector unless
     specified by the operation.  See *note A.18.2::(262/2).

68/2
   * The worst-case time complexity of Element, Insert with Count=1, and
     Delete with Count=1 for Containers.Doubly_Linked_Lists should be
     <O>(log <N>).  See *note A.18.3::(160/2).

69/2
   * A call on procedure Sort of an instance of
     Containers.Doubly_Linked_Lists.Generic_Sorting should have an
     average time complexity better than <O>(<N>**2) and worst case no
     worse than <O>(<N>**2).  See *note A.18.3::(161/2).

70/2
   * Containers.Doubly_Linked_Lists.Move should not copy elements, and
     should minimize copying of internal data structures.  See *note
     A.18.3::(162/2).

71/2
   * If an exception is propagated from a list operation, no storage
     should be lost, nor any elements removed from a list unless
     specified by the operation.  See *note A.18.3::(163/2).

72/2
   * Move for a map should not copy elements, and should minimize
     copying of internal data structures.  See *note A.18.4::(83/2).

73/2
   * If an exception is propagated from a map operation, no storage
     should be lost, nor any elements removed from a map unless
     specified by the operation.  See *note A.18.4::(84/2).

74/2
   * The average time complexity of Element, Insert, Include, Replace,
     Delete, Exclude and Find operations that take a key parameter for
     Containers.Hashed_Maps should be <O>(log <N>).  The average time
     complexity of the subprograms of Containers.Hashed_Maps that take a
     cursor parameter should be <O>(1).  The average time complexity of
     Containers.Hashed_Maps.Reserve_Capacity should be <O>(<N>).  See
     *note A.18.5::(62/2).

75/2
   * The worst-case time complexity of Element, Insert, Include,
     Replace, Delete, Exclude and Find operations that take a key
     parameter for Containers.Ordered_Maps should be <O>((log <N>)**2)
     or better.  The worst-case time complexity of the subprograms of
     Containers.Ordered_Maps that take a cursor parameter should be
     <O>(1).  See *note A.18.6::(95/2).

76/2
   * Move for sets should not copy elements, and should minimize copying
     of internal data structures.  See *note A.18.7::(104/2).

77/2
   * If an exception is propagated from a set operation, no storage
     should be lost, nor any elements removed from a set unless
     specified by the operation.  See *note A.18.7::(105/2).

78/2
   * The average time complexity of the Insert, Include, Replace,
     Delete, Exclude and Find operations of Containers.Hashed_Sets that
     take an element parameter should be <O>(log <N>).  The average time
     complexity of the subprograms of Containers.Hashed_Sets that take a
     cursor parameter should be <O>(1).  The average time complexity of
     Containers.Hashed_Sets.Reserve_Capacity should be <O>(<N>).  See
     *note A.18.8::(88/2).

79/2
   * The worst-case time complexity of the Insert, Include, Replace,
     Delete, Exclude and Find operations of Containers.Ordered_Sets that
     take an element parameter should be <O>((log <N>)**2).  The
     worst-case time complexity of the subprograms of
     Containers.Ordered_Sets that take a cursor parameter should be
     <O>(1).  See *note A.18.9::(116/2).

79.1/3
   * The worst-case time complexity of the Element, Parent, First_Child,
     Last_Child, Next_Sibling, Previous_Sibling, Insert_Child with
     Count=1, and Delete operations of Containers.Multiway_Trees should
     be <O>(log <N>).  See *note A.18.10::(231/3).

79.2/3
   * Containers.Multiway_Trees.Move should not copy elements, and should
     minimize copying of internal data structures.  See *note
     A.18.10::(232/3).

79.3/3
   * If an exception is propagated from a tree operation, no storage
     should be lost, nor any elements removed from a tree unless
     specified by the operation.  See *note A.18.10::(233/3).

79.4/3
   * Containers.Indefinite_Holders.Move should not copy the element, and
     should minimize copying of internal data structures.  See *note
     A.18.18::(73/3).

79.5/3
   * If an exception is propagated from a holder operation, no storage
     should be lost, nor should the element be removed from a holder
     container unless specified by the operation.  See *note
     A.18.18::(74/3).

79.6/3
   * Bounded vector objects should be implemented without implicit
     pointers or dynamic allocation.  See *note A.18.19::(16/3).

79.7/3
   * The implementation advice for procedure Move to minimize copying
     does not apply to bounded vectors.  See *note A.18.19::(17/3).

79.8/3
   * Bounded list objects should be implemented without implicit
     pointers or dynamic allocation.  See *note A.18.20::(19/3).

79.9/3
   * The implementation advice for procedure Move to minimize copying
     does not apply to bounded lists.  See *note A.18.20::(20/3).

79.10/3
   * Bounded hashed map objects should be implemented without implicit
     pointers or dynamic allocation.  See *note A.18.21::(21/3).

79.11/3
   * The implementation advice for procedure Move to minimize copying
     does not apply to bounded hashed maps.  See *note A.18.21::(22/3).

79.12/3
   * Bounded ordered map objects should be implemented without implicit
     pointers or dynamic allocation.  See *note A.18.22::(18/3).

79.13/3
   * The implementation advice for procedure Move to minimize copying
     does not apply to bounded ordered maps.  See *note A.18.22::(19/3).

79.14/3
   * Bounded hashed set objects should be implemented without implicit
     pointers or dynamic allocation.  See *note A.18.23::(20/3).

79.15/3
   * The implementation advice for procedure Move to minimize copying
     does not apply to bounded hashed sets.  See *note A.18.23::(21/3).

79.16/3
   * Bounded ordered set objects should be implemented without implicit
     pointers or dynamic allocation.  See *note A.18.24::(17/3).

79.17/3
   * The implementation advice for procedure Move to minimize copying
     does not apply to bounded ordered sets.  See *note A.18.24::(18/3).

79.18/3
   * Bounded tree objects should be implemented without implicit
     pointers or dynamic allocation.  See *note A.18.25::(19/3).

79.19/3
   * The implementation advice for procedure Move to minimize copying
     does not apply to bounded trees.  See *note A.18.25::(20/3).

80/2
   * Containers.Generic_Array_Sort and
     Containers.Generic_Constrained_Array_Sort should have an average
     time complexity better than <O>(<N>**2) and worst case no worse
     than <O>(<N>**2).  See *note A.18.26::(10/2).

81/2
   * Containers.Generic_Array_Sort and
     Containers.Generic_Constrained_Array_Sort should minimize copying
     of elements.  See *note A.18.26::(11/2).

81.1/3
   * Containers.Generic_Sort should have an average time complexity
     better than <O>(<N>**2) and worst case no worse than <O>(<N>**2).
     See *note A.18.26::(12/3).

81.2/3
   * Containers.Generic_Sort should minimize calls to the generic formal
     Swap.  See *note A.18.26::(13/3).

81.3/3
   * Bounded queue objects should be implemented without implicit
     pointers or dynamic allocation.  See *note A.18.29::(13/3).

81.4/3
   * Bounded priority queue objects should be implemented without
     implicit pointers or dynamic allocation.  See *note
     A.18.31::(14/3).

82/3
   * If Export is supported for a language, the main program should be
     able to be written in that language.  Subprograms named "adainit"
     and "adafinal" should be provided for elaboration and finalization
     of the environment task.  See *note B.1::(39/3).

83/3
   * Automatic elaboration of preelaborated packages should be provided
     when specifying the Export aspect as True is supported.  See *note
     B.1::(40/3).

84/3
   * For each supported convention <L> other than Intrinsic, specifying
     the aspects Import and Export should be supported for objects of
     <L>-compatible types and for subprograms, and aspect Convention
     should be supported for <L>-eligible types and for subprograms.
     See *note B.1::(41/4).

85/2
   * If an interface to C, COBOL, or Fortran is provided, the
     corresponding package or packages described in *note Annex B::,
     "*note Annex B:: Interface to Other Languages" should also be
     provided.  See *note B.2::(13/3).

86/2
   * The constants nul, wide_nul, char16_nul, and char32_nul in package
     Interfaces.C should have a representation of zero.  See *note
     B.3::(62.5/3).

87/2
   * If C interfacing is supported, the interface correspondences
     between Ada and C should be supported.  See *note B.3::(71).

88/2
   * If COBOL interfacing is supported, the interface correspondences
     between Ada and COBOL should be supported.  See *note B.4::(98).

89/2
   * If Fortran interfacing is supported, the interface correspondences
     between Ada and Fortran should be supported.  See *note B.5::(26).

90/2
   * The machine code or intrinsics support should allow access to all
     operations normally available to assembly language programmers for
     the target environment.  See *note C.1::(3).

91/2
   * Interface to assembler should be supported; the default assembler
     should be associated with the convention identifier Assembler.  See
     *note C.1::(4/3).

92/2
   * If an entity is exported to assembly language, then the
     implementation should allocate it at an addressable location even
     if not otherwise referenced from the Ada code.  A call to a machine
     code or assembler subprogram should be treated as if it could read
     or update every object that is specified as exported.  See *note
     C.1::(5).

93/2
   * Little or no overhead should be associated with calling intrinsic
     and machine-code subprograms.  See *note C.1::(10).

94/2
   * Intrinsic subprograms should be provided to access any machine
     operations that provide special capabilities or efficiency not
     normally available.  See *note C.1::(16).

95/2
   * If the Ceiling_Locking policy is not in effect and the target
     system allows for finer-grained control of interrupt blocking, a
     means for the application to specify which interrupts are to be
     blocked during protected actions should be provided.  See *note
     C.3::(28/2).

96/2
   * Interrupt handlers should be called directly by the hardware.  See
     *note C.3.1::(20).

97/2
   * Violations of any implementation-defined restrictions on interrupt
     handlers should be detected before run time.  See *note
     C.3.1::(21).

98/2
   * If implementation-defined forms of interrupt handler procedures are
     supported, then for each such form of a handler, a type analogous
     to Parameterless_Handler should be specified in a child package of
     Interrupts, with the same operations as in the predefined package
     Interrupts.  See *note C.3.2::(25).

99/2
   * Preelaborated packages should be implemented such that little or no
     code is executed at run time for the elaboration of entities.  See
     *note C.4::(14).

100/4
   * If aspect Discard_Names is True for an entity, then the amount of
     storage used for storing names associated with that entity should
     be reduced.  See *note C.5::(8/4).

101/2
   * A load or store of a volatile object whose size is a multiple of
     System.Storage_Unit and whose alignment is nonzero, should be
     implemented by accessing exactly the bits of the object and no
     others.  See *note C.6::(22/2).

102/2
   * A load or store of an atomic object should be implemented by a
     single load or store instruction.  See *note C.6::(23/2).

103/2
   * If the target domain requires deterministic memory use at run time,
     storage for task attributes should be pre-allocated statically and
     the number of attributes pre-allocated should be documented.  See
     *note C.7.2::(30).

104/2
   * Finalization of task attributes and reclamation of associated
     storage should be performed as soon as possible after task
     termination.  See *note C.7.2::(30.1/2).

105/2
   * Names that end with "_Locking" should be used for
     implementation-defined locking policies.  See *note D.3::(17).

106/2
   * Names that end with "_Queuing" should be used for
     implementation-defined queuing policies.  See *note D.4::(16).

107/2
   * The abort_statement should not require the task executing the
     statement to block.  See *note D.6::(9).

108/2
   * On a multi-processor, the delay associated with aborting a task on
     another processor should be bounded.  See *note D.6::(10).

109/2
   * When feasible, specified restrictions should be used to produce a
     more efficient implementation.  See *note D.7::(21).

110/2
   * When appropriate, mechanisms to change the value of Tick should be
     provided.  See *note D.8::(47).

111/2
   * Calendar.Clock and Real_Time.Clock should be transformations of the
     same time base.  See *note D.8::(48).

112/2
   * The "best" time base which exists in the underlying system should
     be available to the application through Real_Time.Clock.  See *note
     D.8::(49).

112.1/3
   * On a multiprocessor system, each processor should have a separate
     and disjoint ready queue.  See *note D.13::(9).

113/2
   * When appropriate, implementations should provide configuration
     mechanisms to change the value of Execution_Time.CPU_Tick.  See
     *note D.14::(29/2).

114/2
   * For a timing event, the handler should be executed directly by the
     real-time clock interrupt mechanism.  See *note D.15::(25).

114.1/3
   * Each dispatching domain should have separate and disjoint ready
     queues.  See *note D.16.1::(31).

115/2
   * The PCS should allow for multiple tasks to call the RPC-receiver.
     See *note E.5::(28).

116/2
   * The System.RPC.Write operation should raise Storage_Error if it
     runs out of space when writing an item.  See *note E.5::(29).

117/2
   * If COBOL (respectively, C) is supported in the target environment,
     then interfacing to COBOL (respectively, C) should be supported as
     specified in *note Annex B::.  See *note F::(7/3).

118/2
   * Packed decimal should be used as the internal representation for
     objects of subtype <S> when <S>'Machine_Radix = 10.  See *note
     F.1::(2).

119/2
   * If Fortran (respectively, C) is supported in the target
     environment, then interfacing to Fortran (respectively, C) should
     be supported as specified in *note Annex B::.  See *note G::(7/3).

120/2
   * Mixed real and complex operations (as well as pure-imaginary and
     complex operations) should not be performed by converting the real
     (resp.  pure-imaginary) operand to complex.  See *note G.1.1::(56).

121/3
   * If Real'Signed_Zeros is True for Numerics.Generic_Complex_Types, a
     rational treatment of the signs of zero results and result
     components should be provided.  See *note G.1.1::(58).

122/3
   * If Complex_Types.Real'Signed_Zeros is True for
     Numerics.Generic_Complex_Elementary_Functions, a rational treatment
     of the signs of zero results and result components should be
     provided.  See *note G.1.2::(49).

123/2
   * For elementary functions, the forward trigonometric functions
     without a Cycle parameter should not be implemented by calling the
     corresponding version with a Cycle parameter.  Log without a Base
     parameter should not be implemented by calling Log with a Base
     parameter.  See *note G.2.4::(19).

124/2
   * For complex arithmetic, the Compose_From_Polar function without a
     Cycle parameter should not be implemented by calling
     Compose_From_Polar with a Cycle parameter.  See *note G.2.6::(15).

125/2
   * Solve and Inverse for Numerics.Generic_Real_Arrays should be
     implemented using established techniques such as LU decomposition
     and the result should be refined by an iteration on the residuals.
     See *note G.3.1::(88/3).

126/2
   * The equality operator should be used to test that a matrix in
     Numerics.Generic_Real_Arrays is symmetric.  See *note
     G.3.1::(90/2).

126.1/3
   * An implementation should minimize the circumstances under which the
     algorithm used for Numerics.Generic_Real_Arrays.Eigenvalues and
     Numerics.Generic_Real_Arrays.Eigensystem fails to converge.  See
     *note G.3.1::(91/3).

127/2
   * Solve and Inverse for Numerics.Generic_Complex_Arrays should be
     implemented using established techniques and the result should be
     refined by an iteration on the residuals.  See *note
     G.3.2::(158/3).

128/2
   * The equality and negation operators should be used to test that a
     matrix is Hermitian.  See *note G.3.2::(160/2).

128.1/3
   * An implementation should minimize the circumstances under which the
     algorithm used for Numerics.Generic_Complex_Arrays.Eigenvalues and
     Numerics.Generic_Complex_Arrays.Eigensystem fails to converge.  See
     *note G.3.2::(160.1/3).

129/2
   * Mixed real and complex operations should not be performed by
     converting the real operand to complex.  See *note G.3.2::(161/2).

130/2
   * The information produced by pragma Reviewable should be provided in
     both a human-readable and machine-readable form, and the latter
     form should be documented.  See *note H.3.1::(19).

131/2
   * Object code listings should be provided both in a symbolic format
     and in a numeric format.  See *note H.3.1::(20).

132/3
   * If the partition elaboration policy is Sequential and the
     Environment task becomes permanently blocked during elaboration,
     then the partition should be immediately terminated.  See *note
     H.6::(15/3).


File: arm2012.info,  Node: Annex N,  Next: Annex P,  Prev: Annex M,  Up: Top

Annex N Glossary
****************

1/2
This Annex contains informal descriptions of some of the terms used in
this International Standard.  The index provides references to more
formal definitions of all of the terms used in this International
Standard.

1.1/2
Abstract type.  An abstract type is a tagged type intended for use as an
ancestor of other types, but which is not allowed to have objects of its
own.

2
Access type.  An access type has values that designate aliased objects.
Access types correspond to "pointer types" or "reference types" in some
other languages.

3
Aliased.  An aliased view of an object is one that can be designated by
an access value.  Objects allocated by allocators are aliased.  Objects
can also be explicitly declared as aliased with the reserved word
aliased.  The Access attribute can be used to create an access value
designating an aliased object.

3.1/2
Ancestor.  An ancestor of a type is the type itself or, in the case of a
type derived from other types, its parent type or one of its progenitor
types or one of their ancestors.  Note that ancestor and descendant are
inverse relationships.

4
Array type.  An array type is a composite type whose components are all
of the same type.  Components are selected by indexing.

4.1/3
Aspect.  An aspect is a specifiable property of an entity.  An aspect
may be specified by an aspect_specification on the declaration of the
entity.  Some aspects may be queried via attributes.

4.2/3
Assertion.  An assertion is a boolean expression that appears in any of
the following: a pragma Assert, a predicate, a precondition, a
postcondition, an invariant, a constraint, or a null exclusion.  An
assertion is expected to be True at run time at certain specified
places.

4.3/2
Category (of types).  A category of types is a set of types with one or
more common properties, such as primitive operations.  A category of
types that is closed under derivation is also known as a <class>.

5
Character type.  A character type is an enumeration type whose values
include characters.

6/2
Class (of types).  A class is a set of types that is closed under
derivation, which means that if a given type is in the class, then all
types derived from that type are also in the class.  The set of types of
a class share common properties, such as their primitive operations.

7
Compilation unit.  The text of a program can be submitted to the
compiler in one or more compilations.  Each compilation is a succession
of compilation_units.  A compilation_unit contains either the
declaration, the body, or a renaming of a program unit.

8/2
Composite type.  A composite type may have components.

9
Construct.  A <construct> is a piece of text (explicit or implicit) that
is an instance of a syntactic category defined under "Syntax".

9.1/3
Container.  A container is an object that contain other objects all of
the same type, which could be class-wide.  Several predefined container
types are provided by the children of package Ada.Containers (see *note
A.18.1::).

10
Controlled type.  A controlled type supports user-defined assignment and
finalization.  Objects are always finalized before being destroyed.

11
Declaration.  A <declaration> is a language construct that associates a
name with (a view of) an entity.  A declaration may appear explicitly in
the program text (an <explicit> declaration), or may be supposed to
occur at a given place in the text as a consequence of the semantics of
another construct (an <implicit> declaration).

12/2
<This paragraph was deleted.>

13/2
Derived type.  A derived type is a type defined in terms of one or more
other types given in a derived type definition.  The first of those
types is the parent type of the derived type and any others are
progenitor types.  Each class containing the parent type or a progenitor
type also contains the derived type.  The derived type inherits
properties such as components and primitive operations from the parent
and progenitors.  A type together with the types derived from it
(directly or indirectly) form a derivation class.

13.1/2
Descendant.  A type is a descendant of itself, its parent and progenitor
types, and their ancestors.  Note that descendant and ancestor are
inverse relationships.

14
Discrete type.  A discrete type is either an integer type or an
enumeration type.  Discrete types may be used, for example, in
case_statements and as array indices.

15/2
Discriminant.  A discriminant is a parameter for a composite type.  It
can control, for example, the bounds of a component of the type if the
component is an array.  A discriminant for a task type can be used to
pass data to a task of the type upon creation.

15.1/2
Elaboration.  The process by which a declaration achieves its run-time
effect is called elaboration.  Elaboration is one of the forms of
execution.

16
Elementary type.  An elementary type does not have components.

17
Enumeration type.  An enumeration type is defined by an enumeration of
its values, which may be named by identifiers or character literals.

17.1/2
Evaluation.  The process by which an expression achieves its run-time
effect is called evaluation.  Evaluation is one of the forms of
execution.

18
Exception.  An <exception> represents a kind of exceptional situation;
an occurrence of such a situation (at run time) is called an <exception
occurrence>.  To <raise> an exception is to abandon normal program
execution so as to draw attention to the fact that the corresponding
situation has arisen.  Performing some actions in response to the
arising of an exception is called <handling> the exception.

19
Execution.  The process by which a construct achieves its run-time
effect is called <execution>.  Execution of a declaration is also called
<elaboration>.  Execution of an expression is also called <evaluation>.

19.1/2
Function.  A function is a form of subprogram that returns a result and
can be called as part of an expression.

20
Generic unit.  A generic unit is a template for a (nongeneric) program
unit; the template can be parameterized by objects, types, subprograms,
and packages.  An instance of a generic unit is created by a
generic_instantiation.  The rules of the language are enforced when a
generic unit is compiled, using a generic contract model; additional
checks are performed upon instantiation to verify the contract is met.
That is, the declaration of a generic unit represents a contract between
the body of the generic and instances of the generic.  Generic units can
be used to perform the role that macros sometimes play in other
languages.

20.1/2
Incomplete type.  An incomplete type gives a view of a type that reveals
only some of its properties.  The remaining properties are provided by
the full view given elsewhere.  Incomplete types can be used for
defining recursive data structures.

20.2/3
Indexable container type.  An indexable container type is one that has
user-defined behavior for indexing, via the Constant_Indexing or
Variable_Indexing aspects.

21
Integer type.  Integer types comprise the signed integer types and the
modular types.  A signed integer type has a base range that includes
both positive and negative numbers, and has operations that may raise an
exception when the result is outside the base range.  A modular type has
a base range whose lower bound is zero, and has operations with
"wraparound" semantics.  Modular types subsume what are called "unsigned
types" in some other languages.

21.1/2
Interface type.  An interface type is a form of abstract tagged type
which has no components or concrete operations except possibly null
procedures.  Interface types are used for composing other interfaces and
tagged types and thereby provide multiple inheritance.  Only an
interface type can be used as a progenitor of another type.

21.2/4
Invariant.  An invariant is an assertion that is expected to be True for
all objects of a given private type when viewed from outside the
defining package.

21.3/3
Iterable container type.  An iterable container type is one that has
user-defined behavior for iteration, via the Default_Iterator and
Iterator_Element aspects.

21.4/3
Iterator.  An iterator is a construct that is used to loop over the
elements of an array or container.  Iterators may be user defined, and
may perform arbitrary computations to access elements from a container.

22
Library unit.  A library unit is a separately compiled program unit, and
is always a package, subprogram, or generic unit.  Library units may
have other (logically nested) library units as children, and may have
other program units physically nested within them.  A root library unit,
together with its children and grandchildren and so on, form a
<subsystem>.

23/2
Limited type.  A limited type is a type for which copying (such as in an
assignment_statement) is not allowed.  A nonlimited type is a type for
which copying is allowed.

24
Object.  An object is either a constant or a variable.  An object
contains a value.  An object is created by an object_declaration or by
an allocator.  A formal parameter is (a view of) an object.  A
subcomponent of an object is an object.

24.1/2
Overriding operation.  An overriding operation is one that replaces an
inherited primitive operation.  Operations may be marked explicitly as
overriding or not overriding.

25
Package.  Packages are program units that allow the specification of
groups of logically related entities.  Typically, a package contains the
declaration of a type (often a private type or private extension) along
with the declarations of primitive subprograms of the type, which can be
called from outside the package, while their inner workings remain
hidden from outside users.

25.1/2
Parent.  The parent of a derived type is the first type given in the
definition of the derived type.  The parent can be almost any kind of
type, including an interface type.

26
Partition.  A <partition> is a part of a program.  Each partition
consists of a set of library units.  Each partition may run in a
separate address space, possibly on a separate computer.  A program may
contain just one partition.  A distributed program typically contains
multiple partitions, which can execute concurrently.

26.1/3
Postcondition.  A postcondition is an assertion that is expected to be
True when a given subprogram returns normally.

27
Pragma.  A pragma is a compiler directive.  There are language-defined
pragmas that give instructions for optimization, listing control, etc.
An implementation may support additional (implementation-defined)
pragmas.

27.1/3
Precondition.  A precondition is an assertion that is expected to be
True when a given subprogram is called.

27.2/3
Predicate.  A predicate is an assertion that is expected to be True for
all objects of a given subtype.

28
Primitive operations.  The primitive operations of a type are the
operations (such as subprograms) declared together with the type
declaration.  They are inherited by other types in the same class of
types.  For a tagged type, the primitive subprograms are dispatching
subprograms, providing run-time polymorphism.  A dispatching subprogram
may be called with statically tagged operands, in which case the
subprogram body invoked is determined at compile time.  Alternatively, a
dispatching subprogram may be called using a dispatching call, in which
case the subprogram body invoked is determined at run time.

29/2
Private extension.  A private extension is a type that extends another
type, with the additional properties hidden from its clients.

30/2
Private type.  A private type gives a view of a type that reveals only
some of its properties.  The remaining properties are provided by the
full view given elsewhere.  Private types can be used for defining
abstractions that hide unnecessary details from their clients.

30.1/2
Procedure.  A procedure is a form of subprogram that does not return a
result and can only be called by a statement.

30.2/2
Progenitor.  A progenitor of a derived type is one of the types given in
the definition of the derived type other than the first.  A progenitor
is always an interface type.  Interfaces, tasks, and protected types may
also have progenitors.

31
Program.  A <program> is a set of <partitions>, each of which may
execute in a separate address space, possibly on a separate computer.  A
partition consists of a set of library units.

32
Program unit.  A <program unit> is either a package, a task unit, a
protected unit, a protected entry, a generic unit, or an explicitly
declared subprogram other than an enumeration literal.  Certain kinds of
program units can be separately compiled.  Alternatively, they can
appear physically nested within other program units.

33/2
Protected type.  A protected type is a composite type whose components
are accessible only through one of its protected operations which
synchronize concurrent access by multiple tasks.

34
Real type.  A real type has values that are approximations of the real
numbers.  Floating point and fixed point types are real types.

35
Record extension.  A record extension is a type that extends another
type by adding additional components.

36
Record type.  A record type is a composite type consisting of zero or
more named components, possibly of different types.

36.1/3
Reference type.  A reference type is one that has user-defined behavior
for ".all", defined by the Implicit_Dereference aspect.

36.2/2
Renaming.  A renaming_declaration is a declaration that does not define
a new entity, but instead defines a view of an existing entity.

37
Scalar type.  A scalar type is either a discrete type or a real type.

37.1/3
Storage pool.  Each access-to-object type has an associated storage pool
object.  The storage for an object created by an allocator comes from
the storage pool of the type of the allocator.  Some storage pools may
be partitioned into subpools in order to support finer-grained storage
management.

37.2/3
Stream.  A stream is a sequence of elements that can be used, along with
the stream-oriented attributes, to support marshalling and unmarshalling
of values of most types.

37.3/2
Subprogram.  A subprogram is a section of a program that can be executed
in various contexts.  It is invoked by a subprogram call that may
qualify the effect of the subprogram through the passing of parameters.
There are two forms of subprograms: functions, which return values, and
procedures, which do not.

38/3
Subtype.  A subtype is a type together with optional constraints, null
exclusions, and predicates, which constrain the values of the subtype to
satisfy certain conditions.  The values of a subtype are a subset of the
values of its type.

38.1/2
Synchronized.  A synchronized entity is one that will work safely with
multiple tasks at one time.  A synchronized interface can be an ancestor
of a task or a protected type.  Such a task or protected type is called
a synchronized tagged type.

39
Tagged type.  The objects of a tagged type have a run-time type tag,
which indicates the specific type with which the object was originally
created.  An operand of a class-wide tagged type can be used in a
dispatching call; the tag indicates which subprogram body to invoke.
Nondispatching calls, in which the subprogram body to invoke is
determined at compile time, are also allowed.  Tagged types may be
extended with additional components.

40/2
Task type.  A task type is a composite type used to represent active
entities which execute concurrently and which can communicate via queued
task entries.  The top-level task of a partition is called the
environment task.

41/2
Type.  Each object has a type.  A <type> has an associated set of
values, and a set of <primitive operations> which implement the
fundamental aspects of its semantics.  Types are grouped into
<categories>.  Most language-defined categories of types are also
<classes> of types.

41.1/4
Type Invariant.  See Invariant.

42/2
View.  A view of an entity reveals some or all of the properties of the
entity.  A single entity may have multiple views.


File: arm2012.info,  Node: Annex P,  Next: Annex Q,  Prev: Annex N,  Up: Top

Annex P Syntax Summary
**********************

This Annex summarizes the complete syntax of the language.  See *note
1.1.4:: for a description of the notation used.

     *note 2.3:::
     identifier ::= 
        identifier_start {identifier_start | identifier_extend}

     *note 2.3:::
     identifier_start ::= 
          letter_uppercase
        | letter_lowercase
        | letter_titlecase
        | letter_modifier
        | letter_other
        | number_letter

     *note 2.3:::
     identifier_extend ::= 
          mark_non_spacing
        | mark_spacing_combining
        | number_decimal
        | punctuation_connector

     *note 2.4:::
     numeric_literal ::= decimal_literal | based_literal

     *note 2.4.1:::
     decimal_literal ::= numeral [.numeral] [exponent]

     *note 2.4.1:::
     numeral ::= digit {[underline] digit}

     *note 2.4.1:::
     exponent ::= E [+] numeral | E - numeral

     *note 2.4.1:::
     digit ::= 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9

     *note 2.4.2:::
     based_literal ::= 
        base # based_numeral [.based_numeral] # [exponent]

     *note 2.4.2:::
     base ::= numeral

     *note 2.4.2:::
     based_numeral ::= 
        extended_digit {[underline] extended_digit}

     *note 2.4.2:::
     extended_digit ::= digit | A | B | C | D | E | F

     *note 2.5:::
     character_literal ::= 'graphic_character'

     *note 2.6:::
     string_literal ::= "{string_element}"

     *note 2.6:::
     string_element ::= "" | <non_quotation_mark_>graphic_character

     *note 2.7:::
     comment ::= --{<non_end_of_line_>character}

     *note 2.8:::
     pragma ::= 
        pragma identifier [(pragma_argument_association {, 
     pragma_argument_association})];

     *note 2.8:::
     pragma_argument_association ::= 
          [<pragma_argument_>identifier =>] name
        | [<pragma_argument_>identifier =>] expression
        | <pragma_argument_>aspect_mark =>  name
        | <pragma_argument_>aspect_mark =>  expression

     *note 3.1:::
     basic_declaration ::= 
          type_declaration   | subtype_declaration
        | object_declaration   | number_declaration
        | subprogram_declaration   | abstract_subprogram_declaration
        | null_procedure_declaration   | expression_function_declaration
        | package_declaration   | renaming_declaration
        | exception_declaration   | generic_declaration
        | generic_instantiation

     *note 3.1:::
     defining_identifier ::= identifier

     *note 3.2.1:::
     type_declaration ::=  full_type_declaration
        | incomplete_type_declaration
        | private_type_declaration
        | private_extension_declaration

     *note 3.2.1:::
     full_type_declaration ::= 
          type defining_identifier [known_discriminant_part] is 
     type_definition
             [aspect_specification];
        | task_type_declaration
        | protected_type_declaration

     *note 3.2.1:::
     type_definition ::= 
          enumeration_type_definition   | integer_type_definition
        | real_type_definition   | array_type_definition
        | record_type_definition   | access_type_definition
        | derived_type_definition   | interface_type_definition

     *note 3.2.2:::
     subtype_declaration ::= 
        subtype defining_identifier is subtype_indication
             [aspect_specification];

     *note 3.2.2:::
     subtype_indication ::=  [null_exclusion] subtype_mark [constraint]

     *note 3.2.2:::
     subtype_mark ::= <subtype_>name

     *note 3.2.2:::
     constraint ::= scalar_constraint | composite_constraint

     *note 3.2.2:::
     scalar_constraint ::= 
          range_constraint | digits_constraint | delta_constraint

     *note 3.2.2:::
     composite_constraint ::= 
          index_constraint | discriminant_constraint

     *note 3.3.1:::
     object_declaration ::= 
         defining_identifier_list : [aliased] [constant] 
     subtype_indication [:= expression]
             [aspect_specification];
       | defining_identifier_list : [aliased] [constant] 
     access_definition [:= expression]
             [aspect_specification];
       | defining_identifier_list : [aliased] [constant] 
     array_type_definition [:= expression]
             [aspect_specification];
       | single_task_declaration
       | single_protected_declaration

     *note 3.3.1:::
     defining_identifier_list ::= 
       defining_identifier {, defining_identifier}

     *note 3.3.2:::
     number_declaration ::= 
          defining_identifier_list : constant := <static_>expression;

     *note 3.4:::
     derived_type_definition ::= 
         [abstract] [limited] new <parent_>subtype_indication [[and 
     interface_list] record_extension_part]

     *note 3.5:::
     range_constraint ::=  range range

     *note 3.5:::
     range ::=  range_attribute_reference
        | simple_expression .. simple_expression

     *note 3.5.1:::
     enumeration_type_definition ::= 
        (enumeration_literal_specification {, 
     enumeration_literal_specification})

     *note 3.5.1:::
     enumeration_literal_specification ::=  defining_identifier | 
     defining_character_literal

     *note 3.5.1:::
     defining_character_literal ::= character_literal

     *note 3.5.4:::
     integer_type_definition ::= signed_integer_type_definition | 
     modular_type_definition

     *note 3.5.4:::
     signed_integer_type_definition ::= range <static_>
     simple_expression .. <static_>simple_expression

     *note 3.5.4:::
     modular_type_definition ::= mod <static_>expression

     *note 3.5.6:::
     real_type_definition ::= 
        floating_point_definition | fixed_point_definition

     *note 3.5.7:::
     floating_point_definition ::= 
       digits <static_>expression [real_range_specification]

     *note 3.5.7:::
     real_range_specification ::= 
       range <static_>simple_expression .. <static_>simple_expression

     *note 3.5.9:::
     fixed_point_definition ::= ordinary_fixed_point_definition | 
     decimal_fixed_point_definition

     *note 3.5.9:::
     ordinary_fixed_point_definition ::= 
        delta <static_>expression  real_range_specification

     *note 3.5.9:::
     decimal_fixed_point_definition ::= 
        delta <static_>expression digits <static_>expression [
     real_range_specification]

     *note 3.5.9:::
     digits_constraint ::= 
        digits <static_>simple_expression [range_constraint]

     *note 3.6:::
     array_type_definition ::= 
        unconstrained_array_definition | constrained_array_definition

     *note 3.6:::
     unconstrained_array_definition ::= 
        array(index_subtype_definition {, index_subtype_definition}) of 
     component_definition

     *note 3.6:::
     index_subtype_definition ::= subtype_mark range <>

     *note 3.6:::
     constrained_array_definition ::= 
        array (discrete_subtype_definition {, 
     discrete_subtype_definition}) of component_definition

     *note 3.6:::
     discrete_subtype_definition ::= <discrete_>subtype_indication | 
     range

     *note 3.6:::
     component_definition ::= 
        [aliased] subtype_indication
      | [aliased] access_definition

     *note 3.6.1:::
     index_constraint ::=  (discrete_range {, discrete_range})

     *note 3.6.1:::
     discrete_range ::= <discrete_>subtype_indication | range

     *note 3.7:::
     discriminant_part ::= unknown_discriminant_part | 
     known_discriminant_part

     *note 3.7:::
     unknown_discriminant_part ::= (<>)

     *note 3.7:::
     known_discriminant_part ::= 
        (discriminant_specification {; discriminant_specification})

     *note 3.7:::
     discriminant_specification ::= 
        defining_identifier_list : [null_exclusion] subtype_mark [:= 
     default_expression]
      | defining_identifier_list : access_definition [:= 
     default_expression]

     *note 3.7:::
     default_expression ::= expression

     *note 3.7.1:::
     discriminant_constraint ::= 
        (discriminant_association {, discriminant_association})

     *note 3.7.1:::
     discriminant_association ::= 
        [<discriminant_>selector_name {| <discriminant_>
     selector_name} =>] expression

     *note 3.8:::
     record_type_definition ::= [[abstract] tagged] [limited] 
     record_definition

     *note 3.8:::
     record_definition ::= 
         record
            component_list
         end record
       | null record

     *note 3.8:::
     component_list ::= 
           component_item {component_item}
        | {component_item} variant_part
        |  null;

     *note 3.8:::
     component_item ::= component_declaration | aspect_clause

     *note 3.8:::
     component_declaration ::= 
        defining_identifier_list : component_definition [:= 
     default_expression]
             [aspect_specification];

     *note 3.8.1:::
     variant_part ::= 
        case <discriminant_>direct_name is
            variant
           {variant}
        end case;

     *note 3.8.1:::
     variant ::= 
        when discrete_choice_list =>
           component_list

     *note 3.8.1:::
     discrete_choice_list ::= discrete_choice {| discrete_choice}

     *note 3.8.1:::
     discrete_choice ::= choice_expression | <discrete_>
     subtype_indication | range | others

     *note 3.9.1:::
     record_extension_part ::= with record_definition

     *note 3.9.3:::
     abstract_subprogram_declaration ::= 
         [overriding_indicator]
         subprogram_specification is abstract
             [aspect_specification];

     *note 3.9.4:::
     interface_type_definition ::= 
         [limited | task | protected | synchronized] interface [and 
     interface_list]

     *note 3.9.4:::
     interface_list ::= <interface_>subtype_mark {and <interface_>
     subtype_mark}

     *note 3.10:::
     access_type_definition ::= 
         [null_exclusion] access_to_object_definition
       | [null_exclusion] access_to_subprogram_definition

     *note 3.10:::
     access_to_object_definition ::= 
         access [general_access_modifier] subtype_indication

     *note 3.10:::
     general_access_modifier ::= all | constant

     *note 3.10:::
     access_to_subprogram_definition ::= 
         access [protected] procedure parameter_profile
       | access [protected] function  parameter_and_result_profile

     *note 3.10:::
     null_exclusion ::= not null

     *note 3.10:::
     access_definition ::= 
         [null_exclusion] access [constant] subtype_mark
       | [null_exclusion] access [protected] procedure parameter_profile
       | [null_exclusion] access [protected] function 
     parameter_and_result_profile

     *note 3.10.1:::
     incomplete_type_declaration ::= type defining_identifier [
     discriminant_part] [is tagged];

     *note 3.11:::
     declarative_part ::= {declarative_item}

     *note 3.11:::
     declarative_item ::= 
         basic_declarative_item | body

     *note 3.11:::
     basic_declarative_item ::= 
         basic_declaration | aspect_clause | use_clause

     *note 3.11:::
     body ::= proper_body | body_stub

     *note 3.11:::
     proper_body ::= 
         subprogram_body | package_body | task_body | protected_body

     *note 4.1:::
     name ::= 
          direct_name   | explicit_dereference
        | indexed_component   | slice
        | selected_component   | attribute_reference
        | type_conversion   | function_call
        | character_literal   | qualified_expression
        | generalized_reference   | generalized_indexing

     *note 4.1:::
     direct_name ::= identifier | operator_symbol

     *note 4.1:::
     prefix ::= name | implicit_dereference

     *note 4.1:::
     explicit_dereference ::= name.all

     *note 4.1:::
     implicit_dereference ::= name

     *note 4.1.1:::
     indexed_component ::= prefix(expression {, expression})

     *note 4.1.2:::
     slice ::= prefix(discrete_range)

     *note 4.1.3:::
     selected_component ::= prefix . selector_name

     *note 4.1.3:::
     selector_name ::= identifier | character_literal | operator_symbol

     *note 4.1.4:::
     attribute_reference ::= prefix'attribute_designator

     *note 4.1.4:::
     attribute_designator ::= 
         identifier[(<static_>expression)]
       | Access | Delta | Digits | Mod

     *note 4.1.4:::
     range_attribute_reference ::= prefix'range_attribute_designator

     *note 4.1.4:::
     range_attribute_designator ::= Range[(<static_>expression)]

     *note 4.1.5:::
     generalized_reference ::= <reference_object_>name

     *note 4.1.6:::
     generalized_indexing ::= <indexable_container_object_>prefix 
     actual_parameter_part

     *note 4.3:::
     aggregate ::= record_aggregate | extension_aggregate | 
     array_aggregate

     *note 4.3.1:::
     record_aggregate ::= (record_component_association_list)

     *note 4.3.1:::
     record_component_association_list ::= 
         record_component_association {, record_component_association}
       | null record

     *note 4.3.1:::
     record_component_association ::= 
         [component_choice_list =>] expression
        | component_choice_list => <>

     *note 4.3.1:::
     component_choice_list ::= 
          <component_>selector_name {| <component_>selector_name}
        | others

     *note 4.3.2:::
     extension_aggregate ::= 
         (ancestor_part with record_component_association_list)

     *note 4.3.2:::
     ancestor_part ::= expression | subtype_mark

     *note 4.3.3:::
     array_aggregate ::= 
       positional_array_aggregate | named_array_aggregate

     *note 4.3.3:::
     positional_array_aggregate ::= 
         (expression, expression {, expression})
       | (expression {, expression}, others => expression)
       | (expression {, expression}, others => <>)

     *note 4.3.3:::
     named_array_aggregate ::= 
         (array_component_association {, array_component_association})

     *note 4.3.3:::
     array_component_association ::= 
         discrete_choice_list => expression
       | discrete_choice_list => <>

     *note 4.4:::
     expression ::= 
          relation {and relation}    | relation {and then relation}
        | relation {or relation}    | relation {or else relation}
        | relation {xor relation}

     *note 4.4:::
     choice_expression ::= 
          choice_relation {and choice_relation}
        | choice_relation {or choice_relation}
        | choice_relation {xor choice_relation}
        | choice_relation {and then choice_relation}
        | choice_relation {or else choice_relation}

     *note 4.4:::
     choice_relation ::= 
          simple_expression [relational_operator simple_expression]

     *note 4.4:::
     relation ::= 
          simple_expression [relational_operator simple_expression]
        | <tested_>simple_expression [not] in membership_choice_list
        | raise_expression

     *note 4.4:::
     membership_choice_list ::= membership_choice {| membership_choice}

     *note 4.4:::
     membership_choice ::= <choice_>simple_expression | range | 
     subtype_mark

     *note 4.4:::
     simple_expression ::= [unary_adding_operator] term {
     binary_adding_operator term}

     *note 4.4:::
     term ::= factor {multiplying_operator factor}

     *note 4.4:::
     factor ::= primary [** primary] | abs primary | not primary

     *note 4.4:::
     primary ::= 
        numeric_literal | null | string_literal | aggregate
      | name | allocator | (expression)
      | (conditional_expression) | (quantified_expression)

     *note 4.5:::
     logical_operator ::=     and | or  | xor

     *note 4.5:::
     relational_operator ::=     =   | /=  | <   | <= | > | >=

     *note 4.5:::
     binary_adding_operator ::=     +   | -   | &

     *note 4.5:::
     unary_adding_operator ::=     +   | -

     *note 4.5:::
     multiplying_operator ::=     *   | /   | mod | rem

     *note 4.5:::
     highest_precedence_operator ::=     **  | abs | not

     *note 4.5.7:::
     conditional_expression ::= if_expression | case_expression

     *note 4.5.7:::
     if_expression ::= 
        if condition then <dependent_>expression
        {elsif condition then <dependent_>expression}
        [else <dependent_>expression]

     *note 4.5.7:::
     condition ::= <boolean_>expression

     *note 4.5.7:::
     case_expression ::= 
         case <selecting_>expression is
         case_expression_alternative {,
         case_expression_alternative}

     *note 4.5.7:::
     case_expression_alternative ::= 
         when discrete_choice_list =>
             <dependent_>expression

     *note 4.5.8:::
     quantified_expression ::= for quantifier 
     loop_parameter_specification => predicate
       | for quantifier iterator_specification => predicate

     *note 4.5.8:::
     quantifier ::= all | some

     *note 4.5.8:::
     predicate ::= <boolean_>expression

     *note 4.6:::
     type_conversion ::= 
         subtype_mark(expression)
       | subtype_mark(name)

     *note 4.7:::
     qualified_expression ::= 
        subtype_mark'(expression) | subtype_mark'aggregate

     *note 4.8:::
     allocator ::= 
        new [subpool_specification] subtype_indication
      | new [subpool_specification] qualified_expression

     *note 4.8:::
     subpool_specification ::= (<subpool_handle_>name)

     *note 5.1:::
     sequence_of_statements ::= statement {statement} {label}

     *note 5.1:::
     statement ::= 
        {label} simple_statement | {label} compound_statement

     *note 5.1:::
     simple_statement ::= null_statement
        | assignment_statement   | exit_statement
        | goto_statement   | procedure_call_statement
        | simple_return_statement   | entry_call_statement
        | requeue_statement   | delay_statement
        | abort_statement   | raise_statement
        | code_statement

     *note 5.1:::
     compound_statement ::= 
          if_statement   | case_statement
        | loop_statement   | block_statement
        | extended_return_statement
        | accept_statement   | select_statement

     *note 5.1:::
     null_statement ::= null;

     *note 5.1:::
     label ::= <<<label_>statement_identifier>>

     *note 5.1:::
     statement_identifier ::= direct_name

     *note 5.2:::
     assignment_statement ::= 
        <variable_>name := expression;

     *note 5.3:::
     if_statement ::= 
         if condition then
           sequence_of_statements
        {elsif condition then
           sequence_of_statements}
        [else
           sequence_of_statements]
         end if;

     *note 5.4:::
     case_statement ::= 
        case <selecting_>expression is
            case_statement_alternative
           {case_statement_alternative}
        end case;

     *note 5.4:::
     case_statement_alternative ::= 
        when discrete_choice_list =>
           sequence_of_statements

     *note 5.5:::
     loop_statement ::= 
        [<loop_>statement_identifier:]
           [iteration_scheme] loop
              sequence_of_statements
            end loop [<loop_>identifier];

     *note 5.5:::
     iteration_scheme ::= while condition
        | for loop_parameter_specification
        | for iterator_specification

     *note 5.5:::
     loop_parameter_specification ::= 
        defining_identifier in [reverse] discrete_subtype_definition

     *note 5.5.2:::
     iterator_specification ::= 
         defining_identifier in [reverse] <iterator_>name
       | defining_identifier [: 
     subtype_indication] of [reverse] <iterable_>name

     *note 5.6:::
     block_statement ::= 
        [<block_>statement_identifier:]
            [declare
                 declarative_part]
             begin
                 handled_sequence_of_statements
             end [<block_>identifier];

     *note 5.7:::
     exit_statement ::= 
        exit [<loop_>name] [when condition];

     *note 5.8:::
     goto_statement ::= goto <label_>name;

     *note 6.1:::
     subprogram_declaration ::= 
         [overriding_indicator]
         subprogram_specification
             [aspect_specification];

     *note 6.1:::
     subprogram_specification ::= 
         procedure_specification
       | function_specification

     *note 6.1:::
     procedure_specification ::= procedure defining_program_unit_name 
     parameter_profile

     *note 6.1:::
     function_specification ::= function defining_designator 
     parameter_and_result_profile

     *note 6.1:::
     designator ::= [parent_unit_name . ]identifier | operator_symbol

     *note 6.1:::
     defining_designator ::= defining_program_unit_name | 
     defining_operator_symbol

     *note 6.1:::
     defining_program_unit_name ::= [parent_unit_name . ]
     defining_identifier

     *note 6.1:::
     operator_symbol ::= string_literal

     *note 6.1:::
     defining_operator_symbol ::= operator_symbol

     *note 6.1:::
     parameter_profile ::= [formal_part]

     *note 6.1:::
     parameter_and_result_profile ::= 
         [formal_part] return [null_exclusion] subtype_mark
       | [formal_part] return access_definition

     *note 6.1:::
     formal_part ::= 
        (parameter_specification {; parameter_specification})

     *note 6.1:::
     parameter_specification ::= 
         defining_identifier_list : [aliased] mode [null_exclusion] 
     subtype_mark [:= default_expression]
       | defining_identifier_list : access_definition [:= 
     default_expression]

     *note 6.1:::
     mode ::= [in] | in out | out

     *note 6.3:::
     subprogram_body ::= 
         [overriding_indicator]
         subprogram_specification
            [aspect_specification] is
            declarative_part
         begin
             handled_sequence_of_statements
         end [designator];

     *note 6.4:::
     procedure_call_statement ::= 
         <procedure_>name;
       | <procedure_>prefix actual_parameter_part;

     *note 6.4:::
     function_call ::= 
         <function_>name
       | <function_>prefix actual_parameter_part

     *note 6.4:::
     actual_parameter_part ::= 
         (parameter_association {, parameter_association})

     *note 6.4:::
     parameter_association ::= 
        [<formal_parameter_>selector_name =>] explicit_actual_parameter

     *note 6.4:::
     explicit_actual_parameter ::= expression | <variable_>name

     *note 6.5:::
     simple_return_statement ::= return [expression];

     *note 6.5:::
     extended_return_object_declaration ::= 
         defining_identifier : [aliased][constant] 
     return_subtype_indication [:= expression]

     *note 6.5:::
     extended_return_statement ::= 
         return extended_return_object_declaration [do
             handled_sequence_of_statements
         end return];

     *note 6.5:::
     return_subtype_indication ::= subtype_indication | 
     access_definition

     *note 6.7:::
     null_procedure_declaration ::= 
        [overriding_indicator]
        procedure_specification is null
            [aspect_specification];

     *note 6.8:::
     expression_function_declaration ::= 
        [overriding_indicator]
        function_specification is
            (expression)
            [aspect_specification];
      | [overriding_indicator]
        function_specification is
            aggregate
            [aspect_specification];

     *note 7.1:::
     package_declaration ::= package_specification;

     *note 7.1:::
     package_specification ::= 
         package defining_program_unit_name
             [aspect_specification] is
           {basic_declarative_item}
        [private
           {basic_declarative_item}]
         end [[parent_unit_name.]identifier]

     *note 7.2:::
     package_body ::= 
         package body defining_program_unit_name
             [aspect_specification] is
            declarative_part
        [begin
             handled_sequence_of_statements]
         end [[parent_unit_name.]identifier];

     *note 7.3:::
     private_type_declaration ::= 
        type defining_identifier [
     discriminant_part] is [[abstract] tagged] [limited] private
           [aspect_specification];

     *note 7.3:::
     private_extension_declaration ::= 
        type defining_identifier [discriminant_part] is
          [abstract] [limited | synchronized] new <ancestor_>
     subtype_indication
          [and interface_list] with private
            [aspect_specification];

     *note 8.3.1:::
     overriding_indicator ::= [not] overriding

     *note 8.4:::
     use_clause ::= use_package_clause | use_type_clause

     *note 8.4:::
     use_package_clause ::= use <package_>name {, <package_>name};

     *note 8.4:::
     use_type_clause ::= use [all] type subtype_mark {, subtype_mark};

     *note 8.5:::
     renaming_declaration ::= 
           object_renaming_declaration
         | exception_renaming_declaration
         | package_renaming_declaration
         | subprogram_renaming_declaration
         | generic_renaming_declaration

     *note 8.5.1:::
     object_renaming_declaration ::= 
         defining_identifier : [null_exclusion] 
     subtype_mark renames <object_>name
             [aspect_specification];
       | defining_identifier : access_definition renames <object_>name
             [aspect_specification];

     *note 8.5.2:::
     exception_renaming_declaration ::= 
     defining_identifier : exception renames <exception_>name
        [aspect_specification];

     *note 8.5.3:::
     package_renaming_declaration ::= package 
     defining_program_unit_name renames <package_>name
        [aspect_specification];

     *note 8.5.4:::
     subprogram_renaming_declaration ::= 
         [overriding_indicator]
         subprogram_specification renames <callable_entity_>name
             [aspect_specification];

     *note 8.5.5:::
     generic_renaming_declaration ::= 
         generic package   
     defining_program_unit_name renames <generic_package_>name
             [aspect_specification];
       | generic procedure   
     defining_program_unit_name renames <generic_procedure_>name
             [aspect_specification];
       | generic function   
     defining_program_unit_name renames <generic_function_>name
             [aspect_specification];

     *note 9.1:::
     task_type_declaration ::= 
        task type defining_identifier [known_discriminant_part]
             [aspect_specification] [is
          [new interface_list with]
          task_definition];

     *note 9.1:::
     single_task_declaration ::= 
        task defining_identifier 
             [aspect_specification][is
          [new interface_list with]
          task_definition];

     *note 9.1:::
     task_definition ::= 
          {task_item}
       [ private
          {task_item}]
       end [<task_>identifier]

     *note 9.1:::
     task_item ::= entry_declaration | aspect_clause

     *note 9.1:::
     task_body ::= 
        task body defining_identifier
             [aspect_specification] is
          declarative_part
        begin
          handled_sequence_of_statements
        end [<task_>identifier];

     *note 9.4:::
     protected_type_declaration ::= 
       protected type defining_identifier [known_discriminant_part]
             [aspect_specification] is
          [new interface_list with]
          protected_definition;

     *note 9.4:::
     single_protected_declaration ::= 
       protected defining_identifier
             [aspect_specification] is
          [new interface_list with]
          protected_definition;

     *note 9.4:::
     protected_definition ::= 
         { protected_operation_declaration }
     [ private
         { protected_element_declaration } ]
       end [<protected_>identifier]

     *note 9.4:::
     protected_operation_declaration ::= subprogram_declaration
          | entry_declaration
          | aspect_clause

     *note 9.4:::
     protected_element_declaration ::= protected_operation_declaration
          | component_declaration

     *note 9.4:::
     protected_body ::= 
       protected body defining_identifier
             [aspect_specification] is
        { protected_operation_item }
       end [<protected_>identifier];

     *note 9.4:::
     protected_operation_item ::= subprogram_declaration
          | subprogram_body
          | null_procedure_declaration
          | expression_function_declaration
          | entry_body
          | aspect_clause

     *note 9.5:::
     synchronization_kind ::= By_Entry | By_Protected_Procedure | Optional

     *note 9.5.2:::
     entry_declaration ::= 
        [overriding_indicator]
        entry defining_identifier [(discrete_subtype_definition)] 
     parameter_profile
           [aspect_specification];

     *note 9.5.2:::
     accept_statement ::= 
        accept <entry_>direct_name [(entry_index)] parameter_profile [do
          handled_sequence_of_statements
        end [<entry_>identifier]];

     *note 9.5.2:::
     entry_index ::= expression

     *note 9.5.2:::
     entry_body ::= 
       entry defining_identifier  entry_body_formal_part  
     entry_barrier is
         declarative_part
       begin
         handled_sequence_of_statements
       end [<entry_>identifier];

     *note 9.5.2:::
     entry_body_formal_part ::= [(entry_index_specification)] 
     parameter_profile

     *note 9.5.2:::
     entry_barrier ::= when condition

     *note 9.5.2:::
     entry_index_specification ::= for defining_identifier in 
     discrete_subtype_definition

     *note 9.5.3:::
     entry_call_statement ::= <entry_>name [actual_parameter_part];

     *note 9.5.4:::
     requeue_statement ::= requeue <procedure_or_entry_>
     name [with abort];

     *note 9.6:::
     delay_statement ::= delay_until_statement | 
     delay_relative_statement

     *note 9.6:::
     delay_until_statement ::= delay until <delay_>expression;

     *note 9.6:::
     delay_relative_statement ::= delay <delay_>expression;

     *note 9.7:::
     select_statement ::= 
        selective_accept
       | timed_entry_call
       | conditional_entry_call
       | asynchronous_select

     *note 9.7.1:::
     selective_accept ::= 
       select
        [guard]
          select_alternative
     { or
        [guard]
          select_alternative }
     [ else
        sequence_of_statements ]
       end select;

     *note 9.7.1:::
     guard ::= when condition =>

     *note 9.7.1:::
     select_alternative ::= 
        accept_alternative
       | delay_alternative
       | terminate_alternative

     *note 9.7.1:::
     accept_alternative ::= 
       accept_statement [sequence_of_statements]

     *note 9.7.1:::
     delay_alternative ::= 
       delay_statement [sequence_of_statements]

     *note 9.7.1:::
     terminate_alternative ::= terminate;

     *note 9.7.2:::
     timed_entry_call ::= 
       select
        entry_call_alternative
       or
        delay_alternative
       end select;

     *note 9.7.2:::
     entry_call_alternative ::= 
       procedure_or_entry_call [sequence_of_statements]

     *note 9.7.2:::
     procedure_or_entry_call ::= 
       procedure_call_statement | entry_call_statement

     *note 9.7.3:::
     conditional_entry_call ::= 
       select
        entry_call_alternative
       else
        sequence_of_statements
       end select;

     *note 9.7.4:::
     asynchronous_select ::= 
       select
        triggering_alternative
       then abort
        abortable_part
       end select;

     *note 9.7.4:::
     triggering_alternative ::= triggering_statement [
     sequence_of_statements]

     *note 9.7.4:::
     triggering_statement ::= procedure_or_entry_call | delay_statement

     *note 9.7.4:::
     abortable_part ::= sequence_of_statements

     *note 9.8:::
     abort_statement ::= abort <task_>name {, <task_>name};

     *note 10.1.1:::
     compilation ::= {compilation_unit}

     *note 10.1.1:::
     compilation_unit ::= 
         context_clause library_item
       | context_clause subunit

     *note 10.1.1:::
     library_item ::= [private] library_unit_declaration
       | library_unit_body
       | [private] library_unit_renaming_declaration

     *note 10.1.1:::
     library_unit_declaration ::= 
          subprogram_declaration   | package_declaration
        | generic_declaration   | generic_instantiation

     *note 10.1.1:::
     library_unit_renaming_declaration ::= 
        package_renaming_declaration
      | generic_renaming_declaration
      | subprogram_renaming_declaration

     *note 10.1.1:::
     library_unit_body ::= subprogram_body | package_body

     *note 10.1.1:::
     parent_unit_name ::= name

     *note 10.1.2:::
     context_clause ::= {context_item}

     *note 10.1.2:::
     context_item ::= with_clause | use_clause

     *note 10.1.2:::
     with_clause ::= limited_with_clause | nonlimited_with_clause

     *note 10.1.2:::
     limited_with_clause ::= limited [private] with <library_unit_>
     name {, <library_unit_>name};

     *note 10.1.2:::
     nonlimited_with_clause ::= [private] with <library_unit_>
     name {, <library_unit_>name};

     *note 10.1.3:::
     body_stub ::= subprogram_body_stub | package_body_stub | 
     task_body_stub | protected_body_stub

     *note 10.1.3:::
     subprogram_body_stub ::= 
        [overriding_indicator]
        subprogram_specification is separate
           [aspect_specification];

     *note 10.1.3:::
     package_body_stub ::= 
        package body defining_identifier is separate
           [aspect_specification];

     *note 10.1.3:::
     task_body_stub ::= 
        task body defining_identifier is separate
           [aspect_specification];

     *note 10.1.3:::
     protected_body_stub ::= 
        protected body defining_identifier is separate
           [aspect_specification];

     *note 10.1.3:::
     subunit ::= separate (parent_unit_name) proper_body

     *note 11.1:::
     exception_declaration ::= defining_identifier_list : exception
        [aspect_specification];

     *note 11.2:::
     handled_sequence_of_statements ::= 
          sequence_of_statements
       [exception
          exception_handler
         {exception_handler}]

     *note 11.2:::
     exception_handler ::= 
       when [choice_parameter_specification:] exception_choice {| 
     exception_choice} =>
          sequence_of_statements

     *note 11.2:::
     choice_parameter_specification ::= defining_identifier

     *note 11.2:::
     exception_choice ::= <exception_>name | others

     *note 11.3:::
     raise_statement ::= raise;
           | raise <exception_>name [with <string_>expression];

     *note 11.3:::
     raise_expression ::= raise <exception_>name [with <string_>
     simple_expression]

     *note 12.1:::
     generic_declaration ::= generic_subprogram_declaration | 
     generic_package_declaration

     *note 12.1:::
     generic_subprogram_declaration ::= 
          generic_formal_part  subprogram_specification
             [aspect_specification];

     *note 12.1:::
     generic_package_declaration ::= 
          generic_formal_part  package_specification;

     *note 12.1:::
     generic_formal_part ::= generic {
     generic_formal_parameter_declaration | use_clause}

     *note 12.1:::
     generic_formal_parameter_declaration ::= 
           formal_object_declaration
         | formal_type_declaration
         | formal_subprogram_declaration
         | formal_package_declaration

     *note 12.3:::
     generic_instantiation ::= 
          package defining_program_unit_name is
              new <generic_package_>name [generic_actual_part]
                 [aspect_specification];
        | [overriding_indicator]
          procedure defining_program_unit_name is
              new <generic_procedure_>name [generic_actual_part]
                 [aspect_specification];
        | [overriding_indicator]
          function defining_designator is
              new <generic_function_>name [generic_actual_part]
                 [aspect_specification];

     *note 12.3:::
     generic_actual_part ::= 
        (generic_association {, generic_association})

     *note 12.3:::
     generic_association ::= 
        [<generic_formal_parameter_>selector_name =>] 
     explicit_generic_actual_parameter

     *note 12.3:::
     explicit_generic_actual_parameter ::= expression | <variable_>name
        | <subprogram_>name | <entry_>name | subtype_mark
        | <package_instance_>name

     *note 12.4:::
     formal_object_declaration ::= 
         defining_identifier_list : mode [null_exclusion] 
     subtype_mark [:= default_expression]
             [aspect_specification];
       |  defining_identifier_list : mode access_definition [:= 
     default_expression]
             [aspect_specification];

     *note 12.5:::
     formal_type_declaration ::= 
           formal_complete_type_declaration
         | formal_incomplete_type_declaration

     *note 12.5:::
     formal_complete_type_declaration ::= 
         type defining_identifier[discriminant_part] is 
     formal_type_definition
             [aspect_specification];

     *note 12.5:::
     formal_incomplete_type_declaration ::= 
         type defining_identifier[discriminant_part] [is tagged];

     *note 12.5:::
     formal_type_definition ::= 
           formal_private_type_definition
         | formal_derived_type_definition
         | formal_discrete_type_definition
         | formal_signed_integer_type_definition
         | formal_modular_type_definition
         | formal_floating_point_definition
         | formal_ordinary_fixed_point_definition
         | formal_decimal_fixed_point_definition
         | formal_array_type_definition
         | formal_access_type_definition
         | formal_interface_type_definition

     *note 12.5.1:::
     formal_private_type_definition ::= [[abstract] tagged] [limited] private

     *note 12.5.1:::
     formal_derived_type_definition ::= 
          [abstract] [limited | synchronized] new subtype_mark [[and 
     interface_list]with private]

     *note 12.5.2:::
     formal_discrete_type_definition ::= (<>)

     *note 12.5.2:::
     formal_signed_integer_type_definition ::= range <>

     *note 12.5.2:::
     formal_modular_type_definition ::= mod <>

     *note 12.5.2:::
     formal_floating_point_definition ::= digits <>

     *note 12.5.2:::
     formal_ordinary_fixed_point_definition ::= delta <>

     *note 12.5.2:::
     formal_decimal_fixed_point_definition ::= delta <> digits <>

     *note 12.5.3:::
     formal_array_type_definition ::= array_type_definition

     *note 12.5.4:::
     formal_access_type_definition ::= access_type_definition

     *note 12.5.5:::
     formal_interface_type_definition ::= interface_type_definition

     *note 12.6:::
     formal_subprogram_declaration ::= 
     formal_concrete_subprogram_declaration
         | formal_abstract_subprogram_declaration

     *note 12.6:::
     formal_concrete_subprogram_declaration ::= 
          with subprogram_specification [is subprogram_default]
             [aspect_specification];

     *note 12.6:::
     formal_abstract_subprogram_declaration ::= 
          with subprogram_specification is abstract [subprogram_default]
             [aspect_specification];

     *note 12.6:::
     subprogram_default ::= default_name | <> | null

     *note 12.6:::
     default_name ::= name

     *note 12.7:::
     formal_package_declaration ::= 
         with package defining_identifier is new <generic_package_>
     name  formal_package_actual_part
             [aspect_specification];

     *note 12.7:::
     formal_package_actual_part ::= 
         ([others =>] <>)
       | [generic_actual_part]
       | (formal_package_association {, 
     formal_package_association} [, others => <>])

     *note 12.7:::
     formal_package_association ::= 
         generic_association
       | <generic_formal_parameter_>selector_name => <>

     *note 13.1:::
     aspect_clause ::= attribute_definition_clause
           | enumeration_representation_clause
           | record_representation_clause
           | at_clause

     *note 13.1:::
     local_name ::= direct_name
           | direct_name'attribute_designator
           | <library_unit_>name

     *note 13.1.1:::
     aspect_specification ::= 
        with aspect_mark [=> aspect_definition] {,
                aspect_mark [=> aspect_definition] }

     *note 13.1.1:::
     aspect_mark ::= <aspect_>identifier['Class]

     *note 13.1.1:::
     aspect_definition ::= name | expression | identifier

     *note 13.3:::
     attribute_definition_clause ::= 
           for local_name'attribute_designator use expression;
         | for local_name'attribute_designator use name;

     *note 13.4:::
     enumeration_representation_clause ::= 
         for <first_subtype_>local_name use enumeration_aggregate;

     *note 13.4:::
     enumeration_aggregate ::= array_aggregate

     *note 13.5.1:::
     record_representation_clause ::= 
         for <first_subtype_>local_name use
           record [mod_clause]
             {component_clause}
           end record;

     *note 13.5.1:::
     component_clause ::= 
         <component_>local_name at position range first_bit .. last_bit;

     *note 13.5.1:::
     position ::= <static_>expression

     *note 13.5.1:::
     first_bit ::= <static_>simple_expression

     *note 13.5.1:::
     last_bit ::= <static_>simple_expression

     *note 13.8:::
     code_statement ::= qualified_expression;

     *note 13.11.3:::
     storage_pool_indicator ::= <storage_pool_>name | null | Standard

     *note 13.12:::
     restriction ::= <restriction_>identifier
         | <restriction_parameter_>identifier => 
     restriction_parameter_argument

     *note 13.12:::
     restriction_parameter_argument ::= name | expression

     *note J.3:::
     delta_constraint ::= delta <static_>simple_expression [
     range_constraint]

     *note J.7:::
     at_clause ::= for direct_name use at expression;

     *note J.8:::
     mod_clause ::= at mod <static_>expression;

Syntax Cross Reference


1/3
In the following syntax cross reference, each syntactic category is
followed by the subclause number where it is defined.  In addition, each
syntactic category <S> is followed by a list of the categories that use
<S> in their definitions.  For example, the first listing below shows
that abort_statement appears in the definition of simple_statement.

     abort_statement   *note 9.8::
        simple_statement   *note 5.1::

     abortable_part   *note 9.7.4::
        asynchronous_select   *note 9.7.4::

     abstract_subprogram_declaration   *note 3.9.3::
        basic_declaration   *note 3.1::

     accept_alternative   *note 9.7.1::
        select_alternative   *note 9.7.1::

     accept_statement   *note 9.5.2::
        accept_alternative   *note 9.7.1::
        compound_statement   *note 5.1::

     access_definition   *note 3.10::
        component_definition   *note 3.6::
        discriminant_specification   *note 3.7::
        formal_object_declaration   *note 12.4::
        object_declaration   *note 3.3.1::
        object_renaming_declaration   *note 8.5.1::
        parameter_and_result_profile   *note 6.1::
        parameter_specification   *note 6.1::
        return_subtype_indication   *note 6.5::

     access_to_object_definition   *note 3.10::
        access_type_definition   *note 3.10::

     access_to_subprogram_definition   *note 3.10::
        access_type_definition   *note 3.10::

     access_type_definition   *note 3.10::
        formal_access_type_definition   *note 12.5.4::
        type_definition   *note 3.2.1::

     actual_parameter_part   *note 6.4::
        entry_call_statement   *note 9.5.3::
        function_call   *note 6.4::
        generalized_indexing   *note 4.1.6::
        procedure_call_statement   *note 6.4::

     aggregate   *note 4.3::
        expression_function_declaration   *note 6.8::
        primary   *note 4.4::
        qualified_expression   *note 4.7::

     allocator   *note 4.8::
        primary   *note 4.4::

     ancestor_part   *note 4.3.2::
        extension_aggregate   *note 4.3.2::

     array_aggregate   *note 4.3.3::
        aggregate   *note 4.3::
        enumeration_aggregate   *note 13.4::

     array_component_association   *note 4.3.3::
        named_array_aggregate   *note 4.3.3::

     array_type_definition   *note 3.6::
        formal_array_type_definition   *note 12.5.3::
        object_declaration   *note 3.3.1::
        type_definition   *note 3.2.1::

     aspect_clause   *note 13.1::
        basic_declarative_item   *note 3.11::
        component_item   *note 3.8::
        protected_operation_declaration   *note 9.4::
        protected_operation_item   *note 9.4::
        task_item   *note 9.1::

     aspect_definition   *note 13.1.1::
        aspect_specification   *note 13.1.1::

     aspect_mark   *note 13.1.1::
        aspect_specification   *note 13.1.1::
        pragma_argument_association   *note 2.8::

     aspect_specification   *note 13.1.1::
        abstract_subprogram_declaration   *note 3.9.3::
        component_declaration   *note 3.8::
        entry_declaration   *note 9.5.2::
        exception_declaration   *note 11.1::
        exception_renaming_declaration   *note 8.5.2::
        expression_function_declaration   *note 6.8::
        formal_abstract_subprogram_declaration   *note 12.6::
        formal_complete_type_declaration   *note 12.5::
        formal_concrete_subprogram_declaration   *note 12.6::
        formal_object_declaration   *note 12.4::
        formal_package_declaration   *note 12.7::
        full_type_declaration   *note 3.2.1::
        generic_instantiation   *note 12.3::
        generic_renaming_declaration   *note 8.5.5::
        generic_subprogram_declaration   *note 12.1::
        null_procedure_declaration   *note 6.7::
        object_declaration   *note 3.3.1::
        object_renaming_declaration   *note 8.5.1::
        package_body   *note 7.2::
        package_body_stub   *note 10.1.3::
        package_renaming_declaration   *note 8.5.3::
        package_specification   *note 7.1::
        private_extension_declaration   *note 7.3::
        private_type_declaration   *note 7.3::
        protected_body   *note 9.4::
        protected_body_stub   *note 10.1.3::
        protected_type_declaration   *note 9.4::
        single_protected_declaration   *note 9.4::
        single_task_declaration   *note 9.1::
        subprogram_body   *note 6.3::
        subprogram_body_stub   *note 10.1.3::
        subprogram_declaration   *note 6.1::
        subprogram_renaming_declaration   *note 8.5.4::
        subtype_declaration   *note 3.2.2::
        task_body   *note 9.1::
        task_body_stub   *note 10.1.3::
        task_type_declaration   *note 9.1::

     assignment_statement   *note 5.2::
        simple_statement   *note 5.1::

     asynchronous_select   *note 9.7.4::
        select_statement   *note 9.7::

     at_clause   *note J.7::
        aspect_clause   *note 13.1::

     attribute_definition_clause   *note 13.3::
        aspect_clause   *note 13.1::

     attribute_designator   *note 4.1.4::
        attribute_definition_clause   *note 13.3::
        attribute_reference   *note 4.1.4::
        local_name   *note 13.1::

     attribute_reference   *note 4.1.4::
        name   *note 4.1::

     base   *note 2.4.2::
        based_literal   *note 2.4.2::

     based_literal   *note 2.4.2::
        numeric_literal   *note 2.4::

     based_numeral   *note 2.4.2::
        based_literal   *note 2.4.2::

     basic_declaration   *note 3.1::
        basic_declarative_item   *note 3.11::

     basic_declarative_item   *note 3.11::
        declarative_item   *note 3.11::
        package_specification   *note 7.1::

     binary_adding_operator   *note 4.5::
        simple_expression   *note 4.4::

     block_statement   *note 5.6::
        compound_statement   *note 5.1::

     body   *note 3.11::
        declarative_item   *note 3.11::

     body_stub   *note 10.1.3::
        body   *note 3.11::

     case_expression   *note 4.5.7::
        conditional_expression   *note 4.5.7::

     case_expression_alternative   *note 4.5.7::
        case_expression   *note 4.5.7::

     case_statement   *note 5.4::
        compound_statement   *note 5.1::

     case_statement_alternative   *note 5.4::
        case_statement   *note 5.4::

     character   *note 2.1::
        comment   *note 2.7::

     character_literal   *note 2.5::
        defining_character_literal   *note 3.5.1::
        name   *note 4.1::
        selector_name   *note 4.1.3::

     choice_expression   *note 4.4::
        discrete_choice   *note 3.8.1::

     choice_parameter_specification   *note 11.2::
        exception_handler   *note 11.2::

     choice_relation   *note 4.4::
        choice_expression   *note 4.4::

     code_statement   *note 13.8::
        simple_statement   *note 5.1::

     compilation_unit   *note 10.1.1::
        compilation   *note 10.1.1::

     component_choice_list   *note 4.3.1::
        record_component_association   *note 4.3.1::

     component_clause   *note 13.5.1::
        record_representation_clause   *note 13.5.1::

     component_declaration   *note 3.8::
        component_item   *note 3.8::
        protected_element_declaration   *note 9.4::

     component_definition   *note 3.6::
        component_declaration   *note 3.8::
        constrained_array_definition   *note 3.6::
        unconstrained_array_definition   *note 3.6::

     component_item   *note 3.8::
        component_list   *note 3.8::

     component_list   *note 3.8::
        record_definition   *note 3.8::
        variant   *note 3.8.1::

     composite_constraint   *note 3.2.2::
        constraint   *note 3.2.2::

     compound_statement   *note 5.1::
        statement   *note 5.1::

     condition   *note 4.5.7::
        entry_barrier   *note 9.5.2::
        exit_statement   *note 5.7::
        guard   *note 9.7.1::
        if_expression   *note 4.5.7::
        if_statement   *note 5.3::
        iteration_scheme   *note 5.5::

     conditional_entry_call   *note 9.7.3::
        select_statement   *note 9.7::

     conditional_expression   *note 4.5.7::
        primary   *note 4.4::

     constrained_array_definition   *note 3.6::
        array_type_definition   *note 3.6::

     constraint   *note 3.2.2::
        subtype_indication   *note 3.2.2::

     context_clause   *note 10.1.2::
        compilation_unit   *note 10.1.1::

     context_item   *note 10.1.2::
        context_clause   *note 10.1.2::

     decimal_fixed_point_definition   *note 3.5.9::
        fixed_point_definition   *note 3.5.9::

     decimal_literal   *note 2.4.1::
        numeric_literal   *note 2.4::

     declarative_item   *note 3.11::
        declarative_part   *note 3.11::

     declarative_part   *note 3.11::
        block_statement   *note 5.6::
        entry_body   *note 9.5.2::
        package_body   *note 7.2::
        subprogram_body   *note 6.3::
        task_body   *note 9.1::

     default_expression   *note 3.7::
        component_declaration   *note 3.8::
        discriminant_specification   *note 3.7::
        formal_object_declaration   *note 12.4::
        parameter_specification   *note 6.1::

     default_name   *note 12.6::
        subprogram_default   *note 12.6::

     defining_character_literal   *note 3.5.1::
        enumeration_literal_specification   *note 3.5.1::

     defining_designator   *note 6.1::
        function_specification   *note 6.1::
        generic_instantiation   *note 12.3::

     defining_identifier   *note 3.1::
        choice_parameter_specification   *note 11.2::
        defining_identifier_list   *note 3.3.1::
        defining_program_unit_name   *note 6.1::
        entry_body   *note 9.5.2::
        entry_declaration   *note 9.5.2::
        entry_index_specification   *note 9.5.2::
        enumeration_literal_specification   *note 3.5.1::
        exception_renaming_declaration   *note 8.5.2::
        extended_return_object_declaration   *note 6.5::
        formal_complete_type_declaration   *note 12.5::
        formal_incomplete_type_declaration   *note 12.5::
        formal_package_declaration   *note 12.7::
        full_type_declaration   *note 3.2.1::
        incomplete_type_declaration   *note 3.10.1::
        iterator_specification   *note 5.5.2::
        loop_parameter_specification   *note 5.5::
        object_renaming_declaration   *note 8.5.1::
        package_body_stub   *note 10.1.3::
        private_extension_declaration   *note 7.3::
        private_type_declaration   *note 7.3::
        protected_body   *note 9.4::
        protected_body_stub   *note 10.1.3::
        protected_type_declaration   *note 9.4::
        single_protected_declaration   *note 9.4::
        single_task_declaration   *note 9.1::
        subtype_declaration   *note 3.2.2::
        task_body   *note 9.1::
        task_body_stub   *note 10.1.3::
        task_type_declaration   *note 9.1::

     defining_identifier_list   *note 3.3.1::
        component_declaration   *note 3.8::
        discriminant_specification   *note 3.7::
        exception_declaration   *note 11.1::
        formal_object_declaration   *note 12.4::
        number_declaration   *note 3.3.2::
        object_declaration   *note 3.3.1::
        parameter_specification   *note 6.1::

     defining_operator_symbol   *note 6.1::
        defining_designator   *note 6.1::

     defining_program_unit_name   *note 6.1::
        defining_designator   *note 6.1::
        generic_instantiation   *note 12.3::
        generic_renaming_declaration   *note 8.5.5::
        package_body   *note 7.2::
        package_renaming_declaration   *note 8.5.3::
        package_specification   *note 7.1::
        procedure_specification   *note 6.1::

     delay_alternative   *note 9.7.1::
        select_alternative   *note 9.7.1::
        timed_entry_call   *note 9.7.2::

     delay_relative_statement   *note 9.6::
        delay_statement   *note 9.6::

     delay_statement   *note 9.6::
        delay_alternative   *note 9.7.1::
        simple_statement   *note 5.1::
        triggering_statement   *note 9.7.4::

     delay_until_statement   *note 9.6::
        delay_statement   *note 9.6::

     delta_constraint   *note J.3::
        scalar_constraint   *note 3.2.2::

     derived_type_definition   *note 3.4::
        type_definition   *note 3.2.1::

     designator   *note 6.1::
        subprogram_body   *note 6.3::

     digit   *note 2.4.1::
        extended_digit   *note 2.4.2::
        numeral   *note 2.4.1::

     digits_constraint   *note 3.5.9::
        scalar_constraint   *note 3.2.2::

     direct_name   *note 4.1::
        accept_statement   *note 9.5.2::
        at_clause   *note J.7::
        local_name   *note 13.1::
        name   *note 4.1::
        statement_identifier   *note 5.1::
        variant_part   *note 3.8.1::

     discrete_choice   *note 3.8.1::
        discrete_choice_list   *note 3.8.1::

     discrete_choice_list   *note 3.8.1::
        array_component_association   *note 4.3.3::
        case_expression_alternative   *note 4.5.7::
        case_statement_alternative   *note 5.4::
        variant   *note 3.8.1::

     discrete_range   *note 3.6.1::
        index_constraint   *note 3.6.1::
        slice   *note 4.1.2::

     discrete_subtype_definition   *note 3.6::
        constrained_array_definition   *note 3.6::
        entry_declaration   *note 9.5.2::
        entry_index_specification   *note 9.5.2::
        loop_parameter_specification   *note 5.5::

     discriminant_association   *note 3.7.1::
        discriminant_constraint   *note 3.7.1::

     discriminant_constraint   *note 3.7.1::
        composite_constraint   *note 3.2.2::

     discriminant_part   *note 3.7::
        formal_complete_type_declaration   *note 12.5::
        formal_incomplete_type_declaration   *note 12.5::
        incomplete_type_declaration   *note 3.10.1::
        private_extension_declaration   *note 7.3::
        private_type_declaration   *note 7.3::

     discriminant_specification   *note 3.7::
        known_discriminant_part   *note 3.7::

     entry_barrier   *note 9.5.2::
        entry_body   *note 9.5.2::

     entry_body   *note 9.5.2::
        protected_operation_item   *note 9.4::

     entry_body_formal_part   *note 9.5.2::
        entry_body   *note 9.5.2::

     entry_call_alternative   *note 9.7.2::
        conditional_entry_call   *note 9.7.3::
        timed_entry_call   *note 9.7.2::

     entry_call_statement   *note 9.5.3::
        procedure_or_entry_call   *note 9.7.2::
        simple_statement   *note 5.1::

     entry_declaration   *note 9.5.2::
        protected_operation_declaration   *note 9.4::
        task_item   *note 9.1::

     entry_index   *note 9.5.2::
        accept_statement   *note 9.5.2::

     entry_index_specification   *note 9.5.2::
        entry_body_formal_part   *note 9.5.2::

     enumeration_aggregate   *note 13.4::
        enumeration_representation_clause   *note 13.4::

     enumeration_literal_specification   *note 3.5.1::
        enumeration_type_definition   *note 3.5.1::

     enumeration_representation_clause   *note 13.4::
        aspect_clause   *note 13.1::

     enumeration_type_definition   *note 3.5.1::
        type_definition   *note 3.2.1::

     exception_choice   *note 11.2::
        exception_handler   *note 11.2::

     exception_declaration   *note 11.1::
        basic_declaration   *note 3.1::

     exception_handler   *note 11.2::
        handled_sequence_of_statements   *note 11.2::

     exception_renaming_declaration   *note 8.5.2::
        renaming_declaration   *note 8.5::

     exit_statement   *note 5.7::
        simple_statement   *note 5.1::

     explicit_actual_parameter   *note 6.4::
        parameter_association   *note 6.4::

     explicit_dereference   *note 4.1::
        name   *note 4.1::

     explicit_generic_actual_parameter   *note 12.3::
        generic_association   *note 12.3::

     exponent   *note 2.4.1::
        based_literal   *note 2.4.2::
        decimal_literal   *note 2.4.1::

     expression   *note 4.4::
        ancestor_part   *note 4.3.2::
        array_component_association   *note 4.3.3::
        aspect_definition   *note 13.1.1::
        assignment_statement   *note 5.2::
        at_clause   *note J.7::
        attribute_definition_clause   *note 13.3::
        attribute_designator   *note 4.1.4::
        case_expression   *note 4.5.7::
        case_expression_alternative   *note 4.5.7::
        case_statement   *note 5.4::
        condition   *note 4.5.7::
        decimal_fixed_point_definition   *note 3.5.9::
        default_expression   *note 3.7::
        delay_relative_statement   *note 9.6::
        delay_until_statement   *note 9.6::
        discriminant_association   *note 3.7.1::
        entry_index   *note 9.5.2::
        explicit_actual_parameter   *note 6.4::
        explicit_generic_actual_parameter   *note 12.3::
        expression_function_declaration   *note 6.8::
        extended_return_object_declaration   *note 6.5::
        floating_point_definition   *note 3.5.7::
        if_expression   *note 4.5.7::
        indexed_component   *note 4.1.1::
        mod_clause   *note J.8::
        modular_type_definition   *note 3.5.4::
        number_declaration   *note 3.3.2::
        object_declaration   *note 3.3.1::
        ordinary_fixed_point_definition   *note 3.5.9::
        position   *note 13.5.1::
        positional_array_aggregate   *note 4.3.3::
        pragma_argument_association   *note 2.8::
        predicate   *note 4.5.8::
        primary   *note 4.4::
        qualified_expression   *note 4.7::
        raise_statement   *note 11.3::
        range_attribute_designator   *note 4.1.4::
        record_component_association   *note 4.3.1::
        restriction_parameter_argument   *note 13.12::
        simple_return_statement   *note 6.5::
        type_conversion   *note 4.6::

     expression_function_declaration   *note 6.8::
        basic_declaration   *note 3.1::
        protected_operation_item   *note 9.4::

     extended_digit   *note 2.4.2::
        based_numeral   *note 2.4.2::

     extended_return_object_declaration   *note 6.5::
        extended_return_statement   *note 6.5::

     extended_return_statement   *note 6.5::
        compound_statement   *note 5.1::

     extension_aggregate   *note 4.3.2::
        aggregate   *note 4.3::

     factor   *note 4.4::
        term   *note 4.4::

     first_bit   *note 13.5.1::
        component_clause   *note 13.5.1::

     fixed_point_definition   *note 3.5.9::
        real_type_definition   *note 3.5.6::

     floating_point_definition   *note 3.5.7::
        real_type_definition   *note 3.5.6::

     formal_abstract_subprogram_declaration   *note 12.6::
        formal_subprogram_declaration   *note 12.6::

     formal_access_type_definition   *note 12.5.4::
        formal_type_definition   *note 12.5::

     formal_array_type_definition   *note 12.5.3::
        formal_type_definition   *note 12.5::

     formal_complete_type_declaration   *note 12.5::
        formal_type_declaration   *note 12.5::

     formal_concrete_subprogram_declaration   *note 12.6::
        formal_subprogram_declaration   *note 12.6::

     formal_decimal_fixed_point_definition   *note 12.5.2::
        formal_type_definition   *note 12.5::

     formal_derived_type_definition   *note 12.5.1::
        formal_type_definition   *note 12.5::

     formal_discrete_type_definition   *note 12.5.2::
        formal_type_definition   *note 12.5::

     formal_floating_point_definition   *note 12.5.2::
        formal_type_definition   *note 12.5::

     formal_incomplete_type_declaration   *note 12.5::
        formal_type_declaration   *note 12.5::

     formal_interface_type_definition   *note 12.5.5::
        formal_type_definition   *note 12.5::

     formal_modular_type_definition   *note 12.5.2::
        formal_type_definition   *note 12.5::

     formal_object_declaration   *note 12.4::
        generic_formal_parameter_declaration   *note 12.1::

     formal_ordinary_fixed_point_definition   *note 12.5.2::
        formal_type_definition   *note 12.5::

     formal_package_actual_part   *note 12.7::
        formal_package_declaration   *note 12.7::

     formal_package_association   *note 12.7::
        formal_package_actual_part   *note 12.7::

     formal_package_declaration   *note 12.7::
        generic_formal_parameter_declaration   *note 12.1::

     formal_part   *note 6.1::
        parameter_and_result_profile   *note 6.1::
        parameter_profile   *note 6.1::

     formal_private_type_definition   *note 12.5.1::
        formal_type_definition   *note 12.5::

     formal_signed_integer_type_definition   *note 12.5.2::
        formal_type_definition   *note 12.5::

     formal_subprogram_declaration   *note 12.6::
        generic_formal_parameter_declaration   *note 12.1::

     formal_type_declaration   *note 12.5::
        generic_formal_parameter_declaration   *note 12.1::

     formal_type_definition   *note 12.5::
        formal_complete_type_declaration   *note 12.5::

     full_type_declaration   *note 3.2.1::
        type_declaration   *note 3.2.1::

     function_call   *note 6.4::
        name   *note 4.1::

     function_specification   *note 6.1::
        expression_function_declaration   *note 6.8::
        subprogram_specification   *note 6.1::

     general_access_modifier   *note 3.10::
        access_to_object_definition   *note 3.10::

     generalized_indexing   *note 4.1.6::
        name   *note 4.1::

     generalized_reference   *note 4.1.5::
        name   *note 4.1::

     generic_actual_part   *note 12.3::
        formal_package_actual_part   *note 12.7::
        generic_instantiation   *note 12.3::

     generic_association   *note 12.3::
        formal_package_association   *note 12.7::
        generic_actual_part   *note 12.3::

     generic_declaration   *note 12.1::
        basic_declaration   *note 3.1::
        library_unit_declaration   *note 10.1.1::

     generic_formal_parameter_declaration   *note 12.1::
        generic_formal_part   *note 12.1::

     generic_formal_part   *note 12.1::
        generic_package_declaration   *note 12.1::
        generic_subprogram_declaration   *note 12.1::

     generic_instantiation   *note 12.3::
        basic_declaration   *note 3.1::
        library_unit_declaration   *note 10.1.1::

     generic_package_declaration   *note 12.1::
        generic_declaration   *note 12.1::

     generic_renaming_declaration   *note 8.5.5::
        library_unit_renaming_declaration   *note 10.1.1::
        renaming_declaration   *note 8.5::

     generic_subprogram_declaration   *note 12.1::
        generic_declaration   *note 12.1::

     goto_statement   *note 5.8::
        simple_statement   *note 5.1::

     graphic_character   *note 2.1::
        character_literal   *note 2.5::
        string_element   *note 2.6::

     guard   *note 9.7.1::
        selective_accept   *note 9.7.1::

     handled_sequence_of_statements   *note 11.2::
        accept_statement   *note 9.5.2::
        block_statement   *note 5.6::
        entry_body   *note 9.5.2::
        extended_return_statement   *note 6.5::
        package_body   *note 7.2::
        subprogram_body   *note 6.3::
        task_body   *note 9.1::

     identifier   *note 2.3::
        accept_statement   *note 9.5.2::
        aspect_definition   *note 13.1.1::
        aspect_mark   *note 13.1.1::
        attribute_designator   *note 4.1.4::
        block_statement   *note 5.6::
        defining_identifier   *note 3.1::
        designator   *note 6.1::
        direct_name   *note 4.1::
        entry_body   *note 9.5.2::
        loop_statement   *note 5.5::
        package_body   *note 7.2::
        package_specification   *note 7.1::
        pragma   *note 2.8::
        pragma_argument_association   *note 2.8::
        protected_body   *note 9.4::
        protected_definition   *note 9.4::
        restriction   *note 13.12::
        selector_name   *note 4.1.3::
        task_body   *note 9.1::
        task_definition   *note 9.1::

     identifier_extend   *note 2.3::
        identifier   *note 2.3::

     identifier_start   *note 2.3::
        identifier   *note 2.3::

     if_expression   *note 4.5.7::
        conditional_expression   *note 4.5.7::

     if_statement   *note 5.3::
        compound_statement   *note 5.1::

     implicit_dereference   *note 4.1::
        prefix   *note 4.1::

     incomplete_type_declaration   *note 3.10.1::
        type_declaration   *note 3.2.1::

     index_constraint   *note 3.6.1::
        composite_constraint   *note 3.2.2::

     index_subtype_definition   *note 3.6::
        unconstrained_array_definition   *note 3.6::

     indexed_component   *note 4.1.1::
        name   *note 4.1::

     integer_type_definition   *note 3.5.4::
        type_definition   *note 3.2.1::

     interface_list   *note 3.9.4::
        derived_type_definition   *note 3.4::
        formal_derived_type_definition   *note 12.5.1::
        interface_type_definition   *note 3.9.4::
        private_extension_declaration   *note 7.3::
        protected_type_declaration   *note 9.4::
        single_protected_declaration   *note 9.4::
        single_task_declaration   *note 9.1::
        task_type_declaration   *note 9.1::

     interface_type_definition   *note 3.9.4::
        formal_interface_type_definition   *note 12.5.5::
        type_definition   *note 3.2.1::

     iteration_scheme   *note 5.5::
        loop_statement   *note 5.5::

     iterator_specification   *note 5.5.2::
        iteration_scheme   *note 5.5::
        quantified_expression   *note 4.5.8::

     known_discriminant_part   *note 3.7::
        discriminant_part   *note 3.7::
        full_type_declaration   *note 3.2.1::
        protected_type_declaration   *note 9.4::
        task_type_declaration   *note 9.1::

     label   *note 5.1::
        sequence_of_statements   *note 5.1::
        statement   *note 5.1::

     last_bit   *note 13.5.1::
        component_clause   *note 13.5.1::

     letter_lowercase   ...
        identifier_start   *note 2.3::

     letter_modifier   ...
        identifier_start   *note 2.3::

     letter_other   ...
        identifier_start   *note 2.3::

     letter_titlecase   ...
        identifier_start   *note 2.3::

     letter_uppercase   ...
        identifier_start   *note 2.3::

     library_item   *note 10.1.1::
        compilation_unit   *note 10.1.1::

     library_unit_body   *note 10.1.1::
        library_item   *note 10.1.1::

     library_unit_declaration   *note 10.1.1::
        library_item   *note 10.1.1::

     library_unit_renaming_declaration   *note 10.1.1::
        library_item   *note 10.1.1::

     limited_with_clause   *note 10.1.2::
        with_clause   *note 10.1.2::

     local_name   *note 13.1::
        attribute_definition_clause   *note 13.3::
        component_clause   *note 13.5.1::
        enumeration_representation_clause   *note 13.4::
        record_representation_clause   *note 13.5.1::

     loop_parameter_specification   *note 5.5::
        iteration_scheme   *note 5.5::
        quantified_expression   *note 4.5.8::

     loop_statement   *note 5.5::
        compound_statement   *note 5.1::

     mark_non_spacing   ...
        identifier_extend   *note 2.3::

     mark_spacing_combining   ...
        identifier_extend   *note 2.3::

     membership_choice   *note 4.4::
        membership_choice_list   *note 4.4::

     membership_choice_list   *note 4.4::
        relation   *note 4.4::

     mod_clause   *note J.8::
        record_representation_clause   *note 13.5.1::

     mode   *note 6.1::
        formal_object_declaration   *note 12.4::
        parameter_specification   *note 6.1::

     modular_type_definition   *note 3.5.4::
        integer_type_definition   *note 3.5.4::

     multiplying_operator   *note 4.5::
        term   *note 4.4::

     name   *note 4.1::
        abort_statement   *note 9.8::
        aspect_definition   *note 13.1.1::
        assignment_statement   *note 5.2::
        attribute_definition_clause   *note 13.3::
        default_name   *note 12.6::
        entry_call_statement   *note 9.5.3::
        exception_choice   *note 11.2::
        exception_renaming_declaration   *note 8.5.2::
        exit_statement   *note 5.7::
        explicit_actual_parameter   *note 6.4::
        explicit_dereference   *note 4.1::
        explicit_generic_actual_parameter   *note 12.3::
        formal_package_declaration   *note 12.7::
        function_call   *note 6.4::
        generalized_reference   *note 4.1.5::
        generic_instantiation   *note 12.3::
        generic_renaming_declaration   *note 8.5.5::
        goto_statement   *note 5.8::
        implicit_dereference   *note 4.1::
        iterator_specification   *note 5.5.2::
        limited_with_clause   *note 10.1.2::
        local_name   *note 13.1::
        nonlimited_with_clause   *note 10.1.2::
        object_renaming_declaration   *note 8.5.1::
        package_renaming_declaration   *note 8.5.3::
        parent_unit_name   *note 10.1.1::
        pragma_argument_association   *note 2.8::
        prefix   *note 4.1::
        primary   *note 4.4::
        procedure_call_statement   *note 6.4::
        raise_expression   *note 11.3::
        raise_statement   *note 11.3::
        requeue_statement   *note 9.5.4::
        restriction_parameter_argument   *note 13.12::
        storage_pool_indicator   *note 13.11.3::
        subpool_specification   *note 4.8::
        subprogram_renaming_declaration   *note 8.5.4::
        subtype_mark   *note 3.2.2::
        type_conversion   *note 4.6::
        use_package_clause   *note 8.4::

     named_array_aggregate   *note 4.3.3::
        array_aggregate   *note 4.3.3::

     nonlimited_with_clause   *note 10.1.2::
        with_clause   *note 10.1.2::

     null_exclusion   *note 3.10::
        access_definition   *note 3.10::
        access_type_definition   *note 3.10::
        discriminant_specification   *note 3.7::
        formal_object_declaration   *note 12.4::
        object_renaming_declaration   *note 8.5.1::
        parameter_and_result_profile   *note 6.1::
        parameter_specification   *note 6.1::
        subtype_indication   *note 3.2.2::

     null_procedure_declaration   *note 6.7::
        basic_declaration   *note 3.1::
        protected_operation_item   *note 9.4::

     null_statement   *note 5.1::
        simple_statement   *note 5.1::

     number_decimal   ...
        identifier_extend   *note 2.3::

     number_declaration   *note 3.3.2::
        basic_declaration   *note 3.1::

     number_letter   ...
        identifier_start   *note 2.3::

     numeral   *note 2.4.1::
        base   *note 2.4.2::
        decimal_literal   *note 2.4.1::
        exponent   *note 2.4.1::

     numeric_literal   *note 2.4::
        primary   *note 4.4::

     object_declaration   *note 3.3.1::
        basic_declaration   *note 3.1::

     object_renaming_declaration   *note 8.5.1::
        renaming_declaration   *note 8.5::

     operator_symbol   *note 6.1::
        defining_operator_symbol   *note 6.1::
        designator   *note 6.1::
        direct_name   *note 4.1::
        selector_name   *note 4.1.3::

     ordinary_fixed_point_definition   *note 3.5.9::
        fixed_point_definition   *note 3.5.9::

     overriding_indicator   *note 8.3.1::
        abstract_subprogram_declaration   *note 3.9.3::
        entry_declaration   *note 9.5.2::
        expression_function_declaration   *note 6.8::
        generic_instantiation   *note 12.3::
        null_procedure_declaration   *note 6.7::
        subprogram_body   *note 6.3::
        subprogram_body_stub   *note 10.1.3::
        subprogram_declaration   *note 6.1::
        subprogram_renaming_declaration   *note 8.5.4::

     package_body   *note 7.2::
        library_unit_body   *note 10.1.1::
        proper_body   *note 3.11::

     package_body_stub   *note 10.1.3::
        body_stub   *note 10.1.3::

     package_declaration   *note 7.1::
        basic_declaration   *note 3.1::
        library_unit_declaration   *note 10.1.1::

     package_renaming_declaration   *note 8.5.3::
        library_unit_renaming_declaration   *note 10.1.1::
        renaming_declaration   *note 8.5::

     package_specification   *note 7.1::
        generic_package_declaration   *note 12.1::
        package_declaration   *note 7.1::

     parameter_and_result_profile   *note 6.1::
        access_definition   *note 3.10::
        access_to_subprogram_definition   *note 3.10::
        function_specification   *note 6.1::

     parameter_association   *note 6.4::
        actual_parameter_part   *note 6.4::

     parameter_profile   *note 6.1::
        accept_statement   *note 9.5.2::
        access_definition   *note 3.10::
        access_to_subprogram_definition   *note 3.10::
        entry_body_formal_part   *note 9.5.2::
        entry_declaration   *note 9.5.2::
        procedure_specification   *note 6.1::

     parameter_specification   *note 6.1::
        formal_part   *note 6.1::

     parent_unit_name   *note 10.1.1::
        defining_program_unit_name   *note 6.1::
        designator   *note 6.1::
        package_body   *note 7.2::
        package_specification   *note 7.1::
        subunit   *note 10.1.3::

     position   *note 13.5.1::
        component_clause   *note 13.5.1::

     positional_array_aggregate   *note 4.3.3::
        array_aggregate   *note 4.3.3::

     pragma_argument_association   *note 2.8::
        pragma   *note 2.8::

     predicate   *note 4.5.8::
        quantified_expression   *note 4.5.8::

     prefix   *note 4.1::
        attribute_reference   *note 4.1.4::
        function_call   *note 6.4::
        generalized_indexing   *note 4.1.6::
        indexed_component   *note 4.1.1::
        procedure_call_statement   *note 6.4::
        range_attribute_reference   *note 4.1.4::
        selected_component   *note 4.1.3::
        slice   *note 4.1.2::

     primary   *note 4.4::
        factor   *note 4.4::

     private_extension_declaration   *note 7.3::
        type_declaration   *note 3.2.1::

     private_type_declaration   *note 7.3::
        type_declaration   *note 3.2.1::

     procedure_call_statement   *note 6.4::
        procedure_or_entry_call   *note 9.7.2::
        simple_statement   *note 5.1::

     procedure_or_entry_call   *note 9.7.2::
        entry_call_alternative   *note 9.7.2::
        triggering_statement   *note 9.7.4::

     procedure_specification   *note 6.1::
        null_procedure_declaration   *note 6.7::
        subprogram_specification   *note 6.1::

     proper_body   *note 3.11::
        body   *note 3.11::
        subunit   *note 10.1.3::

     protected_body   *note 9.4::
        proper_body   *note 3.11::

     protected_body_stub   *note 10.1.3::
        body_stub   *note 10.1.3::

     protected_definition   *note 9.4::
        protected_type_declaration   *note 9.4::
        single_protected_declaration   *note 9.4::

     protected_element_declaration   *note 9.4::
        protected_definition   *note 9.4::

     protected_operation_declaration   *note 9.4::
        protected_definition   *note 9.4::
        protected_element_declaration   *note 9.4::

     protected_operation_item   *note 9.4::
        protected_body   *note 9.4::

     protected_type_declaration   *note 9.4::
        full_type_declaration   *note 3.2.1::

     punctuation_connector   ...
        identifier_extend   *note 2.3::

     qualified_expression   *note 4.7::
        allocator   *note 4.8::
        code_statement   *note 13.8::
        name   *note 4.1::

     quantified_expression   *note 4.5.8::
        primary   *note 4.4::

     quantifier   *note 4.5.8::
        quantified_expression   *note 4.5.8::

     raise_expression   *note 11.3::
        relation   *note 4.4::

     raise_statement   *note 11.3::
        simple_statement   *note 5.1::

     range   *note 3.5::
        discrete_choice   *note 3.8.1::
        discrete_range   *note 3.6.1::
        discrete_subtype_definition   *note 3.6::
        membership_choice   *note 4.4::
        range_constraint   *note 3.5::

     range_attribute_designator   *note 4.1.4::
        range_attribute_reference   *note 4.1.4::

     range_attribute_reference   *note 4.1.4::
        range   *note 3.5::

     range_constraint   *note 3.5::
        delta_constraint   *note J.3::
        digits_constraint   *note 3.5.9::
        scalar_constraint   *note 3.2.2::

     real_range_specification   *note 3.5.7::
        decimal_fixed_point_definition   *note 3.5.9::
        floating_point_definition   *note 3.5.7::
        ordinary_fixed_point_definition   *note 3.5.9::

     real_type_definition   *note 3.5.6::
        type_definition   *note 3.2.1::

     record_aggregate   *note 4.3.1::
        aggregate   *note 4.3::

     record_component_association   *note 4.3.1::
        record_component_association_list   *note 4.3.1::

     record_component_association_list   *note 4.3.1::
        extension_aggregate   *note 4.3.2::
        record_aggregate   *note 4.3.1::

     record_definition   *note 3.8::
        record_extension_part   *note 3.9.1::
        record_type_definition   *note 3.8::

     record_extension_part   *note 3.9.1::
        derived_type_definition   *note 3.4::

     record_representation_clause   *note 13.5.1::
        aspect_clause   *note 13.1::

     record_type_definition   *note 3.8::
        type_definition   *note 3.2.1::

     relation   *note 4.4::
        expression   *note 4.4::

     relational_operator   *note 4.5::
        choice_relation   *note 4.4::
        relation   *note 4.4::

     renaming_declaration   *note 8.5::
        basic_declaration   *note 3.1::

     requeue_statement   *note 9.5.4::
        simple_statement   *note 5.1::

     restriction_parameter_argument   *note 13.12::
        restriction   *note 13.12::

     return_subtype_indication   *note 6.5::
        extended_return_object_declaration   *note 6.5::

     scalar_constraint   *note 3.2.2::
        constraint   *note 3.2.2::

     select_alternative   *note 9.7.1::
        selective_accept   *note 9.7.1::

     select_statement   *note 9.7::
        compound_statement   *note 5.1::

     selected_component   *note 4.1.3::
        name   *note 4.1::

     selective_accept   *note 9.7.1::
        select_statement   *note 9.7::

     selector_name   *note 4.1.3::
        component_choice_list   *note 4.3.1::
        discriminant_association   *note 3.7.1::
        formal_package_association   *note 12.7::
        generic_association   *note 12.3::
        parameter_association   *note 6.4::
        selected_component   *note 4.1.3::

     sequence_of_statements   *note 5.1::
        abortable_part   *note 9.7.4::
        accept_alternative   *note 9.7.1::
        case_statement_alternative   *note 5.4::
        conditional_entry_call   *note 9.7.3::
        delay_alternative   *note 9.7.1::
        entry_call_alternative   *note 9.7.2::
        exception_handler   *note 11.2::
        handled_sequence_of_statements   *note 11.2::
        if_statement   *note 5.3::
        loop_statement   *note 5.5::
        selective_accept   *note 9.7.1::
        triggering_alternative   *note 9.7.4::

     signed_integer_type_definition   *note 3.5.4::
        integer_type_definition   *note 3.5.4::

     simple_expression   *note 4.4::
        choice_relation   *note 4.4::
        delta_constraint   *note J.3::
        digits_constraint   *note 3.5.9::
        first_bit   *note 13.5.1::
        last_bit   *note 13.5.1::
        membership_choice   *note 4.4::
        raise_expression   *note 11.3::
        range   *note 3.5::
        real_range_specification   *note 3.5.7::
        relation   *note 4.4::
        signed_integer_type_definition   *note 3.5.4::

     simple_return_statement   *note 6.5::
        simple_statement   *note 5.1::

     simple_statement   *note 5.1::
        statement   *note 5.1::

     single_protected_declaration   *note 9.4::
        object_declaration   *note 3.3.1::

     single_task_declaration   *note 9.1::
        object_declaration   *note 3.3.1::

     slice   *note 4.1.2::
        name   *note 4.1::

     statement   *note 5.1::
        sequence_of_statements   *note 5.1::

     statement_identifier   *note 5.1::
        block_statement   *note 5.6::
        label   *note 5.1::
        loop_statement   *note 5.5::

     string_element   *note 2.6::
        string_literal   *note 2.6::

     string_literal   *note 2.6::
        operator_symbol   *note 6.1::
        primary   *note 4.4::

     subpool_specification   *note 4.8::
        allocator   *note 4.8::

     subprogram_body   *note 6.3::
        library_unit_body   *note 10.1.1::
        proper_body   *note 3.11::
        protected_operation_item   *note 9.4::

     subprogram_body_stub   *note 10.1.3::
        body_stub   *note 10.1.3::

     subprogram_declaration   *note 6.1::
        basic_declaration   *note 3.1::
        library_unit_declaration   *note 10.1.1::
        protected_operation_declaration   *note 9.4::
        protected_operation_item   *note 9.4::

     subprogram_default   *note 12.6::
        formal_abstract_subprogram_declaration   *note 12.6::
        formal_concrete_subprogram_declaration   *note 12.6::

     subprogram_renaming_declaration   *note 8.5.4::
        library_unit_renaming_declaration   *note 10.1.1::
        renaming_declaration   *note 8.5::

     subprogram_specification   *note 6.1::
        abstract_subprogram_declaration   *note 3.9.3::
        formal_abstract_subprogram_declaration   *note 12.6::
        formal_concrete_subprogram_declaration   *note 12.6::
        generic_subprogram_declaration   *note 12.1::
        subprogram_body   *note 6.3::
        subprogram_body_stub   *note 10.1.3::
        subprogram_declaration   *note 6.1::
        subprogram_renaming_declaration   *note 8.5.4::

     subtype_declaration   *note 3.2.2::
        basic_declaration   *note 3.1::

     subtype_indication   *note 3.2.2::
        access_to_object_definition   *note 3.10::
        allocator   *note 4.8::
        component_definition   *note 3.6::
        derived_type_definition   *note 3.4::
        discrete_choice   *note 3.8.1::
        discrete_range   *note 3.6.1::
        discrete_subtype_definition   *note 3.6::
        iterator_specification   *note 5.5.2::
        object_declaration   *note 3.3.1::
        private_extension_declaration   *note 7.3::
        return_subtype_indication   *note 6.5::
        subtype_declaration   *note 3.2.2::

     subtype_mark   *note 3.2.2::
        access_definition   *note 3.10::
        ancestor_part   *note 4.3.2::
        discriminant_specification   *note 3.7::
        explicit_generic_actual_parameter   *note 12.3::
        formal_derived_type_definition   *note 12.5.1::
        formal_object_declaration   *note 12.4::
        index_subtype_definition   *note 3.6::
        interface_list   *note 3.9.4::
        membership_choice   *note 4.4::
        object_renaming_declaration   *note 8.5.1::
        parameter_and_result_profile   *note 6.1::
        parameter_specification   *note 6.1::
        qualified_expression   *note 4.7::
        subtype_indication   *note 3.2.2::
        type_conversion   *note 4.6::
        use_type_clause   *note 8.4::

     subunit   *note 10.1.3::
        compilation_unit   *note 10.1.1::

     task_body   *note 9.1::
        proper_body   *note 3.11::

     task_body_stub   *note 10.1.3::
        body_stub   *note 10.1.3::

     task_definition   *note 9.1::
        single_task_declaration   *note 9.1::
        task_type_declaration   *note 9.1::

     task_item   *note 9.1::
        task_definition   *note 9.1::

     task_type_declaration   *note 9.1::
        full_type_declaration   *note 3.2.1::

     term   *note 4.4::
        simple_expression   *note 4.4::

     terminate_alternative   *note 9.7.1::
        select_alternative   *note 9.7.1::

     timed_entry_call   *note 9.7.2::
        select_statement   *note 9.7::

     triggering_alternative   *note 9.7.4::
        asynchronous_select   *note 9.7.4::

     triggering_statement   *note 9.7.4::
        triggering_alternative   *note 9.7.4::

     type_conversion   *note 4.6::
        name   *note 4.1::

     type_declaration   *note 3.2.1::
        basic_declaration   *note 3.1::

     type_definition   *note 3.2.1::
        full_type_declaration   *note 3.2.1::

     unary_adding_operator   *note 4.5::
        simple_expression   *note 4.4::

     unconstrained_array_definition   *note 3.6::
        array_type_definition   *note 3.6::

     underline   ...
        based_numeral   *note 2.4.2::
        numeral   *note 2.4.1::

     unknown_discriminant_part   *note 3.7::
        discriminant_part   *note 3.7::

     use_clause   *note 8.4::
        basic_declarative_item   *note 3.11::
        context_item   *note 10.1.2::
        generic_formal_part   *note 12.1::

     use_package_clause   *note 8.4::
        use_clause   *note 8.4::

     use_type_clause   *note 8.4::
        use_clause   *note 8.4::

     variant   *note 3.8.1::
        variant_part   *note 3.8.1::

     variant_part   *note 3.8.1::
        component_list   *note 3.8::

     with_clause   *note 10.1.2::
        context_item   *note 10.1.2::


File: arm2012.info,  Node: Annex Q,  Next: Index,  Prev: Annex P,  Up: Top

Annex Q Language-Defined Entities
*********************************

1/2
This annex lists the language-defined entities of the language.  A list
of language-defined library units can be found in *note Annex A::,
"*note Annex A:: Predefined Language Environment".

* Menu:

* Q.1 ::      Language-Defined Packages
* Q.2 ::      Language-Defined Types and Subtypes
* Q.3 ::      Language-Defined Subprograms
* Q.4 ::      Language-Defined Exceptions
* Q.5 ::      Language-Defined Objects


File: arm2012.info,  Node: Q.1,  Next: Q.2,  Up: Annex Q

Q.1 Language-Defined Packages
=============================

1/3
This subclause lists all language-defined packages.

 

Ada   *note A.2(2): 5456.

Address_To_Access_Conversions
   <child of> System   *note 13.7.2(2): 5144.

Arithmetic
   <child of> Ada.Calendar   *note 9.6.1(8/2): 4173.

ASCII
   <in> Standard   *note A.1(36.3/2): 5445.

Assertions
   <child of> Ada   *note 11.4.2(12/2): 4604.

Asynchronous_Task_Control
   <child of> Ada   *note D.11(3/2): 7988.

Bounded
   <child of> Ada.Strings   *note A.4.4(3): 5843.

Bounded_IO
   <child of> Ada.Text_IO   *note A.10.11(3/2): 6537.
   <child of> Ada.Wide_Text_IO   *note A.11(4/3): 6561.
   <child of> Ada.Wide_Wide_Text_IO   *note A.11(4/3): 6562.

Bounded_Priority_Queues
   <child of> Ada.Containers   *note A.18.31(2/3): 7362.

Bounded_Synchronized_Queues
   <child of> Ada.Containers   *note A.18.29(2/3): 7349.

C
   <child of> Interfaces   *note B.3(4): 7432.

Calendar
   <child of> Ada   *note 9.6(10): 4145.

Characters
   <child of> Ada   *note A.3.1(2): 5457.

COBOL
   <child of> Interfaces   *note B.4(7): 7545.

Command_Line
   <child of> Ada   *note A.15(3): 6626.

Complex_Arrays
   <child of> Ada.Numerics   *note G.3.2(53/2): 8422.

Complex_Elementary_Functions
   <child of> Ada.Numerics   *note G.1.2(9/1): 8306.

Complex_Text_IO
   <child of> Ada   *note G.1.3(9.1/2): 8324.

Complex_Types
   <child of> Ada.Numerics   *note G.1.1(25/1): 8279.

Complex_IO
   <child of> Ada.Text_IO   *note G.1.3(3): 8314.
   <child of> Ada.Wide_Text_IO   *note G.1.4(1): 8326.
   <child of> Ada.Wide_Wide_Text_IO   *note G.1.5(1/2): 8328.

Constants
   <child of> Ada.Strings.Maps   *note A.4.6(3/2): 5954.

Containers
   <child of> Ada   *note A.18.1(3/2): 6715.

Conversions
   <child of> Ada.Characters   *note A.3.4(2/2): 5729.
   <child of> Ada.Strings.UTF_Encoding   *note A.4.11(15/3): 6075.

Decimal
   <child of> Ada   *note F.2(2): 8223.

Decimal_Conversions
   <in> Interfaces.COBOL   *note B.4(31): 7579.

Decimal_IO
   <in> Ada.Text_IO   *note A.10.1(73): 6501.

Decimal_Output
   <in> Ada.Text_IO.Editing   *note F.3.3(11): 8246.

Direct_IO
   <child of> Ada   *note A.8.4(2): 6323.

Directories
   <child of> Ada   *note A.16(3/2): 6635.

Discrete_Random
   <child of> Ada.Numerics   *note A.5.2(17): 6160.

Dispatching
   <child of> Ada   *note D.2.1(1.2/3): 7769.

Dispatching_Domains
   <child of> System.Multiprocessors   *note D.16.1(3/3): 8077.

Doubly_Linked_Lists
   <child of> Ada.Containers   *note A.18.3(5/3): 6822.

Dynamic_Priorities
   <child of> Ada   *note D.5.1(3/2): 7865.

EDF
   <child of> Ada.Dispatching   *note D.2.6(9/2): 7821.
   <child of> Ada.Synchronous_Task_Control   *note D.10(5.2/3): 7979.

Editing
   <child of> Ada.Text_IO   *note F.3.3(3): 8234.
   <child of> Ada.Wide_Text_IO   *note F.3.4(1): 8254.
   <child of> Ada.Wide_Wide_Text_IO   *note F.3.5(1/2): 8256.

Elementary_Functions
   <child of> Ada.Numerics   *note A.5.1(9/1): 6139.

Enumeration_IO
   <in> Ada.Text_IO   *note A.10.1(79): 6511.

Environment_Variables
   <child of> Ada   *note A.17(3/2): 6699.

Exceptions
   <child of> Ada   *note 11.4.1(2/2): 4564.

Execution_Time
   <child of> Ada   *note D.14(3/2): 7999.

Finalization
   <child of> Ada   *note 7.6(4/3): 3661.

Fixed
   <child of> Ada.Strings   *note A.4.3(5): 5807.

Fixed_IO
   <in> Ada.Text_IO   *note A.10.1(68): 6491.

Float_Random
   <child of> Ada.Numerics   *note A.5.2(5): 6147.

Float_Text_IO
   <child of> Ada   *note A.10.9(33): 6536.

Float_Wide_Text_IO
   <child of> Ada   *note A.11(2/2): 6557.

Float_Wide_Wide_Text_IO
   <child of> Ada   *note A.11(3/2): 6560.

Float_IO
   <in> Ada.Text_IO   *note A.10.1(63): 6481.

Formatting
   <child of> Ada.Calendar   *note 9.6.1(15/2): 4177.

Fortran
   <child of> Interfaces   *note B.5(4): 7599.

Generic_Complex_Arrays
   <child of> Ada.Numerics   *note G.3.2(2/2): 8386.

Generic_Complex_Elementary_Functions
   <child of> Ada.Numerics   *note G.1.2(2/2): 8285.

Generic_Complex_Types
   <child of> Ada.Numerics   *note G.1.1(2/1): 8258.

Generic_Dispatching_Constructor
   <child of> Ada.Tags   *note 3.9(18.2/3): 2125.

Generic_Elementary_Functions
   <child of> Ada.Numerics   *note A.5.1(3): 6110.

Generic_Bounded_Length
   <in> Ada.Strings.Bounded   *note A.4.4(4): 5844.

Generic_Keys
   <in> Ada.Containers.Hashed_Sets   *note A.18.8(50/2): 7087.
   <in> Ada.Containers.Ordered_Sets   *note A.18.9(62/2): 7165.

Generic_Real_Arrays
   <child of> Ada.Numerics   *note G.3.1(2/2): 8370.

Generic_Sorting
   <in> Ada.Containers.Doubly_Linked_Lists   *note A.18.3(47/2): 6869.
   <in> Ada.Containers.Vectors   *note A.18.2(75/2): 6797.

Group_Budgets
   <child of> Ada.Execution_Time   *note D.14.2(3/3): 8030.

Handling
   <child of> Ada.Characters   *note A.3.2(2/2): 5460.
   <child of> Ada.Wide_Characters   *note A.3.5(3/3): 5748.
   <child of> Ada.Wide_Wide_Characters   *note A.3.6(1/3): 5769.

Hashed_Maps
   <child of> Ada.Containers   *note A.18.5(2/3): 6908.

Hashed_Sets
   <child of> Ada.Containers   *note A.18.8(2/3): 7040.

Hierarchical_File_Names
   <child of> Ada.Directories   *note A.16.1(3/3): 6686.

Indefinite_Doubly_Linked_Lists
   <child of> Ada.Containers   *note A.18.12(2/3): 7277.

Indefinite_Hashed_Maps
   <child of> Ada.Containers   *note A.18.13(2/3): 7278.

Indefinite_Hashed_Sets
   <child of> Ada.Containers   *note A.18.15(2/3): 7280.

Indefinite_Holders
   <child of> Ada.Containers   *note A.18.18(5/3): 7284.

Indefinite_Multiway_Trees
   <child of> Ada.Containers   *note A.18.17(2/3): 7282.

Indefinite_Ordered_Maps
   <child of> Ada.Containers   *note A.18.14(2/3): 7279.

Indefinite_Ordered_Sets
   <child of> Ada.Containers   *note A.18.16(2/3): 7281.

Indefinite_Vectors
   <child of> Ada.Containers   *note A.18.11(2/3): 7276.

Information
   <child of> Ada.Directories   *note A.16(124/2): 6685.

Integer_Text_IO
   <child of> Ada   *note A.10.8(21): 6535.

Integer_Wide_Text_IO
   <child of> Ada   *note A.11(2/2): 6556.

Integer_Wide_Wide_Text_IO
   <child of> Ada   *note A.11(3/2): 6559.

Integer_IO
   <in> Ada.Text_IO   *note A.10.1(52): 6463.

Interfaces   *note B.2(3): 7420.

Interrupts
   <child of> Ada   *note C.3.2(2/3): 7659.
   <child of> Ada.Execution_Time   *note D.14.3(3/3): 8055.

IO_Exceptions
   <child of> Ada   *note A.13(3): 6613.

Iterator_Interfaces
   <child of> Ada   *note 5.5.1(2/3): 3209.

Latin_1
   <child of> Ada.Characters   *note A.3.3(3): 5498.

List_Iterator_Interfaces
   <in> Ada.Containers.Doubly_Linked_Lists   *note A.18.3(9.2/3): 6828.

Locales
   <child of> Ada   *note A.19(3/3): 7370.

Machine_Code
   <child of> System   *note 13.8(7): 5153.

Map_Iterator_Interfaces
   <in> Ada.Containers.Hashed_Maps   *note A.18.5(6.2/3): 6914.
   <in> Ada.Containers.Ordered_Maps   *note A.18.6(7.2/3): 6967.

Maps
   <child of> Ada.Strings   *note A.4.2(3/2): 5783.

Modular_IO
   <in> Ada.Text_IO   *note A.10.1(57): 6472.

Multiprocessors
   <child of> System   *note D.16(3/3): 8070.

Multiway_Trees
   <child of> Ada.Containers   *note A.18.10(7/3): 7201.

Names
   <child of> Ada.Interrupts   *note C.3.2(12): 7670.

Non_Preemptive
   <child of> Ada.Dispatching   *note D.2.4(2.2/3): 7806.

Numerics
   <child of> Ada   *note A.5(3/2): 6106.

Ordered_Maps
   <child of> Ada.Containers   *note A.18.6(2/3): 6960.

Ordered_Sets
   <child of> Ada.Containers   *note A.18.9(2/3): 7112.

Pointers
   <child of> Interfaces.C   *note B.3.2(4): 7518.

Real_Arrays
   <child of> Ada.Numerics   *note G.3.1(31/2): 8382.

Real_Time
   <child of> Ada   *note D.8(3): 7941.

Round_Robin
   <child of> Ada.Dispatching   *note D.2.5(4/2): 7813.

RPC
   <child of> System   *note E.5(3): 8204.

Sequential_IO
   <child of> Ada   *note A.8.1(2): 6298.

Set_Iterator_Interfaces
   <in> Ada.Containers.Hashed_Sets   *note A.18.8(6.2/3): 7046.
   <in> Ada.Containers.Ordered_Sets   *note A.18.9(7.2/3): 7119.

Single_Precision_Complex_Types
   <in> Interfaces.Fortran   *note B.5(8): 7604.

Standard   *note A.1(4): 5436.

Storage_Elements
   <child of> System   *note 13.7.1(2/2): 5132.

Storage_IO
   <child of> Ada   *note A.9(3): 6355.

Storage_Pools
   <child of> System   *note 13.11(5): 5187.

Stream_IO
   <child of> Ada.Streams   *note A.12.1(3/3): 6568.

Streams
   <child of> Ada   *note 13.13.1(2): 5333.

Strings
   <child of> Ada   *note A.4.1(3): 5770.
   <child of> Ada.Strings.UTF_Encoding   *note A.4.11(22/3): 6081.
   <child of> Interfaces.C   *note B.3.1(3): 7496.

Subpools
   <child of> System.Storage_Pools   *note 13.11.4(3/3): 5256.

Synchronized_Queue_Interfaces
   <child of> Ada.Containers   *note A.18.27(3/3): 7336.

Synchronous_Barriers
   <child of> Ada   *note D.10.1(3/3): 7984.

Synchronous_Task_Control
   <child of> Ada   *note D.10(3/2): 7973.

System   *note 13.7(3/2): 5105.

Tags
   <child of> Ada   *note 3.9(6/2): 2100.

Task_Attributes
   <child of> Ada   *note C.7.2(2): 7728.

Task_Identification
   <child of> Ada   *note C.7.1(2/2): 7708.

Task_Termination
   <child of> Ada   *note C.7.3(2/2): 7740.

Text_Streams
   <child of> Ada.Text_IO   *note A.12.2(3): 6604.
   <child of> Ada.Wide_Text_IO   *note A.12.3(3): 6607.
   <child of> Ada.Wide_Wide_Text_IO   *note A.12.4(3/2): 6610.

Text_IO
   <child of> Ada   *note A.10.1(2): 6374.

Time_Zones
   <child of> Ada.Calendar   *note 9.6.1(2/2): 4169.

Timers
   <child of> Ada.Execution_Time   *note D.14.1(3/2): 8015.

Timing_Events
   <child of> Ada.Real_Time   *note D.15(3/2): 8058.

Tree_Iterator_Interfaces
   <in> Ada.Containers.Multiway_Trees   *note A.18.10(13/3): 7207.

Unbounded
   <child of> Ada.Strings   *note A.4.5(3): 5902.

Unbounded_IO
   <child of> Ada.Text_IO   *note A.10.12(3/2): 6546.
   <child of> Ada.Wide_Text_IO   *note A.11(5/3): 6563.
   <child of> Ada.Wide_Wide_Text_IO   *note A.11(5/3): 6564.

Unbounded_Priority_Queues
   <child of> Ada.Containers   *note A.18.30(2/3): 7355.

Unbounded_Synchronized_Queues
   <child of> Ada.Containers   *note A.18.28(2/3): 7343.

UTF_Encoding
   <child of> Ada.Strings   *note A.4.11(3/3): 6064.

Vector_Iterator_Interfaces
   <in> Ada.Containers.Vectors   *note A.18.2(11.2/3): 6732.

Vectors
   <child of> Ada.Containers   *note A.18.2(6/3): 6724.

Wide_Bounded
   <child of> Ada.Strings   *note A.4.7(1/3): 5970.

Wide_Constants
   <child of> Ada.Strings.Wide_Maps   *note A.4.7(1/3): 5984, *note
A.4.8(28/2): 6045.

Wide_Equal_Case_Insensitive
   <child of> Ada.Strings   *note A.4.7(1/3): 5976.

Wide_Fixed
   <child of> Ada.Strings   *note A.4.7(1/3): 5969.

Wide_Hash
   <child of> Ada.Strings   *note A.4.7(1/3): 5972.

Wide_Hash_Case_Insensitive
   <child of> Ada.Strings   *note A.4.7(1/3): 5980.

Wide_Maps
   <child of> Ada.Strings   *note A.4.7(3): 5985.

Wide_Text_IO
   <child of> Ada   *note A.11(2/2): 6555.

Wide_Unbounded
   <child of> Ada.Strings   *note A.4.7(1/3): 5971.

Wide_Characters
   <child of> Ada   *note A.3.1(4/2): 5458.

Wide_Strings
   <child of> Ada.Strings.UTF_Encoding   *note A.4.11(30/3): 6088.

Wide_Wide_Constants
   <child of> Ada.Strings.Wide_Wide_Maps   *note A.4.8(1/3): 6023.

Wide_Wide_Equal_Case_Insensitive
   <child of> Ada.Strings   *note A.4.8(1/3): 6015.

Wide_Wide_Hash
   <child of> Ada.Strings   *note A.4.8(1/3): 6011.

Wide_Wide_Hash_Case_Insensitive
   <child of> Ada.Strings   *note A.4.8(1/3): 6019.

Wide_Wide_Text_IO
   <child of> Ada   *note A.11(3/2): 6558.

Wide_Wide_Bounded
   <child of> Ada.Strings   *note A.4.8(1/3): 6009.

Wide_Wide_Characters
   <child of> Ada   *note A.3.1(6/2): 5459.

Wide_Wide_Fixed
   <child of> Ada.Strings   *note A.4.8(1/3): 6008.

Wide_Wide_Maps
   <child of> Ada.Strings   *note A.4.8(3/2): 6024.

Wide_Wide_Strings
   <child of> Ada.Strings.UTF_Encoding   *note A.4.11(38/3): 6095.

Wide_Wide_Unbounded
   <child of> Ada.Strings   *note A.4.8(1/3): 6010.


File: arm2012.info,  Node: Q.2,  Next: Q.3,  Prev: Q.1,  Up: Annex Q

Q.2 Language-Defined Types and Subtypes
=======================================

1/3
This subclause lists all language-defined types and subtypes.

 

Address
   <in> System   *note 13.7(12): 5117.

Alignment
   <in> Ada.Strings   *note A.4.1(6): 5778.

Alphanumeric
   <in> Interfaces.COBOL   *note B.4(16/3): 7557.

Any_Priority <subtype of> Integer
   <in> System   *note 13.7(16): 5127.

Attribute_Handle
   <in> Ada.Task_Attributes   *note C.7.2(3): 7729.

Barrier_Limit <subtype of> Positive
   <in> Ada.Synchronous_Barriers   *note D.10.1(4/3): 7985.

Binary
   <in> Interfaces.COBOL   *note B.4(10): 7548.

Binary_Format
   <in> Interfaces.COBOL   *note B.4(24): 7569.

Bit_Order
   <in> System   *note 13.7(15/2): 5123.

Boolean
   <in> Standard   *note A.1(5): 5437.

Bounded_String
   <in> Ada.Strings.Bounded   *note A.4.4(6): 5846.

Buffer_Type <subtype of> Storage_Array
   <in> Ada.Storage_IO   *note A.9(4): 6357.

Byte
   <in> Interfaces.COBOL   *note B.4(29/3): 7576.

Byte_Array
   <in> Interfaces.COBOL   *note B.4(29/3): 7577.

C_float
   <in> Interfaces.C   *note B.3(15): 7448.

Cause_Of_Termination
   <in> Ada.Task_Termination   *note C.7.3(3/2): 7741.

char
   <in> Interfaces.C   *note B.3(19): 7451.

char16_array
   <in> Interfaces.C   *note B.3(39.5/3): 7475.

char16_t
   <in> Interfaces.C   *note B.3(39.2/2): 7471.

char32_array
   <in> Interfaces.C   *note B.3(39.14/3): 7485.

char32_t
   <in> Interfaces.C   *note B.3(39.11/2): 7481.

char_array
   <in> Interfaces.C   *note B.3(23/3): 7455.

char_array_access
   <in> Interfaces.C.Strings   *note B.3.1(4): 7497.

Character
   <in> Standard   *note A.1(35/3): 5442.

Character_Mapping
   <in> Ada.Strings.Maps   *note A.4.2(20/2): 5797.

Character_Mapping_Function
   <in> Ada.Strings.Maps   *note A.4.2(25): 5803.

Character_Range
   <in> Ada.Strings.Maps   *note A.4.2(6): 5786.

Character_Ranges
   <in> Ada.Strings.Maps   *note A.4.2(7): 5787.

Character_Sequence <subtype of> String
   <in> Ada.Strings.Maps   *note A.4.2(16): 5793.

Character_Set
   <in> Ada.Strings.Maps   *note A.4.2(4/2): 5784.
   <in> Interfaces.Fortran   *note B.5(11): 7609.

chars_ptr
   <in> Interfaces.C.Strings   *note B.3.1(5/2): 7498.

chars_ptr_array
   <in> Interfaces.C.Strings   *note B.3.1(6/2): 7499.

COBOL_Character
   <in> Interfaces.COBOL   *note B.4(13): 7554.

Complex
   <in> Ada.Numerics.Generic_Complex_Types   *note G.1.1(3): 8259.
   <in> Interfaces.Fortran   *note B.5(9): 7605.

Complex_Matrix
   <in> Ada.Numerics.Generic_Complex_Arrays   *note G.3.2(4/2): 8388.

Complex_Vector
   <in> Ada.Numerics.Generic_Complex_Arrays   *note G.3.2(4/2): 8387.

Constant_Reference_Type
   <in> Ada.Containers.Indefinite_Holders   *note A.18.18(16/3): 7294.
   <in> Ada.Containers.Multiway_Trees   *note A.18.10(28/3): 7221.

Controlled
   <in> Ada.Finalization   *note 7.6(5/2): 3662.

Count
   <in> Ada.Direct_IO   *note A.8.4(4): 6326.
   <in> Ada.Streams.Stream_IO   *note A.12.1(7): 6572.
   <in> Ada.Text_IO   *note A.10.1(5): 6377.

Count_Type
   <in> Ada.Containers   *note A.18.1(5/2): 6717.

Country_Code
   <in> Ada.Locales   *note A.19(4/4): 7372.

CPU <subtype of> CPU_Range
   <in> System.Multiprocessors   *note D.16(4/3): 8073.

CPU_Range
   <in> System.Multiprocessors   *note D.16(4/3): 8071.

CPU_Set
   <in> System.Multiprocessors.Dispatching_Domains   *note
D.16.1(9.1/4): 8084.

CPU_Time
   <in> Ada.Execution_Time   *note D.14(4/2): 8000.

Cursor
   <in> Ada.Containers.Doubly_Linked_Lists   *note A.18.3(7/2): 6824.
   <in> Ada.Containers.Hashed_Maps   *note A.18.5(4/2): 6910.
   <in> Ada.Containers.Hashed_Sets   *note A.18.8(4/2): 7042.
   <in> Ada.Containers.Multiway_Trees   *note A.18.10(9/3): 7203.
   <in> Ada.Containers.Ordered_Maps   *note A.18.6(5/2): 6963.
   <in> Ada.Containers.Ordered_Sets   *note A.18.9(5/2): 7115.
   <in> Ada.Containers.Vectors   *note A.18.2(9/2): 6728.

Day_Count
   <in> Ada.Calendar.Arithmetic   *note 9.6.1(10/2): 4174.

Day_Duration <subtype of> Duration
   <in> Ada.Calendar   *note 9.6(11/2): 4150.

Day_Name
   <in> Ada.Calendar.Formatting   *note 9.6.1(17/2): 4178.

Day_Number <subtype of> Integer
   <in> Ada.Calendar   *note 9.6(11/2): 4149.

Deadline <subtype of> Time
   <in> Ada.Dispatching.EDF   *note D.2.6(9/2): 7822.

Decimal_Element
   <in> Interfaces.COBOL   *note B.4(12/3): 7552.

Direction
   <in> Ada.Strings   *note A.4.1(6): 5781.

Directory_Entry_Type
   <in> Ada.Directories   *note A.16(29/2): 6659.

Dispatching_Domain
   <in> System.Multiprocessors.Dispatching_Domains   *note D.16.1(5/3):
8079.

Display_Format
   <in> Interfaces.COBOL   *note B.4(22): 7563.

double
   <in> Interfaces.C   *note B.3(16): 7449.

Double_Precision
   <in> Interfaces.Fortran   *note B.5(6): 7602.

Duration
   <in> Standard   *note A.1(43): 5450.

Encoding_Scheme
   <in> Ada.Strings.UTF_Encoding   *note A.4.11(4/3): 6065.

Exception_Id
   <in> Ada.Exceptions   *note 11.4.1(2/2): 4565.

Exception_Occurrence
   <in> Ada.Exceptions   *note 11.4.1(3/2): 4570.

Exception_Occurrence_Access
   <in> Ada.Exceptions   *note 11.4.1(3/2): 4571.

Exit_Status
   <in> Ada.Command_Line   *note A.15(7): 6630.

Extended_Index <subtype of> Index_Type'Base
   <in> Ada.Containers.Vectors   *note A.18.2(7/2): 6725.

Field <subtype of> Integer
   <in> Ada.Text_IO   *note A.10.1(6): 6380.

File_Access
   <in> Ada.Text_IO   *note A.10.1(18): 6402.

File_Kind
   <in> Ada.Directories   *note A.16(22/2): 6653.

File_Mode
   <in> Ada.Direct_IO   *note A.8.4(4): 6325.
   <in> Ada.Sequential_IO   *note A.8.1(4): 6300.
   <in> Ada.Streams.Stream_IO   *note A.12.1(6): 6571.
   <in> Ada.Text_IO   *note A.10.1(4): 6376.

File_Size
   <in> Ada.Directories   *note A.16(23/2): 6654.

File_Type
   <in> Ada.Direct_IO   *note A.8.4(3): 6324.
   <in> Ada.Sequential_IO   *note A.8.1(3): 6299.
   <in> Ada.Streams.Stream_IO   *note A.12.1(5/4): 6570.
   <in> Ada.Text_IO   *note A.10.1(3): 6375.

Filter_Type
   <in> Ada.Directories   *note A.16(30/2): 6660.

Float
   <in> Standard   *note A.1(21): 5441.

Floating
   <in> Interfaces.COBOL   *note B.4(9): 7546.

Fortran_Character
   <in> Interfaces.Fortran   *note B.5(12/3): 7610.

Fortran_Integer
   <in> Interfaces.Fortran   *note B.5(5): 7600.

Forward_Iterator
   <in> Ada.Iterator_Interfaces   *note 5.5.1(3/3): 3210.

Generator
   <in> Ada.Numerics.Discrete_Random   *note A.5.2(19): 6161.
   <in> Ada.Numerics.Float_Random   *note A.5.2(7): 6148.

Group_Budget
   <in> Ada.Execution_Time.Group_Budgets   *note D.14.2(4/3): 8031.

Group_Budget_Handler
   <in> Ada.Execution_Time.Group_Budgets   *note D.14.2(5/2): 8032.

Hash_Type
   <in> Ada.Containers   *note A.18.1(4/2): 6716.

Holder
   <in> Ada.Containers.Indefinite_Holders   *note A.18.18(6/3): 7285.

Hour_Number <subtype of> Natural
   <in> Ada.Calendar.Formatting   *note 9.6.1(20/2): 4187.

Imaginary
   <in> Ada.Numerics.Generic_Complex_Types   *note G.1.1(4/2): 8260.

Imaginary <subtype of> Imaginary
   <in> Interfaces.Fortran   *note B.5(10): 7606.

int
   <in> Interfaces.C   *note B.3(7): 7437.

Integer
   <in> Standard   *note A.1(12): 5438.

Integer_Address
   <in> System.Storage_Elements   *note 13.7.1(10/3): 5138.

Interrupt_Id
   <in> Ada.Interrupts   *note C.3.2(2/3): 7660.

Interrupt_Priority <subtype of> Any_Priority
   <in> System   *note 13.7(16): 5129.

ISO_646 <subtype of> Character
   <in> Ada.Characters.Handling   *note A.3.2(9): 5483.

Language_Code
   <in> Ada.Locales   *note A.19(4/4): 7371.

Leap_Seconds_Count <subtype of> Integer
   <in> Ada.Calendar.Arithmetic   *note 9.6.1(11/2): 4175.

Length_Range <subtype of> Natural
   <in> Ada.Strings.Bounded   *note A.4.4(8): 5848.

Limited_Controlled
   <in> Ada.Finalization   *note 7.6(7/2): 3666.

List
   <in> Ada.Containers.Doubly_Linked_Lists   *note A.18.3(6/3): 6823.

Logical
   <in> Interfaces.Fortran   *note B.5(7): 7603.

long
   <in> Interfaces.C   *note B.3(7): 7439.

Long_Binary
   <in> Interfaces.COBOL   *note B.4(10): 7549.

long_double
   <in> Interfaces.C   *note B.3(17): 7450.

Long_Floating
   <in> Interfaces.COBOL   *note B.4(9): 7547.

Map
   <in> Ada.Containers.Hashed_Maps   *note A.18.5(3/3): 6909.
   <in> Ada.Containers.Ordered_Maps   *note A.18.6(4/3): 6962.

Membership
   <in> Ada.Strings   *note A.4.1(6): 5780.

Minute_Number <subtype of> Natural
   <in> Ada.Calendar.Formatting   *note 9.6.1(20/2): 4188.

Month_Number <subtype of> Integer
   <in> Ada.Calendar   *note 9.6(11/2): 4148.

Name
   <in> System   *note 13.7(4): 5106.

Name_Case_Kind
   <in> Ada.Directories   *note A.16(20.1/3): 6651.

Natural <subtype of> Integer
   <in> Standard   *note A.1(13): 5439.

Number_Base <subtype of> Integer
   <in> Ada.Text_IO   *note A.10.1(6): 6381.

Numeric
   <in> Interfaces.COBOL   *note B.4(20/3): 7562.

Packed_Decimal
   <in> Interfaces.COBOL   *note B.4(12/3): 7553.

Packed_Format
   <in> Interfaces.COBOL   *note B.4(26): 7573.

Parameterless_Handler
   <in> Ada.Interrupts   *note C.3.2(2/3): 7661.

Params_Stream_Type
   <in> System.RPC   *note E.5(6): 8207.

Partition_Id
   <in> System.RPC   *note E.5(4): 8205.

Picture
   <in> Ada.Text_IO.Editing   *note F.3.3(4): 8235.

plain_char
   <in> Interfaces.C   *note B.3(11): 7445.

Pointer
   <in> Interfaces.C.Pointers   *note B.3.2(5): 7519.

Positive <subtype of> Integer
   <in> Standard   *note A.1(13): 5440.

Positive_Count <subtype of> Count
   <in> Ada.Direct_IO   *note A.8.4(4): 6327.
   <in> Ada.Streams.Stream_IO   *note A.12.1(7): 6573.
   <in> Ada.Text_IO   *note A.10.1(5): 6378.

Priority <subtype of> Any_Priority
   <in> System   *note 13.7(16): 5128.

ptrdiff_t
   <in> Interfaces.C   *note B.3(12): 7446.

Queue
   <in> Ada.Containers.Bounded_Priority_Queues   *note A.18.31(4/3):
7363.
   <in> Ada.Containers.Bounded_Synchronized_Queues   *note A.18.29(4/3):
7350.
   <in> Ada.Containers.Synchronized_Queue_Interfaces   *note
A.18.27(4/3): 7337.
   <in> Ada.Containers.Unbounded_Priority_Queues   *note A.18.30(4/3):
7356.
   <in> Ada.Containers.Unbounded_Synchronized_Queues   *note
A.18.28(4/3): 7344.

Real
   <in> Interfaces.Fortran   *note B.5(6): 7601.

Real_Matrix
   <in> Ada.Numerics.Generic_Real_Arrays   *note G.3.1(4/2): 8372.

Real_Vector
   <in> Ada.Numerics.Generic_Real_Arrays   *note G.3.1(4/2): 8371.

Reference_Type
   <in> Ada.Containers.Doubly_Linked_Lists   *note A.18.3(17.2/3): 6836.
   <in> Ada.Containers.Hashed_Maps   *note A.18.5(17.2/3): 6925.
   <in> Ada.Containers.Hashed_Sets   *note A.18.8(58.1/3): 7096.
   <in> Ada.Containers.Indefinite_Holders   *note A.18.18(17/3): 7295.
   <in> Ada.Containers.Multiway_Trees   *note A.18.10(29/3): 7222.
   <in> Ada.Containers.Ordered_Maps   *note A.18.6(16.2/3): 6976.
   <in> Ada.Containers.Ordered_Sets   *note A.18.9(73.1/3): 7177.
   <in> Ada.Containers.Vectors   *note A.18.2(34.2/3): 6751.

Reversible_Iterator
   <in> Ada.Iterator_Interfaces   *note 5.5.1(4/3): 3213.

Root_Storage_Pool
   <in> System.Storage_Pools   *note 13.11(6/2): 5188.

Root_Storage_Pool_With_Subpools
   <in> System.Storage_Pools.Subpools   *note 13.11.4(4/3): 5257.

Root_Stream_Type
   <in> Ada.Streams   *note 13.13.1(3/2): 5335.

Root_Subpool
   <in> System.Storage_Pools.Subpools   *note 13.11.4(5/3): 5258.

RPC_Receiver
   <in> System.RPC   *note E.5(11): 8212.

Search_Type
   <in> Ada.Directories   *note A.16(31/2): 6661.

Second_Duration <subtype of> Day_Duration
   <in> Ada.Calendar.Formatting   *note 9.6.1(20/2): 4190.

Second_Number <subtype of> Natural
   <in> Ada.Calendar.Formatting   *note 9.6.1(20/2): 4189.

Seconds_Count
   <in> Ada.Real_Time   *note D.8(15): 7960.

Set
   <in> Ada.Containers.Hashed_Sets   *note A.18.8(3/3): 7041.
   <in> Ada.Containers.Ordered_Sets   *note A.18.9(4/3): 7114.

short
   <in> Interfaces.C   *note B.3(7): 7438.

signed_char
   <in> Interfaces.C   *note B.3(8): 7440.

size_t
   <in> Interfaces.C   *note B.3(13): 7447.

State
   <in> Ada.Numerics.Discrete_Random   *note A.5.2(23): 6165.
   <in> Ada.Numerics.Float_Random   *note A.5.2(11): 6153.

Storage_Array
   <in> System.Storage_Elements   *note 13.7.1(5): 5136.

Storage_Count <subtype of> Storage_Offset
   <in> System.Storage_Elements   *note 13.7.1(4): 5134.

Storage_Element
   <in> System.Storage_Elements   *note 13.7.1(5): 5135.

Storage_Offset
   <in> System.Storage_Elements   *note 13.7.1(3): 5133.

Stream_Access
   <in> Ada.Streams.Stream_IO   *note A.12.1(4): 6569.
   <in> Ada.Text_IO.Text_Streams   *note A.12.2(3): 6605.
   <in> Ada.Wide_Text_IO.Text_Streams   *note A.12.3(3): 6608.
   <in> Ada.Wide_Wide_Text_IO.Text_Streams   *note A.12.4(3/2): 6611.

Stream_Element
   <in> Ada.Streams   *note 13.13.1(4/1): 5336.

Stream_Element_Array
   <in> Ada.Streams   *note 13.13.1(4/1): 5339.

Stream_Element_Count <subtype of> Stream_Element_Offset
   <in> Ada.Streams   *note 13.13.1(4/1): 5338.

Stream_Element_Offset
   <in> Ada.Streams   *note 13.13.1(4/1): 5337.

String
   <in> Standard   *note A.1(37/3): 5447.

String_Access
   <in> Ada.Strings.Unbounded   *note A.4.5(7): 5906.

Subpool_Handle
   <in> System.Storage_Pools.Subpools   *note 13.11.4(6/3): 5259.

Suspension_Object
   <in> Ada.Synchronous_Task_Control   *note D.10(4): 7974.

Synchronous_Barrier
   <in> Ada.Synchronous_Barriers   *note D.10.1(5/3): 7986.

Tag
   <in> Ada.Tags   *note 3.9(6/2): 2101.

Tag_Array
   <in> Ada.Tags   *note 3.9(7.3/2): 2111.

Task_Array
   <in> Ada.Execution_Time.Group_Budgets   *note D.14.2(6/2): 8033.

Task_Id
   <in> Ada.Task_Identification   *note C.7.1(2/2): 7709.

Termination_Handler
   <in> Ada.Task_Termination   *note C.7.3(4/2): 7742.

Time
   <in> Ada.Calendar   *note 9.6(10): 4146.
   <in> Ada.Real_Time   *note D.8(4): 7942.

Time_Offset
   <in> Ada.Calendar.Time_Zones   *note 9.6.1(4/2): 4170.

Time_Span
   <in> Ada.Real_Time   *note D.8(5): 7946.

Timer
   <in> Ada.Execution_Time.Timers   *note D.14.1(4/2): 8016.

Timer_Handler
   <in> Ada.Execution_Time.Timers   *note D.14.1(5/2): 8017.

Timing_Event
   <in> Ada.Real_Time.Timing_Events   *note D.15(4/2): 8059.

Timing_Event_Handler
   <in> Ada.Real_Time.Timing_Events   *note D.15(4/2): 8060.

Tree
   <in> Ada.Containers.Multiway_Trees   *note A.18.10(8/3): 7202.

Trim_End
   <in> Ada.Strings   *note A.4.1(6): 5782.

Truncation
   <in> Ada.Strings   *note A.4.1(6): 5779.

Type_Set
   <in> Ada.Text_IO   *note A.10.1(7): 6382.

Unbounded_String
   <in> Ada.Strings.Unbounded   *note A.4.5(4/2): 5903.

Uniformly_Distributed <subtype of> Float
   <in> Ada.Numerics.Float_Random   *note A.5.2(8): 6149.

unsigned
   <in> Interfaces.C   *note B.3(9): 7441.

unsigned_char
   <in> Interfaces.C   *note B.3(10): 7444.

unsigned_long
   <in> Interfaces.C   *note B.3(9): 7443.

unsigned_short
   <in> Interfaces.C   *note B.3(9): 7442.

UTF_16_Wide_String <subtype of> Wide_String
   <in> Ada.Strings.UTF_Encoding   *note A.4.11(7/3): 6068.

UTF_8_String <subtype of> String
   <in> Ada.Strings.UTF_Encoding   *note A.4.11(6/3): 6067.

UTF_String <subtype of> String
   <in> Ada.Strings.UTF_Encoding   *note A.4.11(5/3): 6066.

Vector
   <in> Ada.Containers.Vectors   *note A.18.2(8/3): 6727.

wchar_array
   <in> Interfaces.C   *note B.3(33/3): 7465.

wchar_t
   <in> Interfaces.C   *note B.3(30/1): 7461.

Wide_Character
   <in> Standard   *note A.1(36.1/3): 5443.

Wide_Character_Mapping
   <in> Ada.Strings.Wide_Maps   *note A.4.7(20/2): 5999.

Wide_Character_Mapping_Function
   <in> Ada.Strings.Wide_Maps   *note A.4.7(26): 6005.

Wide_Character_Range
   <in> Ada.Strings.Wide_Maps   *note A.4.7(6): 5988.

Wide_Character_Ranges
   <in> Ada.Strings.Wide_Maps   *note A.4.7(7): 5989.

Wide_Character_Sequence <subtype of> Wide_String
   <in> Ada.Strings.Wide_Maps   *note A.4.7(16): 5995.

Wide_Character_Set
   <in> Ada.Strings.Wide_Maps   *note A.4.7(4/2): 5986.

Wide_String
   <in> Standard   *note A.1(41/3): 5448.

Wide_Wide_Character
   <in> Standard   *note A.1(36.2/3): 5444.

Wide_Wide_Character_Mapping
   <in> Ada.Strings.Wide_Wide_Maps   *note A.4.8(20/2): 6038.

Wide_Wide_Character_Mapping_Function
   <in> Ada.Strings.Wide_Wide_Maps   *note A.4.8(26/2): 6044.

Wide_Wide_Character_Range
   <in> Ada.Strings.Wide_Wide_Maps   *note A.4.8(6/2): 6027.

Wide_Wide_Character_Ranges
   <in> Ada.Strings.Wide_Wide_Maps   *note A.4.8(7/2): 6028.

Wide_Wide_Character_Sequence <subtype of> Wide_Wide_String
   <in> Ada.Strings.Wide_Wide_Maps   *note A.4.8(16/2): 6034.

Wide_Wide_Character_Set
   <in> Ada.Strings.Wide_Wide_Maps   *note A.4.8(4/2): 6025.

Wide_Wide_String
   <in> Standard   *note A.1(42.1/3): 5449.

Year_Number <subtype of> Integer
   <in> Ada.Calendar   *note 9.6(11/2): 4147.


File: arm2012.info,  Node: Q.3,  Next: Q.4,  Prev: Q.2,  Up: Annex Q

Q.3 Language-Defined Subprograms
================================

1/3
This subclause lists all language-defined subprograms.

 

Abort_Task <in> Ada.Task_Identification   *note C.7.1(3/3): 7714.

Activation_Is_Complete
   <in> Ada.Task_Identification   *note C.7.1(4/3): 7717.

Actual_Quantum
   <in> Ada.Dispatching.Round_Robin   *note D.2.5(4/2): 7817.

Ada.Unchecked_Deallocate_Subpool
   <child of> Ada   *note 13.11.5(3/3): 5287.

Add
   <in> Ada.Execution_Time.Group_Budgets   *note D.14.2(9/2): 8041.

Add_Task
   <in> Ada.Execution_Time.Group_Budgets   *note D.14.2(8/2): 8035.

Adjust <in> Ada.Finalization   *note 7.6(6/2): 3664.

Allocate
   <in> System.Storage_Pools   *note 13.11(7): 5189.
   <in> System.Storage_Pools.Subpools   *note 13.11.4(14/3): 5266.

Allocate_From_Subpool
   <in> System.Storage_Pools.Subpools   *note 13.11.4(11/3): 5263.

Ancestor_Find
   <in> Ada.Containers.Multiway_Trees   *note A.18.10(40/3): 7233.

Append
   <in> Ada.Containers.Doubly_Linked_Lists   *note A.18.3(23/2): 6846.
   <in> Ada.Containers.Vectors   *note A.18.2(46/2): 6769, *note
A.18.2(47/2): 6770.
   <in> Ada.Strings.Bounded   *note A.4.4(13): 5853, *note A.4.4(14):
5854, *note A.4.4(15): 5855, *note A.4.4(16): 5856, *note A.4.4(17):
5857, *note A.4.4(18): 5858, *note A.4.4(19): 5859, *note A.4.4(20):
5860.
   <in> Ada.Strings.Unbounded   *note A.4.5(12): 5912, *note A.4.5(13):
5913, *note A.4.5(14): 5914.

Append_Child
   <in> Ada.Containers.Multiway_Trees   *note A.18.10(52/3): 7245.

Arccos
   <in> Ada.Numerics.Generic_Complex_Elementary_Functions   *note
G.1.2(5): 8295.
   <in> Ada.Numerics.Generic_Elementary_Functions   *note A.5.1(6):
6125.

Arccosh
   <in> Ada.Numerics.Generic_Complex_Elementary_Functions   *note
G.1.2(7): 8303.
   <in> Ada.Numerics.Generic_Elementary_Functions   *note A.5.1(7):
6136.

Arccot
   <in> Ada.Numerics.Generic_Complex_Elementary_Functions   *note
G.1.2(5): 8297.
   <in> Ada.Numerics.Generic_Elementary_Functions   *note A.5.1(6):
6130.

Arccoth
   <in> Ada.Numerics.Generic_Complex_Elementary_Functions   *note
G.1.2(7): 8305.
   <in> Ada.Numerics.Generic_Elementary_Functions   *note A.5.1(7):
6138.

Arcsin
   <in> Ada.Numerics.Generic_Complex_Elementary_Functions   *note
G.1.2(5): 8294.
   <in> Ada.Numerics.Generic_Elementary_Functions   *note A.5.1(6):
6124.

Arcsinh
   <in> Ada.Numerics.Generic_Complex_Elementary_Functions   *note
G.1.2(7): 8302.
   <in> Ada.Numerics.Generic_Elementary_Functions   *note A.5.1(7):
6135.

Arctan
   <in> Ada.Numerics.Generic_Complex_Elementary_Functions   *note
G.1.2(5): 8296.
   <in> Ada.Numerics.Generic_Elementary_Functions   *note A.5.1(6):
6128.

Arctanh
   <in> Ada.Numerics.Generic_Complex_Elementary_Functions   *note
G.1.2(7): 8304.
   <in> Ada.Numerics.Generic_Elementary_Functions   *note A.5.1(7):
6137.

Argument
   <in> Ada.Command_Line   *note A.15(5): 6628.
   <in> Ada.Numerics.Generic_Complex_Arrays   *note G.3.2(10/2): 8397,
*note G.3.2(31/2): 8409.
   <in> Ada.Numerics.Generic_Complex_Types   *note G.1.1(10): 8273.

Argument_Count <in> Ada.Command_Line   *note A.15(4): 6627.

Assert <in> Ada.Assertions   *note 11.4.2(14/2): 4606.

Assign
   <in> Ada.Containers.Doubly_Linked_Lists   *note A.18.3(17.5/3): 6839.
   <in> Ada.Containers.Hashed_Maps   *note A.18.5(17.7/3): 6930.
   <in> Ada.Containers.Hashed_Sets   *note A.18.8(17.3/3): 7058.
   <in> Ada.Containers.Indefinite_Holders   *note A.18.18(20/3): 7298.
   <in> Ada.Containers.Multiway_Trees   *note A.18.10(32/3): 7225.
   <in> Ada.Containers.Ordered_Maps   *note A.18.6(16.7/3): 6981.
   <in> Ada.Containers.Ordered_Sets   *note A.18.9(16.3/3): 7129.
   <in> Ada.Containers.Vectors   *note A.18.2(34.7/3): 6756.

Assign_Task
   <in> System.Multiprocessors.Dispatching_Domains   *note D.16.1(11/3):
8088.

Attach_Handler <in> Ada.Interrupts   *note C.3.2(7): 7665.

Base_Name <in> Ada.Directories   *note A.16(19/2): 6649.

Blank_When_Zero
   <in> Ada.Text_IO.Editing   *note F.3.3(7): 8239.

Bounded_Slice <in> Ada.Strings.Bounded   *note A.4.4(28.1/2): 5864,
*note A.4.4(28.2/2): 5865.

Budget_Has_Expired
   <in> Ada.Execution_Time.Group_Budgets   *note D.14.2(9/2): 8042.

Budget_Remaining
   <in> Ada.Execution_Time.Group_Budgets   *note D.14.2(9/2): 8043.

Cancel_Handler
   <in> Ada.Execution_Time.Group_Budgets   *note D.14.2(10/2): 8046.
   <in> Ada.Execution_Time.Timers   *note D.14.1(7/2): 8022.
   <in> Ada.Real_Time.Timing_Events   *note D.15(5/2): 8064.

Capacity
   <in> Ada.Containers.Hashed_Maps   *note A.18.5(8/2): 6915.
   <in> Ada.Containers.Hashed_Sets   *note A.18.8(10/2): 7049.
   <in> Ada.Containers.Vectors   *note A.18.2(19/2): 6735.

Ceiling
   <in> Ada.Containers.Ordered_Maps   *note A.18.6(41/2): 7007.
   <in> Ada.Containers.Ordered_Sets   *note A.18.9(51/2): 7161, *note
A.18.9(71/2): 7174.

Character_Set_Version
   <in> Ada.Wide_Characters.Handling   *note A.3.5(4/3): 5749.

Child_Count
   <in> Ada.Containers.Multiway_Trees   *note A.18.10(46/3): 7239.

Child_Depth
   <in> Ada.Containers.Multiway_Trees   *note A.18.10(47/3): 7240.

Clear
   <in> Ada.Containers.Doubly_Linked_Lists   *note A.18.3(13/2): 6831.
   <in> Ada.Containers.Hashed_Maps   *note A.18.5(12/2): 6919.
   <in> Ada.Containers.Hashed_Sets   *note A.18.8(14/2): 7053.
   <in> Ada.Containers.Indefinite_Holders   *note A.18.18(11/3): 7289.
   <in> Ada.Containers.Multiway_Trees   *note A.18.10(23/3): 7216.
   <in> Ada.Containers.Ordered_Maps   *note A.18.6(11/2): 6970.
   <in> Ada.Containers.Ordered_Sets   *note A.18.9(13/2): 7124.
   <in> Ada.Containers.Vectors   *note A.18.2(24/2): 6740.
   <in> Ada.Environment_Variables   *note A.17(7/2): 6704.

Clock
   <in> Ada.Calendar   *note 9.6(12): 4151.
   <in> Ada.Execution_Time   *note D.14(5/2): 8005.
   <in> Ada.Execution_Time.Interrupts   *note D.14.3(3/3): 8056.
   <in> Ada.Real_Time   *note D.8(6): 7952.

Clock_For_Interrupts
   <in> Ada.Execution_Time   *note D.14(9.3/3): 8010.

Close
   <in> Ada.Direct_IO   *note A.8.4(8): 6330.
   <in> Ada.Sequential_IO   *note A.8.1(8): 6303.
   <in> Ada.Streams.Stream_IO   *note A.12.1(10): 6576.
   <in> Ada.Text_IO   *note A.10.1(11): 6385.

Col <in> Ada.Text_IO   *note A.10.1(37): 6438.

Command_Name <in> Ada.Command_Line   *note A.15(6): 6629.

Compose
   <in> Ada.Directories   *note A.16(20/2): 6650.
   <in> Ada.Directories.Hierarchical_File_Names   *note A.16.1(14/3):
6697.

Compose_From_Cartesian
   <in> Ada.Numerics.Generic_Complex_Arrays   *note G.3.2(9/2): 8394,
*note G.3.2(29/2): 8406.
   <in> Ada.Numerics.Generic_Complex_Types   *note G.1.1(8): 8270.

Compose_From_Polar
   <in> Ada.Numerics.Generic_Complex_Arrays   *note G.3.2(11/2): 8398,
*note G.3.2(32/2): 8411.
   <in> Ada.Numerics.Generic_Complex_Types   *note G.1.1(11): 8275.

Conjugate
   <in> Ada.Numerics.Generic_Complex_Arrays   *note G.3.2(13/2): 8400,
*note G.3.2(34/2): 8413.
   <in> Ada.Numerics.Generic_Complex_Types   *note G.1.1(12): 8277,
*note G.1.1(15): 8278.

Constant_Reference
   <in> Ada.Containers.Doubly_Linked_Lists   *note A.18.3(17.3/3): 6837.
   <in> Ada.Containers.Hashed_Maps   *note A.18.5(17.3/3): 6926, *note
A.18.5(17.5/3): 6928.
   <in> Ada.Containers.Hashed_Sets   *note A.18.8(17.2/3): 7057, *note
A.18.8(58.3/3): 7098.
   <in> Ada.Containers.Indefinite_Holders   *note A.18.18(18/3): 7296.
   <in> Ada.Containers.Multiway_Trees   *note A.18.10(30/3): 7223.
   <in> Ada.Containers.Ordered_Maps   *note A.18.6(16.3/3): 6977, *note
A.18.6(16.5/3): 6979.
   <in> Ada.Containers.Ordered_Sets   *note A.18.9(16.2/3): 7128, *note
A.18.9(73.3/3): 7179.
   <in> Ada.Containers.Vectors   *note A.18.2(34.3/3): 6752, *note
A.18.2(34.5/3): 6754.

Containing_Directory
   <in> Ada.Directories   *note A.16(17/2): 6647.
   <in> Ada.Directories.Hierarchical_File_Names   *note A.16.1(11/3):
6694.

Contains
   <in> Ada.Containers.Doubly_Linked_Lists   *note A.18.3(43/2): 6866.
   <in> Ada.Containers.Hashed_Maps   *note A.18.5(32/2): 6946.
   <in> Ada.Containers.Hashed_Sets   *note A.18.8(44/2): 7082, *note
A.18.8(57/2): 7094.
   <in> Ada.Containers.Multiway_Trees   *note A.18.10(41/3): 7234.
   <in> Ada.Containers.Ordered_Maps   *note A.18.6(42/2): 7008.
   <in> Ada.Containers.Ordered_Sets   *note A.18.9(52/2): 7162, *note
A.18.9(72/2): 7175.
   <in> Ada.Containers.Vectors   *note A.18.2(71/2): 6794.

Continue
   <in> Ada.Asynchronous_Task_Control   *note D.11(3/2): 7990.

Convert
   <in> Ada.Strings.UTF_Encoding.Conversions   *note A.4.11(16/3): 6076,
*note A.4.11(17/3): 6077, *note A.4.11(18/3): 6078, *note A.4.11(19/3):
6079, *note A.4.11(20/3): 6080.

Copy
   <in> Ada.Containers.Doubly_Linked_Lists   *note A.18.3(17.6/3): 6840.
   <in> Ada.Containers.Hashed_Maps   *note A.18.5(17.8/3): 6931.
   <in> Ada.Containers.Hashed_Sets   *note A.18.8(17.4/3): 7059.
   <in> Ada.Containers.Indefinite_Holders   *note A.18.18(21/3): 7299,
*note A.18.20(10/3): 7311, *note A.18.21(13/3): 7315, *note
A.18.22(10/3): 7318, *note A.18.23(13/3): 7322, *note A.18.24(10/3):
7325.
   <in> Ada.Containers.Multiway_Trees   *note A.18.10(33/3): 7226.
   <in> Ada.Containers.Ordered_Maps   *note A.18.6(16.8/3): 6982.
   <in> Ada.Containers.Ordered_Sets   *note A.18.9(16.4/3): 7130.
   <in> Ada.Containers.Vectors   *note A.18.2(34.8/3): 6757.

Copy_Array <in> Interfaces.C.Pointers   *note B.3.2(15): 7527.

Copy_File <in> Ada.Directories   *note A.16(13/2): 6644.

Copy_Subtree
   <in> Ada.Containers.Multiway_Trees   *note A.18.10(54/3): 7247.

Copy_Terminated_Array
   <in> Interfaces.C.Pointers   *note B.3.2(14): 7526.

Cos
   <in> Ada.Numerics.Generic_Complex_Elementary_Functions   *note
G.1.2(4): 8291.
   <in> Ada.Numerics.Generic_Elementary_Functions   *note A.5.1(5):
6117.

Cosh
   <in> Ada.Numerics.Generic_Complex_Elementary_Functions   *note
G.1.2(6): 8299.
   <in> Ada.Numerics.Generic_Elementary_Functions   *note A.5.1(7):
6132.

Cot
   <in> Ada.Numerics.Generic_Complex_Elementary_Functions   *note
G.1.2(4): 8293.
   <in> Ada.Numerics.Generic_Elementary_Functions   *note A.5.1(5):
6121.

Coth
   <in> Ada.Numerics.Generic_Complex_Elementary_Functions   *note
G.1.2(6): 8301.
   <in> Ada.Numerics.Generic_Elementary_Functions   *note A.5.1(7):
6134.

Count
   <in> Ada.Strings.Bounded   *note A.4.4(48): 5874, *note A.4.4(49):
5875, *note A.4.4(50): 5876.
   <in> Ada.Strings.Fixed   *note A.4.3(13): 5817, *note A.4.3(14):
5818, *note A.4.3(15): 5819.
   <in> Ada.Strings.Unbounded   *note A.4.5(43): 5928, *note A.4.5(44):
5929, *note A.4.5(45): 5930.

Country <in> Ada.Locales   *note A.19(6/3): 7376.

Create
   <in> Ada.Direct_IO   *note A.8.4(6): 6328.
   <in> Ada.Sequential_IO   *note A.8.1(6): 6301.
   <in> Ada.Streams.Stream_IO   *note A.12.1(8): 6574.
   <in> Ada.Text_IO   *note A.10.1(9): 6383.
   <in> System.Multiprocessors.Dispatching_Domains   *note D.16.1(7/4):
8081, *note D.16.1(9.2/4): 8085.

Create_Directory <in> Ada.Directories   *note A.16(7/2): 6638.

Create_Path <in> Ada.Directories   *note A.16(9/2): 6640.

Create_Subpool
   <in> System.Storage_Pools.Subpools   *note 13.11.4(7/3): 5260.

Current_Directory <in> Ada.Directories   *note A.16(5/2): 6636.

Current_Error <in> Ada.Text_IO   *note A.10.1(17): 6401, *note
A.10.1(20): 6408.

Current_Handler
   <in> Ada.Execution_Time.Group_Budgets   *note D.14.2(10/2): 8045.
   <in> Ada.Execution_Time.Timers   *note D.14.1(7/2): 8021.
   <in> Ada.Interrupts   *note C.3.2(6): 7664.
   <in> Ada.Real_Time.Timing_Events   *note D.15(5/2): 8063.

Current_Input <in> Ada.Text_IO   *note A.10.1(17): 6399, *note
A.10.1(20): 6406.

Current_Output <in> Ada.Text_IO   *note A.10.1(17): 6400, *note
A.10.1(20): 6407.

Current_State
   <in> Ada.Synchronous_Task_Control   *note D.10(4): 7977.

Current_Task
   <in> Ada.Task_Identification   *note C.7.1(3/3): 7712.

Current_Task_Fallback_Handler
   <in> Ada.Task_Termination   *note C.7.3(5/2): 7744.

Current_Use
   <in> Ada.Containers.Bounded_Priority_Queues   *note A.18.31(7/3):
7367.
   <in> Ada.Containers.Bounded_Synchronized_Queues   *note A.18.29(6/3):
7353.
   <in> Ada.Containers.Synchronized_Queue_Interfaces   *note
A.18.27(7/3): 7340.
   <in> Ada.Containers.Unbounded_Priority_Queues   *note A.18.30(7/3):
7360.
   <in> Ada.Containers.Unbounded_Synchronized_Queues   *note
A.18.28(6/3): 7347.

Day
   <in> Ada.Calendar   *note 9.6(13): 4154.
   <in> Ada.Calendar.Formatting   *note 9.6.1(23/2): 4193.

Day_of_Week
   <in> Ada.Calendar.Formatting   *note 9.6.1(18/2): 4186.

Deallocate
   <in> System.Storage_Pools   *note 13.11(8): 5190.
   <in> System.Storage_Pools.Subpools   *note 13.11.4(15/3): 5267.

Deallocate_Subpool
   <in> System.Storage_Pools.Subpools   *note 13.11.4(12/3): 5264.

Decode
   <in> Ada.Strings.UTF_Encoding.Strings   *note A.4.11(26/3): 6085,
*note A.4.11(27/3): 6086, *note A.4.11(28/3): 6087.
   <in> Ada.Strings.UTF_Encoding.Wide_Strings   *note A.4.11(34/3):
6092, *note A.4.11(35/3): 6093, *note A.4.11(36/3): 6094.
   <in> Ada.Strings.UTF_Encoding.Wide_Wide_Strings   *note A.4.11(42/3):
6099, *note A.4.11(43/3): 6100, *note A.4.11(44/3): 6101.

Decrement <in> Interfaces.C.Pointers   *note B.3.2(11/3): 7524.

Default_Modulus
   <in> Ada.Containers.Indefinite_Holders   *note A.18.21(10/3): 7314,
*note A.18.23(10/3): 7321.

Default_Subpool_for_Pool
   <in> System.Storage_Pools.Subpools   *note 13.11.4(13/3): 5265.

Delay_Until_And_Set_CPU
   <in> System.Multiprocessors.Dispatching_Domains   *note D.16.1(14/3):
8091.

Delay_Until_And_Set_Deadline
   <in> Ada.Dispatching.EDF   *note D.2.6(9/2): 7825.

Delete
   <in> Ada.Containers.Doubly_Linked_Lists   *note A.18.3(24/2): 6847.
   <in> Ada.Containers.Hashed_Maps   *note A.18.5(25/2): 6939, *note
A.18.5(26/2): 6940.
   <in> Ada.Containers.Hashed_Sets   *note A.18.8(24/2): 7066, *note
A.18.8(25/2): 7067, *note A.18.8(55/2): 7092.
   <in> Ada.Containers.Ordered_Maps   *note A.18.6(24/2): 6990, *note
A.18.6(25/2): 6991.
   <in> Ada.Containers.Ordered_Sets   *note A.18.9(23/2): 7137, *note
A.18.9(24/2): 7138, *note A.18.9(68/2): 7171.
   <in> Ada.Containers.Vectors   *note A.18.2(50/2): 6773, *note
A.18.2(51/2): 6774.
   <in> Ada.Direct_IO   *note A.8.4(8): 6331.
   <in> Ada.Sequential_IO   *note A.8.1(8): 6304.
   <in> Ada.Streams.Stream_IO   *note A.12.1(10): 6577.
   <in> Ada.Strings.Bounded   *note A.4.4(64): 5889, *note A.4.4(65):
5890.
   <in> Ada.Strings.Fixed   *note A.4.3(29): 5832, *note A.4.3(30):
5833.
   <in> Ada.Strings.Unbounded   *note A.4.5(59): 5943, *note A.4.5(60):
5944.
   <in> Ada.Text_IO   *note A.10.1(11): 6386.

Delete_Children
   <in> Ada.Containers.Multiway_Trees   *note A.18.10(53/3): 7246.

Delete_Directory <in> Ada.Directories   *note A.16(8/2): 6639.

Delete_File <in> Ada.Directories   *note A.16(11/2): 6642.

Delete_First
   <in> Ada.Containers.Doubly_Linked_Lists   *note A.18.3(25/2): 6848.
   <in> Ada.Containers.Ordered_Maps   *note A.18.6(26/2): 6992.
   <in> Ada.Containers.Ordered_Sets   *note A.18.9(25/2): 7139.
   <in> Ada.Containers.Vectors   *note A.18.2(52/2): 6775.

Delete_Last
   <in> Ada.Containers.Doubly_Linked_Lists   *note A.18.3(26/2): 6849.
   <in> Ada.Containers.Ordered_Maps   *note A.18.6(27/2): 6993.
   <in> Ada.Containers.Ordered_Sets   *note A.18.9(26/2): 7140.
   <in> Ada.Containers.Vectors   *note A.18.2(53/2): 6776.

Delete_Leaf
   <in> Ada.Containers.Multiway_Trees   *note A.18.10(35/3): 7228.

Delete_Subtree
   <in> Ada.Containers.Multiway_Trees   *note A.18.10(36/3): 7229.

Delete_Tree <in> Ada.Directories   *note A.16(10/2): 6641.

Depth
   <in> Ada.Containers.Multiway_Trees   *note A.18.10(19/3): 7212.

Dequeue
   <in> Ada.Containers.Bounded_Priority_Queues   *note A.18.31(5/3):
7365.
   <in> Ada.Containers.Bounded_Synchronized_Queues   *note A.18.29(5/3):
7352.
   <in> Ada.Containers.Synchronized_Queue_Interfaces   *note
A.18.27(6/3): 7339.
   <in> Ada.Containers.Unbounded_Priority_Queues   *note A.18.30(5/3):
7358.
   <in> Ada.Containers.Unbounded_Synchronized_Queues   *note
A.18.28(5/3): 7346.

Dequeue_Only_High_Priority
   <in> Ada.Containers.Bounded_Priority_Queues   *note A.18.31(6/3):
7366.
   <in> Ada.Containers.Unbounded_Priority_Queues   *note A.18.30(6/3):
7359.

Dereference_Error
   <in> Interfaces.C.Strings   *note B.3.1(12): 7505.

Descendant_Tag <in> Ada.Tags   *note 3.9(7.1/2): 2108.

Detach_Handler <in> Ada.Interrupts   *note C.3.2(9): 7667.

Determinant
   <in> Ada.Numerics.Generic_Complex_Arrays   *note G.3.2(46/2): 8418.
   <in> Ada.Numerics.Generic_Real_Arrays   *note G.3.1(24/2): 8378.

Difference
   <in> Ada.Calendar.Arithmetic   *note 9.6.1(12/2): 4176.
   <in> Ada.Containers.Hashed_Sets   *note A.18.8(32/2): 7072, *note
A.18.8(33/2): 7073.
   <in> Ada.Containers.Ordered_Sets   *note A.18.9(33/2): 7145, *note
A.18.9(34/2): 7146.

Divide <in> Ada.Decimal   *note F.2(6/3): 8229.

Do_APC <in> System.RPC   *note E.5(10): 8211.

Do_RPC <in> System.RPC   *note E.5(9): 8210.

Eigensystem
   <in> Ada.Numerics.Generic_Complex_Arrays   *note G.3.2(49/2): 8420.
   <in> Ada.Numerics.Generic_Real_Arrays   *note G.3.1(27/2): 8380.

Eigenvalues
   <in> Ada.Numerics.Generic_Complex_Arrays   *note G.3.2(48/2): 8419.
   <in> Ada.Numerics.Generic_Real_Arrays   *note G.3.1(26/2): 8379.

Element
   <in> Ada.Containers.Doubly_Linked_Lists   *note A.18.3(14/2): 6832.
   <in> Ada.Containers.Hashed_Maps   *note A.18.5(14/2): 6921, *note
A.18.5(31/2): 6945.
   <in> Ada.Containers.Hashed_Sets   *note A.18.8(15/2): 7054, *note
A.18.8(52/2): 7089.
   <in> Ada.Containers.Indefinite_Holders   *note A.18.18(12/3): 7290.
   <in> Ada.Containers.Multiway_Trees   *note A.18.10(24/3): 7217.
   <in> Ada.Containers.Ordered_Maps   *note A.18.6(13/2): 6972, *note
A.18.6(39/2): 7005.
   <in> Ada.Containers.Ordered_Sets   *note A.18.9(14/2): 7125, *note
A.18.9(65/2): 7168.
   <in> Ada.Containers.Vectors   *note A.18.2(27/2): 6743, *note
A.18.2(28/2): 6744.
   <in> Ada.Strings.Bounded   *note A.4.4(26): 5861.
   <in> Ada.Strings.Unbounded   *note A.4.5(20): 5915.

Encode
   <in> Ada.Strings.UTF_Encoding.Strings   *note A.4.11(23/3): 6082,
*note A.4.11(24/3): 6083, *note A.4.11(25/3): 6084.
   <in> Ada.Strings.UTF_Encoding.Wide_Strings   *note A.4.11(31/3):
6089, *note A.4.11(32/3): 6090, *note A.4.11(33/3): 6091.
   <in> Ada.Strings.UTF_Encoding.Wide_Wide_Strings   *note A.4.11(39/3):
6096, *note A.4.11(40/3): 6097, *note A.4.11(41/3): 6098.

Encoding <in> Ada.Strings.UTF_Encoding   *note A.4.11(13/3): 6074.

End_Of_File
   <in> Ada.Direct_IO   *note A.8.4(16): 6346.
   <in> Ada.Sequential_IO   *note A.8.1(13): 6314.
   <in> Ada.Streams.Stream_IO   *note A.12.1(12): 6584.
   <in> Ada.Text_IO   *note A.10.1(34): 6431.

End_Of_Line <in> Ada.Text_IO   *note A.10.1(30): 6424.

End_Of_Page <in> Ada.Text_IO   *note A.10.1(33): 6430.

End_Search <in> Ada.Directories   *note A.16(33/2): 6663.

Enqueue
   <in> Ada.Containers.Bounded_Priority_Queues   *note A.18.31(5/3):
7364.
   <in> Ada.Containers.Bounded_Synchronized_Queues   *note A.18.29(5/3):
7351.
   <in> Ada.Containers.Synchronized_Queue_Interfaces   *note
A.18.27(5/3): 7338.
   <in> Ada.Containers.Unbounded_Priority_Queues   *note A.18.30(5/3):
7357.
   <in> Ada.Containers.Unbounded_Synchronized_Queues   *note
A.18.28(5/3): 7345.

Environment_Task
   <in> Ada.Task_Identification   *note C.7.1(3/3): 7713.

Equal_Case_Insensitive
   <child of> Ada.Strings   *note A.4.10(2/3): 6056.
   <child of> Ada.Strings.Bounded   *note A.4.10(7/3): 6058.
   <child of> Ada.Strings.Fixed   *note A.4.10(5/3): 6057.
   <child of> Ada.Strings.Unbounded   *note A.4.10(10/3): 6059.

Equal_Subtree
   <in> Ada.Containers.Multiway_Trees   *note A.18.10(14/3): 7208.

Equivalent_Elements
   <in> Ada.Containers.Hashed_Sets   *note A.18.8(46/2): 7083, *note
A.18.8(47/2): 7084, *note A.18.8(48/2): 7085.
   <in> Ada.Containers.Ordered_Sets   *note A.18.9(3/2): 7113.

Equivalent_Keys
   <in> Ada.Containers.Hashed_Maps   *note A.18.5(34/2): 6947, *note
A.18.5(35/2): 6948, *note A.18.5(36/2): 6949.
   <in> Ada.Containers.Ordered_Maps   *note A.18.6(3/2): 6961.
   <in> Ada.Containers.Ordered_Sets   *note A.18.9(63/2): 7166.

Equivalent_Sets
   <in> Ada.Containers.Hashed_Sets   *note A.18.8(8/2): 7047.
   <in> Ada.Containers.Ordered_Sets   *note A.18.9(9/2): 7120.

Establish_RPC_Receiver <in> System.RPC   *note E.5(12): 8213.

Exception_Identity <in> Ada.Exceptions   *note 11.4.1(5/2): 4576.

Exception_Information
   <in> Ada.Exceptions   *note 11.4.1(5/2): 4580.

Exception_Message <in> Ada.Exceptions   *note 11.4.1(4/3): 4574.

Exception_Name <in> Ada.Exceptions   *note 11.4.1(2/2): 4567, *note
11.4.1(5/2): 4577.

Exchange_Handler <in> Ada.Interrupts   *note C.3.2(8): 7666.

Exclude
   <in> Ada.Containers.Hashed_Maps   *note A.18.5(24/2): 6938.
   <in> Ada.Containers.Hashed_Sets   *note A.18.8(23/2): 7065, *note
A.18.8(54/2): 7091.
   <in> Ada.Containers.Ordered_Maps   *note A.18.6(23/2): 6989.
   <in> Ada.Containers.Ordered_Sets   *note A.18.9(22/2): 7136, *note
A.18.9(67/2): 7170.

Exists
   <in> Ada.Directories   *note A.16(24/2): 6655.
   <in> Ada.Environment_Variables   *note A.17(5/2): 6702.

Exp
   <in> Ada.Numerics.Generic_Complex_Elementary_Functions   *note
G.1.2(3): 8288.
   <in> Ada.Numerics.Generic_Elementary_Functions   *note A.5.1(4):
6114.

Expanded_Name <in> Ada.Tags   *note 3.9(7/2): 2103.

Extension <in> Ada.Directories   *note A.16(18/2): 6648.

External_Tag <in> Ada.Tags   *note 3.9(7/2): 2106.

Finalize <in> Ada.Finalization   *note 7.6(6/2): 3665, *note 7.6(8/2):
3668.

Find
   <in> Ada.Containers.Doubly_Linked_Lists   *note A.18.3(41/2): 6864.
   <in> Ada.Containers.Hashed_Maps   *note A.18.5(30/2): 6944.
   <in> Ada.Containers.Hashed_Sets   *note A.18.8(43/2): 7081, *note
A.18.8(56/2): 7093.
   <in> Ada.Containers.Multiway_Trees   *note A.18.10(38/3): 7231.
   <in> Ada.Containers.Ordered_Maps   *note A.18.6(38/2): 7004.
   <in> Ada.Containers.Ordered_Sets   *note A.18.9(49/2): 7159, *note
A.18.9(69/2): 7172.
   <in> Ada.Containers.Vectors   *note A.18.2(68/2): 6791.

Find_In_Subtree
   <in> Ada.Containers.Multiway_Trees   *note A.18.10(39/3): 7232.

Find_Index <in> Ada.Containers.Vectors   *note A.18.2(67/2): 6790.

Find_Token
   <in> Ada.Strings.Bounded   *note A.4.4(50.1/3): 5877, *note
A.4.4(51): 5878.
   <in> Ada.Strings.Fixed   *note A.4.3(15.1/3): 5820, *note A.4.3(16):
5821.
   <in> Ada.Strings.Unbounded   *note A.4.5(45.1/3): 5931, *note
A.4.5(46): 5932.

First
   <in> Ada.Containers.Doubly_Linked_Lists   *note A.18.3(33/2): 6856.
   <in> Ada.Containers.Hashed_Maps   *note A.18.5(27/2): 6941.
   <in> Ada.Containers.Hashed_Sets   *note A.18.8(40/2): 7078.
   <in> Ada.Containers.Ordered_Maps   *note A.18.6(28/2): 6994.
   <in> Ada.Containers.Ordered_Sets   *note A.18.9(41/2): 7151.
   <in> Ada.Containers.Vectors   *note A.18.2(58/2): 6781.
   <in> Ada.Iterator_Interfaces   *note 5.5.1(3/3): 3211.

First_Child
   <in> Ada.Containers.Multiway_Trees   *note A.18.10(60/3): 7253.

First_Child_Element
   <in> Ada.Containers.Multiway_Trees   *note A.18.10(61/3): 7254.

First_Element
   <in> Ada.Containers.Doubly_Linked_Lists   *note A.18.3(34/2): 6857.
   <in> Ada.Containers.Ordered_Maps   *note A.18.6(29/2): 6995.
   <in> Ada.Containers.Ordered_Sets   *note A.18.9(42/2): 7152.
   <in> Ada.Containers.Vectors   *note A.18.2(59/2): 6782.

First_Index <in> Ada.Containers.Vectors   *note A.18.2(57/2): 6780.

First_Key
   <in> Ada.Containers.Ordered_Maps   *note A.18.6(30/2): 6996.

Floor
   <in> Ada.Containers.Ordered_Maps   *note A.18.6(40/2): 7006.
   <in> Ada.Containers.Ordered_Sets   *note A.18.9(50/2): 7160, *note
A.18.9(70/2): 7173.

Flush
   <in> Ada.Direct_IO   *note A.8.4(10.1/4): 6338.
   <in> Ada.Sequential_IO   *note A.8.1(10.1/4): 6311.
   <in> Ada.Streams.Stream_IO   *note A.12.1(25/1): 6594.
   <in> Ada.Text_IO   *note A.10.1(21/1): 6410.

Form
   <in> Ada.Direct_IO   *note A.8.4(9): 6336.
   <in> Ada.Sequential_IO   *note A.8.1(9): 6309.
   <in> Ada.Streams.Stream_IO   *note A.12.1(11): 6582.
   <in> Ada.Text_IO   *note A.10.1(12): 6391.

Free
   <in> Ada.Strings.Unbounded   *note A.4.5(7): 5907.
   <in> Interfaces.C.Strings   *note B.3.1(11): 7504.

Full_Name <in> Ada.Directories   *note A.16(15/2): 6645, *note
A.16(39/2): 6667.

Generic_Array_Sort
   <child of> Ada.Containers   *note A.18.26(3/2): 7330.

Generic_Constrained_Array_Sort
   <child of> Ada.Containers   *note A.18.26(7/2): 7332.

Generic_Sort
   <child of> Ada.Containers   *note A.18.26(9.2/4): 7334.

Get
   <in> Ada.Text_IO   *note A.10.1(41): 6444, *note A.10.1(47): 6453,
*note A.10.1(54): 6466, *note A.10.1(55): 6470, *note A.10.1(59): 6476,
*note A.10.1(60): 6479, *note A.10.1(65): 6486, *note A.10.1(67): 6489,
*note A.10.1(70): 6496, *note A.10.1(72): 6499, *note A.10.1(75): 6506,
*note A.10.1(77): 6509, *note A.10.1(81): 6515, *note A.10.1(83): 6518.
   <in> Ada.Text_IO.Complex_IO   *note G.1.3(6): 8319, *note G.1.3(8):
8322.

Get_CPU
   <in> Ada.Interrupts   *note C.3.2(10.1/3): 7669.
   <in> System.Multiprocessors.Dispatching_Domains   *note D.16.1(13/3):
8090.

Get_CPU_Set
   <in> System.Multiprocessors.Dispatching_Domains   *note
D.16.1(9.3/4): 8086.

Get_Deadline <in> Ada.Dispatching.EDF   *note D.2.6(9/2): 7826.

Get_Dispatching_Domain
   <in> System.Multiprocessors.Dispatching_Domains   *note D.16.1(10/3):
8087.

Get_First_CPU
   <in> System.Multiprocessors.Dispatching_Domains   *note D.16.1(8/3):
8082.

Get_Immediate <in> Ada.Text_IO   *note A.10.1(44): 6450, *note
A.10.1(45): 6451.

Get_Last_CPU
   <in> System.Multiprocessors.Dispatching_Domains   *note D.16.1(9/4):
8083.

Get_Line
   <in> Ada.Text_IO   *note A.10.1(49): 6458, *note A.10.1(49.1/2):
6459.
   <in> Ada.Text_IO.Bounded_IO   *note A.10.11(8/2): 6542, *note
A.10.11(9/2): 6543, *note A.10.11(10/2): 6544, *note A.10.11(11/2):
6545.
   <in> Ada.Text_IO.Unbounded_IO   *note A.10.12(8/2): 6551, *note
A.10.12(9/2): 6552, *note A.10.12(10/2): 6553, *note A.10.12(11/2):
6554.

Get_Next_Entry <in> Ada.Directories   *note A.16(35/2): 6665.

Get_Priority
   <in> Ada.Dynamic_Priorities   *note D.5.1(5): 7867.

Has_Element
   <in> Ada.Containers.Doubly_Linked_Lists   *note A.18.3(9.1/3): 6827.
   <in> Ada.Containers.Hashed_Maps   *note A.18.5(6.1/3): 6913.
   <in> Ada.Containers.Hashed_Sets   *note A.18.8(6.1/3): 7045.
   <in> Ada.Containers.Multiway_Trees   *note A.18.10(12/3): 7206.
   <in> Ada.Containers.Ordered_Maps   *note A.18.6(7.1/3): 6966.
   <in> Ada.Containers.Ordered_Sets   *note A.18.9(7.1/3): 7118.
   <in> Ada.Containers.Vectors   *note A.18.2(11.1/3): 6731.

Hash
   <child of> Ada.Strings   *note A.4.9(2/3): 6049.
   <child of> Ada.Strings.Bounded   *note A.4.9(7/3): 6050.
   <child of> Ada.Strings.Unbounded   *note A.4.9(10/3): 6051.

Hash_Case_Insensitive
   <child of> Ada.Strings   *note A.4.9(11.2/3): 6052.
   <child of> Ada.Strings.Bounded   *note A.4.9(11.7/3): 6054.
   <child of> Ada.Strings.Fixed   *note A.4.9(11.5/3): 6053.
   <child of> Ada.Strings.Unbounded   *note A.4.9(11.10/3): 6055.

Head
   <in> Ada.Strings.Bounded   *note A.4.4(70): 5895, *note A.4.4(71):
5896.
   <in> Ada.Strings.Fixed   *note A.4.3(35): 5838, *note A.4.3(36):
5839.
   <in> Ada.Strings.Unbounded   *note A.4.5(65): 5949, *note A.4.5(66):
5950.

Hold <in> Ada.Asynchronous_Task_Control   *note D.11(3/2): 7989.

Hour <in> Ada.Calendar.Formatting   *note 9.6.1(24/2): 4194.

Im
   <in> Ada.Numerics.Generic_Complex_Arrays   *note G.3.2(7/2): 8390,
*note G.3.2(27/2): 8403.
   <in> Ada.Numerics.Generic_Complex_Types   *note G.1.1(6): 8264.

Image
   <in> Ada.Calendar.Formatting   *note 9.6.1(35/2): 4205, *note
9.6.1(37/2): 4207.
   <in> Ada.Numerics.Discrete_Random   *note A.5.2(26): 6169.
   <in> Ada.Numerics.Float_Random   *note A.5.2(14): 6157.
   <in> Ada.Task_Identification   *note C.7.1(3/3): 7711.
   <in> Ada.Text_IO.Editing   *note F.3.3(13): 8249.

Include
   <in> Ada.Containers.Hashed_Maps   *note A.18.5(22/2): 6936.
   <in> Ada.Containers.Hashed_Sets   *note A.18.8(21/2): 7063.
   <in> Ada.Containers.Ordered_Maps   *note A.18.6(21/2): 6987.
   <in> Ada.Containers.Ordered_Sets   *note A.18.9(20/2): 7134.

Increment <in> Interfaces.C.Pointers   *note B.3.2(11/3): 7523.

Index
   <in> Ada.Direct_IO   *note A.8.4(15): 6344.
   <in> Ada.Streams.Stream_IO   *note A.12.1(23): 6591.
   <in> Ada.Strings.Bounded   *note A.4.4(43.1/2): 5866, *note
A.4.4(43.2/2): 5867, *note A.4.4(44): 5868, *note A.4.4(45): 5869, *note
A.4.4(45.1/2): 5870, *note A.4.4(46): 5871.
   <in> Ada.Strings.Fixed   *note A.4.3(8.1/2): 5809, *note
A.4.3(8.2/2): 5810, *note A.4.3(9): 5811, *note A.4.3(10): 5812, *note
A.4.3(10.1/2): 5813, *note A.4.3(11): 5814.
   <in> Ada.Strings.Unbounded   *note A.4.5(38.1/2): 5920, *note
A.4.5(38.2/2): 5921, *note A.4.5(39): 5922, *note A.4.5(40): 5923, *note
A.4.5(40.1/2): 5924, *note A.4.5(41): 5925.

Index_Non_Blank
   <in> Ada.Strings.Bounded   *note A.4.4(46.1/2): 5872, *note
A.4.4(47): 5873.
   <in> Ada.Strings.Fixed   *note A.4.3(11.1/2): 5815, *note A.4.3(12):
5816.
   <in> Ada.Strings.Unbounded   *note A.4.5(41.1/2): 5926, *note
A.4.5(42): 5927.

Initial_Directory
   <in> Ada.Directories.Hierarchical_File_Names   *note A.16.1(12/3):
6695.

Initialize <in> Ada.Finalization   *note 7.6(6/2): 3663, *note 7.6(8/2):
3667.

Insert
   <in> Ada.Containers.Doubly_Linked_Lists   *note A.18.3(19/2): 6842,
*note A.18.3(20/2): 6843, *note A.18.3(21/2): 6844.
   <in> Ada.Containers.Hashed_Maps   *note A.18.5(19/2): 6933, *note
A.18.5(20/2): 6934, *note A.18.5(21/2): 6935.
   <in> Ada.Containers.Hashed_Sets   *note A.18.8(19/2): 7061, *note
A.18.8(20/2): 7062.
   <in> Ada.Containers.Ordered_Maps   *note A.18.6(18/2): 6984, *note
A.18.6(19/2): 6985, *note A.18.6(20/2): 6986.
   <in> Ada.Containers.Ordered_Sets   *note A.18.9(18/2): 7132, *note
A.18.9(19/2): 7133.
   <in> Ada.Containers.Vectors   *note A.18.2(36/2): 6759, *note
A.18.2(37/2): 6760, *note A.18.2(38/2): 6761, *note A.18.2(39/2): 6762,
*note A.18.2(40/2): 6763, *note A.18.2(41/2): 6764, *note A.18.2(42/2):
6765, *note A.18.2(43/2): 6766.
   <in> Ada.Strings.Bounded   *note A.4.4(60): 5885, *note A.4.4(61):
5886.
   <in> Ada.Strings.Fixed   *note A.4.3(25): 5828, *note A.4.3(26):
5829.
   <in> Ada.Strings.Unbounded   *note A.4.5(55): 5939, *note A.4.5(56):
5940.

Insert_Child
   <in> Ada.Containers.Multiway_Trees   *note A.18.10(48/3): 7241, *note
A.18.10(49/3): 7242, *note A.18.10(50/3): 7243.

Insert_Space
   <in> Ada.Containers.Vectors   *note A.18.2(48/2): 6771, *note
A.18.2(49/2): 6772.

Interface_Ancestor_Tags <in> Ada.Tags   *note 3.9(7.4/2): 2112.

Internal_Tag <in> Ada.Tags   *note 3.9(7/2): 2107.

Intersection
   <in> Ada.Containers.Hashed_Sets   *note A.18.8(29/2): 7070, *note
A.18.8(30/2): 7071.
   <in> Ada.Containers.Ordered_Sets   *note A.18.9(30/2): 7143, *note
A.18.9(31/2): 7144.

Inverse
   <in> Ada.Numerics.Generic_Complex_Arrays   *note G.3.2(46/2): 8417.
   <in> Ada.Numerics.Generic_Real_Arrays   *note G.3.1(24/2): 8377.

Is_A_Group_Member
   <in> Ada.Execution_Time.Group_Budgets   *note D.14.2(8/2): 8038.

Is_Abstract <in> Ada.Tags   *note 3.9(7.5/3): 2113.

Is_Alphanumeric
   <in> Ada.Characters.Handling   *note A.3.2(4/3): 5470.
   <in> Ada.Wide_Characters.Handling   *note A.3.5(12/3): 5757.

Is_Attached <in> Ada.Interrupts   *note C.3.2(5): 7663.

Is_Basic <in> Ada.Characters.Handling   *note A.3.2(4/3): 5466.

Is_Callable
   <in> Ada.Task_Identification   *note C.7.1(4/3): 7716.

Is_Character
   <in> Ada.Characters.Conversions   *note A.3.4(3/2): 5732.

Is_Control
   <in> Ada.Characters.Handling   *note A.3.2(4/3): 5461.
   <in> Ada.Wide_Characters.Handling   *note A.3.5(5/3): 5750.

Is_Current_Directory_Name
   <in> Ada.Directories.Hierarchical_File_Names   *note A.16.1(7/3):
6690.

Is_Decimal_Digit
   <in> Ada.Characters.Handling   *note A.3.2(4/3): 5468.
   <in> Ada.Wide_Characters.Handling   *note A.3.5(10/3): 5755.

Is_Descendant_At_Same_Level
   <in> Ada.Tags   *note 3.9(7.1/2): 2109.

Is_Digit
   <in> Ada.Characters.Handling   *note A.3.2(4/3): 5467.
   <in> Ada.Wide_Characters.Handling   *note A.3.5(9/3): 5754.

Is_Empty
   <in> Ada.Containers.Doubly_Linked_Lists   *note A.18.3(12/2): 6830.
   <in> Ada.Containers.Hashed_Maps   *note A.18.5(11/2): 6918.
   <in> Ada.Containers.Hashed_Sets   *note A.18.8(13/2): 7052.
   <in> Ada.Containers.Indefinite_Holders   *note A.18.18(10/3): 7288.
   <in> Ada.Containers.Multiway_Trees   *note A.18.10(16/3): 7209.
   <in> Ada.Containers.Ordered_Maps   *note A.18.6(10/2): 6969.
   <in> Ada.Containers.Ordered_Sets   *note A.18.9(12/2): 7123.
   <in> Ada.Containers.Vectors   *note A.18.2(23/2): 6739.

Is_Full_Name
   <in> Ada.Directories.Hierarchical_File_Names   *note A.16.1(8/3):
6691.

Is_Graphic
   <in> Ada.Characters.Handling   *note A.3.2(4/3): 5462.
   <in> Ada.Wide_Characters.Handling   *note A.3.5(19/3): 5764.

Is_Held
   <in> Ada.Asynchronous_Task_Control   *note D.11(3/2): 7991.

Is_Hexadecimal_Digit
   <in> Ada.Characters.Handling   *note A.3.2(4/3): 5469.
   <in> Ada.Wide_Characters.Handling   *note A.3.5(11/3): 5756.

Is_In
   <in> Ada.Strings.Maps   *note A.4.2(13): 5791.
   <in> Ada.Strings.Wide_Maps   *note A.4.7(13): 5993.
   <in> Ada.Strings.Wide_Wide_Maps   *note A.4.8(13/2): 6032.

Is_ISO_646 <in> Ada.Characters.Handling   *note A.3.2(10): 5485.

Is_Leaf
   <in> Ada.Containers.Multiway_Trees   *note A.18.10(21/3): 7214.

Is_Letter
   <in> Ada.Characters.Handling   *note A.3.2(4/3): 5463.
   <in> Ada.Wide_Characters.Handling   *note A.3.5(6/3): 5751.

Is_Line_Terminator
   <in> Ada.Characters.Handling   *note A.3.2(4/3): 5472.
   <in> Ada.Wide_Characters.Handling   *note A.3.5(14/3): 5759.

Is_Lower
   <in> Ada.Characters.Handling   *note A.3.2(4/3): 5464.
   <in> Ada.Wide_Characters.Handling   *note A.3.5(7/3): 5752.

Is_Mark
   <in> Ada.Characters.Handling   *note A.3.2(4/3): 5473.
   <in> Ada.Wide_Characters.Handling   *note A.3.5(15/3): 5760.

Is_Member
   <in> Ada.Execution_Time.Group_Budgets   *note D.14.2(8/2): 8037.

Is_Nul_Terminated <in> Interfaces.C   *note B.3(24): 7456, *note
B.3(35): 7466, *note B.3(39.16/2): 7486, *note B.3(39.7/2): 7476.

Is_Open
   <in> Ada.Direct_IO   *note A.8.4(10): 6337.
   <in> Ada.Sequential_IO   *note A.8.1(10): 6310.
   <in> Ada.Streams.Stream_IO   *note A.12.1(12): 6583.
   <in> Ada.Text_IO   *note A.10.1(13): 6392.

Is_Other_Format
   <in> Ada.Characters.Handling   *note A.3.2(4/3): 5474.
   <in> Ada.Wide_Characters.Handling   *note A.3.5(16/3): 5761.

Is_Parent_Directory_Name
   <in> Ada.Directories.Hierarchical_File_Names   *note A.16.1(6/3):
6689.

Is_Punctuation_Connector
   <in> Ada.Characters.Handling   *note A.3.2(4/3): 5475.
   <in> Ada.Wide_Characters.Handling   *note A.3.5(17/3): 5762.

Is_Relative_Name
   <in> Ada.Directories.Hierarchical_File_Names   *note A.16.1(9/3):
6692.

Is_Reserved <in> Ada.Interrupts   *note C.3.2(4): 7662.

Is_Root
   <in> Ada.Containers.Multiway_Trees   *note A.18.10(20/3): 7213.

Is_Root_Directory_Name
   <in> Ada.Directories.Hierarchical_File_Names   *note A.16.1(5/3):
6688.

Is_Round_Robin
   <in> Ada.Dispatching.Round_Robin   *note D.2.5(4/2): 7818.

Is_Simple_Name
   <in> Ada.Directories.Hierarchical_File_Names   *note A.16.1(4/3):
6687.

Is_Sorted
   <in> Ada.Containers.Doubly_Linked_Lists   *note A.18.3(48/2): 6870.
   <in> Ada.Containers.Vectors   *note A.18.2(76/2): 6798.

Is_Space
   <in> Ada.Characters.Handling   *note A.3.2(4/3): 5476.
   <in> Ada.Wide_Characters.Handling   *note A.3.5(18/3): 5763.

Is_Special
   <in> Ada.Characters.Handling   *note A.3.2(4/3): 5471.
   <in> Ada.Wide_Characters.Handling   *note A.3.5(13/3): 5758.

Is_String
   <in> Ada.Characters.Conversions   *note A.3.4(3/2): 5731.

Is_Subset
   <in> Ada.Containers.Hashed_Sets   *note A.18.8(39/2): 7077.
   <in> Ada.Containers.Ordered_Sets   *note A.18.9(40/2): 7150.
   <in> Ada.Strings.Maps   *note A.4.2(14): 5792.
   <in> Ada.Strings.Wide_Maps   *note A.4.7(14): 5994.
   <in> Ada.Strings.Wide_Wide_Maps   *note A.4.8(14/2): 6033.

Is_Terminated
   <in> Ada.Task_Identification   *note C.7.1(4/3): 7715.

Is_Upper
   <in> Ada.Characters.Handling   *note A.3.2(4/3): 5465.
   <in> Ada.Wide_Characters.Handling   *note A.3.5(8/3): 5753.

Is_Wide_Character
   <in> Ada.Characters.Conversions   *note A.3.4(3/2): 5734.

Is_Wide_String
   <in> Ada.Characters.Conversions   *note A.3.4(3/2): 5735.

Iterate
   <in> Ada.Containers.Doubly_Linked_Lists   *note A.18.3(45/2): 6867.
   <in> Ada.Containers.Hashed_Maps   *note A.18.5(37/2): 6950.
   <in> Ada.Containers.Hashed_Sets   *note A.18.8(49/2): 7086.
   <in> Ada.Containers.Multiway_Trees   *note A.18.10(42/3): 7235, *note
A.18.10(44/3): 7237.
   <in> Ada.Containers.Ordered_Maps   *note A.18.6(50/2): 7009.
   <in> Ada.Containers.Ordered_Sets   *note A.18.9(60/2): 7163.
   <in> Ada.Containers.Vectors   *note A.18.2(73/2): 6795.
   <in> Ada.Environment_Variables   *note A.17(8/3): 6706.

Iterate_Children
   <in> Ada.Containers.Multiway_Trees   *note A.18.10(68/3): 7261, *note
A.18.10(70/3): 7263.

Iterate_Subtree
   <in> Ada.Containers.Multiway_Trees   *note A.18.10(43/3): 7236, *note
A.18.10(45/3): 7238.

Key
   <in> Ada.Containers.Hashed_Maps   *note A.18.5(13/2): 6920.
   <in> Ada.Containers.Hashed_Sets   *note A.18.8(51/2): 7088.
   <in> Ada.Containers.Ordered_Maps   *note A.18.6(12/2): 6971.
   <in> Ada.Containers.Ordered_Sets   *note A.18.9(64/2): 7167.

Kind <in> Ada.Directories   *note A.16(25/2): 6656, *note A.16(40/2):
6668.

Language <in> Ada.Locales   *note A.19(6/3): 7375.

Last
   <in> Ada.Containers.Doubly_Linked_Lists   *note A.18.3(35/2): 6858.
   <in> Ada.Containers.Ordered_Maps   *note A.18.6(31/2): 6997.
   <in> Ada.Containers.Ordered_Sets   *note A.18.9(43/2): 7153.
   <in> Ada.Containers.Vectors   *note A.18.2(61/2): 6784.
   <in> Ada.Iterator_Interfaces   *note 5.5.1(4/3): 3214.

Last_Child
   <in> Ada.Containers.Multiway_Trees   *note A.18.10(62/3): 7255.

Last_Child_Element
   <in> Ada.Containers.Multiway_Trees   *note A.18.10(63/3): 7256.

Last_Element
   <in> Ada.Containers.Doubly_Linked_Lists   *note A.18.3(36/2): 6859.
   <in> Ada.Containers.Ordered_Maps   *note A.18.6(32/2): 6998.
   <in> Ada.Containers.Ordered_Sets   *note A.18.9(44/2): 7154.
   <in> Ada.Containers.Vectors   *note A.18.2(62/2): 6785.

Last_Index <in> Ada.Containers.Vectors   *note A.18.2(60/2): 6783.

Last_Key
   <in> Ada.Containers.Ordered_Maps   *note A.18.6(33/2): 6999.

Length
   <in> Ada.Containers.Doubly_Linked_Lists   *note A.18.3(11/2): 6829.
   <in> Ada.Containers.Hashed_Maps   *note A.18.5(10/2): 6917.
   <in> Ada.Containers.Hashed_Sets   *note A.18.8(12/2): 7051.
   <in> Ada.Containers.Ordered_Maps   *note A.18.6(9/2): 6968.
   <in> Ada.Containers.Ordered_Sets   *note A.18.9(11/2): 7122.
   <in> Ada.Containers.Vectors   *note A.18.2(21/2): 6737.
   <in> Ada.Strings.Bounded   *note A.4.4(9): 5849.
   <in> Ada.Strings.Unbounded   *note A.4.5(6): 5905.
   <in> Ada.Text_IO.Editing   *note F.3.3(11): 8247.
   <in> Interfaces.COBOL   *note B.4(34): 7581, *note B.4(39): 7585,
*note B.4(44): 7589.

Less_Case_Insensitive
   <child of> Ada.Strings   *note A.4.10(13/3): 6060.
   <child of> Ada.Strings.Bounded   *note A.4.10(18/3): 6062.
   <child of> Ada.Strings.Fixed   *note A.4.10(16/3): 6061.
   <child of> Ada.Strings.Unbounded   *note A.4.10(21/3): 6063.

Line <in> Ada.Text_IO   *note A.10.1(38): 6440.

Line_Length <in> Ada.Text_IO   *note A.10.1(25): 6415.

Log
   <in> Ada.Numerics.Generic_Complex_Elementary_Functions   *note
G.1.2(3): 8287.
   <in> Ada.Numerics.Generic_Elementary_Functions   *note A.5.1(4):
6113.

Look_Ahead <in> Ada.Text_IO   *note A.10.1(43): 6448.

Members
   <in> Ada.Execution_Time.Group_Budgets   *note D.14.2(8/2): 8039.

Merge
   <in> Ada.Containers.Doubly_Linked_Lists   *note A.18.3(50/2): 6872.
   <in> Ada.Containers.Vectors   *note A.18.2(78/2): 6800.

Microseconds <in> Ada.Real_Time   *note D.8(14/2): 7956.

Milliseconds <in> Ada.Real_Time   *note D.8(14/2): 7957.

Minute <in> Ada.Calendar.Formatting   *note 9.6.1(25/2): 4195.

Minutes <in> Ada.Real_Time   *note D.8(14/2): 7959.

Mode
   <in> Ada.Direct_IO   *note A.8.4(9): 6334.
   <in> Ada.Sequential_IO   *note A.8.1(9): 6307.
   <in> Ada.Streams.Stream_IO   *note A.12.1(11): 6580.
   <in> Ada.Text_IO   *note A.10.1(12): 6389.

Modification_Time <in> Ada.Directories   *note A.16(27/2): 6658, *note
A.16(42/2): 6670.

Modulus
   <in> Ada.Numerics.Generic_Complex_Arrays   *note G.3.2(10/2): 8395,
*note G.3.2(30/2): 8408.
   <in> Ada.Numerics.Generic_Complex_Types   *note G.1.1(9): 8272.

Month
   <in> Ada.Calendar   *note 9.6(13): 4153.
   <in> Ada.Calendar.Formatting   *note 9.6.1(22/2): 4192.

More_Entries <in> Ada.Directories   *note A.16(34/2): 6664.

Move
   <in> Ada.Containers.Doubly_Linked_Lists   *note A.18.3(18/2): 6841.
   <in> Ada.Containers.Hashed_Maps   *note A.18.5(18/2): 6932.
   <in> Ada.Containers.Hashed_Sets   *note A.18.8(18/2): 7060.
   <in> Ada.Containers.Indefinite_Holders   *note A.18.18(22/3): 7300.
   <in> Ada.Containers.Multiway_Trees   *note A.18.10(34/3): 7227.
   <in> Ada.Containers.Ordered_Maps   *note A.18.6(17/2): 6983.
   <in> Ada.Containers.Ordered_Sets   *note A.18.9(17/2): 7131.
   <in> Ada.Containers.Vectors   *note A.18.2(35/2): 6758.
   <in> Ada.Strings.Fixed   *note A.4.3(7): 5808.

Name
   <in> Ada.Direct_IO   *note A.8.4(9): 6335.
   <in> Ada.Sequential_IO   *note A.8.1(9): 6308.
   <in> Ada.Streams.Stream_IO   *note A.12.1(11): 6581.
   <in> Ada.Text_IO   *note A.10.1(12): 6390.

Name_Case_Equivalence
   <in> Ada.Directories   *note A.16(20.2/3): 6652.

Nanoseconds <in> Ada.Real_Time   *note D.8(14/2): 7955.

New_Char_Array
   <in> Interfaces.C.Strings   *note B.3.1(9): 7502.

New_Line <in> Ada.Text_IO   *note A.10.1(28): 6420.

New_Page <in> Ada.Text_IO   *note A.10.1(31): 6426.

New_String <in> Interfaces.C.Strings   *note B.3.1(10): 7503.

Next
   <in> Ada.Containers.Doubly_Linked_Lists   *note A.18.3(37/2): 6860,
*note A.18.3(39/2): 6862.
   <in> Ada.Containers.Hashed_Maps   *note A.18.5(28/2): 6942, *note
A.18.5(29/2): 6943.
   <in> Ada.Containers.Hashed_Sets   *note A.18.8(41/2): 7079, *note
A.18.8(42/2): 7080.
   <in> Ada.Containers.Ordered_Maps   *note A.18.6(34/2): 7000, *note
A.18.6(35/2): 7001.
   <in> Ada.Containers.Ordered_Sets   *note A.18.9(45/2): 7155, *note
A.18.9(46/2): 7156.
   <in> Ada.Containers.Vectors   *note A.18.2(63/2): 6786, *note
A.18.2(64/2): 6787.
   <in> Ada.Iterator_Interfaces   *note 5.5.1(3/3): 3212.

Next_Sibling
   <in> Ada.Containers.Multiway_Trees   *note A.18.10(64/3): 7257, *note
A.18.10(66/3): 7259.

Node_Count
   <in> Ada.Containers.Multiway_Trees   *note A.18.10(17/3): 7210.

Null_Task_Id
   <in> Ada.Task_Identification   *note C.7.1(2/2): 7710.

Number_Of_CPUs
   <in> System.Multiprocessors   *note D.16(5/3): 8074.

Open
   <in> Ada.Direct_IO   *note A.8.4(7): 6329.
   <in> Ada.Sequential_IO   *note A.8.1(7): 6302.
   <in> Ada.Streams.Stream_IO   *note A.12.1(9): 6575.
   <in> Ada.Text_IO   *note A.10.1(10): 6384.

Overlap
   <in> Ada.Containers.Hashed_Sets   *note A.18.8(38/2): 7076.
   <in> Ada.Containers.Ordered_Sets   *note A.18.9(39/2): 7149.

Overwrite
   <in> Ada.Strings.Bounded   *note A.4.4(62): 5887, *note A.4.4(63):
5888.
   <in> Ada.Strings.Fixed   *note A.4.3(27): 5830, *note A.4.3(28):
5831.
   <in> Ada.Strings.Unbounded   *note A.4.5(57): 5941, *note A.4.5(58):
5942.

Page <in> Ada.Text_IO   *note A.10.1(39): 6441.

Page_Length <in> Ada.Text_IO   *note A.10.1(26): 6417.

Parent
   <in> Ada.Containers.Multiway_Trees   *note A.18.10(59/3): 7252.

Parent_Tag <in> Ada.Tags   *note 3.9(7.2/2): 2110.

Peak_Use
   <in> Ada.Containers.Bounded_Priority_Queues   *note A.18.31(7/3):
7368.
   <in> Ada.Containers.Bounded_Synchronized_Queues   *note A.18.29(6/3):
7354.
   <in> Ada.Containers.Synchronized_Queue_Interfaces   *note
A.18.27(7/3): 7341.
   <in> Ada.Containers.Unbounded_Priority_Queues   *note A.18.30(7/3):
7361.
   <in> Ada.Containers.Unbounded_Synchronized_Queues   *note
A.18.28(6/3): 7348.

Pic_String <in> Ada.Text_IO.Editing   *note F.3.3(7): 8238.

Pool_of_Subpool
   <in> System.Storage_Pools.Subpools   *note 13.11.4(9/3): 5261.

Prepend
   <in> Ada.Containers.Doubly_Linked_Lists   *note A.18.3(22/2): 6845.
   <in> Ada.Containers.Vectors   *note A.18.2(44/2): 6767, *note
A.18.2(45/2): 6768.

Prepend_Child
   <in> Ada.Containers.Multiway_Trees   *note A.18.10(51/3): 7244.

Previous
   <in> Ada.Containers.Doubly_Linked_Lists   *note A.18.3(38/2): 6861,
*note A.18.3(40/2): 6863.
   <in> Ada.Containers.Ordered_Maps   *note A.18.6(36/2): 7002, *note
A.18.6(37/2): 7003.
   <in> Ada.Containers.Ordered_Sets   *note A.18.9(47/2): 7157, *note
A.18.9(48/2): 7158.
   <in> Ada.Containers.Vectors   *note A.18.2(65/2): 6788, *note
A.18.2(66/2): 6789.
   <in> Ada.Iterator_Interfaces   *note 5.5.1(4/3): 3215.

Previous_Sibling
   <in> Ada.Containers.Multiway_Trees   *note A.18.10(65/3): 7258, *note
A.18.10(67/3): 7260.

Put
   <in> Ada.Text_IO   *note A.10.1(42): 6446, *note A.10.1(48): 6456,
*note A.10.1(55): 6471, *note A.10.1(60): 6478, *note A.10.1(66): 6487,
*note A.10.1(67): 6490, *note A.10.1(71): 6498, *note A.10.1(72): 6500,
*note A.10.1(76): 6507, *note A.10.1(77): 6510, *note A.10.1(82): 6516,
*note A.10.1(83): 6519.
   <in> Ada.Text_IO.Bounded_IO   *note A.10.11(4/2): 6538, *note
A.10.11(5/2): 6539.
   <in> Ada.Text_IO.Complex_IO   *note G.1.3(7): 8321, *note G.1.3(8):
8323.
   <in> Ada.Text_IO.Editing   *note F.3.3(14): 8250, *note F.3.3(15):
8251, *note F.3.3(16): 8252.
   <in> Ada.Text_IO.Unbounded_IO   *note A.10.12(4/2): 6547, *note
A.10.12(5/2): 6548.

Put_Line
   <in> Ada.Text_IO   *note A.10.1(50): 6462.
   <in> Ada.Text_IO.Bounded_IO   *note A.10.11(6/2): 6540, *note
A.10.11(7/2): 6541.
   <in> Ada.Text_IO.Unbounded_IO   *note A.10.12(6/2): 6549, *note
A.10.12(7/2): 6550.

Query_Element
   <in> Ada.Containers.Doubly_Linked_Lists   *note A.18.3(16/2): 6834.
   <in> Ada.Containers.Hashed_Maps   *note A.18.5(16/2): 6923.
   <in> Ada.Containers.Hashed_Sets   *note A.18.8(17/2): 7056.
   <in> Ada.Containers.Indefinite_Holders   *note A.18.18(14/3): 7292.
   <in> Ada.Containers.Multiway_Trees   *note A.18.10(26/3): 7219.
   <in> Ada.Containers.Ordered_Maps   *note A.18.6(15/2): 6974.
   <in> Ada.Containers.Ordered_Sets   *note A.18.9(16/2): 7127.
   <in> Ada.Containers.Vectors   *note A.18.2(31/2): 6747, *note
A.18.2(32/2): 6748.

Raise_Exception <in> Ada.Exceptions   *note 11.4.1(4/3): 4573.

Random
   <in> Ada.Numerics.Discrete_Random   *note A.5.2(20): 6162.
   <in> Ada.Numerics.Float_Random   *note A.5.2(8): 6150.

Re
   <in> Ada.Numerics.Generic_Complex_Arrays   *note G.3.2(7/2): 8389,
*note G.3.2(27/2): 8402.
   <in> Ada.Numerics.Generic_Complex_Types   *note G.1.1(6): 8263.

Read
   <in> Ada.Direct_IO   *note A.8.4(12): 6339.
   <in> Ada.Sequential_IO   *note A.8.1(12): 6312.
   <in> Ada.Storage_IO   *note A.9(6): 6358.
   <in> Ada.Streams   *note 13.13.1(5): 5340.
   <in> Ada.Streams.Stream_IO   *note A.12.1(15): 6586, *note
A.12.1(16): 6587.
   <in> System.RPC   *note E.5(7): 8208.

Reference
   <in> Ada.Containers.Doubly_Linked_Lists   *note A.18.3(17.4/3): 6838.
   <in> Ada.Containers.Hashed_Maps   *note A.18.5(17.4/3): 6927, *note
A.18.5(17.6/3): 6929.
   <in> Ada.Containers.Indefinite_Holders   *note A.18.18(19/3): 7297.
   <in> Ada.Containers.Multiway_Trees   *note A.18.10(31/3): 7224.
   <in> Ada.Containers.Ordered_Maps   *note A.18.6(16.4/3): 6978, *note
A.18.6(16.6/3): 6980.
   <in> Ada.Containers.Vectors   *note A.18.2(34.4/3): 6753, *note
A.18.2(34.6/3): 6755.
   <in> Ada.Interrupts   *note C.3.2(10): 7668.
   <in> Ada.Task_Attributes   *note C.7.2(5): 7731.

Reference_Preserving_Key
   <in> Ada.Containers.Hashed_Sets   *note A.18.8(58.2/3): 7097, *note
A.18.8(58.4/3): 7099.
   <in> Ada.Containers.Ordered_Sets   *note A.18.9(73.2/3): 7178, *note
A.18.9(73.4/3): 7180.

Reinitialize <in> Ada.Task_Attributes   *note C.7.2(6): 7733.

Relative_Name
   <in> Ada.Directories.Hierarchical_File_Names   *note A.16.1(13/3):
6696.

Remove_Task
   <in> Ada.Execution_Time.Group_Budgets   *note D.14.2(8/2): 8036.

Rename <in> Ada.Directories   *note A.16(12/2): 6643.

Replace
   <in> Ada.Containers.Hashed_Maps   *note A.18.5(23/2): 6937.
   <in> Ada.Containers.Hashed_Sets   *note A.18.8(22/2): 7064, *note
A.18.8(53/2): 7090.
   <in> Ada.Containers.Ordered_Maps   *note A.18.6(22/2): 6988.
   <in> Ada.Containers.Ordered_Sets   *note A.18.9(21/2): 7135, *note
A.18.9(66/2): 7169.

Replace_Element
   <in> Ada.Containers.Doubly_Linked_Lists   *note A.18.3(15/2): 6833.
   <in> Ada.Containers.Hashed_Maps   *note A.18.5(15/2): 6922.
   <in> Ada.Containers.Hashed_Sets   *note A.18.8(16/2): 7055.
   <in> Ada.Containers.Indefinite_Holders   *note A.18.18(13/3): 7291.
   <in> Ada.Containers.Multiway_Trees   *note A.18.10(25/3): 7218.
   <in> Ada.Containers.Ordered_Maps   *note A.18.6(14/2): 6973.
   <in> Ada.Containers.Ordered_Sets   *note A.18.9(15/2): 7126.
   <in> Ada.Containers.Vectors   *note A.18.2(29/2): 6745, *note
A.18.2(30/2): 6746.
   <in> Ada.Strings.Bounded   *note A.4.4(27): 5862.
   <in> Ada.Strings.Unbounded   *note A.4.5(21): 5916.

Replace_Slice
   <in> Ada.Strings.Bounded   *note A.4.4(58): 5883, *note A.4.4(59):
5884.
   <in> Ada.Strings.Fixed   *note A.4.3(23): 5826, *note A.4.3(24):
5827.
   <in> Ada.Strings.Unbounded   *note A.4.5(53): 5937, *note A.4.5(54):
5938.

Replenish
   <in> Ada.Execution_Time.Group_Budgets   *note D.14.2(9/2): 8040.

Replicate <in> Ada.Strings.Bounded   *note A.4.4(78): 5899, *note
A.4.4(79): 5900, *note A.4.4(80): 5901.

Reraise_Occurrence <in> Ada.Exceptions   *note 11.4.1(4/3): 4575.

Reserve_Capacity
   <in> Ada.Containers.Hashed_Maps   *note A.18.5(9/2): 6916.
   <in> Ada.Containers.Hashed_Sets   *note A.18.8(11/2): 7050.
   <in> Ada.Containers.Vectors   *note A.18.2(20/2): 6736.

Reset
   <in> Ada.Direct_IO   *note A.8.4(8): 6333.
   <in> Ada.Numerics.Discrete_Random   *note A.5.2(21): 6164, *note
A.5.2(24): 6167.
   <in> Ada.Numerics.Float_Random   *note A.5.2(9): 6151, *note
A.5.2(12): 6155.
   <in> Ada.Sequential_IO   *note A.8.1(8): 6306.
   <in> Ada.Streams.Stream_IO   *note A.12.1(10): 6578.
   <in> Ada.Text_IO   *note A.10.1(11): 6388.

Reverse_Elements
   <in> Ada.Containers.Doubly_Linked_Lists   *note A.18.3(27/2): 6850.
   <in> Ada.Containers.Vectors   *note A.18.2(54/2): 6777.

Reverse_Find
   <in> Ada.Containers.Doubly_Linked_Lists   *note A.18.3(42/2): 6865.
   <in> Ada.Containers.Vectors   *note A.18.2(70/2): 6793.

Reverse_Find_Index
   <in> Ada.Containers.Vectors   *note A.18.2(69/2): 6792.

Reverse_Iterate
   <in> Ada.Containers.Doubly_Linked_Lists   *note A.18.3(46/2): 6868.
   <in> Ada.Containers.Ordered_Maps   *note A.18.6(51/2): 7010.
   <in> Ada.Containers.Ordered_Sets   *note A.18.9(61/2): 7164.
   <in> Ada.Containers.Vectors   *note A.18.2(74/2): 6796.

Reverse_Iterate_Children
   <in> Ada.Containers.Multiway_Trees   *note A.18.10(69/3): 7262.

Root <in> Ada.Containers.Multiway_Trees   *note A.18.10(22/3): 7215.

Save
   <in> Ada.Numerics.Discrete_Random   *note A.5.2(24): 6166.
   <in> Ada.Numerics.Float_Random   *note A.5.2(12): 6154.

Save_Occurrence <in> Ada.Exceptions   *note 11.4.1(6/2): 4582.

Second <in> Ada.Calendar.Formatting   *note 9.6.1(26/2): 4196.

Seconds
   <in> Ada.Calendar   *note 9.6(13): 4155.
   <in> Ada.Real_Time   *note D.8(14/2): 7958.

Seconds_Of <in> Ada.Calendar.Formatting   *note 9.6.1(28/2): 4198.

Set <in> Ada.Environment_Variables   *note A.17(6/2): 6703.

Set_Bounded_String
   <in> Ada.Strings.Bounded   *note A.4.4(12.1/2): 5852.

Set_Col <in> Ada.Text_IO   *note A.10.1(35): 6434.

Set_CPU
   <in> System.Multiprocessors.Dispatching_Domains   *note D.16.1(12/3):
8089.

Set_Deadline <in> Ada.Dispatching.EDF   *note D.2.6(9/2): 7824.

Set_Dependents_Fallback_Handler
   <in> Ada.Task_Termination   *note C.7.3(5/2): 7743.

Set_Directory <in> Ada.Directories   *note A.16(6/2): 6637.

Set_Error <in> Ada.Text_IO   *note A.10.1(15): 6395.

Set_Exit_Status <in> Ada.Command_Line   *note A.15(9): 6633.

Set_False
   <in> Ada.Synchronous_Task_Control   *note D.10(4): 7976.

Set_Handler
   <in> Ada.Execution_Time.Group_Budgets   *note D.14.2(10/2): 8044.
   <in> Ada.Execution_Time.Timers   *note D.14.1(7/2): 8020.
   <in> Ada.Real_Time.Timing_Events   *note D.15(5/2): 8061.

Set_Im
   <in> Ada.Numerics.Generic_Complex_Arrays   *note G.3.2(8/2): 8392,
*note G.3.2(28/2): 8405.
   <in> Ada.Numerics.Generic_Complex_Types   *note G.1.1(7): 8267.

Set_Index
   <in> Ada.Direct_IO   *note A.8.4(14): 6343.
   <in> Ada.Streams.Stream_IO   *note A.12.1(22): 6590.

Set_Input <in> Ada.Text_IO   *note A.10.1(15): 6393.

Set_Length <in> Ada.Containers.Vectors   *note A.18.2(22/2): 6738.

Set_Line <in> Ada.Text_IO   *note A.10.1(36): 6436.

Set_Line_Length <in> Ada.Text_IO   *note A.10.1(23): 6411.

Set_Mode <in> Ada.Streams.Stream_IO   *note A.12.1(24): 6593.

Set_Output <in> Ada.Text_IO   *note A.10.1(15): 6394.

Set_Page_Length <in> Ada.Text_IO   *note A.10.1(24): 6414.

Set_Pool_of_Subpool
   <in> System.Storage_Pools.Subpools   *note 13.11.4(10/3): 5262.

Set_Priority
   <in> Ada.Dynamic_Priorities   *note D.5.1(4): 7866.

Set_Quantum
   <in> Ada.Dispatching.Round_Robin   *note D.2.5(4/2): 7815.

Set_Re
   <in> Ada.Numerics.Generic_Complex_Arrays   *note G.3.2(8/2): 8391,
*note G.3.2(28/2): 8404.
   <in> Ada.Numerics.Generic_Complex_Types   *note G.1.1(7): 8266.

Set_Specific_Handler
   <in> Ada.Task_Termination   *note C.7.3(6/2): 7745.

Set_True
   <in> Ada.Synchronous_Task_Control   *note D.10(4): 7975.

Set_Unbounded_String
   <in> Ada.Strings.Unbounded   *note A.4.5(11.1/2): 5911.

Set_Value <in> Ada.Task_Attributes   *note C.7.2(6): 7732.

Simple_Name
   <in> Ada.Directories   *note A.16(16/2): 6646, *note A.16(38/2):
6666.
   <in> Ada.Directories.Hierarchical_File_Names   *note A.16.1(10/3):
6693.

Sin
   <in> Ada.Numerics.Generic_Complex_Elementary_Functions   *note
G.1.2(4): 8290.
   <in> Ada.Numerics.Generic_Elementary_Functions   *note A.5.1(5):
6116.

Sinh
   <in> Ada.Numerics.Generic_Complex_Elementary_Functions   *note
G.1.2(6): 8298.
   <in> Ada.Numerics.Generic_Elementary_Functions   *note A.5.1(7):
6131.

Size
   <in> Ada.Direct_IO   *note A.8.4(15): 6345.
   <in> Ada.Directories   *note A.16(26/2): 6657, *note A.16(41/2):
6669.
   <in> Ada.Streams.Stream_IO   *note A.12.1(23): 6592.

Skip_Line <in> Ada.Text_IO   *note A.10.1(29): 6422.

Skip_Page <in> Ada.Text_IO   *note A.10.1(32): 6428.

Slice
   <in> Ada.Strings.Bounded   *note A.4.4(28): 5863.
   <in> Ada.Strings.Unbounded   *note A.4.5(22): 5917.

Solve
   <in> Ada.Numerics.Generic_Complex_Arrays   *note G.3.2(46/2): 8415.
   <in> Ada.Numerics.Generic_Real_Arrays   *note G.3.1(24/2): 8376.

Sort
   <in> Ada.Containers.Doubly_Linked_Lists   *note A.18.3(49/2): 6871.
   <in> Ada.Containers.Vectors   *note A.18.2(77/2): 6799.

Specific_Handler
   <in> Ada.Task_Termination   *note C.7.3(6/2): 7746.

Splice
   <in> Ada.Containers.Doubly_Linked_Lists   *note A.18.3(30/2): 6853,
*note A.18.3(31/2): 6854, *note A.18.3(32/2): 6855.

Splice_Children
   <in> Ada.Containers.Multiway_Trees   *note A.18.10(57/3): 7250, *note
A.18.10(58/3): 7251.

Splice_Subtree
   <in> Ada.Containers.Multiway_Trees   *note A.18.10(55/3): 7248, *note
A.18.10(56/3): 7249.

Split
   <in> Ada.Calendar   *note 9.6(14): 4156.
   <in> Ada.Calendar.Formatting   *note 9.6.1(29/2): 4199, *note
9.6.1(32/2): 4202, *note 9.6.1(33/2): 4203, *note 9.6.1(34/2): 4204.
   <in> Ada.Execution_Time   *note D.14(8/2): 8006.
   <in> Ada.Real_Time   *note D.8(16): 7961.

Sqrt
   <in> Ada.Numerics.Generic_Complex_Elementary_Functions   *note
G.1.2(3): 8286.
   <in> Ada.Numerics.Generic_Elementary_Functions   *note A.5.1(4):
6111.

Standard_Error <in> Ada.Text_IO   *note A.10.1(16): 6398, *note
A.10.1(19): 6405.

Standard_Input <in> Ada.Text_IO   *note A.10.1(16): 6396, *note
A.10.1(19): 6403.

Standard_Output <in> Ada.Text_IO   *note A.10.1(16): 6397, *note
A.10.1(19): 6404.

Start_Search <in> Ada.Directories   *note A.16(32/2): 6662.

Storage_Size
   <in> System.Storage_Pools   *note 13.11(9): 5191.
   <in> System.Storage_Pools.Subpools   *note 13.11.4(16/3): 5268.

Stream
   <in> Ada.Streams.Stream_IO   *note A.12.1(13): 6585.
   <in> Ada.Text_IO.Text_Streams   *note A.12.2(4): 6606.
   <in> Ada.Wide_Text_IO.Text_Streams   *note A.12.3(4): 6609.
   <in> Ada.Wide_Wide_Text_IO.Text_Streams   *note A.12.4(4/2): 6612.

Strlen <in> Interfaces.C.Strings   *note B.3.1(17): 7510.

Sub_Second <in> Ada.Calendar.Formatting   *note 9.6.1(27/2): 4197.

Subtree_Node_Count
   <in> Ada.Containers.Multiway_Trees   *note A.18.10(18/3): 7211.

Supported
   <in> Ada.Execution_Time.Interrupts   *note D.14.3(3/3): 8057.

Suspend_Until_True
   <in> Ada.Synchronous_Task_Control   *note D.10(4): 7978.

Suspend_Until_True_And_Set_Deadline
   <in> Ada.Synchronous_Task_Control.EDF   *note D.10(5.2/3): 7980.

Swap
   <in> Ada.Containers.Doubly_Linked_Lists   *note A.18.3(28/2): 6851.
   <in> Ada.Containers.Multiway_Trees   *note A.18.10(37/3): 7230.
   <in> Ada.Containers.Vectors   *note A.18.2(55/2): 6778, *note
A.18.2(56/2): 6779.

Swap_Links
   <in> Ada.Containers.Doubly_Linked_Lists   *note A.18.3(29/2): 6852.

Symmetric_Difference
   <in> Ada.Containers.Hashed_Sets   *note A.18.8(35/2): 7074, *note
A.18.8(36/2): 7075.
   <in> Ada.Containers.Ordered_Sets   *note A.18.9(36/2): 7147, *note
A.18.9(37/2): 7148.

Tail
   <in> Ada.Strings.Bounded   *note A.4.4(72): 5897, *note A.4.4(73):
5898.
   <in> Ada.Strings.Fixed   *note A.4.3(37): 5840, *note A.4.3(38):
5841.
   <in> Ada.Strings.Unbounded   *note A.4.5(67): 5951, *note A.4.5(68):
5952.

Tan
   <in> Ada.Numerics.Generic_Complex_Elementary_Functions   *note
G.1.2(4): 8292.
   <in> Ada.Numerics.Generic_Elementary_Functions   *note A.5.1(5):
6119.

Tanh
   <in> Ada.Numerics.Generic_Complex_Elementary_Functions   *note
G.1.2(6): 8300.
   <in> Ada.Numerics.Generic_Elementary_Functions   *note A.5.1(7):
6133.

Time_Of
   <in> Ada.Calendar   *note 9.6(15): 4157.
   <in> Ada.Calendar.Formatting   *note 9.6.1(30/2): 4200, *note
9.6.1(31/2): 4201.
   <in> Ada.Execution_Time   *note D.14(9/2): 8007.
   <in> Ada.Real_Time   *note D.8(16): 7962.

Time_Of_Event
   <in> Ada.Real_Time.Timing_Events   *note D.15(6/2): 8065.

Time_Remaining
   <in> Ada.Execution_Time.Timers   *note D.14.1(8/2): 8023.

To_Ada
   <in> Interfaces.C   *note B.3(22): 7454, *note B.3(26): 7458, *note
B.3(28): 7460, *note B.3(32): 7464, *note B.3(37): 7468, *note B.3(39):
7470, *note B.3(39.10/2): 7480, *note B.3(39.13/2): 7484, *note
B.3(39.17/2): 7488, *note B.3(39.19/2): 7490, *note B.3(39.4/2): 7474,
*note B.3(39.8/2): 7478.
   <in> Interfaces.COBOL   *note B.4(17): 7559, *note B.4(19): 7561.
   <in> Interfaces.Fortran   *note B.5(13): 7612, *note B.5(14): 7614,
*note B.5(16): 7616.

To_Address
   <in> System.Address_To_Access_Conversions   *note 13.7.2(3/3): 5146.
   <in> System.Storage_Elements   *note 13.7.1(10/3): 5139.

To_Basic <in> Ada.Characters.Handling   *note A.3.2(6): 5479, *note
A.3.2(7): 5482.

To_Binary <in> Interfaces.COBOL   *note B.4(45): 7591, *note B.4(48):
7594.

To_Bounded_String
   <in> Ada.Strings.Bounded   *note A.4.4(11): 5850.

To_C <in> Interfaces.C   *note B.3(21): 7453, *note B.3(25): 7457, *note
B.3(27): 7459, *note B.3(32): 7463, *note B.3(36): 7467, *note B.3(38):
7469, *note B.3(39.13/2): 7483, *note B.3(39.16/2): 7487, *note
B.3(39.18/2): 7489, *note B.3(39.4/2): 7473, *note B.3(39.7/2): 7477,
*note B.3(39.9/2): 7479.

To_Character
   <in> Ada.Characters.Conversions   *note A.3.4(5/2): 5744.

To_Chars_Ptr <in> Interfaces.C.Strings   *note B.3.1(8): 7501.

To_COBOL <in> Interfaces.COBOL   *note B.4(17): 7558, *note B.4(18):
7560.

To_Cursor <in> Ada.Containers.Vectors   *note A.18.2(25/2): 6741.

To_Decimal <in> Interfaces.COBOL   *note B.4(35): 7582, *note B.4(40):
7586, *note B.4(44): 7590, *note B.4(47): 7592.

To_Display <in> Interfaces.COBOL   *note B.4(36): 7583.

To_Domain
   <in> Ada.Strings.Maps   *note A.4.2(24): 5801.
   <in> Ada.Strings.Wide_Maps   *note A.4.7(24): 6003.
   <in> Ada.Strings.Wide_Wide_Maps   *note A.4.8(24/2): 6042.

To_Duration <in> Ada.Real_Time   *note D.8(13): 7953.

To_Fortran <in> Interfaces.Fortran   *note B.5(13): 7611, *note B.5(14):
7613, *note B.5(15): 7615.

To_Holder
   <in> Ada.Containers.Indefinite_Holders   *note A.18.18(9/3): 7287.

To_Index <in> Ada.Containers.Vectors   *note A.18.2(26/2): 6742.

To_Integer <in> System.Storage_Elements   *note 13.7.1(10/3): 5140.

To_ISO_646 <in> Ada.Characters.Handling   *note A.3.2(11): 5486, *note
A.3.2(12): 5487.

To_Long_Binary <in> Interfaces.COBOL   *note B.4(48): 7595.

To_Lower
   <in> Ada.Characters.Handling   *note A.3.2(6): 5477, *note A.3.2(7):
5480.
   <in> Ada.Wide_Characters.Handling   *note A.3.5(20/3): 5765, *note
A.3.5(21/3): 5767.

To_Mapping
   <in> Ada.Strings.Maps   *note A.4.2(23): 5800.
   <in> Ada.Strings.Wide_Maps   *note A.4.7(23): 6002.
   <in> Ada.Strings.Wide_Wide_Maps   *note A.4.8(23/2): 6041.

To_Packed <in> Interfaces.COBOL   *note B.4(41): 7587.

To_Picture <in> Ada.Text_IO.Editing   *note F.3.3(6): 8237.

To_Pointer
   <in> System.Address_To_Access_Conversions   *note 13.7.2(3/3): 5145.

To_Range
   <in> Ada.Strings.Maps   *note A.4.2(24): 5802.
   <in> Ada.Strings.Wide_Maps   *note A.4.7(25): 6004.
   <in> Ada.Strings.Wide_Wide_Maps   *note A.4.8(25/2): 6043.

To_Ranges
   <in> Ada.Strings.Maps   *note A.4.2(10): 5790.
   <in> Ada.Strings.Wide_Maps   *note A.4.7(10): 5992.
   <in> Ada.Strings.Wide_Wide_Maps   *note A.4.8(10/2): 6031.

To_Sequence
   <in> Ada.Strings.Maps   *note A.4.2(19): 5796.
   <in> Ada.Strings.Wide_Maps   *note A.4.7(19): 5998.
   <in> Ada.Strings.Wide_Wide_Maps   *note A.4.8(19/2): 6037.

To_Set
   <in> Ada.Containers.Hashed_Sets   *note A.18.8(9/2): 7048.
   <in> Ada.Containers.Ordered_Sets   *note A.18.9(10/2): 7121.
   <in> Ada.Strings.Maps   *note A.4.2(8): 5788, *note A.4.2(9): 5789,
*note A.4.2(17): 5794, *note A.4.2(18): 5795.
   <in> Ada.Strings.Wide_Maps   *note A.4.7(8): 5990, *note A.4.7(9):
5991, *note A.4.7(17): 5996, *note A.4.7(18): 5997.
   <in> Ada.Strings.Wide_Wide_Maps   *note A.4.8(8/2): 6029, *note
A.4.8(9/2): 6030, *note A.4.8(17/2): 6035, *note A.4.8(18/2): 6036.

To_String
   <in> Ada.Characters.Conversions   *note A.3.4(5/2): 5743.
   <in> Ada.Strings.Bounded   *note A.4.4(12): 5851.
   <in> Ada.Strings.Unbounded   *note A.4.5(11): 5910.

To_Time_Span <in> Ada.Real_Time   *note D.8(13): 7954.

To_Unbounded_String
   <in> Ada.Strings.Unbounded   *note A.4.5(9): 5908, *note A.4.5(10):
5909.

To_Upper
   <in> Ada.Characters.Handling   *note A.3.2(6): 5478, *note A.3.2(7):
5481.
   <in> Ada.Wide_Characters.Handling   *note A.3.5(20/3): 5766, *note
A.3.5(21/3): 5768.

To_Vector <in> Ada.Containers.Vectors   *note A.18.2(13/2): 6733, *note
A.18.2(14/2): 6734.

To_Wide_Character
   <in> Ada.Characters.Conversions   *note A.3.4(4/2): 5736, *note
A.3.4(5/2): 5746.

To_Wide_String
   <in> Ada.Characters.Conversions   *note A.3.4(4/2): 5737, *note
A.3.4(5/2): 5747.

To_Wide_Wide_Character
   <in> Ada.Characters.Conversions   *note A.3.4(4/2): 5740.

To_Wide_Wide_String
   <in> Ada.Characters.Conversions   *note A.3.4(4/2): 5741.

Translate
   <in> Ada.Strings.Bounded   *note A.4.4(53): 5879, *note A.4.4(54):
5880, *note A.4.4(55): 5881, *note A.4.4(56): 5882.
   <in> Ada.Strings.Fixed   *note A.4.3(18): 5822, *note A.4.3(19):
5823, *note A.4.3(20): 5824, *note A.4.3(21): 5825.
   <in> Ada.Strings.Unbounded   *note A.4.5(48): 5933, *note A.4.5(49):
5934, *note A.4.5(50): 5935, *note A.4.5(51): 5936.

Transpose
   <in> Ada.Numerics.Generic_Complex_Arrays   *note G.3.2(34/2): 8414.
   <in> Ada.Numerics.Generic_Real_Arrays   *note G.3.1(17/2): 8374.

Trim
   <in> Ada.Strings.Bounded   *note A.4.4(67): 5891, *note A.4.4(68):
5893, *note A.4.4(69): 5894.
   <in> Ada.Strings.Fixed   *note A.4.3(31): 5834, *note A.4.3(32):
5835, *note A.4.3(33): 5836, *note A.4.3(34): 5837.
   <in> Ada.Strings.Unbounded   *note A.4.5(61): 5945, *note A.4.5(62):
5946, *note A.4.5(63): 5947, *note A.4.5(64): 5948.

Unbounded_Slice
   <in> Ada.Strings.Unbounded   *note A.4.5(22.1/2): 5918, *note
A.4.5(22.2/2): 5919.

Unchecked_Conversion
   <child of> Ada   *note 13.9(3/3): 5159.

Unchecked_Deallocation
   <child of> Ada   *note 13.11.2(3/3): 5228.

Union
   <in> Ada.Containers.Hashed_Sets   *note A.18.8(26/2): 7068, *note
A.18.8(27/2): 7069.
   <in> Ada.Containers.Ordered_Sets   *note A.18.9(27/2): 7141, *note
A.18.9(28/2): 7142.

Unit_Matrix
   <in> Ada.Numerics.Generic_Complex_Arrays   *note G.3.2(51/2): 8421.
   <in> Ada.Numerics.Generic_Real_Arrays   *note G.3.1(29/2): 8381.

Unit_Vector
   <in> Ada.Numerics.Generic_Complex_Arrays   *note G.3.2(24/2): 8401.
   <in> Ada.Numerics.Generic_Real_Arrays   *note G.3.1(14/2): 8373.

Update <in> Interfaces.C.Strings   *note B.3.1(18): 7511, *note
B.3.1(19): 7512.

Update_Element
   <in> Ada.Containers.Doubly_Linked_Lists   *note A.18.3(17/2): 6835.
   <in> Ada.Containers.Hashed_Maps   *note A.18.5(17/2): 6924.
   <in> Ada.Containers.Indefinite_Holders   *note A.18.18(15/3): 7293.
   <in> Ada.Containers.Multiway_Trees   *note A.18.10(27/3): 7220.
   <in> Ada.Containers.Ordered_Maps   *note A.18.6(16/2): 6975.
   <in> Ada.Containers.Vectors   *note A.18.2(33/2): 6749, *note
A.18.2(34/2): 6750.

Update_Element_Preserving_Key
   <in> Ada.Containers.Hashed_Sets   *note A.18.8(58/2): 7095.
   <in> Ada.Containers.Ordered_Sets   *note A.18.9(73/2): 7176.

Update_Error <in> Interfaces.C.Strings   *note B.3.1(20): 7513.

UTC_Time_Offset
   <in> Ada.Calendar.Time_Zones   *note 9.6.1(6/2): 4172.

Valid
   <in> Ada.Text_IO.Editing   *note F.3.3(5): 8236, *note F.3.3(12):
8248.
   <in> Interfaces.COBOL   *note B.4(33): 7580, *note B.4(38): 7584,
*note B.4(43): 7588.

Value
   <in> Ada.Calendar.Formatting   *note 9.6.1(36/2): 4206, *note
9.6.1(38/2): 4208.
   <in> Ada.Environment_Variables   *note A.17(4.1/3): 6701, *note
A.17(4/2): 6700.
   <in> Ada.Numerics.Discrete_Random   *note A.5.2(26): 6170.
   <in> Ada.Numerics.Float_Random   *note A.5.2(14): 6158.
   <in> Ada.Strings.Maps   *note A.4.2(21): 5798.
   <in> Ada.Strings.Wide_Maps   *note A.4.7(21): 6000.
   <in> Ada.Strings.Wide_Wide_Maps   *note A.4.8(21/2): 6039.
   <in> Ada.Task_Attributes   *note C.7.2(4): 7730.
   <in> Interfaces.C.Pointers   *note B.3.2(6): 7520, *note B.3.2(7):
7521.
   <in> Interfaces.C.Strings   *note B.3.1(13): 7506, *note B.3.1(14):
7507, *note B.3.1(15): 7508, *note B.3.1(16): 7509.

Virtual_Length
   <in> Interfaces.C.Pointers   *note B.3.2(13): 7525.

Wait_For_Release
   <in> Ada.Synchronous_Barriers   *note D.10.1(6/3): 7987.

Wide_Equal_Case_Insensitive
   <child of> Ada.Strings.Wide_Bounded   *note A.4.7(1/3): 5978.
   <child of> Ada.Strings.Wide_Fixed   *note A.4.7(1/3): 5977.
   <child of> Ada.Strings.Wide_Unbounded   *note A.4.7(1/3): 5979.

Wide_Hash
   <child of> Ada.Strings.Wide_Bounded   *note A.4.7(1/3): 5974.
   <child of> Ada.Strings.Wide_Fixed   *note A.4.7(1/3): 5973.
   <child of> Ada.Strings.Wide_Unbounded   *note A.4.7(1/3): 5975.

Wide_Hash_Case_Insensitive
   <child of> Ada.Strings.Wide_Bounded   *note A.4.7(1/3): 5982.
   <child of> Ada.Strings.Wide_Fixed   *note A.4.7(1/3): 5981.
   <child of> Ada.Strings.Wide_Unbounded   *note A.4.7(1/3): 5983.

Wide_Exception_Name <in> Ada.Exceptions   *note 11.4.1(2/2): 4568, *note
11.4.1(5/2): 4578.

Wide_Expanded_Name <in> Ada.Tags   *note 3.9(7/2): 2104.

Wide_Wide_Equal_Case_Insensitive
   <child of> Ada.Strings.Wide_Wide_Bounded   *note A.4.8(1/3): 6017.
   <child of> Ada.Strings.Wide_Wide_Fixed   *note A.4.8(1/3): 6016.
   <child of> Ada.Strings.Wide_Wide_Unbounded   *note A.4.8(1/3): 6018.

Wide_Wide_Hash
   <child of> Ada.Strings.Wide_Wide_Bounded   *note A.4.8(1/3): 6013.
   <child of> Ada.Strings.Wide_Wide_Fixed   *note A.4.8(1/3): 6012.
   <child of> Ada.Strings.Wide_Wide_Unbounded   *note A.4.8(1/3): 6014.

Wide_Wide_Hash_Case_Insensitive
   <child of> Ada.Strings.Wide_Wide_Bounded   *note A.4.8(1/3): 6021.
   <child of> Ada.Strings.Wide_Wide_Fixed   *note A.4.8(1/3): 6020.
   <child of> Ada.Strings.Wide_Wide_Unbounded   *note A.4.8(1/3): 6022.

Wide_Wide_Exception_Name
   <in> Ada.Exceptions   *note 11.4.1(2/2): 4569, *note 11.4.1(5/2):
4579.

Wide_Wide_Expanded_Name <in> Ada.Tags   *note 3.9(7/2): 2105.

Write
   <in> Ada.Direct_IO   *note A.8.4(13): 6341.
   <in> Ada.Sequential_IO   *note A.8.1(12): 6313.
   <in> Ada.Storage_IO   *note A.9(7): 6359.
   <in> Ada.Streams   *note 13.13.1(6): 5341.
   <in> Ada.Streams.Stream_IO   *note A.12.1(18): 6588, *note
A.12.1(19): 6589.
   <in> System.RPC   *note E.5(8): 8209.

Year
   <in> Ada.Calendar   *note 9.6(13): 4152.
   <in> Ada.Calendar.Formatting   *note 9.6.1(21/2): 4191.

Yield <in> Ada.Dispatching   *note D.2.1(1.3/3): 7770.

Yield_To_Higher
   <in> Ada.Dispatching.Non_Preemptive   *note D.2.4(2.2/3): 7807.

Yield_To_Same_Or_Higher
   <in> Ada.Dispatching.Non_Preemptive   *note D.2.4(2.2/3): 7808.


File: arm2012.info,  Node: Q.4,  Next: Q.5,  Prev: Q.3,  Up: Annex Q

Q.4 Language-Defined Exceptions
===============================

1/3
This subclause lists all language-defined exceptions.

 

Argument_Error
   <in> Ada.Numerics   *note A.5(3/2): 6107.

Assertion_Error
   <in> Ada.Assertions   *note 11.4.2(13/2): 4605.

Capacity_Error
   <in> Ada.Containers   *note A.18.1(5.1/3): 6718.

Communication_Error
   <in> System.RPC   *note E.5(5): 8206.

Constraint_Error
   <in> Standard   *note A.1(46): 5451.

Conversion_Error
   <in> Interfaces.COBOL   *note B.4(30): 7578.

Data_Error
   <in> Ada.Direct_IO   *note A.8.4(18): 6353.
   <in> Ada.IO_Exceptions   *note A.13(4): 6620.
   <in> Ada.Sequential_IO   *note A.8.1(15): 6321.
   <in> Ada.Storage_IO   *note A.9(9): 6360.
   <in> Ada.Streams.Stream_IO   *note A.12.1(26): 6601.
   <in> Ada.Text_IO   *note A.10.1(85): 6526.

Device_Error
   <in> Ada.Direct_IO   *note A.8.4(18): 6351.
   <in> Ada.Directories   *note A.16(43/2): 6674.
   <in> Ada.IO_Exceptions   *note A.13(4): 6618.
   <in> Ada.Sequential_IO   *note A.8.1(15): 6319.
   <in> Ada.Streams.Stream_IO   *note A.12.1(26): 6599.
   <in> Ada.Text_IO   *note A.10.1(85): 6524.

Dispatching_Domain_Error
   <in> System.Multiprocessors.Dispatching_Domains   *note D.16.1(4/3):
8078.

Dispatching_Policy_Error
   <in> Ada.Dispatching   *note D.2.1(1.4/3): 7771.

Encoding_Error
   <in> Ada.Strings.UTF_Encoding   *note A.4.11(8/3): 6069.

End_Error
   <in> Ada.Direct_IO   *note A.8.4(18): 6352.
   <in> Ada.IO_Exceptions   *note A.13(4): 6619.
   <in> Ada.Sequential_IO   *note A.8.1(15): 6320.
   <in> Ada.Streams.Stream_IO   *note A.12.1(26): 6600.
   <in> Ada.Text_IO   *note A.10.1(85): 6525.

Group_Budget_Error
   <in> Ada.Execution_Time.Group_Budgets   *note D.14.2(11/2): 8047.

Index_Error
   <in> Ada.Strings   *note A.4.1(5): 5776.

Layout_Error
   <in> Ada.IO_Exceptions   *note A.13(4): 6621.
   <in> Ada.Text_IO   *note A.10.1(85): 6527.

Length_Error
   <in> Ada.Strings   *note A.4.1(5): 5774.

Mode_Error
   <in> Ada.Direct_IO   *note A.8.4(18): 6348.
   <in> Ada.IO_Exceptions   *note A.13(4): 6615.
   <in> Ada.Sequential_IO   *note A.8.1(15): 6316.
   <in> Ada.Streams.Stream_IO   *note A.12.1(26): 6596.
   <in> Ada.Text_IO   *note A.10.1(85): 6521.

Name_Error
   <in> Ada.Direct_IO   *note A.8.4(18): 6349.
   <in> Ada.Directories   *note A.16(43/2): 6672.
   <in> Ada.IO_Exceptions   *note A.13(4): 6616.
   <in> Ada.Sequential_IO   *note A.8.1(15): 6317.
   <in> Ada.Streams.Stream_IO   *note A.12.1(26): 6597.
   <in> Ada.Text_IO   *note A.10.1(85): 6522.

Pattern_Error
   <in> Ada.Strings   *note A.4.1(5): 5775.

Picture_Error
   <in> Ada.Text_IO.Editing   *note F.3.3(9): 8241.

Pointer_Error
   <in> Interfaces.C.Pointers   *note B.3.2(8): 7522.

Program_Error
   <in> Standard   *note A.1(46): 5452.

Status_Error
   <in> Ada.Direct_IO   *note A.8.4(18): 6347.
   <in> Ada.Directories   *note A.16(43/2): 6671.
   <in> Ada.IO_Exceptions   *note A.13(4): 6614.
   <in> Ada.Sequential_IO   *note A.8.1(15): 6315.
   <in> Ada.Streams.Stream_IO   *note A.12.1(26): 6595.
   <in> Ada.Text_IO   *note A.10.1(85): 6520.

Storage_Error
   <in> Standard   *note A.1(46): 5453.

Tag_Error
   <in> Ada.Tags   *note 3.9(8): 2114.

Tasking_Error
   <in> Standard   *note A.1(46): 5454.

Terminator_Error
   <in> Interfaces.C   *note B.3(40): 7491.

Time_Error
   <in> Ada.Calendar   *note 9.6(18): 4158.

Timer_Resource_Error
   <in> Ada.Execution_Time.Timers   *note D.14.1(9/2): 8024.

Translation_Error
   <in> Ada.Strings   *note A.4.1(5): 5777.

Unknown_Zone_Error
   <in> Ada.Calendar.Time_Zones   *note 9.6.1(5/2): 4171.

Use_Error
   <in> Ada.Direct_IO   *note A.8.4(18): 6350.
   <in> Ada.Directories   *note A.16(43/2): 6673.
   <in> Ada.IO_Exceptions   *note A.13(4): 6617.
   <in> Ada.Sequential_IO   *note A.8.1(15): 6318.
   <in> Ada.Streams.Stream_IO   *note A.12.1(26): 6598.
   <in> Ada.Text_IO   *note A.10.1(85): 6523.


File: arm2012.info,  Node: Q.5,  Prev: Q.4,  Up: Annex Q

Q.5 Language-Defined Objects
============================

1/3
This subclause lists all language-defined constants, variables, named
numbers, and enumeration literals.

 

ACK <in> Ada.Characters.Latin_1   *note A.3.3(5): 5506.

Acute <in> Ada.Characters.Latin_1   *note A.3.3(22): 5652.

Ada_To_COBOL <in> Interfaces.COBOL   *note B.4(14): 7555.

Alphanumeric_Set
   <in> Ada.Strings.Maps.Constants   *note A.4.6(4): 5963.

Ampersand <in> Ada.Characters.Latin_1   *note A.3.3(8): 5538.

APC <in> Ada.Characters.Latin_1   *note A.3.3(19): 5629.

Apostrophe <in> Ada.Characters.Latin_1   *note A.3.3(8): 5539.

Asterisk <in> Ada.Characters.Latin_1   *note A.3.3(8): 5542.

Basic_Map
   <in> Ada.Strings.Maps.Constants   *note A.4.6(5): 5968.

Basic_Set
   <in> Ada.Strings.Maps.Constants   *note A.4.6(4): 5960.

BEL <in> Ada.Characters.Latin_1   *note A.3.3(5): 5507.

BOM_16 <in> Ada.Strings.UTF_Encoding   *note A.4.11(12/3): 6073.

BOM_16BE <in> Ada.Strings.UTF_Encoding   *note A.4.11(10/3): 6071.

BOM_16LE <in> Ada.Strings.UTF_Encoding   *note A.4.11(11/3): 6072.

BOM_8 <in> Ada.Strings.UTF_Encoding   *note A.4.11(9/3): 6070.

BPH <in> Ada.Characters.Latin_1   *note A.3.3(17): 5600.

Broken_Bar <in> Ada.Characters.Latin_1   *note A.3.3(21/3): 5637.

BS <in> Ada.Characters.Latin_1   *note A.3.3(5): 5508.

Buffer_Size <in> Ada.Storage_IO   *note A.9(4): 6356.

CAN <in> Ada.Characters.Latin_1   *note A.3.3(6): 5524.

CCH <in> Ada.Characters.Latin_1   *note A.3.3(18): 5618.

Cedilla <in> Ada.Characters.Latin_1   *note A.3.3(22): 5657.

Cent_Sign <in> Ada.Characters.Latin_1   *note A.3.3(21/3): 5633.

char16_nul <in> Interfaces.C   *note B.3(39.3/2): 7472.

char32_nul <in> Interfaces.C   *note B.3(39.12/2): 7482.

CHAR_BIT <in> Interfaces.C   *note B.3(6): 7433.

Character_Set
   <in> Ada.Strings.Wide_Maps   *note A.4.7(46/2): 6006.
   <in> Ada.Strings.Wide_Maps.Wide_Constants   *note A.4.8(48/2): 6046.

Circumflex <in> Ada.Characters.Latin_1   *note A.3.3(12): 5559.

COBOL_To_Ada <in> Interfaces.COBOL   *note B.4(15): 7556.

Colon <in> Ada.Characters.Latin_1   *note A.3.3(10): 5549.

Comma <in> Ada.Characters.Latin_1   *note A.3.3(8): 5544.

Commercial_At
   <in> Ada.Characters.Latin_1   *note A.3.3(10): 5555.

Control_Set
   <in> Ada.Strings.Maps.Constants   *note A.4.6(4): 5955.

Copyright_Sign
   <in> Ada.Characters.Latin_1   *note A.3.3(21/3): 5640.

Country_Unknown <in> Ada.Locales   *note A.19(5/3): 7374.

CPU_Tick <in> Ada.Execution_Time   *note D.14(4/2): 8004.

CPU_Time_First <in> Ada.Execution_Time   *note D.14(4/2): 8001.

CPU_Time_Last <in> Ada.Execution_Time   *note D.14(4/2): 8002.

CPU_Time_Unit <in> Ada.Execution_Time   *note D.14(4/2): 8003.

CR <in> Ada.Characters.Latin_1   *note A.3.3(5): 5513.

CSI <in> Ada.Characters.Latin_1   *note A.3.3(19): 5625.

Currency_Sign
   <in> Ada.Characters.Latin_1   *note A.3.3(21/3): 5635.

DC1 <in> Ada.Characters.Latin_1   *note A.3.3(6): 5517.

DC2 <in> Ada.Characters.Latin_1   *note A.3.3(6): 5518.

DC3 <in> Ada.Characters.Latin_1   *note A.3.3(6): 5519.

DC4 <in> Ada.Characters.Latin_1   *note A.3.3(6): 5520.

DCS <in> Ada.Characters.Latin_1   *note A.3.3(18): 5614.

Decimal_Digit_Set
   <in> Ada.Strings.Maps.Constants   *note A.4.6(4): 5961.

Default_Aft
   <in> Ada.Text_IO   *note A.10.1(64): 6483, *note A.10.1(69): 6493,
*note A.10.1(74): 6503.
   <in> Ada.Text_IO.Complex_IO   *note G.1.3(5): 8316.

Default_Base <in> Ada.Text_IO   *note A.10.1(53): 6465, *note
A.10.1(58): 6474.

Default_Bit_Order <in> System   *note 13.7(15/2): 5126.

Default_Currency
   <in> Ada.Text_IO.Editing   *note F.3.3(10): 8242.

Default_Deadline
   <in> Ada.Dispatching.EDF   *note D.2.6(9/2): 7823.

Default_Exp
   <in> Ada.Text_IO   *note A.10.1(64): 6484, *note A.10.1(69): 6494,
*note A.10.1(74): 6504.
   <in> Ada.Text_IO.Complex_IO   *note G.1.3(5): 8317.

Default_Fill <in> Ada.Text_IO.Editing   *note F.3.3(10): 8243.

Default_Fore
   <in> Ada.Text_IO   *note A.10.1(64): 6482, *note A.10.1(69): 6492,
*note A.10.1(74): 6502.
   <in> Ada.Text_IO.Complex_IO   *note G.1.3(5): 8315.

Default_Priority <in> System   *note 13.7(17): 5130.

Default_Quantum
   <in> Ada.Dispatching.Round_Robin   *note D.2.5(4/2): 7814.

Default_Radix_Mark
   <in> Ada.Text_IO.Editing   *note F.3.3(10): 8245.

Default_Separator
   <in> Ada.Text_IO.Editing   *note F.3.3(10): 8244.

Default_Setting <in> Ada.Text_IO   *note A.10.1(80): 6513.

Default_Width <in> Ada.Text_IO   *note A.10.1(53): 6464, *note
A.10.1(58): 6473, *note A.10.1(80): 6512.

Degree_Sign <in> Ada.Characters.Latin_1   *note A.3.3(22): 5647.

DEL <in> Ada.Characters.Latin_1   *note A.3.3(14): 5592.

Diaeresis <in> Ada.Characters.Latin_1   *note A.3.3(21/3): 5639.

Division_Sign
   <in> Ada.Characters.Latin_1   *note A.3.3(26): 5720.

DLE <in> Ada.Characters.Latin_1   *note A.3.3(6): 5516.

Dollar_Sign <in> Ada.Characters.Latin_1   *note A.3.3(8): 5536.

e <in> Ada.Numerics   *note A.5(3/2): 6109.

EM <in> Ada.Characters.Latin_1   *note A.3.3(6): 5525.

Empty_Holder
   <in> Ada.Containers.Indefinite_Holders   *note A.18.18(7/3): 7286.

Empty_List
   <in> Ada.Containers.Doubly_Linked_Lists   *note A.18.3(8/2): 6825.

Empty_Map
   <in> Ada.Containers.Hashed_Maps   *note A.18.5(5/2): 6911.
   <in> Ada.Containers.Ordered_Maps   *note A.18.6(6/2): 6964.

Empty_Set
   <in> Ada.Containers.Hashed_Sets   *note A.18.8(5/2): 7043.
   <in> Ada.Containers.Ordered_Sets   *note A.18.9(6/2): 7116.

Empty_Tree
   <in> Ada.Containers.Multiway_Trees   *note A.18.10(10/3): 7204.

Empty_Vector
   <in> Ada.Containers.Vectors   *note A.18.2(10/2): 6729.

ENQ <in> Ada.Characters.Latin_1   *note A.3.3(5): 5505.

EOT <in> Ada.Characters.Latin_1   *note A.3.3(5): 5504.

EPA <in> Ada.Characters.Latin_1   *note A.3.3(18): 5621.

Equals_Sign <in> Ada.Characters.Latin_1   *note A.3.3(10): 5552.

ESA <in> Ada.Characters.Latin_1   *note A.3.3(17): 5605.

ESC <in> Ada.Characters.Latin_1   *note A.3.3(6): 5527.

ETB <in> Ada.Characters.Latin_1   *note A.3.3(6): 5523.

ETX <in> Ada.Characters.Latin_1   *note A.3.3(5): 5503.

Exclamation <in> Ada.Characters.Latin_1   *note A.3.3(8): 5533.

Failure <in> Ada.Command_Line   *note A.15(8): 6632.

Feminine_Ordinal_Indicator
   <in> Ada.Characters.Latin_1   *note A.3.3(21/3): 5641.

FF <in> Ada.Characters.Latin_1   *note A.3.3(5): 5512.

Fine_Delta <in> System   *note 13.7(9): 5115.

Fraction_One_Half
   <in> Ada.Characters.Latin_1   *note A.3.3(22): 5662.

Fraction_One_Quarter
   <in> Ada.Characters.Latin_1   *note A.3.3(22): 5661.

Fraction_Three_Quarters
   <in> Ada.Characters.Latin_1   *note A.3.3(22): 5663.

Friday <in> Ada.Calendar.Formatting   *note 9.6.1(17/2): 4183.

FS <in> Ada.Characters.Latin_1   *note A.3.3(6): 5528.

Full_Stop <in> Ada.Characters.Latin_1   *note A.3.3(8): 5547.

Graphic_Set
   <in> Ada.Strings.Maps.Constants   *note A.4.6(4): 5956.

Grave <in> Ada.Characters.Latin_1   *note A.3.3(13): 5561.

Greater_Than_Sign
   <in> Ada.Characters.Latin_1   *note A.3.3(10): 5553.

GS <in> Ada.Characters.Latin_1   *note A.3.3(6): 5529.

Hexadecimal_Digit_Set
   <in> Ada.Strings.Maps.Constants   *note A.4.6(4): 5962.

High_Order_First
   <in> Interfaces.COBOL   *note B.4(25): 7570.
   <in> System   *note 13.7(15/2): 5124.

HT <in> Ada.Characters.Latin_1   *note A.3.3(5): 5509.

HTJ <in> Ada.Characters.Latin_1   *note A.3.3(17): 5607.

HTS <in> Ada.Characters.Latin_1   *note A.3.3(17): 5606.

Hyphen <in> Ada.Characters.Latin_1   *note A.3.3(8): 5545.

i
   <in> Ada.Numerics.Generic_Complex_Types   *note G.1.1(5): 8261.
   <in> Interfaces.Fortran   *note B.5(10): 7607.

Identity
   <in> Ada.Strings.Maps   *note A.4.2(22): 5799.
   <in> Ada.Strings.Wide_Maps   *note A.4.7(22): 6001.
   <in> Ada.Strings.Wide_Wide_Maps   *note A.4.8(22/2): 6040.

Interrupt_Clocks_Supported
   <in> Ada.Execution_Time   *note D.14(9.1/3): 8008.

Inverted_Exclamation
   <in> Ada.Characters.Latin_1   *note A.3.3(21/3): 5632.

Inverted_Question
   <in> Ada.Characters.Latin_1   *note A.3.3(22): 5664.

IS1 <in> Ada.Characters.Latin_1   *note A.3.3(16): 5597.

IS2 <in> Ada.Characters.Latin_1   *note A.3.3(16): 5596.

IS3 <in> Ada.Characters.Latin_1   *note A.3.3(16): 5595.

IS4 <in> Ada.Characters.Latin_1   *note A.3.3(16): 5594.

ISO_646_Set
   <in> Ada.Strings.Maps.Constants   *note A.4.6(4): 5965.

j
   <in> Ada.Numerics.Generic_Complex_Types   *note G.1.1(5): 8262.
   <in> Interfaces.Fortran   *note B.5(10): 7608.

Language_Unknown <in> Ada.Locales   *note A.19(5/3): 7373.

LC_A <in> Ada.Characters.Latin_1   *note A.3.3(13): 5562.

LC_A_Acute <in> Ada.Characters.Latin_1   *note A.3.3(25): 5698.

LC_A_Circumflex
   <in> Ada.Characters.Latin_1   *note A.3.3(25): 5699.

LC_A_Diaeresis
   <in> Ada.Characters.Latin_1   *note A.3.3(25): 5701.

LC_A_Grave <in> Ada.Characters.Latin_1   *note A.3.3(25): 5697.

LC_A_Ring <in> Ada.Characters.Latin_1   *note A.3.3(25): 5702.

LC_A_Tilde <in> Ada.Characters.Latin_1   *note A.3.3(25): 5700.

LC_AE_Diphthong
   <in> Ada.Characters.Latin_1   *note A.3.3(25): 5703.

LC_B <in> Ada.Characters.Latin_1   *note A.3.3(13): 5563.

LC_C <in> Ada.Characters.Latin_1   *note A.3.3(13): 5564.

LC_C_Cedilla
   <in> Ada.Characters.Latin_1   *note A.3.3(25): 5704.

LC_D <in> Ada.Characters.Latin_1   *note A.3.3(13): 5565.

LC_E <in> Ada.Characters.Latin_1   *note A.3.3(13): 5566.

LC_E_Acute <in> Ada.Characters.Latin_1   *note A.3.3(25): 5706.

LC_E_Circumflex
   <in> Ada.Characters.Latin_1   *note A.3.3(25): 5707.

LC_E_Diaeresis
   <in> Ada.Characters.Latin_1   *note A.3.3(25): 5708.

LC_E_Grave <in> Ada.Characters.Latin_1   *note A.3.3(25): 5705.

LC_F <in> Ada.Characters.Latin_1   *note A.3.3(13): 5567.

LC_G <in> Ada.Characters.Latin_1   *note A.3.3(13): 5568.

LC_German_Sharp_S
   <in> Ada.Characters.Latin_1   *note A.3.3(24): 5696.

LC_H <in> Ada.Characters.Latin_1   *note A.3.3(13): 5569.

LC_I <in> Ada.Characters.Latin_1   *note A.3.3(13): 5570.

LC_I_Acute <in> Ada.Characters.Latin_1   *note A.3.3(25): 5710.

LC_I_Circumflex
   <in> Ada.Characters.Latin_1   *note A.3.3(25): 5711.

LC_I_Diaeresis
   <in> Ada.Characters.Latin_1   *note A.3.3(25): 5712.

LC_I_Grave <in> Ada.Characters.Latin_1   *note A.3.3(25): 5709.

LC_Icelandic_Eth
   <in> Ada.Characters.Latin_1   *note A.3.3(26): 5713.

LC_Icelandic_Thorn
   <in> Ada.Characters.Latin_1   *note A.3.3(26): 5727.

LC_J <in> Ada.Characters.Latin_1   *note A.3.3(13): 5571.

LC_K <in> Ada.Characters.Latin_1   *note A.3.3(13): 5572.

LC_L <in> Ada.Characters.Latin_1   *note A.3.3(13): 5573.

LC_M <in> Ada.Characters.Latin_1   *note A.3.3(13): 5574.

LC_N <in> Ada.Characters.Latin_1   *note A.3.3(13): 5575.

LC_N_Tilde <in> Ada.Characters.Latin_1   *note A.3.3(26): 5714.

LC_O <in> Ada.Characters.Latin_1   *note A.3.3(13): 5576.

LC_O_Acute <in> Ada.Characters.Latin_1   *note A.3.3(26): 5716.

LC_O_Circumflex
   <in> Ada.Characters.Latin_1   *note A.3.3(26): 5717.

LC_O_Diaeresis
   <in> Ada.Characters.Latin_1   *note A.3.3(26): 5719.

LC_O_Grave <in> Ada.Characters.Latin_1   *note A.3.3(26): 5715.

LC_O_Oblique_Stroke
   <in> Ada.Characters.Latin_1   *note A.3.3(26): 5721.

LC_O_Tilde <in> Ada.Characters.Latin_1   *note A.3.3(26): 5718.

LC_P <in> Ada.Characters.Latin_1   *note A.3.3(14): 5577.

LC_Q <in> Ada.Characters.Latin_1   *note A.3.3(14): 5578.

LC_R <in> Ada.Characters.Latin_1   *note A.3.3(14): 5579.

LC_S <in> Ada.Characters.Latin_1   *note A.3.3(14): 5580.

LC_T <in> Ada.Characters.Latin_1   *note A.3.3(14): 5581.

LC_U <in> Ada.Characters.Latin_1   *note A.3.3(14): 5582.

LC_U_Acute <in> Ada.Characters.Latin_1   *note A.3.3(26): 5723.

LC_U_Circumflex
   <in> Ada.Characters.Latin_1   *note A.3.3(26): 5724.

LC_U_Diaeresis
   <in> Ada.Characters.Latin_1   *note A.3.3(26): 5725.

LC_U_Grave <in> Ada.Characters.Latin_1   *note A.3.3(26): 5722.

LC_V <in> Ada.Characters.Latin_1   *note A.3.3(14): 5583.

LC_W <in> Ada.Characters.Latin_1   *note A.3.3(14): 5584.

LC_X <in> Ada.Characters.Latin_1   *note A.3.3(14): 5585.

LC_Y <in> Ada.Characters.Latin_1   *note A.3.3(14): 5586.

LC_Y_Acute <in> Ada.Characters.Latin_1   *note A.3.3(26): 5726.

LC_Y_Diaeresis
   <in> Ada.Characters.Latin_1   *note A.3.3(26): 5728.

LC_Z <in> Ada.Characters.Latin_1   *note A.3.3(14): 5587.

Leading_Nonseparate
   <in> Interfaces.COBOL   *note B.4(23): 7567.

Leading_Separate <in> Interfaces.COBOL   *note B.4(23): 7565.

Left_Angle_Quotation
   <in> Ada.Characters.Latin_1   *note A.3.3(21/3): 5642.

Left_Curly_Bracket
   <in> Ada.Characters.Latin_1   *note A.3.3(14): 5588.

Left_Parenthesis
   <in> Ada.Characters.Latin_1   *note A.3.3(8): 5540.

Left_Square_Bracket
   <in> Ada.Characters.Latin_1   *note A.3.3(12): 5556.

Less_Than_Sign
   <in> Ada.Characters.Latin_1   *note A.3.3(10): 5551.

Letter_Set
   <in> Ada.Strings.Maps.Constants   *note A.4.6(4): 5957.

LF <in> Ada.Characters.Latin_1   *note A.3.3(5): 5510.

Low_Line <in> Ada.Characters.Latin_1   *note A.3.3(12): 5560.

Low_Order_First
   <in> Interfaces.COBOL   *note B.4(25): 7571.
   <in> System   *note 13.7(15/2): 5125.

Lower_Case_Map
   <in> Ada.Strings.Maps.Constants   *note A.4.6(5): 5966.

Lower_Set
   <in> Ada.Strings.Maps.Constants   *note A.4.6(4): 5958.

Macron <in> Ada.Characters.Latin_1   *note A.3.3(21/3): 5646.

Masculine_Ordinal_Indicator
   <in> Ada.Characters.Latin_1   *note A.3.3(22): 5659.

Max_Base_Digits <in> System   *note 13.7(8): 5112.

Max_Binary_Modulus <in> System   *note 13.7(7): 5110.

Max_Decimal_Digits <in> Ada.Decimal   *note F.2(5): 8228.

Max_Delta <in> Ada.Decimal   *note F.2(4): 8227.

Max_Digits <in> System   *note 13.7(8): 5113.

Max_Digits_Binary <in> Interfaces.COBOL   *note B.4(11): 7550.

Max_Digits_Long_Binary
   <in> Interfaces.COBOL   *note B.4(11): 7551.

Max_Image_Width
   <in> Ada.Numerics.Discrete_Random   *note A.5.2(25): 6168.
   <in> Ada.Numerics.Float_Random   *note A.5.2(13): 6156.

Max_Int <in> System   *note 13.7(6): 5109.

Max_Length <in> Ada.Strings.Bounded   *note A.4.4(5): 5845.

Max_Mantissa <in> System   *note 13.7(9): 5114.

Max_Nonbinary_Modulus <in> System   *note 13.7(7): 5111.

Max_Picture_Length
   <in> Ada.Text_IO.Editing   *note F.3.3(8): 8240.

Max_Scale <in> Ada.Decimal   *note F.2(3): 8224.

Memory_Size <in> System   *note 13.7(13): 5121.

Micro_Sign <in> Ada.Characters.Latin_1   *note A.3.3(22): 5653.

Middle_Dot <in> Ada.Characters.Latin_1   *note A.3.3(22): 5656.

Min_Delta <in> Ada.Decimal   *note F.2(4): 8226.

Min_Handler_Ceiling
   <in> Ada.Execution_Time.Group_Budgets   *note D.14.2(7/2): 8034.
   <in> Ada.Execution_Time.Timers   *note D.14.1(6/2): 8018.

Min_Int <in> System   *note 13.7(6): 5108.

Min_Scale <in> Ada.Decimal   *note F.2(3): 8225.

Minus_Sign <in> Ada.Characters.Latin_1   *note A.3.3(8): 5546.

Monday <in> Ada.Calendar.Formatting   *note 9.6.1(17/2): 4179.

Multiplication_Sign
   <in> Ada.Characters.Latin_1   *note A.3.3(24): 5688.

MW <in> Ada.Characters.Latin_1   *note A.3.3(18): 5619.

NAK <in> Ada.Characters.Latin_1   *note A.3.3(6): 5521.

Native_Binary <in> Interfaces.COBOL   *note B.4(25): 7572.

NBH <in> Ada.Characters.Latin_1   *note A.3.3(17): 5601.

NBSP <in> Ada.Characters.Latin_1   *note A.3.3(21/3): 5631.

NEL <in> Ada.Characters.Latin_1   *note A.3.3(17): 5603.

No_Break_Space
   <in> Ada.Characters.Latin_1   *note A.3.3(21/3): 5630.

No_Element
   <in> Ada.Containers.Doubly_Linked_Lists   *note A.18.3(9/2): 6826.
   <in> Ada.Containers.Hashed_Maps   *note A.18.5(6/2): 6912.
   <in> Ada.Containers.Hashed_Sets   *note A.18.8(6/2): 7044.
   <in> Ada.Containers.Multiway_Trees   *note A.18.10(11/3): 7205.
   <in> Ada.Containers.Ordered_Maps   *note A.18.6(7/2): 6965.
   <in> Ada.Containers.Ordered_Sets   *note A.18.9(7/2): 7117.
   <in> Ada.Containers.Vectors   *note A.18.2(11/2): 6730.

No_Index <in> Ada.Containers.Vectors   *note A.18.2(7/2): 6726.

No_Tag <in> Ada.Tags   *note 3.9(6.1/2): 2102.

Not_A_Specific_CPU
   <in> System.Multiprocessors   *note D.16(4/3): 8072.

Not_Sign <in> Ada.Characters.Latin_1   *note A.3.3(21/3): 5643.

NUL
   <in> Ada.Characters.Latin_1   *note A.3.3(5): 5500.
   <in> Interfaces.C   *note B.3(20/1): 7452.

Null_Address <in> System   *note 13.7(12): 5118.

Null_Bounded_String
   <in> Ada.Strings.Bounded   *note A.4.4(7): 5847.

Null_Id <in> Ada.Exceptions   *note 11.4.1(2/2): 4566.

Null_Occurrence <in> Ada.Exceptions   *note 11.4.1(3/2): 4572.

Null_Ptr <in> Interfaces.C.Strings   *note B.3.1(7): 7500.

Null_Set
   <in> Ada.Strings.Maps   *note A.4.2(5): 5785.
   <in> Ada.Strings.Wide_Maps   *note A.4.7(5): 5987.
   <in> Ada.Strings.Wide_Wide_Maps   *note A.4.8(5/2): 6026.

Null_Unbounded_String
   <in> Ada.Strings.Unbounded   *note A.4.5(5): 5904.

Number_Sign <in> Ada.Characters.Latin_1   *note A.3.3(8): 5535.

OSC <in> Ada.Characters.Latin_1   *note A.3.3(19): 5627.

Packed_Signed <in> Interfaces.COBOL   *note B.4(27): 7575.

Packed_Unsigned <in> Interfaces.COBOL   *note B.4(27): 7574.

Paragraph_Sign
   <in> Ada.Characters.Latin_1   *note A.3.3(22): 5655.

Percent_Sign
   <in> Ada.Characters.Latin_1   *note A.3.3(8): 5537.

Pi <in> Ada.Numerics   *note A.5(3/2): 6108.

Pilcrow_Sign
   <in> Ada.Characters.Latin_1   *note A.3.3(22): 5654.

PLD <in> Ada.Characters.Latin_1   *note A.3.3(17): 5609.

PLU <in> Ada.Characters.Latin_1   *note A.3.3(17): 5610.

Plus_Minus_Sign
   <in> Ada.Characters.Latin_1   *note A.3.3(22): 5649.

Plus_Sign <in> Ada.Characters.Latin_1   *note A.3.3(8): 5543.

PM <in> Ada.Characters.Latin_1   *note A.3.3(19): 5628.

Pound_Sign <in> Ada.Characters.Latin_1   *note A.3.3(21/3): 5634.

PU1 <in> Ada.Characters.Latin_1   *note A.3.3(18): 5615.

PU2 <in> Ada.Characters.Latin_1   *note A.3.3(18): 5616.

Question <in> Ada.Characters.Latin_1   *note A.3.3(10): 5554.

Quotation <in> Ada.Characters.Latin_1   *note A.3.3(8): 5534.

Registered_Trade_Mark_Sign
   <in> Ada.Characters.Latin_1   *note A.3.3(21/3): 5645.

Reserved_128
   <in> Ada.Characters.Latin_1   *note A.3.3(17): 5598.

Reserved_129
   <in> Ada.Characters.Latin_1   *note A.3.3(17): 5599.

Reserved_132
   <in> Ada.Characters.Latin_1   *note A.3.3(17): 5602.

Reserved_153
   <in> Ada.Characters.Latin_1   *note A.3.3(19): 5623.

Reverse_Solidus
   <in> Ada.Characters.Latin_1   *note A.3.3(12): 5557.

RI <in> Ada.Characters.Latin_1   *note A.3.3(17): 5611.

Right_Angle_Quotation
   <in> Ada.Characters.Latin_1   *note A.3.3(22): 5660.

Right_Curly_Bracket
   <in> Ada.Characters.Latin_1   *note A.3.3(14): 5590.

Right_Parenthesis
   <in> Ada.Characters.Latin_1   *note A.3.3(8): 5541.

Right_Square_Bracket
   <in> Ada.Characters.Latin_1   *note A.3.3(12): 5558.

Ring_Above <in> Ada.Characters.Latin_1   *note A.3.3(22): 5648.

RS <in> Ada.Characters.Latin_1   *note A.3.3(6): 5530.

Saturday <in> Ada.Calendar.Formatting   *note 9.6.1(17/2): 4184.

SCHAR_MAX <in> Interfaces.C   *note B.3(6): 7435.

SCHAR_MIN <in> Interfaces.C   *note B.3(6): 7434.

SCI <in> Ada.Characters.Latin_1   *note A.3.3(19): 5624.

Section_Sign
   <in> Ada.Characters.Latin_1   *note A.3.3(21/3): 5638.

Semicolon <in> Ada.Characters.Latin_1   *note A.3.3(10): 5550.

Separate_Interrupt_Clocks_Supported
   <in> Ada.Execution_Time   *note D.14(9.2/3): 8009.

SI <in> Ada.Characters.Latin_1   *note A.3.3(5): 5515.

SO <in> Ada.Characters.Latin_1   *note A.3.3(5): 5514.

Soft_Hyphen <in> Ada.Characters.Latin_1   *note A.3.3(21/3): 5644.

SOH <in> Ada.Characters.Latin_1   *note A.3.3(5): 5501.

Solidus <in> Ada.Characters.Latin_1   *note A.3.3(8): 5548.

SOS <in> Ada.Characters.Latin_1   *note A.3.3(19): 5622.

SPA <in> Ada.Characters.Latin_1   *note A.3.3(18): 5620.

Space
   <in> Ada.Characters.Latin_1   *note A.3.3(8): 5532.
   <in> Ada.Strings   *note A.4.1(4/2): 5771.

Special_Set
   <in> Ada.Strings.Maps.Constants   *note A.4.6(4): 5964.

SS2 <in> Ada.Characters.Latin_1   *note A.3.3(17): 5612.

SS3 <in> Ada.Characters.Latin_1   *note A.3.3(17): 5613.

SSA <in> Ada.Characters.Latin_1   *note A.3.3(17): 5604.

ST <in> Ada.Characters.Latin_1   *note A.3.3(19): 5626.

Storage_Unit <in> System   *note 13.7(13): 5119.

STS <in> Ada.Characters.Latin_1   *note A.3.3(18): 5617.

STX <in> Ada.Characters.Latin_1   *note A.3.3(5): 5502.

SUB <in> Ada.Characters.Latin_1   *note A.3.3(6): 5526.

Success <in> Ada.Command_Line   *note A.15(8): 6631.

Sunday <in> Ada.Calendar.Formatting   *note 9.6.1(17/2): 4185.

Superscript_One
   <in> Ada.Characters.Latin_1   *note A.3.3(22): 5658.

Superscript_Three
   <in> Ada.Characters.Latin_1   *note A.3.3(22): 5651.

Superscript_Two
   <in> Ada.Characters.Latin_1   *note A.3.3(22): 5650.

SYN <in> Ada.Characters.Latin_1   *note A.3.3(6): 5522.

System_Dispatching_Domain
   <in> System.Multiprocessors.Dispatching_Domains   *note D.16.1(6/3):
8080.

System_Name <in> System   *note 13.7(4): 5107.

Thursday <in> Ada.Calendar.Formatting   *note 9.6.1(17/2): 4182.

Tick
   <in> Ada.Real_Time   *note D.8(6): 7951.
   <in> System   *note 13.7(10): 5116.

Tilde <in> Ada.Characters.Latin_1   *note A.3.3(14): 5591.

Time_First <in> Ada.Real_Time   *note D.8(4): 7943.

Time_Last <in> Ada.Real_Time   *note D.8(4): 7944.

Time_Span_First <in> Ada.Real_Time   *note D.8(5): 7947.

Time_Span_Last <in> Ada.Real_Time   *note D.8(5): 7948.

Time_Span_Unit <in> Ada.Real_Time   *note D.8(5): 7950.

Time_Span_Zero <in> Ada.Real_Time   *note D.8(5): 7949.

Time_Unit <in> Ada.Real_Time   *note D.8(4): 7945.

Trailing_Nonseparate
   <in> Interfaces.COBOL   *note B.4(23): 7568.

Trailing_Separate <in> Interfaces.COBOL   *note B.4(23): 7566.

Tuesday <in> Ada.Calendar.Formatting   *note 9.6.1(17/2): 4180.

UC_A_Acute <in> Ada.Characters.Latin_1   *note A.3.3(23): 5666.

UC_A_Circumflex
   <in> Ada.Characters.Latin_1   *note A.3.3(23): 5667.

UC_A_Diaeresis
   <in> Ada.Characters.Latin_1   *note A.3.3(23): 5669.

UC_A_Grave <in> Ada.Characters.Latin_1   *note A.3.3(23): 5665.

UC_A_Ring <in> Ada.Characters.Latin_1   *note A.3.3(23): 5670.

UC_A_Tilde <in> Ada.Characters.Latin_1   *note A.3.3(23): 5668.

UC_AE_Diphthong
   <in> Ada.Characters.Latin_1   *note A.3.3(23): 5671.

UC_C_Cedilla
   <in> Ada.Characters.Latin_1   *note A.3.3(23): 5672.

UC_E_Acute <in> Ada.Characters.Latin_1   *note A.3.3(23): 5674.

UC_E_Circumflex
   <in> Ada.Characters.Latin_1   *note A.3.3(23): 5675.

UC_E_Diaeresis
   <in> Ada.Characters.Latin_1   *note A.3.3(23): 5676.

UC_E_Grave <in> Ada.Characters.Latin_1   *note A.3.3(23): 5673.

UC_I_Acute <in> Ada.Characters.Latin_1   *note A.3.3(23): 5678.

UC_I_Circumflex
   <in> Ada.Characters.Latin_1   *note A.3.3(23): 5679.

UC_I_Diaeresis
   <in> Ada.Characters.Latin_1   *note A.3.3(23): 5680.

UC_I_Grave <in> Ada.Characters.Latin_1   *note A.3.3(23): 5677.

UC_Icelandic_Eth
   <in> Ada.Characters.Latin_1   *note A.3.3(24): 5681.

UC_Icelandic_Thorn
   <in> Ada.Characters.Latin_1   *note A.3.3(24): 5695.

UC_N_Tilde <in> Ada.Characters.Latin_1   *note A.3.3(24): 5682.

UC_O_Acute <in> Ada.Characters.Latin_1   *note A.3.3(24): 5684.

UC_O_Circumflex
   <in> Ada.Characters.Latin_1   *note A.3.3(24): 5685.

UC_O_Diaeresis
   <in> Ada.Characters.Latin_1   *note A.3.3(24): 5687.

UC_O_Grave <in> Ada.Characters.Latin_1   *note A.3.3(24): 5683.

UC_O_Oblique_Stroke
   <in> Ada.Characters.Latin_1   *note A.3.3(24): 5689.

UC_O_Tilde <in> Ada.Characters.Latin_1   *note A.3.3(24): 5686.

UC_U_Acute <in> Ada.Characters.Latin_1   *note A.3.3(24): 5691.

UC_U_Circumflex
   <in> Ada.Characters.Latin_1   *note A.3.3(24): 5692.

UC_U_Diaeresis
   <in> Ada.Characters.Latin_1   *note A.3.3(24): 5693.

UC_U_Grave <in> Ada.Characters.Latin_1   *note A.3.3(24): 5690.

UC_Y_Acute <in> Ada.Characters.Latin_1   *note A.3.3(24): 5694.

UCHAR_MAX <in> Interfaces.C   *note B.3(6): 7436.

Unbounded <in> Ada.Text_IO   *note A.10.1(5): 6379.

Unsigned <in> Interfaces.COBOL   *note B.4(23): 7564.

Upper_Case_Map
   <in> Ada.Strings.Maps.Constants   *note A.4.6(5): 5967.

Upper_Set
   <in> Ada.Strings.Maps.Constants   *note A.4.6(4): 5959.

US <in> Ada.Characters.Latin_1   *note A.3.3(6): 5531.

Vertical_Line
   <in> Ada.Characters.Latin_1   *note A.3.3(14): 5589.

VT <in> Ada.Characters.Latin_1   *note A.3.3(5): 5511.

VTS <in> Ada.Characters.Latin_1   *note A.3.3(17): 5608.

Wednesday <in> Ada.Calendar.Formatting   *note 9.6.1(17/2): 4181.

Wide_Character_Set
   <in> Ada.Strings.Wide_Maps.Wide_Constants   *note A.4.8(48/2): 6047.

wide_nul <in> Interfaces.C   *note B.3(31/1): 7462.

Wide_Space <in> Ada.Strings   *note A.4.1(4/2): 5772.

Wide_Wide_Space <in> Ada.Strings   *note A.4.1(4/2): 5773.

Word_Size <in> System   *note 13.7(13): 5120.

Yen_Sign <in> Ada.Characters.Latin_1   *note A.3.3(21/3): 5636.


File: arm2012.info,  Node: Index,  Prev: Annex Q,  Up: Top

Index
*****

Index entries are given by paragraph number.
* Menu:

* operators::
* A::
* B::
* C::
* D::
* E::
* F::
* G::
* H::
* I::
* J::
* K::
* L::
* M::
* N::
* O::
* P::
* Q::
* R::
* S::
* T::
* U::
* V::
* W::
* X::
* Y::


File: arm2012.info,  Node: operators,  Next: A,  Up: Index

operators
=========

 

& operator   *note 4.4(1/3): 2625, *note 4.5.3(3): 2815.
 
* operator   *note 4.4(1/3): 2632, *note 4.5.5(1): 2840.
** operator   *note 4.4(1/3): 2646, *note 4.5.6(7): 2871.
 
+ operator   *note 4.4(1/3): 2617, *note 4.5.3(1): 2807, *note 4.5.4(1):
2830.
 
- operator   *note 4.4(1/3): 2621, *note 4.5.3(1): 2811, *note 4.5.4(1):
2834.
 
/ operator   *note 4.4(1/3): 2638, *note 4.5.5(1): 2846.
/= operator   *note 4.4(1/3): 2595, *note 4.5.2(1): 2769, *note
6.6(6/3): 3542.
 
10646:2011, ISO/IEC standard   *note 1.2(8/3): 1115.
14882:2011, ISO/IEC standard   *note 1.2(9/3): 1118.
1539-1:2004, ISO/IEC standard   *note 1.2(3/2): 1095.
19769:2004, ISO/IEC technical report   *note 1.2(10/2): 1121.
1989:2002, ISO standard   *note 1.2(4/2): 1098.
 
3166-1:2006, ISO/IEC standard   *note 1.2(4.1/3): 1101.
 
639-3:2007, ISO standard   *note 1.2(1.1/3): 1089.
6429:1992, ISO/IEC standard   *note 1.2(5): 1104.
646:1991, ISO/IEC standard   *note 1.2(2): 1092.
 
8859-1:1998, ISO/IEC standard   *note 1.2(6/3): 1109.
 
9899:2011, ISO/IEC standard   *note 1.2(7/3): 1112.
 
< operator   *note 4.4(1/3): 2599, *note 4.5.2(1): 2773.
<= operator   *note 4.4(1/3): 2603, *note 4.5.2(1): 2777.
 
= operator   *note 4.4(1/3): 2591, *note 4.5.2(1): 2765.
 
> operator   *note 4.4(1/3): 2607, *note 4.5.2(1): 2781.
>= operator   *note 4.4(1/3): 2611, *note 4.5.2(1): 2785.



File: arm2012.info,  Node: A,  Next: B,  Prev: operators,  Up: Index

A 
==



AARM   *note 0.3(5/3): 1002.
abnormal completion   *note 7.6.1(2/2): 3691.
abnormal state of an object   *note 13.9.1(4): 5167.
   [<partial>]   *note 9.8(21): 4294, *note 11.6(6/3): 4660, *note
A.13(17): 6624.
abnormal task   *note 9.8(4): 4284.
abort
   of a partition   *note E.1(7): 8105.
   of a task   *note 9.8(4): 4283.
   of the execution of a construct   *note 9.8(5): 4287.
abort completion point   *note 9.8(15): 4290.
abort-deferred operation   *note 9.8(5): 4288.
abort_statement   *note 9.8(2): 4277.
   <used>   *note 5.1(4/2): 3131, *note P: 9366.
Abort_Task
   <in> Ada.Task_Identification   *note C.7.1(3/3): 7714.
abortable_part   *note 9.7.4(5): 4264.
   <used>   *note 9.7.4(2): 4257, *note P: 9643.
abs operator   *note 4.4(1/3): 2650, *note 4.5.6(1): 2860.
absolute value   *note 4.4(1/3): 2652, *note 4.5.6(1): 2862.
abstract data type (ADT)
   <See> private types and private extensions   *note 7.3(1): 3598.
   <See also> abstract type   *note 3.9.3(1/2): 2180.
abstract subprogram   *note 3.9.3(1/2): 2183, *note 3.9.3(3/2): 2191.
abstract type   *note 3.9.3(1.2/2): 2189, *note 3.9.3(1/2): 2179, *note
N(1.1/2): 8879.
abstract_subprogram_declaration   *note 3.9.3(1.1/3): 2185.
   <used>   *note 3.1(3/3): 1298, *note P: 9014.
accept_alternative   *note 9.7.1(5): 4227.
   <used>   *note 9.7.1(4): 4224, *note P: 9627.
accept_statement   *note 9.5.2(3): 4044.
   <used>   *note 5.1(5/2): 3140, *note 9.7.1(5): 4228, *note P: 9630.
acceptable interpretation   *note 8.6(14): 3852.
Access attribute   *note 3.10.2(25/1): 2307, *note 3.10.2(33/3): 2317.
   <See also> Unchecked_Access attribute   *note 13.10(3): 5182.
access discriminant   *note 3.7(9/2): 1986.
access parameter   *note 6.1(24/2): 3340.
access paths
   distinct   *note 6.2(12/3): 3398.
access result type   *note 6.1(24/2): 3341.
access type   *note 3.10(1): 2222, *note N(2): 8880.
   subpool   *note 13.11.4(22/3): 5276.
access types
   input-output unspecified   *note A.7(6): 6284.
access value   *note 3.10(1): 2223.
access-to-constant type   *note 3.10(10): 2258.
access-to-object type   *note 3.10(7/1): 2247.
access-to-subprogram type   *note 3.10(7/1): 2248, *note 3.10(11): 2260.
access-to-variable type   *note 3.10(10): 2259.
Access_Check   *note 11.5(11/2): 4629.
   [<partial>]   *note 4.1(13): 2390, *note 4.1.5(8/3): 2459, *note
4.6(51/4): 3004, *note 4.8(10.4/3): 3078.
access_definition   *note 3.10(6/2): 2240.
   <used>   *note 3.3.1(2/3): 1485, *note 3.6(7/2): 1905, *note
3.7(5/2): 1980, *note 6.1(13/2): 3315, *note 6.1(15/3): 3326, *note
6.5(2.3/2): 3508, *note 8.5.1(2/3): 3805, *note 12.4(2/3): 4750, *note
P: 9520.
access_to_object_definition   *note 3.10(3): 2232.
   <used>   *note 3.10(2/2): 2229, *note P: 9169.
access_to_subprogram_definition   *note 3.10(5): 2236.
   <used>   *note 3.10(2/2): 2231, *note P: 9171.
access_type_definition   *note 3.10(2/2): 2227.
   <used>   *note 3.2.1(4/2): 1386, *note 12.5.4(2): 4821, *note P:
9038.
accessibility
   distributed   *note 3.10.2(33.1/3): 2322.
   from shared passive library units   *note E.2.1(8): 8130.
accessibility level   *note 3.10.2(3/2): 2289.
accessibility rule
   Access attribute   *note 3.10.2(29/3): 2310, *note 3.10.2(33/3):
2318.
   requeue statement   *note 9.5.4(6/3): 4125.
   type conversion   *note 4.6(24.17/4): 2955, *note 4.6(24.21/4): 2961.
   type conversion, array components   *note 4.6(24.6/2): 2950.
Accessibility_Check   *note 11.5(19.1/2): 4638.
   [<partial>]   *note 3.10.2(30): 2312, *note 4.6(39.1/2): 2982, *note
4.6(48/3): 2996, *note 4.8(10.1/3): 3069, *note 6.5(8/4): 3526, *note
6.5(21/3): 3532, *note 13.11.4(25/3): 5278, *note 13.11.4(26/3): 5280,
*note E.4(18/1): 8192.
accessible partition   *note E.1(7): 8107.
accuracy   *note 4.6(32): 2972, *note G.2(1): 8329.
ACK
   <in> Ada.Characters.Latin_1   *note A.3.3(5): 5506.
acquire
   execution resource associated with protected object   *note
9.5.1(5/4): 4031.
activation
   of a task   *note 9.2(1): 3935.
activation failure   *note 9.2(1): 3937.
Activation_Is_Complete
   <in> Ada.Task_Identification   *note C.7.1(4/3): 7717.
activator
   of a task   *note 9.2(5): 3938.
active locale   *note A.19(8/3): 7377.
active partition   *note 10.2(28/3): 4460, *note E.1(2): 8100.
active priority   *note D.1(15): 7765.
actual   *note 12.3(7/3): 4726.
actual duration   *note D.9(12): 7972.
actual parameter
   for a formal parameter   *note 6.4.1(3): 3475.
actual subtype   *note 3.3(23/3): 1466, *note 12.5(4): 4791.
   of an object   *note 3.3.1(9/2): 1506.
actual type   *note 12.5(4): 4793.
actual_parameter_part   *note 6.4(4): 3454.
   <used>   *note 4.1.6(10/3): 2470, *note 6.4(2): 3449, *note 6.4(3):
3453, *note 9.5.3(2): 4094, *note P: 9453.
Actual_Quantum
   <in> Ada.Dispatching.Round_Robin   *note D.2.5(4/2): 7817.
Acute
   <in> Ada.Characters.Latin_1   *note A.3.3(22): 5652.
Ada   *note A.2(2): 5456.
Ada calling convention   *note 6.3.1(3/3): 3419.
Ada.Ada.Unchecked_Deallocate_Subpool   *note 13.11.5(3/3): 5287.
Ada.Assertions   *note 11.4.2(12/2): 4604.
Ada.Asynchronous_Task_Control   *note D.11(3/2): 7988.
Ada.Calendar   *note 9.6(10): 4145.
Ada.Calendar.Arithmetic   *note 9.6.1(8/2): 4173.
Ada.Calendar.Formatting   *note 9.6.1(15/2): 4177.
Ada.Calendar.Time_Zones   *note 9.6.1(2/2): 4169.
Ada.Characters   *note A.3.1(2): 5457.
Ada.Characters.Conversions   *note A.3.4(2/2): 5729.
Ada.Characters.Handling   *note A.3.2(2/2): 5460.
Ada.Characters.Latin_1   *note A.3.3(3): 5498.
Ada.Command_Line   *note A.15(3): 6626.
Ada.Complex_Text_IO   *note G.1.3(9.1/2): 8324.
Ada.Containers   *note A.18.1(3/2): 6715.
Ada.Containers.Bounded_Priority_Queues   *note A.18.31(2/3): 7362.
Ada.Containers.Bounded_Synchronized_Queues   *note A.18.29(2/3): 7349.
Ada.Containers.Doubly_Linked_Lists   *note A.18.3(5/3): 6822.
Ada.Containers.Generic_Array_Sort   *note A.18.26(3/2): 7330.
Ada.Containers.Generic_Constrained_Array_Sort   *note A.18.26(7/2):
7332.
Ada.Containers.Generic_Sort   *note A.18.26(9.2/4): 7334.
Ada.Containers.Hashed_Maps   *note A.18.5(2/3): 6908.
Ada.Containers.Hashed_Sets   *note A.18.8(2/3): 7040.
Ada.Containers.Indefinite_Doubly_Linked_Lists   *note A.18.12(2/3):
7277.
Ada.Containers.Indefinite_Hashed_Maps   *note A.18.13(2/3): 7278.
Ada.Containers.Indefinite_Hashed_Sets   *note A.18.15(2/3): 7280.
Ada.Containers.Indefinite_Holders   *note A.18.18(5/3): 7284.
Ada.Containers.Indefinite_Multiway_Trees   *note A.18.17(2/3): 7282.
Ada.Containers.Indefinite_Ordered_Maps   *note A.18.14(2/3): 7279.
Ada.Containers.Indefinite_Ordered_Sets   *note A.18.16(2/3): 7281.
Ada.Containers.Indefinite_Vectors   *note A.18.11(2/3): 7276.
Ada.Containers.Multiway_Trees   *note A.18.10(7/3): 7201.
Ada.Containers.Ordered_Maps   *note A.18.6(2/3): 6960.
Ada.Containers.Ordered_Sets   *note A.18.9(2/3): 7112.
Ada.Containers.Synchronized_Queue_Interfaces   *note A.18.27(3/3): 7336.
Ada.Containers.Unbounded_Priority_Queues   *note A.18.30(2/3): 7355.
Ada.Containers.Unbounded_Synchronized_Queues   *note A.18.28(2/3): 7343.
Ada.Containers.Vectors   *note A.18.2(6/3): 6724.
Ada.Decimal   *note F.2(2): 8223.
Ada.Direct_IO   *note A.8.4(2): 6323.
Ada.Directories   *note A.16(3/2): 6635.
Ada.Directories.Hierarchical_File_Names   *note A.16.1(3/3): 6686.
Ada.Directories.Information   *note A.16(124/2): 6685.
Ada.Dispatching   *note D.2.1(1.2/3): 7769.
Ada.Dispatching.EDF   *note D.2.6(9/2): 7821.
Ada.Dispatching.Non_Preemptive   *note D.2.4(2.2/3): 7806.
Ada.Dispatching.Round_Robin   *note D.2.5(4/2): 7813.
Ada.Dynamic_Priorities   *note D.5.1(3/2): 7865.
Ada.Environment_Variables   *note A.17(3/2): 6699.
Ada.Exceptions   *note 11.4.1(2/2): 4564.
Ada.Execution_Time   *note D.14(3/2): 7999.
Ada.Execution_Time.Group_Budgets   *note D.14.2(3/3): 8030.
Ada.Execution_Time.Interrupts   *note D.14.3(3/3): 8055.
Ada.Execution_Time.Timers   *note D.14.1(3/2): 8015.
Ada.Finalization   *note 7.6(4/3): 3661.
Ada.Float_Text_IO   *note A.10.9(33): 6536.
Ada.Float_Wide_Text_IO   *note A.11(2/2): 6557.
Ada.Float_Wide_Wide_Text_IO   *note A.11(3/2): 6560.
Ada.Integer_Text_IO   *note A.10.8(21): 6535.
Ada.Integer_Wide_Text_IO   *note A.11(2/2): 6556.
Ada.Integer_Wide_Wide_Text_IO   *note A.11(3/2): 6559.
Ada.Interrupts   *note C.3.2(2/3): 7659.
Ada.Interrupts.Names   *note C.3.2(12): 7670.
Ada.IO_Exceptions   *note A.13(3): 6613.
Ada.Iterator_Interfaces   *note 5.5.1(2/3): 3209.
Ada.Locales   *note A.19(3/3): 7370.
Ada.Numerics   *note A.5(3/2): 6106.
Ada.Numerics.Complex_Arrays   *note G.3.2(53/2): 8422.
Ada.Numerics.Complex_Elementary_Functions   *note G.1.2(9/1): 8306.
Ada.Numerics.Complex_Types   *note G.1.1(25/1): 8279.
Ada.Numerics.Discrete_Random   *note A.5.2(17): 6160.
Ada.Numerics.Elementary_Functions   *note A.5.1(9/1): 6139.
Ada.Numerics.Float_Random   *note A.5.2(5): 6147.
Ada.Numerics.Generic_Complex_Arrays   *note G.3.2(2/2): 8386.
Ada.Numerics.Generic_Complex_Elementary_Functions   *note G.1.2(2/2):
8285.
Ada.Numerics.Generic_Complex_Types   *note G.1.1(2/1): 8258.
Ada.Numerics.Generic_Elementary_Functions   *note A.5.1(3): 6110.
Ada.Numerics.Generic_Real_Arrays   *note G.3.1(2/2): 8370.
Ada.Numerics.Real_Arrays   *note G.3.1(31/2): 8382.
Ada.Real_Time   *note D.8(3): 7941.
Ada.Real_Time.Timing_Events   *note D.15(3/2): 8058.
Ada.Sequential_IO   *note A.8.1(2): 6298.
Ada.Storage_IO   *note A.9(3): 6355.
Ada.Streams   *note 13.13.1(2): 5333.
Ada.Streams.Stream_IO   *note A.12.1(3/3): 6568.
Ada.Strings   *note A.4.1(3): 5770.
Ada.Strings.Bounded   *note A.4.4(3): 5843.
Ada.Strings.Bounded.Equal_Case_Insensitive   *note A.4.10(7/3): 6058.
Ada.Strings.Bounded.Hash   *note A.4.9(7/3): 6050.
Ada.Strings.Bounded.Hash_Case_Insensitive   *note A.4.9(11.7/3): 6054.
Ada.Strings.Bounded.Less_Case_Insensitive   *note A.4.10(18/3): 6062.
Ada.Strings.Equal_Case_Insensitive   *note A.4.10(2/3): 6056.
Ada.Strings.Fixed   *note A.4.3(5): 5807.
Ada.Strings.Fixed.Equal_Case_Insensitive   *note A.4.10(5/3): 6057.
Ada.Strings.Fixed.Hash_Case_Insensitive   *note A.4.9(11.5/3): 6053.
Ada.Strings.Fixed.Less_Case_Insensitive   *note A.4.10(16/3): 6061.
Ada.Strings.Hash   *note A.4.9(2/3): 6049.
Ada.Strings.Hash_Case_Insensitive   *note A.4.9(11.2/3): 6052.
Ada.Strings.Less_Case_Insensitive   *note A.4.10(13/3): 6060.
Ada.Strings.Maps   *note A.4.2(3/2): 5783.
Ada.Strings.Maps.Constants   *note A.4.6(3/2): 5954.
Ada.Strings.Unbounded   *note A.4.5(3): 5902.
Ada.Strings.Unbounded.Equal_Case_Insensitive   *note A.4.10(10/3): 6059.
Ada.Strings.Unbounded.Hash   *note A.4.9(10/3): 6051.
Ada.Strings.Unbounded.Hash_Case_Insensitive   *note A.4.9(11.10/3):
6055.
Ada.Strings.Unbounded.Less_Case_Insensitive   *note A.4.10(21/3): 6063.
Ada.Strings.UTF_Encoding   *note A.4.11(3/3): 6064.
Ada.Strings.UTF_Encoding.Conversions   *note A.4.11(15/3): 6075.
Ada.Strings.UTF_Encoding.Strings   *note A.4.11(22/3): 6081.
Ada.Strings.UTF_Encoding.Wide_Strings   *note A.4.11(30/3): 6088.
Ada.Strings.UTF_Encoding.Wide_Wide_Strings   *note A.4.11(38/3): 6095.
Ada.Strings.Wide_Bounded   *note A.4.7(1/3): 5970.
Ada.Strings.Wide_Bounded.Wide_Equal_Case_Insensitive   *note A.4.7(1/3):
5978.
Ada.Strings.Wide_Bounded.Wide_Hash   *note A.4.7(1/3): 5974.
Ada.Strings.Wide_Bounded.Wide_Hash_Case_Insensitive   *note A.4.7(1/3):
5982.
Ada.Strings.Wide_Equal_Case_Insensitive   *note A.4.7(1/3): 5976.
Ada.Strings.Wide_Fixed   *note A.4.7(1/3): 5969.
Ada.Strings.Wide_Fixed.Wide_Equal_Case_Insensitive   *note A.4.7(1/3):
5977.
Ada.Strings.Wide_Fixed.Wide_Hash   *note A.4.7(1/3): 5973.
Ada.Strings.Wide_Fixed.Wide_Hash_Case_Insensitive   *note A.4.7(1/3):
5981.
Ada.Strings.Wide_Hash   *note A.4.7(1/3): 5972.
Ada.Strings.Wide_Hash_Case_Insensitive   *note A.4.7(1/3): 5980.
Ada.Strings.Wide_Maps   *note A.4.7(3): 5985.
Ada.Strings.Wide_Maps.Wide_Constants   *note A.4.7(1/3): 5984, *note
A.4.8(28/2): 6045.
Ada.Strings.Wide_Unbounded   *note A.4.7(1/3): 5971.
Ada.Strings.Wide_Unbounded.Wide_Equal_Case_Insensitive   *note
A.4.7(1/3): 5979.
Ada.Strings.Wide_Unbounded.Wide_Hash   *note A.4.7(1/3): 5975.
Ada.Strings.Wide_Unbounded.Wide_Hash_Case_Insensitive   *note
A.4.7(1/3): 5983.
Ada.Strings.Wide_Wide_Bounded   *note A.4.8(1/3): 6009.
Ada.Strings.Wide_Wide_Bounded.Wide_Wide_Equal_Case_Insensitive   *note
A.4.8(1/3): 6017.
Ada.Strings.Wide_Wide_Bounded.Wide_Wide_Hash   *note A.4.8(1/3): 6013.
Ada.Strings.Wide_Wide_Bounded.Wide_Wide_Hash_Case_Insensitive   *note
A.4.8(1/3): 6021.
Ada.Strings.Wide_Wide_Equal_Case_Insensitive   *note A.4.8(1/3): 6015.
Ada.Strings.Wide_Wide_Fixed   *note A.4.8(1/3): 6008.
Ada.Strings.Wide_Wide_Fixed.Wide_Wide_Equal_Case_Insensitive   *note
A.4.8(1/3): 6016.
Ada.Strings.Wide_Wide_Fixed.Wide_Wide_Hash   *note A.4.8(1/3): 6012.
Ada.Strings.Wide_Wide_Fixed.Wide_Wide_Hash_Case_Insensitive   *note
A.4.8(1/3): 6020.
Ada.Strings.Wide_Wide_Hash   *note A.4.8(1/3): 6011.
Ada.Strings.Wide_Wide_Hash_Case_Insensitive   *note A.4.8(1/3): 6019.
Ada.Strings.Wide_Wide_Maps   *note A.4.8(3/2): 6024.
Ada.Strings.Wide_Wide_Maps.Wide_Wide_Constants   *note A.4.8(1/3): 6023.
Ada.Strings.Wide_Wide_Unbounded   *note A.4.8(1/3): 6010.
Ada.Strings.Wide_Wide_Unbounded.Wide_Wide_Equal_Case_Insensitive   *note
A.4.8(1/3): 6018.
Ada.Strings.Wide_Wide_Unbounded.Wide_Wide_Hash   *note A.4.8(1/3): 6014.
Ada.Strings.Wide_Wide_Unbounded.Wide_Wide_Hash_Case_Insensitive   *note
A.4.8(1/3): 6022.
Ada.Synchronous_Barriers   *note D.10.1(3/3): 7984.
Ada.Synchronous_Task_Control   *note D.10(3/2): 7973.
Ada.Synchronous_Task_Control.EDF   *note D.10(5.2/3): 7979.
Ada.Tags   *note 3.9(6/2): 2100.
Ada.Tags.Generic_Dispatching_Constructor   *note 3.9(18.2/3): 2125.
Ada.Task_Attributes   *note C.7.2(2): 7728.
Ada.Task_Identification   *note C.7.1(2/2): 7708.
Ada.Task_Termination   *note C.7.3(2/2): 7740.
Ada.Text_IO   *note A.10.1(2): 6374.
Ada.Text_IO.Bounded_IO   *note A.10.11(3/2): 6537.
Ada.Text_IO.Complex_IO   *note G.1.3(3): 8314.
Ada.Text_IO.Editing   *note F.3.3(3): 8234.
Ada.Text_IO.Text_Streams   *note A.12.2(3): 6604.
Ada.Text_IO.Unbounded_IO   *note A.10.12(3/2): 6546.
Ada.Unchecked_Conversion   *note 13.9(3/3): 5159.
Ada.Unchecked_Deallocate_Subpool
   <child of> Ada   *note 13.11.5(3/3): 5287.
Ada.Unchecked_Deallocation   *note 13.11.2(3/3): 5228.
Ada.Wide_Characters   *note A.3.1(4/2): 5458.
Ada.Wide_Characters.Handling   *note A.3.5(3/3): 5748.
Ada.Wide_Text_IO   *note A.11(2/2): 6555.
Ada.Wide_Text_IO.Bounded_IO   *note A.11(4/3): 6561.
Ada.Wide_Text_IO.Complex_IO   *note G.1.4(1): 8325.
Ada.Wide_Text_IO.Editing   *note F.3.4(1): 8253.
Ada.Wide_Text_IO.Text_Streams   *note A.12.3(3): 6607.
Ada.Wide_Text_IO.Unbounded_IO   *note A.11(5/3): 6563.
Ada.Wide_Wide_Characters   *note A.3.1(6/2): 5459.
Ada.Wide_Wide_Characters.Handling   *note A.3.6(1/3): 5769.
Ada.Wide_Wide_Text_IO   *note A.11(3/2): 6558.
Ada.Wide_Wide_Text_IO.Bounded_IO   *note A.11(4/3): 6562.
Ada.Wide_Wide_Text_IO.Complex_IO   *note G.1.5(1/2): 8328.
Ada.Wide_Wide_Text_IO.Editing   *note F.3.5(1/2): 8255.
Ada.Wide_Wide_Text_IO.Text_Streams   *note A.12.4(3/2): 6610.
Ada.Wide_Wide_Text_IO.Unbounded_IO   *note A.11(5/3): 6564.
Ada_To_COBOL
   <in> Interfaces.COBOL   *note B.4(14): 7555.
adafinal   *note B.1(39/3): 7417.
adainit   *note B.1(39/3): 7416.
Add
   <in> Ada.Execution_Time.Group_Budgets   *note D.14.2(9/2): 8041.
Add_Task
   <in> Ada.Execution_Time.Group_Budgets   *note D.14.2(8/2): 8035.
address
   arithmetic   *note 13.7.1(6): 5137.
   comparison   *note 13.7(14/3): 5122.
   <in> System   *note 13.7(12): 5117.
Address aspect   *note 13.3(12): 4983.
Address attribute   *note 13.3(11): 4979, *note J.7.1(5): 8510.
Address clause   *note 13.3(7/2): 4959, *note 13.3(12): 4981.
Address_To_Access_Conversions
   <child of> System   *note 13.7.2(2): 5144.
Adjacent attribute   *note A.5.3(48): 6237.
Adjust   *note 7.6(2): 3660.
   <in> Ada.Finalization   *note 7.6(6/2): 3664.
adjusting the value of an object   *note 7.6(15): 3674, *note 7.6(16/3):
3676.
adjustment   *note 7.6(15): 3675, *note 7.6(16/3): 3677.
   as part of assignment   *note 5.2(14/3): 3168.
ADT (abstract data type)
   <See> private types and private extensions   *note 7.3(1): 3599.
   <See also> abstract type   *note 3.9.3(1/2): 2181.
advice   *note 1.1.2(37): 1048.
Aft attribute   *note 3.5.10(5): 1875.
aggregate   *note 4.3(1): 2492, *note 4.3(2): 2494.
   <used>   *note 4.4(7/3): 2712, *note 4.7(2): 3029, *note 6.8(2/4):
3558, *note P: 9344.
   <See also> composite type   *note 3.2(2/2): 1338.
aliased   *note 3.10(9/3): 2255, *note N(3): 8881.
aliasing
   <See> distinct access paths   *note 6.2(12/3): 3399.
Alignment
   <in> Ada.Strings   *note A.4.1(6): 5778.
Alignment (subtype) aspect   *note 13.3(26.4/2): 4995.
Alignment attribute   *note 13.3(23/2): 4987, *note 13.3(26.2/2): 4991.
Alignment clause   *note 13.3(7/2): 4960, *note 13.3(25/2): 4989, *note
13.3(26.4/2): 4993.
All_Calls_Remote aspect   *note E.2.3(16/3): 8165.
All_Calls_Remote pragma   *note E.2.3(5): 8153, *note L(2): 8696.
All_Checks   *note 11.5(25/3): 4643.
Allocate
   <in> System.Storage_Pools   *note 13.11(7): 5189.
   <in> System.Storage_Pools.Subpools   *note 13.11.4(14/3): 5266.
Allocate_From_Subpool
   <in> System.Storage_Pools.Subpools   *note 13.11.4(11/3): 5263.
Allocation_Check   *note 11.5(19.2/2): 4639.
   [<partial>]   *note 4.8(10.2/2): 3072, *note 4.8(10.3/2): 3075, *note
4.8(10.4/3): 3080, *note 13.11.4(30/3): 5283.
allocator   *note 4.8(2/3): 3043.
   <used>   *note 4.4(7/3): 2714, *note P: 9313.
Alphanumeric
   <in> Interfaces.COBOL   *note B.4(16/3): 7557.
alphanumeric character
   a category of Character   *note A.3.2(31): 5496.
Alphanumeric_Set
   <in> Ada.Strings.Maps.Constants   *note A.4.6(4): 5963.
ambiguous   *note 8.6(30): 3872.
ambiguous cursor
   of a vector   *note A.18.2(240/2): 6811.
ampersand   *note 2.1(15/3): 1153.
   <in> Ada.Characters.Latin_1   *note A.3.3(8): 5538.
ampersand operator   *note 4.4(1/3): 2627, *note 4.5.3(3): 2817.
ancestor   *note N(3.1/2): 8882.
   of a library unit   *note 10.1.1(11): 4357.
   of a tree node   *note A.18.10(4/3): 7198.
   of a type   *note 3.4.1(10/2): 1577.
   ultimate   *note 3.4.1(10/2): 1579.
ancestor subtype
   of a formal derived type   *note 12.5.1(5/3): 4804.
   of a private_extension_declaration   *note 7.3(8): 3612.
ancestor type
   of an extension_aggregate   *note 4.3.2(5/3): 2535.
Ancestor_Find
   <in> Ada.Containers.Multiway_Trees   *note A.18.10(40/3): 7233.
ancestor_part   *note 4.3.2(3): 2530.
   <used>   *note 4.3.2(2): 2528, *note P: 9245.
and operator   *note 4.4(1/3): 2583, *note 4.5.1(2): 2745.
and then (short-circuit control form)   *note 4.4(1/3): 2589, *note
4.5.1(1): 2740.
angle threshold   *note G.2.4(10): 8363.
Annex
   informative   *note 1.1.2(18): 1013.
   normative   *note 1.1.2(14): 1010.
   Specialized Needs   *note 1.1.2(7): 1007.
Annotated Ada Reference Manual   *note 0.3(5/3): 1001.
anonymous access type   *note 3.10(12/3): 2263.
anonymous allocator   *note 3.10.2(14/3): 2300.
anonymous array type   *note 3.3.1(1/3): 1476.
anonymous protected type   *note 3.3.1(1/3): 1478.
anonymous task type   *note 3.3.1(1/3): 1477.
anonymous type   *note 3.2.1(7/2): 1391.
Any_Priority <subtype of> Integer
   <in> System   *note 13.7(16): 5127.
APC
   <in> Ada.Characters.Latin_1   *note A.3.3(19): 5629.
apostrophe   *note 2.1(15/3): 1154.
   <in> Ada.Characters.Latin_1   *note A.3.3(8): 5539.
Append
   <in> Ada.Containers.Doubly_Linked_Lists   *note A.18.3(23/2): 6846.
   <in> Ada.Containers.Vectors   *note A.18.2(46/2): 6769, *note
A.18.2(47/2): 6770.
   <in> Ada.Strings.Bounded   *note A.4.4(13): 5853, *note A.4.4(14):
5854, *note A.4.4(15): 5855, *note A.4.4(16): 5856, *note A.4.4(17):
5857, *note A.4.4(18): 5858, *note A.4.4(19): 5859, *note A.4.4(20):
5860.
   <in> Ada.Strings.Unbounded   *note A.4.5(12): 5912, *note A.4.5(13):
5913, *note A.4.5(14): 5914.
Append_Child
   <in> Ada.Containers.Multiway_Trees   *note A.18.10(52/3): 7245.
applicable index constraint   *note 4.3.3(10): 2568.
application areas   *note 1.1.2(7): 1008.
applies
   aspect   *note 13.1.1(23/3): 4931, *note 13.1.1(27/3): 4932, *note
13.1.1(29/3): 4935, *note 13.1.1(30/3): 4936.
apply
   to a callable construct by a return statement   *note 6.5(4/2): 3512.
   to a loop_statement by an exit_statement   *note 5.7(4): 3269.
   to a program unit by a program unit pragma   *note 10.1.5(2): 4421.
arbitrary order   *note 1.1.4(18): 1069.
   allowed   *note 2.8(12): 1280, *note 3.3.1(20/2): 1519, *note 3.5(9):
1609, *note 3.6(22/2): 1928, *note 3.11(10/1): 2349, *note 3.11(11/3):
2350, *note 3.11(13): 2351, *note 4.1.1(7): 2401, *note 4.1.2(7): 2412,
*note 4.3(5): 2501, *note 4.3.1(19): 2526, *note 4.3.2(7): 2538, *note
4.3.3(22): 2570, *note 4.3.3(23): 2573, *note 4.5.2(27/4): 2803, *note
4.8(10/2): 3068, *note 5.2(7): 3160, *note 6.1.1(34/3): 3380, *note
6.1.1(35/3): 3385, *note 6.4(10/2): 3466, *note 6.4.1(17): 3494, *note
7.6(12): 3672, *note 7.6(16/3): 3678, *note 7.6.1(9/3): 3698, *note
7.6.1(11.1/3): 3704, *note 7.6.1(20.2/3): 3712, *note 9.7.1(15): 4237,
*note 9.8(4): 4282, *note 12.3(20): 4737, *note 13.11.5(7/3): 5288.
Arccos
   <in> Ada.Numerics.Generic_Complex_Elementary_Functions   *note
G.1.2(5): 8295.
   <in> Ada.Numerics.Generic_Elementary_Functions   *note A.5.1(6):
6125.
Arccosh
   <in> Ada.Numerics.Generic_Complex_Elementary_Functions   *note
G.1.2(7): 8303.
   <in> Ada.Numerics.Generic_Elementary_Functions   *note A.5.1(7):
6136.
Arccot
   <in> Ada.Numerics.Generic_Complex_Elementary_Functions   *note
G.1.2(5): 8297.
   <in> Ada.Numerics.Generic_Elementary_Functions   *note A.5.1(6):
6129.
Arccoth
   <in> Ada.Numerics.Generic_Complex_Elementary_Functions   *note
G.1.2(7): 8305.
   <in> Ada.Numerics.Generic_Elementary_Functions   *note A.5.1(7):
6138.
Arcsin
   <in> Ada.Numerics.Generic_Complex_Elementary_Functions   *note
G.1.2(5): 8294.
   <in> Ada.Numerics.Generic_Elementary_Functions   *note A.5.1(6):
6124.
Arcsinh
   <in> Ada.Numerics.Generic_Complex_Elementary_Functions   *note
G.1.2(7): 8302.
   <in> Ada.Numerics.Generic_Elementary_Functions   *note A.5.1(7):
6135.
Arctan
   <in> Ada.Numerics.Generic_Complex_Elementary_Functions   *note
G.1.2(5): 8296.
   <in> Ada.Numerics.Generic_Elementary_Functions   *note A.5.1(6):
6128.
Arctanh
   <in> Ada.Numerics.Generic_Complex_Elementary_Functions   *note
G.1.2(7): 8304.
   <in> Ada.Numerics.Generic_Elementary_Functions   *note A.5.1(7):
6137.
Argument
   <in> Ada.Command_Line   *note A.15(5): 6628.
   <in> Ada.Numerics.Generic_Complex_Arrays   *note G.3.2(10/2): 8396,
*note G.3.2(31/2): 8410.
   <in> Ada.Numerics.Generic_Complex_Types   *note G.1.1(10): 8273.
argument of a pragma   *note 2.8(9): 1275.
Argument_Count
   <in> Ada.Command_Line   *note A.15(4): 6627.
Argument_Error
   <in> Ada.Numerics   *note A.5(3/2): 6107.
Arithmetic
   <child of> Ada.Calendar   *note 9.6.1(8/2): 4173.
array   *note 3.6(1): 1885.
array component expression   *note 4.3.3(6): 2563.
array component iterator   *note 5.5.2(3/3): 3245.
array for a loop   *note 5.5.2(11/3): 3255.
array indexing
   <See> indexed_component   *note 4.1.1(1): 2393.
array slice   *note 4.1.2(1): 2406.
array type   *note 3.6(1): 1886, *note N(4): 8883.
array_aggregate   *note 4.3.3(2): 2542.
   <used>   *note 4.3(2): 2497, *note 13.4(3): 5042, *note P: 9823.
array_component_association   *note 4.3.3(5/2): 2557.
   <used>   *note 4.3.3(4): 2556, *note P: 9259.
array_type_definition   *note 3.6(2): 1887.
   <used>   *note 3.2.1(4/2): 1384, *note 3.3.1(2/3): 1489, *note
12.5.3(2): 4817, *note P: 9777.
ASCII
   package physically nested within the declaration of Standard   *note
A.1(36.3/2): 5446.
   <in> Standard   *note A.1(36.3/2): 5445.
aspect   *note 13.1(0.1/3): 4867, *note K.1(1/3): 8648, *note N(4.1/3):
8884.
   class-wide   *note 13.1.1(28/4): 4934.
   interfacing   *note B.1(0.1/3): 7383.
   predicate   *note 3.2.4(1/3): 1435.
aspect of representation   *note 13.1(8/3): 4886.
aspect_clause   *note 13.1(2/1): 4872.
   <used>   *note 3.8(5/1): 2035, *note 3.11(4/1): 2334, *note 9.1(5/1):
3910, *note 9.4(5/1): 3973, *note 9.4(8/4): 3988, *note P: 9188.
aspect_definition   *note 13.1.1(4/3): 4918.
   <used>   *note 13.1.1(2/3): 4913, *note P: 9810.
aspect_mark   *note 13.1.1(3/3): 4916.
   <used>   *note 2.8(3/3): 1270, *note 11.4.2(6.1/3): 4598, *note
13.1.1(2/3): 4912, *note L(2.3/3): 8707, *note P: 9809.
aspect_specification   *note 13.1.1(2/3): 4911.
   <used>   *note 3.2.1(3/3): 1377, *note 3.2.2(2/3): 1403, *note
3.3.1(2/3): 1487, *note 3.8(6/3): 2040, *note 3.9.3(1.1/3): 2188, *note
6.1(2/3): 3284, *note 6.3(2/3): 3405, *note 6.7(2/3): 3546, *note
6.8(2/4): 3555, *note 7.1(3/3): 3575, *note 7.2(2/3): 3588, *note
7.3(2/3): 3603, *note 7.3(3/3): 3609, *note 8.5.1(2/3): 3803, *note
8.5.2(2/3): 3815, *note 8.5.3(2/3): 3819, *note 8.5.4(2/3): 3826, *note
8.5.5(2/3): 3838, *note 9.1(2/3): 3896, *note 9.1(3/3): 3901, *note
9.1(6/3): 3913, *note 9.4(2/3): 3958, *note 9.4(3/3): 3963, *note
9.4(7/3): 3979, *note 9.5.2(2/3): 4043, *note 10.1.3(3/3): 4395, *note
10.1.3(4/3): 4398, *note 10.1.3(5/3): 4401, *note 10.1.3(6/3): 4404,
*note 11.1(2/3): 4517, *note 12.1(3/3): 4673, *note 12.3(2/3): 4708,
*note 12.4(2/3): 4747, *note 12.5(2.1/3): 4774, *note 12.6(2.1/3): 4834,
*note 12.6(2.2/3): 4838, *note 12.7(2/3): 4856, *note P: 9058.
aspects
   Address   *note 13.3(12): 4982.
   Alignment (subtype)   *note 13.3(26.4/2): 4994.
   All_Calls_Remote   *note E.2.3(16/3): 8164.
   Asynchronous   *note E.4.1(8.1/3): 8198.
   Atomic   *note C.6(6.2/3): 7688.
   Atomic_Components   *note C.6(6.6/3): 7694.
   Attach_Handler   *note C.3.1(6.3/3): 7643.
   Bit_Order   *note 13.5.3(4): 5099.
   Coding   *note 13.4(7): 5046.
   Component_Size   *note 13.3(70): 5025.
   Constant_Indexing   *note 4.1.6(2/3): 2462.
   Convention   *note B.1(2/3): 7397.
   CPU   *note D.16(8/3): 8075.
   Default_Component_Value   *note 3.6(22.2/3): 1929.
   Default_Iterator   *note 5.5.1(8/3): 3224.
   Default_Storage_Pool   *note 13.11.3(5/4): 5254.
   Default_Value   *note 3.5(56.3/3): 1683.
   Discard_Names   *note C.5(1.3/4): 7679.
   Dispatching_Domain   *note D.16.1(18/3): 8093.
   Dynamic_Predicate   *note 3.2.4(1/3): 1438.
   Elaborate_Body   *note 10.2.1(26.1/3): 4504.
   Exclusive_Functions   *note 9.5.1(2.2/4): 4025.
   Export   *note B.1(1/3): 7386.
   External_Name   *note B.1(1/3): 7390.
   External_Tag   *note 13.3(75/3): 5036, *note K.2(65): 8663.
   Implicit_Dereference   *note 4.1.5(2/3): 2450.
   Import   *note B.1(1/3): 7384.
   Independent   *note C.6(6.3/3): 7690.
   Independent_Components   *note C.6(6.9/3): 7698.
   Inline   *note 6.3.2(5.1/3): 3443.
   Input   *note 13.13.2(38/4): 5382.
   Input'Class   *note 13.13.2(38/4): 5390.
   Interrupt_Handler   *note C.3.1(6.2/3): 7641.
   Interrupt_Priority   *note D.1(6.3/3): 7759.
   Iterator_Element   *note 5.5.1(9/3): 3227.
   Layout   *note 13.5(1): 5049.
   Link_Name   *note B.1(1/3): 7388.
   Machine_Radix   *note F.1(1): 8221.
   No_Return   *note 6.5.1(3.2/3): 3535.
   Output   *note 13.13.2(38/4): 5384.
   Output'Class   *note 13.13.2(38/4): 5392.
   Pack   *note 13.2(5.1/3): 4939.
   Post   *note 6.1.1(4/3): 3355.
   Post'Class   *note 6.1.1(5/3): 3359.
   Pre   *note 6.1.1(2/3): 3347.
   Pre'Class   *note 6.1.1(3/3): 3351.
   Preelaborate   *note 10.2.1(11/3): 4473.
   Priority   *note D.1(6.2/3): 7757.
   Pure   *note 10.2.1(17/3): 4486.
   Read   *note 13.13.2(38/4): 5378.
   Read'Class   *note 13.13.2(38/4): 5386.
   Record layout   *note 13.5(1): 5053.
   Relative_Deadline   *note D.2.6(9.2/3): 7827.
   Remote_Call_Interface   *note E.2.3(7/3): 8162.
   Remote_Types   *note E.2.2(4/3): 8142.
   Shared_Passive   *note E.2.1(4/3): 8128.
   Size (object)   *note 13.3(41): 5004.
   Size (subtype)   *note 13.3(48): 5011.
   Small   *note 3.5.10(2/1): 1868.
   Static_Predicate   *note 3.2.4(1/3): 1436.
   Storage_Pool   *note 13.11(15): 5205.
   Storage_Size (access)   *note 13.11(15): 5207.
   Storage_Size (task)   *note 13.3(65.2/3): 5016.
   Stream_Size   *note 13.13.2(1.5/2): 5346.
   Synchronization   *note 9.5(12/3): 4019.
   Type_Invariant   *note 7.3.2(2/3): 3628.
   Type_Invariant'Class   *note 7.3.2(3/4): 3630.
   Unchecked_Union   *note B.3.3(3.2/3): 7535.
   Variable_Indexing   *note 4.1.6(3/3): 2464.
   Volatile   *note C.6(6.4/3): 7692.
   Volatile_Components   *note C.6(6.7/3): 7696.
   Write   *note 13.13.2(38/4): 5380.
   Write'Class   *note 13.13.2(38/4): 5388.
assembly language   *note C.1(4/3): 7627.
Assert
   <in> Ada.Assertions   *note 11.4.2(14/2): 4607.
Assert pragma   *note 11.4.2(3/2): 4590, *note L(2.1/2): 8699.
assertion   *note N(4.2/3): 8885.
assertion expressions   *note 11.4.2(1.1/3): 4588.
assertion policy
   Assert pragma   *note 11.4.2(18/3): 4608.
Assertion_Error
   raised by failure of assertion   *note 11.4.2(18/3): 4609.
   raised by failure of run-time check   *note 3.2.4(31.1/4): 1453,
*note 4.6(57/4): 3019, *note 6.1.1(32/3): 3374, *note 6.1.1(33/3): 3377,
*note 6.1.1(35/3): 3384, *note 7.3.2(22/3): 3639.
   <in> Ada.Assertions   *note 11.4.2(13/2): 4605.
Assertion_Policy pragma   *note 11.4.2(6.1/3): 4597, *note 11.4.2(6/2):
4594, *note L(2.2/2): 8703, *note L(2.3/3): 8706.
assertions   *note 11.4.2(1.1/3): 4587.
   <child of> Ada   *note 11.4.2(12/2): 4604.
Assign
   <in> Ada.Containers.Doubly_Linked_Lists   *note A.18.3(17.5/3): 6839.
   <in> Ada.Containers.Hashed_Maps   *note A.18.5(17.7/3): 6930.
   <in> Ada.Containers.Hashed_Sets   *note A.18.8(17.3/3): 7058.
   <in> Ada.Containers.Indefinite_Holders   *note A.18.18(20/3): 7298.
   <in> Ada.Containers.Multiway_Trees   *note A.18.10(32/3): 7225.
   <in> Ada.Containers.Ordered_Maps   *note A.18.6(16.7/3): 6981.
   <in> Ada.Containers.Ordered_Sets   *note A.18.9(16.3/3): 7129.
   <in> Ada.Containers.Vectors   *note A.18.2(34.7/3): 6756.
   <See> assignment operation   *note 5.2(3): 3154.
Assign_Task
   <in> System.Multiprocessors.Dispatching_Domains   *note D.16.1(11/3):
8088.
assigning back of parameters   *note 6.4.1(17): 3491.
assignment
   user-defined   *note 7.6(1): 3653.
assignment operation   *note 5.2(3): 3153, *note 5.2(12): 3166, *note
7.6(13): 3673.
   during elaboration of an object_declaration   *note 3.3.1(18/2):
1517.
   during evaluation of a generic_association for a formal object of
mode in   *note 12.4(11): 4765.
   during evaluation of a parameter_association   *note 6.4.1(11): 3483.
   during evaluation of an aggregate   *note 4.3(5): 2500.
   during evaluation of an initialized allocator   *note 4.8(7/2): 3059.
   during evaluation of an uninitialized allocator   *note 4.8(9/2):
3062.
   during evaluation of concatenation   *note 4.5.3(10): 2827.
   during execution of a for loop   *note 5.5(9/4): 3208.
   during execution of an assignment_statement   *note 5.2(12): 3167.
   during parameter copy back   *note 6.4.1(17): 3492.
assignment_statement   *note 5.2(2): 3150.
   <used>   *note 5.1(4/2): 3123, *note P: 9358.
associated components
   of a record_component_association   *note 4.3.1(10): 2522.
associated declaration
   of an aspect specification   *note 13.1.1(1/3): 4910.
associated discriminants
   of a named discriminant_association   *note 3.7.1(5): 2010.
   of a positional discriminant_association   *note 3.7.1(5): 2011.
associated entity
   of an aspect specification   *note 13.1.1(5/3): 4922.
associated object
   of a value of a by-reference type   *note 6.2(10/4): 3395.
asterisk   *note 2.1(15/3): 1158.
   <in> Ada.Characters.Latin_1   *note A.3.3(8): 5542.
asynchronous
   remote procedure call   *note E.4.1(9/3): 8201.
Asynchronous aspect   *note E.4.1(8.1/3): 8199.
Asynchronous pragma   *note J.15.13(2/3): 8646, *note L(3.1/3): 8712.
asynchronous remote procedure call   *note E.4(1): 8179.
asynchronous_select   *note 9.7.4(2): 4255.
   <used>   *note 9.7(2): 4213, *note P: 9620.
Asynchronous_Task_Control
   <child of> Ada   *note D.11(3/2): 7988.
at-most-once execution   *note E.4(11): 8188.
at_clause   *note J.7(1): 8505.
   <used>   *note 13.1(2/1): 4876, *note P: 9802.
atomic   *note C.6(7/3): 7700.
Atomic aspect   *note C.6(6.2/3): 7689.
Atomic pragma   *note J.15.8(2/3): 8598, *note L(4.1/3): 8715.
Atomic_Components aspect   *note C.6(6.6/3): 7695.
Atomic_Components pragma   *note J.15.8(5/3): 8607, *note L(5.1/3):
8718.
Attach_Handler
   <in> Ada.Interrupts   *note C.3.2(7): 7665.
Attach_Handler aspect   *note C.3.1(6.3/3): 7644.
Attach_Handler pragma   *note J.15.7(4/3): 8592, *note L(6.1/3): 8721.
attaching
   to an interrupt   *note C.3(2): 7636.
attribute   *note 4.1.4(1): 2433, *note K.2(1/3): 8649.
   representation   *note 13.3(1/1): 4943.
   specifiable   *note 13.3(5/3): 4955.
   specifying   *note 13.3(1/1): 4944.
   stream-oriented   *note 13.13.2(1/3): 5343.
attribute_definition_clause   *note 13.3(2): 4945.
   <used>   *note 13.1(2/1): 4873, *note P: 9799.
attribute_designator   *note 4.1.4(3/2): 2437.
   <used>   *note 4.1.4(2): 2436, *note 13.1(3): 4880, *note 13.3(2):
4950, *note P: 9819.
Attribute_Handle
   <in> Ada.Task_Attributes   *note C.7.2(3): 7729.
attribute_reference   *note 4.1.4(2): 2434.
   <used>   *note 4.1(2/3): 2365, *note P: 9201.
attributes
   Access   *note 3.10.2(25/1): 2306, *note 3.10.2(33/3): 2316.
   Address   *note 13.3(11): 4978, *note J.7.1(5): 8509.
   Adjacent   *note A.5.3(48): 6236.
   Aft   *note 3.5.10(5): 1874.
   Alignment   *note 13.3(23/2): 4986, *note 13.3(26.2/2): 4990.
   Base   *note 3.5(15): 1617.
   Bit_Order   *note 13.5.3(4): 5095.
   Body_Version   *note E.3(4): 8171.
   Callable   *note 9.9(2): 4297.
   Caller   *note C.7.1(14/3): 7720.
   Ceiling   *note A.5.3(33): 6220.
   Class   *note 3.9(14): 2117, *note 7.3.1(9): 3625, *note J.11(2/2):
8525.
   Component_Size   *note 13.3(69): 5021.
   Compose   *note A.5.3(24): 6208.
   Constrained   *note 3.7.2(3/3): 2018, *note J.4(2): 8503.
   Copy_Sign   *note A.5.3(51): 6241.
   Count   *note 9.9(5): 4303.
   Definite   *note 12.5.1(23/3): 4807.
   Delta   *note 3.5.10(3): 1870.
   Denorm   *note A.5.3(9): 6190.
   Digits   *note 3.5.8(2/1): 1822, *note 3.5.10(7): 1876.
   Exponent   *note A.5.3(18): 6204.
   External_Tag   *note 13.3(75/3): 5032.
   First   *note 3.5(12): 1611, *note 3.6.2(3): 1946.
   First(N)   *note 3.6.2(4): 1948.
   First_Bit   *note 13.5.2(3/2): 5082.
   First_Valid   *note 3.5.5(7.2/4): 1778.
   Floor   *note A.5.3(30): 6218.
   Fore   *note 3.5.10(4): 1872.
   Fraction   *note A.5.3(21): 6206.
   Has_Same_Storage   *note 13.3(73.2/4): 5028.
   Identity   *note 11.4.1(9): 4583, *note C.7.1(12): 7718.
   Image   *note 3.5(35): 1645, *note 3.5(55.4/4): 1681.
   Input   *note 13.13.2(22): 5359, *note 13.13.2(32): 5363.
   Last   *note 3.5(13): 1613, *note 3.6.2(5): 1950.
   Last(N)   *note 3.6.2(6): 1952.
   Last_Bit   *note 13.5.2(4/2): 5084.
   Last_Valid   *note 3.5.5(7.3/4): 1780.
   Leading_Part   *note A.5.3(54): 6246.
   Length   *note 3.6.2(9): 1958.
   Length(N)   *note 3.6.2(10): 1960.
   Machine   *note A.5.3(60): 6251.
   Machine_Emax   *note A.5.3(8): 6188.
   Machine_Emin   *note A.5.3(7): 6186.
   Machine_Mantissa   *note A.5.3(6): 6184.
   Machine_Overflows   *note A.5.3(12): 6198, *note A.5.4(4): 6276.
   Machine_Radix   *note A.5.3(2): 6181, *note A.5.4(2): 6272.
   Machine_Rounding   *note A.5.3(41.1/2): 6226.
   Machine_Rounds   *note A.5.3(11): 6196, *note A.5.4(3): 6274.
   Max   *note 3.5(19): 1622.
   Max_Alignment_For_Allocation   *note 13.11.1(4/3): 5221.
   Max_Size_In_Storage_Elements   *note 13.11.1(3/3): 5219.
   Min   *note 3.5(16): 1620.
   Mod   *note 3.5.4(16.1/2): 1749.
   Model   *note A.5.3(68): 6265, *note G.2.2(7): 8349.
   Model_Emin   *note A.5.3(65): 6259, *note G.2.2(4): 8342.
   Model_Epsilon   *note A.5.3(66): 6261.
   Model_Mantissa   *note A.5.3(64): 6257, *note G.2.2(3/2): 8340.
   Model_Small   *note A.5.3(67): 6263.
   Modulus   *note 3.5.4(17): 1751.
   Old   *note 6.1.1(26/4): 3370.
   Output   *note 13.13.2(19): 5357, *note 13.13.2(29): 5361.
   Overlaps_Storage   *note 13.3(73.6/3): 5030.
   Partition_Id   *note E.1(9): 8108.
   Pos   *note 3.5.5(2): 1770.
   Position   *note 13.5.2(2/2): 5080.
   Pred   *note 3.5(25): 1631.
   Priority   *note D.5.2(3/2): 7871.
   Range   *note 3.5(14): 1615, *note 3.6.2(7): 1954.
   Range(N)   *note 3.6.2(8): 1956.
   Read   *note 13.13.2(6): 5351, *note 13.13.2(14): 5355.
   Remainder   *note A.5.3(45): 6231.
   Result   *note 6.1.1(29/3): 3372.
   Round   *note 3.5.10(12): 1882.
   Rounding   *note A.5.3(36): 6222.
   Safe_First   *note A.5.3(71): 6267, *note G.2.2(5): 8344.
   Safe_Last   *note A.5.3(72): 6269, *note G.2.2(6): 8346.
   Scale   *note 3.5.10(11): 1879.
   Scaling   *note A.5.3(27): 6213.
   Signed_Zeros   *note A.5.3(13): 6200.
   Size   *note 13.3(40): 5000, *note 13.3(45): 5007.
   Small   *note 3.5.10(2/1): 1864.
   Storage_Pool   *note 13.11(13): 5197.
   Storage_Size   *note 13.3(60/3): 5014, *note 13.11(14): 5199, *note
J.9(2): 8518.
   Stream_Size   *note 13.13.2(1.2/3): 5344.
   Succ   *note 3.5(22): 1624.
   Tag   *note 3.9(16): 2121, *note 3.9(18): 2123.
   Terminated   *note 9.9(3): 4301.
   Truncation   *note A.5.3(42): 6229.
   Unbiased_Rounding   *note A.5.3(39): 6224.
   Unchecked_Access   *note 13.10(3): 5180, *note H.4(18): 8470.
   Val   *note 3.5.5(5): 1772.
   Valid   *note 13.9.2(3/4): 5177, *note H(6): 8429.
   Value   *note 3.5(52): 1671.
   Version   *note E.3(3): 8169.
   Wide_Image   *note 3.5(28): 1642, *note 3.5(55.3/4): 1679.
   Wide_Value   *note 3.5(40): 1665.
   Wide_Wide_Image   *note 3.5(27.1/2): 1638, *note 3.5(55.2/4): 1677.
   Wide_Wide_Value   *note 3.5(39.1/2): 1653.
   Wide_Wide_Width   *note 3.5(37.1/2): 1647.
   Wide_Width   *note 3.5(38): 1649.
   Width   *note 3.5(39): 1651.
   Write   *note 13.13.2(3): 5349, *note 13.13.2(11): 5353.
available
   stream attribute   *note 13.13.2(39/2): 5394.



File: arm2012.info,  Node: B,  Next: C,  Prev: A,  Up: Index

B 
==



Backus-Naur Form (BNF)
   complete listing   *note P: 8961.
   cross reference   *note P: 9850.
   notation   *note 1.1.4(3): 1064.
   under Syntax heading   *note 1.1.2(25): 1018.
Barrier_Limit <subtype of> Positive
   <in> Ada.Synchronous_Barriers   *note D.10.1(4/3): 7985.
base   *note 2.4.2(3): 1238, *note 2.4.2(6): 1246.
   <used>   *note 2.4.2(2): 1234, *note P: 8985.
base 16 literal   *note 2.4.2(1): 1231.
base 2 literal   *note 2.4.2(1): 1225.
base 8 literal   *note 2.4.2(1): 1228.
Base attribute   *note 3.5(15): 1618.
base decimal precision
   of a floating point type   *note 3.5.7(9): 1808.
   of a floating point type   *note 3.5.7(10): 1810.
base priority   *note D.1(15): 7764.
base range
   of a decimal fixed point type   *note 3.5.9(16): 1854.
   of a fixed point type   *note 3.5.9(12): 1849.
   of a floating point type   *note 3.5.7(8): 1807, *note 3.5.7(10):
1812.
   of a modular type   *note 3.5.4(10): 1737.
   of a scalar type   *note 3.5(6): 1601.
   of a signed integer type   *note 3.5.4(9): 1734.
   of an ordinary fixed point type   *note 3.5.9(13): 1850.
base subtype
   of a type   *note 3.5(15): 1619.
Base_Name
   <in> Ada.Directories   *note A.16(19/2): 6649.
based_literal   *note 2.4.2(2): 1233.
   <used>   *note 2.4(2): 1209, *note P: 8976.
based_numeral   *note 2.4.2(4): 1240.
   <used>   *note 2.4.2(2): 1236, *note P: 8987.
basic letter
   a category of Character   *note A.3.2(27): 5493.
basic_declaration   *note 3.1(3/3): 1292.
   <used>   *note 3.11(4/1): 2333, *note P: 9187.
basic_declarative_item   *note 3.11(4/1): 2332.
   <used>   *note 3.11(3): 2330, *note 7.1(3/3): 3576, *note P: 9486.
Basic_Map
   <in> Ada.Strings.Maps.Constants   *note A.4.6(5): 5968.
Basic_Set
   <in> Ada.Strings.Maps.Constants   *note A.4.6(4): 5960.
become nonlimited   *note 7.3.1(5/1): 3621, *note 7.5(16): 3649.
BEL
   <in> Ada.Characters.Latin_1   *note A.3.3(5): 5507.
belong
   to a range   *note 3.5(4): 1596.
   to a subtype   *note 3.2(8/2): 1359.
belongs
   subpool to a pool   *note 13.11.4(20/4): 5274.
bibliography   *note 1.2(1/3): 1087.
big endian   *note 13.5.3(2): 5090.
binary
   literal   *note 2.4.2(1): 1226.
   <in> Interfaces.COBOL   *note B.4(10): 7548.
binary adding operator   *note 4.5.3(1): 2805.
binary literal   *note 2.4.2(1): 1224.
binary operator   *note 4.5(9): 2732.
binary_adding_operator   *note 4.5(4): 2726.
   <used>   *note 4.4(4): 2698, *note P: 9300.
Binary_Format
   <in> Interfaces.COBOL   *note B.4(24): 7569.
bit field
   <See> record_representation_clause   *note 13.5.1(1): 5058.
bit ordering   *note 13.5.3(2): 5088.
bit string
   <See> logical operators on boolean arrays   *note 4.5.1(2): 2751.
Bit_Order
   <in> System   *note 13.7(15/2): 5123.
Bit_Order aspect   *note 13.5.3(4): 5100.
Bit_Order attribute   *note 13.5.3(4): 5096.
Bit_Order clause   *note 13.3(7/2): 4965, *note 13.5.3(4): 5098.
blank
   in text input for enumeration and numeric types   *note A.10.6(5/2):
6530.
Blank_When_Zero
   <in> Ada.Text_IO.Editing   *note F.3.3(7): 8239.
block_statement   *note 5.6(2): 3260.
   <used>   *note 5.1(5/2): 3138, *note P: 9372.
blocked
   [<partial>]   *note D.2.1(11/3): 7783.
   a task state   *note 9(10): 3886.
   during an entry call   *note 9.5.3(19): 4114.
   execution of a selective_accept   *note 9.7.1(16): 4238.
   on a delay_statement   *note 9.6(21): 4163.
   on an accept_statement   *note 9.5.2(24): 4085.
   waiting for activations to complete   *note 9.2(5): 3939.
   waiting for dependents to terminate   *note 9.3(5): 3946.
blocked interrupt   *note C.3(2): 7635.
blocking, potentially   *note 9.5.1(8): 4036.
   Abort_Task   *note C.7.1(16): 7724.
   delay_statement   *note 9.6(34): 4166, *note D.9(5): 7970.
   remote subprogram call   *note E.4(17): 8191.
   RPC operations   *note E.5(23): 8217.
   Suspend_Until_True   *note D.10(10): 7982.
BMP   *note 3.5.2(2/3): 1703, *note 3.5.2(3/3): 1709.
BNF (Backus-Naur Form)
   complete listing   *note P: 8960.
   cross reference   *note P: 9849.
   notation   *note 1.1.4(3): 1063.
   under Syntax heading   *note 1.1.2(25): 1017.
body   *note 3.11(5): 2336, *note 3.11.1(1/3): 2355.
   <used>   *note 3.11(3): 2331, *note P: 9186.
body_stub   *note 10.1.3(2): 4387.
   <used>   *note 3.11(5): 2338, *note P: 9191.
Body_Version attribute   *note E.3(4): 8172.
BOM_16
   <in> Ada.Strings.UTF_Encoding   *note A.4.11(12/3): 6073.
BOM_16BE
   <in> Ada.Strings.UTF_Encoding   *note A.4.11(10/3): 6071.
BOM_16LE
   <in> Ada.Strings.UTF_Encoding   *note A.4.11(11/3): 6072.
BOM_8
   <in> Ada.Strings.UTF_Encoding   *note A.4.11(9/3): 6070.
Boolean   *note 3.5.3(1): 1713.
   <in> Standard   *note A.1(5): 5437.
boolean type   *note 3.5.3(1): 1716.
Bounded
   <child of> Ada.Strings   *note A.4.4(3): 5843.
bounded error   *note 1.1.2(31): 1039, *note 1.1.5(8): 1078.
   cause   *note 4.8(11.1/2): 3084, *note 6.2(12/3): 3400, *note
7.6.1(14/1): 3706, *note 9.4(20.1/2): 4009, *note 9.5.1(8): 4034, *note
9.8(20/3): 4291, *note 10.2(26): 4457, *note 13.9.1(9): 5172, *note
13.11.2(11): 5234, *note 13.11.2(15.2/4): 5241, *note A.17(25/2): 6707,
*note A.18.2(238/3): 6809, *note A.18.2(239/2): 6810, *note
A.18.2(243/2): 6813, *note A.18.3(152.1/3): 6882, *note A.18.3(152.2/3):
6883, *note A.18.3(152/2): 6881, *note A.18.4(75.1/3): 6902, *note
A.18.4(75.2/3): 6903, *note A.18.7(96.13/3): 7034, *note
A.18.7(96.14/3): 7035, *note A.18.10(220/3): 7271, *note A.18.10(221/3):
7272, *note A.18.18(68/3): 7306, *note A.18.18(69/3): 7307, *note
A.18.19(10/3): 7309, *note A.18.20(14/3): 7312, *note A.18.21(15/3):
7316, *note A.18.22(12/3): 7319, *note A.18.23(15/3): 7323, *note
A.18.24(12/3): 7326, *note A.18.25(14/3): 7328, *note C.7.1(17/3): 7725,
*note C.7.2(13.2/1): 7736, *note D.2.6(30/2): 7829, *note D.3(13.1/2):
7848, *note E.1(10/2): 8110, *note E.3(6): 8175, *note J.7.1(11): 8515.
Bounded_IO
   <child of> Ada.Text_IO   *note A.10.11(3/2): 6537.
   <child of> Ada.Wide_Text_IO   *note A.11(4/3): 6561.
   <child of> Ada.Wide_Wide_Text_IO   *note A.11(4/3): 6562.
Bounded_Priority_Queues
   <child of> Ada.Containers   *note A.18.31(2/3): 7362.
Bounded_Slice
   <in> Ada.Strings.Bounded   *note A.4.4(28.1/2): 5864, *note
A.4.4(28.2/2): 5865.
Bounded_String
   <in> Ada.Strings.Bounded   *note A.4.4(6): 5846.
Bounded_Synchronized_Queues
   <child of> Ada.Containers   *note A.18.29(2/3): 7349.
bounds
   of a discrete_range   *note 3.6.1(6): 1940.
   of an array   *note 3.6(13): 1914.
   of the index range of an array_aggregate   *note 4.3.3(24): 2574.
box
   compound delimiter   *note 3.6(15): 1919.
BPH
   <in> Ada.Characters.Latin_1   *note A.3.3(17): 5600.
broadcast signal
   <See> protected object   *note 9.4(1): 3954.
   <See> requeue   *note 9.5.4(1): 4119.
Broken_Bar
   <in> Ada.Characters.Latin_1   *note A.3.3(21/3): 5637.
BS
   <in> Ada.Characters.Latin_1   *note A.3.3(5): 5508.
budget   *note D.14.2(14/2): 8049.
Budget_Has_Expired
   <in> Ada.Execution_Time.Group_Budgets   *note D.14.2(9/2): 8042.
Budget_Remaining
   <in> Ada.Execution_Time.Group_Budgets   *note D.14.2(9/2): 8043.
Buffer_Size
   <in> Ada.Storage_IO   *note A.9(4): 6356.
Buffer_Type <subtype of> Storage_Array
   <in> Ada.Storage_IO   *note A.9(4): 6357.
build-in-place
   <See> built in place
built in place   *note 7.6(17.1/3): 3680.
by copy parameter passing   *note 6.2(2): 3388.
by reference parameter passing   *note 6.2(2): 3391.
by-copy type   *note 6.2(3/3): 3393.
by-reference type   *note 6.2(4): 3394.
   atomic or volatile   *note C.6(18): 7706.
Byte
   <in> Interfaces.COBOL   *note B.4(29/3): 7576.
   <See> storage element   *note 13.3(8): 4975.
byte sex
   <See> ordering of storage elements in a word   *note 13.5.3(5): 5101.
Byte_Array
   <in> Interfaces.COBOL   *note B.4(29/3): 7577.



File: arm2012.info,  Node: C,  Next: D,  Prev: B,  Up: Index

C 
==



C
   <child of> Interfaces   *note B.3(4): 7432.
C interface   *note B.3(1/4): 7431.
C standard   *note 1.2(7/3): 1113.
C++ standard   *note 1.2(9/3): 1119.
C_float
   <in> Interfaces.C   *note B.3(15): 7448.
C_Variadic   *note B.3(60.16/4): 7494.
Calendar
   <child of> Ada   *note 9.6(10): 4145.
call   *note 6(2/3): 3279.
   master of   *note 3.10.2(10.1/3): 2298.
call on a dispatching operation   *note 3.9.2(2/3): 2159.
callable   *note 9.9(2): 4300.
Callable attribute   *note 9.9(2): 4298.
callable construct   *note 6(2/3): 3280.
callable entity   *note 6(2/3): 3278.
called partition   *note E.4(1): 8181.
Caller attribute   *note C.7.1(14/3): 7721.
calling convention   *note 6.3.1(2/1): 3418, *note B.1(11/3): 7405.
   Ada   *note 6.3.1(3/3): 3420.
   associated with a designated profile   *note 3.10(11): 2262.
   entry   *note 6.3.1(13/4): 3426.
   Intrinsic   *note 6.3.1(4): 3422.
   protected   *note 6.3.1(12/4): 3424.
calling partition   *note E.4(1): 8180.
calling stub   *note E.4(10): 8186.
CAN
   <in> Ada.Characters.Latin_1   *note A.3.3(6): 5524.
Cancel_Handler
   <in> Ada.Execution_Time.Group_Budgets   *note D.14.2(10/2): 8046.
   <in> Ada.Execution_Time.Timers   *note D.14.1(7/2): 8022.
   <in> Ada.Real_Time.Timing_Events   *note D.15(5/2): 8064.
cancellation
   of a delay_statement   *note 9.6(22/3): 4164.
   of an entry call   *note 9.5.3(20): 4115.
cancellation of a remote subprogram call   *note E.4(13): 8189.
canonical form   *note A.5.3(3): 6183.
canonical order of array components   *note 5.5.2(11/3): 3256.
canonical semantics   *note 11.6(2/3): 4654.
canonical-form representation   *note A.5.3(10): 6195.
capacity
   of a hashed map   *note A.18.5(41/2): 6951.
   of a hashed set   *note A.18.8(63/2): 7100.
   of a queue   *note A.18.27(10/3): 7342.
   of a vector   *note A.18.2(2/2): 6722.
   <in> Ada.Containers.Hashed_Maps   *note A.18.5(8/2): 6915.
   <in> Ada.Containers.Hashed_Sets   *note A.18.8(10/2): 7049.
   <in> Ada.Containers.Vectors   *note A.18.2(19/2): 6735.
Capacity_Error
   <in> Ada.Containers   *note A.18.1(5.1/3): 6718.
case insensitive   *note 2.3(5/3): 1203.
case_expression   *note 4.5.7(5/3): 2889.
   <used>   *note 4.5.7(2/3): 2880, *note P: 9318.
case_expression_alternative   *note 4.5.7(6/3): 2893.
   <used>   *note 4.5.7(5/3): 2891, *note P: 9326.
case_statement   *note 5.4(2/3): 3176.
   <used>   *note 5.1(5/2): 3136, *note P: 9370.
case_statement_alternative   *note 5.4(3): 3180.
   <used>   *note 5.4(2/3): 3179, *note P: 9387.
cast
   <See> type conversion   *note 4.6(1/3): 2922.
   <See> unchecked type conversion   *note 13.9(1): 5158.
catch (an exception)
   <See> handle   *note 11(1/3): 4510.
categorization aspect   *note E.2(2/3): 8116.
categorization pragma   *note E.2(2/3): 8112.
   Remote_Call_Interface   *note E.2.3(2): 8147.
   Remote_Types   *note E.2.2(2): 8136.
   Shared_Passive   *note E.2.1(2): 8122.
categorized library unit   *note E.2(2/3): 8117.
category
   of types   *note 3.2(2/2): 1331, *note 3.4(1.1/2): 1532.
category (of types)   *note N(4.3/2): 8886.
category determined for a formal type   *note 12.5(6/3): 4799.
catenation operator
   <See> concatenation operator   *note 4.4(1/3): 2631.
   <See> concatenation operator   *note 4.5.3(3): 2821.
Cause_Of_Termination
   <in> Ada.Task_Termination   *note C.7.3(3/2): 7741.
CCH
   <in> Ada.Characters.Latin_1   *note A.3.3(18): 5618.
cease to exist
   object   *note 7.6.1(11/3): 3701, *note 13.11.2(10/4): 5233.
   type   *note 7.6.1(11/3): 3702.
Cedilla
   <in> Ada.Characters.Latin_1   *note A.3.3(22): 5657.
Ceiling
   <in> Ada.Containers.Ordered_Maps   *note A.18.6(41/2): 7007.
   <in> Ada.Containers.Ordered_Sets   *note A.18.9(51/2): 7161, *note
A.18.9(71/2): 7174.
Ceiling attribute   *note A.5.3(33): 6221.
ceiling priority
   of a protected object   *note D.3(8/3): 7844.
Ceiling_Check
   [<partial>]   *note C.3.1(11/3): 7652, *note D.3(13): 7845.
Ceiling_Locking locking policy   *note D.3(7): 7843.
Cent_Sign
   <in> Ada.Characters.Latin_1   *note A.3.3(21/3): 5633.
change of representation   *note 13.6(1/3): 5103.
char
   <in> Interfaces.C   *note B.3(19): 7451.
char16_array
   <in> Interfaces.C   *note B.3(39.5/3): 7475.
char16_nul
   <in> Interfaces.C   *note B.3(39.3/2): 7472.
char16_t
   <in> Interfaces.C   *note B.3(39.2/2): 7471.
char32_array
   <in> Interfaces.C   *note B.3(39.14/3): 7485.
char32_nul
   <in> Interfaces.C   *note B.3(39.12/2): 7482.
char32_t
   <in> Interfaces.C   *note B.3(39.11/2): 7481.
char_array
   <in> Interfaces.C   *note B.3(23/3): 7455.
char_array_access
   <in> Interfaces.C.Strings   *note B.3.1(4): 7497.
CHAR_BIT
   <in> Interfaces.C   *note B.3(6): 7433.
Character   *note 3.5.2(2/3): 1705.
   <used>   *note 2.7(2): 1257, *note P: 8997.
   <in> Standard   *note A.1(35/3): 5442.
character encoding   *note A.4.11(46/3): 6103.
character plane   *note 2.1(1/3): 1129.
character set   *note 2.1(1/3): 1127.
character set standard
   16 and 32-bit   *note 1.2(8/3): 1116.
   7-bit   *note 1.2(2): 1093.
   8-bit   *note 1.2(6/3): 1110.
   control functions   *note 1.2(5): 1105.
character type   *note 3.5.2(1): 1701, *note N(5): 8887.
character_literal   *note 2.5(2): 1247.
   <used>   *note 3.5.1(4): 1694, *note 4.1(2/3): 2368, *note 4.1.3(3):
2423, *note P: 9084.
Character_Mapping
   <in> Ada.Strings.Maps   *note A.4.2(20/2): 5797.
Character_Mapping_Function
   <in> Ada.Strings.Maps   *note A.4.2(25): 5803.
Character_Range
   <in> Ada.Strings.Maps   *note A.4.2(6): 5786.
Character_Ranges
   <in> Ada.Strings.Maps   *note A.4.2(7): 5787.
Character_Sequence <subtype of> String
   <in> Ada.Strings.Maps   *note A.4.2(16): 5793.
Character_Set
   <in> Ada.Strings.Maps   *note A.4.2(4/2): 5784.
   <in> Ada.Strings.Wide_Maps   *note A.4.7(46/2): 6006.
   <in> Ada.Strings.Wide_Maps.Wide_Constants   *note A.4.8(48/2): 6046.
   <in> Interfaces.Fortran   *note B.5(11): 7609.
Character_Set_Version
   <in> Ada.Wide_Characters.Handling   *note A.3.5(4/3): 5749.
characteristics
   [<partial>]   *note 3.4(7/3): 1544.
Characters
   <child of> Ada   *note A.3.1(2): 5457.
chars_ptr
   <in> Interfaces.C.Strings   *note B.3.1(5/2): 7498.
chars_ptr_array
   <in> Interfaces.C.Strings   *note B.3.1(6/2): 7499.
check
   language-defined   *note 11.5(2/3): 4612, *note 11.6(1/3): 4649.
check, language-defined
   Access_Check   *note 4.1(13): 2391, *note 4.1.5(8/3): 2460, *note
4.6(51/4): 3005, *note 4.8(10.4/3): 3079.
   Accessibility_Check   *note 3.10.2(30): 2313, *note 4.6(39.1/2):
2983, *note 4.6(48/3): 2997, *note 4.8(10.1/3): 3070, *note 6.5(8/4):
3527, *note 6.5(21/3): 3533, *note 13.11.4(25/3): 5279, *note
13.11.4(26/3): 5281, *note E.4(18/1): 8193.
   Allocation_Check   *note 4.8(10.2/2): 3073, *note 4.8(10.3/2): 3076,
*note 4.8(10.4/3): 3081, *note 13.11.4(30/3): 5284.
   Ceiling_Check   *note C.3.1(11/3): 7653, *note D.3(13): 7846.
   controlled by assertion policy   *note 3.2.4(31/4): 1452, *note
4.6(51/4): 3007, *note 6.1.1(32/3): 3375, *note 6.1.1(33/3): 3378, *note
6.1.1(35/3): 3383, *note 7.3.2(9/4): 3637.
   Discriminant_Check   *note 4.1.3(15): 2430, *note 4.3(6): 2503, *note
4.3.2(8/3): 2540, *note 4.6(43): 2989, *note 4.6(45): 2991, *note
4.6(51/4): 3001, *note 4.6(52): 3014, *note 4.7(4/4): 3035, *note
4.8(10/2): 3066, *note 6.5(5.11/3): 3521.
   Division_Check   *note 3.5.4(20): 1758, *note 4.5.5(22): 2856, *note
A.5.1(28): 6141, *note A.5.3(47): 6235, *note G.1.1(40): 8281, *note
G.1.2(28): 8308, *note K.2(202): 8679.
   Elaboration_Check   *note 3.11(9): 2348.
   Index_Check   *note 4.1.1(7): 2404, *note 4.1.2(7): 2414, *note
4.3.3(29/3): 2578, *note 4.3.3(30): 2580, *note 4.5.3(8): 2824, *note
4.6(51/4): 3003, *note 4.7(4/4): 3037, *note 4.8(10/2): 3064.
   Length_Check   *note 4.5.1(8): 2754, *note 4.6(37): 2978, *note
4.6(52): 3010.
   Overflow_Check   *note 3.5.4(20): 1755, *note 4.4(11): 2720, *note
4.5.7(21/3): 2903, *note 5.4(13): 3188, *note G.2.1(11): 8338, *note
G.2.2(7): 8352, *note G.2.3(25): 8356, *note G.2.4(2): 8361, *note
G.2.6(3): 8368.
   Partition_Check   *note E.4(19): 8196.
   Range_Check   *note 3.2.2(11): 1424, *note 3.5(24): 1630, *note
3.5(27): 1635, *note 3.5(39.12/3): 1664, *note 3.5(39.4/3): 1658, *note
3.5(39.5/3): 1661, *note 3.5(43/3): 1670, *note 3.5(55/3): 1676, *note
3.5.5(7): 1777, *note 3.5.9(19/4): 1862, *note 4.2(11): 2490, *note
4.3.3(28): 2576, *note 4.5.1(8): 2756, *note 4.5.6(6): 2867, *note
4.5.6(13): 2876, *note 4.6(28): 2968, *note 4.6(38): 2980, *note
4.6(46): 2993, *note 4.6(51/4): 2999, *note 4.7(4/4): 3033, *note
13.13.2(35/3): 5366, *note A.5.2(39): 6176, *note A.5.3(26): 6212, *note
A.5.3(29): 6217, *note A.5.3(50): 6240, *note A.5.3(53): 6245, *note
A.5.3(59): 6250, *note A.5.3(62): 6255, *note K.2(11): 8652, *note
K.2(114): 8667, *note K.2(122): 8670, *note K.2(184): 8674, *note
K.2(220): 8683, *note K.2(241): 8688, *note K.2(41): 8657, *note
K.2(47): 8660.
   Reserved_Check   *note C.3.1(10/3): 7649.
   Storage_Check   *note 11.1(6): 4525, *note 13.3(67): 5019, *note
13.11(17): 5211, *note D.7(17/1): 7923, *note D.7(18/1): 7928, *note
D.7(19/1): 7933.
   Tag_Check   *note 3.9.2(16): 2176, *note 4.6(42): 2987, *note
4.6(52): 3012, *note 5.2(10): 3163, *note 6.5(8.1/3): 3529.
checking pragmas   *note 11.5(1/2): 4610.
child
   of a library unit   *note 10.1.1(1): 4321.
Child_Count
   <in> Ada.Containers.Multiway_Trees   *note A.18.10(46/3): 7239.
Child_Depth
   <in> Ada.Containers.Multiway_Trees   *note A.18.10(47/3): 7240.
choice parameter   *note 11.2(9): 4542.
choice_expression   *note 4.4(2.1/3): 2666.
   <used>   *note 3.8.1(5/3): 2069, *note P: 9158.
choice_parameter_specification   *note 11.2(4): 4537.
   <used>   *note 11.2(3): 4533, *note P: 9698.
choice_relation   *note 4.4(2.2/3): 2677.
   <used>   *note 4.4(2.1/3): 2673, *note P: 9277.
Circumflex
   <in> Ada.Characters.Latin_1   *note A.3.3(12): 5559.
class
   of types   *note 3.2(2/2): 1332, *note 3.4(1.1/2): 1531.
   <See also> package   *note 7(1): 3570.
   <See also> tag   *note 3.9(3): 2098.
class (of types)   *note N(6/2): 8888.
Class attribute   *note 3.9(14): 2118, *note 7.3.1(9): 3626, *note
J.11(2/2): 8526.
class factory   *note 3.9(30/2): 2134.
class-wide aspect   *note 13.1.1(28/4): 4933.
class-wide postcondition expression   *note 6.1.1(5/3): 3357.
class-wide precondition expression   *note 6.1.1(3/3): 3349.
class-wide type   *note 3.4.1(4): 1566, *note 3.7(26): 1998.
class-wide type invariant   *note 7.3.2(3/4): 3632.
cleanup
   <See> finalization   *note 7.6.1(1): 3685.
clear
   execution timer object   *note D.14.1(12/2): 8026.
   group budget object   *note D.14.2(15/2): 8053.
   timing event object   *note D.15(9/2): 8068.
   <in> Ada.Containers.Doubly_Linked_Lists   *note A.18.3(13/2): 6831.
   <in> Ada.Containers.Hashed_Maps   *note A.18.5(12/2): 6919.
   <in> Ada.Containers.Hashed_Sets   *note A.18.8(14/2): 7053.
   <in> Ada.Containers.Indefinite_Holders   *note A.18.18(11/3): 7289.
   <in> Ada.Containers.Multiway_Trees   *note A.18.10(23/3): 7216.
   <in> Ada.Containers.Ordered_Maps   *note A.18.6(11/2): 6970.
   <in> Ada.Containers.Ordered_Sets   *note A.18.9(13/2): 7124.
   <in> Ada.Containers.Vectors   *note A.18.2(24/2): 6740.
   <in> Ada.Environment_Variables   *note A.17(7/2): 6704.
cleared
   termination handler   *note C.7.3(9/2): 7754.
clock   *note 9.6(6/3): 4144.
   <in> Ada.Calendar   *note 9.6(12): 4151.
   <in> Ada.Execution_Time   *note D.14(5/2): 8005.
   <in> Ada.Execution_Time.Interrupts   *note D.14.3(3/3): 8056.
   <in> Ada.Real_Time   *note D.8(6): 7952.
clock jump   *note D.8(32): 7967.
clock tick   *note D.8(23): 7966.
Clock_For_Interrupts
   <in> Ada.Execution_Time   *note D.14(9.3/3): 8010.
Close
   <in> Ada.Direct_IO   *note A.8.4(8): 6330.
   <in> Ada.Sequential_IO   *note A.8.1(8): 6303.
   <in> Ada.Streams.Stream_IO   *note A.12.1(10): 6576.
   <in> Ada.Text_IO   *note A.10.1(11): 6385.
close result set   *note G.2.3(5): 8354.
closed entry   *note 9.5.3(5): 4097.
   of a protected object   *note 9.5.3(7/3): 4102.
   of a task   *note 9.5.3(6/3): 4100.
closed under derivation   *note 3.4(28): 1559, *note N(6/2): 8889.
closure
   downward   *note 3.10.2(38/2): 2326.
COBOL
   <child of> Interfaces   *note B.4(7): 7545.
COBOL interface   *note B.4(1/3): 7544.
COBOL standard   *note 1.2(4/2): 1099.
COBOL_Character
   <in> Interfaces.COBOL   *note B.4(13): 7554.
COBOL_To_Ada
   <in> Interfaces.COBOL   *note B.4(15): 7556.
code point
   for characters   *note 3.5.2(2/3): 1707.
code_statement   *note 13.8(2): 5149.
   <used>   *note 5.1(4/2): 3133, *note P: 9368.
Coding aspect   *note 13.4(7): 5047.
coextension
   of an object   *note 3.10.2(14.4/3): 2301.
Col
   <in> Ada.Text_IO   *note A.10.1(37): 6437.
collection
   of an access type   *note 7.6.1(11.1/3): 3703.
colon   *note 2.1(15/3): 1169.
   <in> Ada.Characters.Latin_1   *note A.3.3(10): 5549.
column number   *note A.10(9): 6368.
comma   *note 2.1(15/3): 1161.
   <in> Ada.Characters.Latin_1   *note A.3.3(8): 5544.
Command_Line
   <child of> Ada   *note A.15(3): 6626.
Command_Name
   <in> Ada.Command_Line   *note A.15(6): 6629.
comment   *note 2.7(2): 1256.
comments, instructions for submission   *note 0.3(58/1): 1004.
Commercial_At
   <in> Ada.Characters.Latin_1   *note A.3.3(10): 5555.
Communication_Error
   <in> System.RPC   *note E.5(5): 8206.
comparison operator
   <See> relational operator   *note 4.5.2(1): 2760.
compatibility
   composite_constraint with an access subtype   *note 3.10(15/2): 2271.
   constraint with a subtype   *note 3.2.2(12): 1425.
   delta_constraint with an ordinary fixed point subtype   *note
J.3(9/4): 8500.
   digits_constraint with a decimal fixed point subtype   *note
3.5.9(18/4): 1859.
   digits_constraint with a floating point subtype   *note J.3(10/4):
8501.
   discriminant constraint with a subtype   *note 3.7.1(10): 2014.
   index constraint with a subtype   *note 3.6.1(7): 1941.
   range with a scalar subtype   *note 3.5(8): 1605.
   range_constraint with a scalar subtype   *note 3.5(8): 1606.
compatible
   a type, with a convention   *note B.1(12): 7406.
compilation   *note 10.1.1(2): 4322.
   separate   *note 10.1(1): 4316.
Compilation unit   *note 10.1(2): 4318, *note 10.1.1(9): 4352, *note
N(7): 8890.
compilation units needed
   by a compilation unit   *note 10.2(2): 4448.
   remote call interface   *note E.2.3(18): 8166.
   shared passive library unit   *note E.2.1(11): 8133.
compilation_unit   *note 10.1.1(3): 4324.
   <used>   *note 10.1.1(2): 4323, *note P: 9651.
compile-time error   *note 1.1.2(27): 1023, *note 1.1.5(4): 1072.
compile-time semantics   *note 1.1.2(28): 1028.
complete context   *note 8.6(4): 3848.
completely defined   *note 3.11.1(8): 2358.
completion
   abnormal   *note 7.6.1(2/2): 3692.
   compile-time concept   *note 3.11.1(1/3): 2354.
   normal   *note 7.6.1(2/2): 3690.
   run-time concept   *note 7.6.1(2/2): 3688.
completion and leaving (completed and left)   *note 7.6.1(2/2): 3687.
completion legality
   [<partial>]   *note 3.10.1(13): 2285.
   entry_body   *note 9.5.2(16): 4073.
Complex
   <in> Ada.Numerics.Generic_Complex_Types   *note G.1.1(3): 8259.
   <in> Interfaces.Fortran   *note B.5(9): 7605.
Complex_Arrays
   <child of> Ada.Numerics   *note G.3.2(53/2): 8422.
Complex_Elementary_Functions
   <child of> Ada.Numerics   *note G.1.2(9/1): 8306.
Complex_IO
   <child of> Ada.Text_IO   *note G.1.3(3): 8314.
   <child of> Ada.Wide_Text_IO   *note G.1.4(1): 8326.
   <child of> Ada.Wide_Wide_Text_IO   *note G.1.5(1/2): 8328.
Complex_Matrix
   <in> Ada.Numerics.Generic_Complex_Arrays   *note G.3.2(4/2): 8388.
Complex_Text_IO
   <child of> Ada   *note G.1.3(9.1/2): 8324.
Complex_Types
   <child of> Ada.Numerics   *note G.1.1(25/1): 8279.
Complex_Vector
   <in> Ada.Numerics.Generic_Complex_Arrays   *note G.3.2(4/2): 8387.
component   *note 3.2(2/2): 1337.
   of a type   *note 3.2(6/2): 1350.
component subtype   *note 3.6(10): 1909.
component_choice_list   *note 4.3.1(5): 2514.
   <used>   *note 4.3.1(4/2): 2513, *note P: 9240.
component_clause   *note 13.5.1(3): 5063.
   <used>   *note 13.5.1(2): 5062, *note P: 9826.
component_declaration   *note 3.8(6/3): 2036.
   <used>   *note 3.8(5/1): 2034, *note 9.4(6): 3976, *note P: 9577.
component_definition   *note 3.6(7/2): 1903.
   <used>   *note 3.6(3): 1893, *note 3.6(5): 1899, *note 3.8(6/3):
2038, *note P: 9148.
component_item   *note 3.8(5/1): 2033.
   <used>   *note 3.8(4): 2029, *note P: 9141.
component_list   *note 3.8(4): 2028.
   <used>   *note 3.8(3): 2027, *note 3.8.1(3): 2064, *note P: 9140.
Component_Size aspect   *note 13.3(70): 5026.
Component_Size attribute   *note 13.3(69): 5022.
Component_Size clause   *note 13.3(7/2): 4962, *note 13.3(70): 5024.
components
   of a record type   *note 3.8(9/2): 2042.
Compose
   <in> Ada.Directories   *note A.16(20/2): 6650.
   <in> Ada.Directories.Hierarchical_File_Names   *note A.16.1(14/3):
6697.
Compose attribute   *note A.5.3(24): 6209.
Compose_From_Cartesian
   <in> Ada.Numerics.Generic_Complex_Arrays   *note G.3.2(9/2): 8393,
*note G.3.2(29/2): 8406.
   <in> Ada.Numerics.Generic_Complex_Types   *note G.1.1(8): 8269.
Compose_From_Polar
   <in> Ada.Numerics.Generic_Complex_Arrays   *note G.3.2(11/2): 8399,
*note G.3.2(32/2): 8412.
   <in> Ada.Numerics.Generic_Complex_Types   *note G.1.1(11): 8275.
composite type   *note 3.2(2/2): 1336, *note N(8/2): 8891.
composite_constraint   *note 3.2.2(7): 1417.
   <used>   *note 3.2.2(5): 1412, *note P: 9049.
compound delimiter   *note 2.2(10): 1186.
compound_statement   *note 5.1(5/2): 3134.
   <used>   *note 5.1(3): 3120, *note P: 9356.
concatenation operator   *note 4.4(1/3): 2629, *note 4.5.3(3): 2819.
concrete subprogram
   <See> nonabstract subprogram   *note 3.9.3(1/2): 2184.
concrete type
   <See> nonabstract type   *note 3.9.3(1/2): 2182.
concurrent processing
   <See> task   *note 9(1/3): 3879.
condition   *note 4.5.7(4/3): 2887.
   <used>   *note 4.5.7(3/3): 2884, *note 5.3(2): 3172, *note 5.5(3/3):
3196, *note 5.7(2): 3268, *note 9.5.2(7): 4063, *note 9.7.1(3): 4222,
*note P: 9382.
   <See also> exception   *note 11(1/3): 4507.
conditional_entry_call   *note 9.7.3(2): 4251.
   <used>   *note 9.7(2): 4212, *note P: 9619.
conditional_expression   *note 4.5.7(2/3): 2878.
   <used>   *note 4.4(7/3): 2716, *note P: 9315.
configuration
   of the partitions of a program   *note E(4): 8099.
configuration pragma   *note 10.1.5(8): 4426.
   Assertion_Policy   *note 11.4.2(7/3): 4602.
   Detect_Blocking   *note H.5(4/2): 8486.
   Discard_Names   *note C.5(4): 7684.
   Locking_Policy   *note D.3(5): 7836.
   Normalize_Scalars   *note H.1(4): 8433.
   Partition_Elaboration_Policy   *note H.6(5/2): 8491.
   Priority_Specific_Dispatching   *note D.2.2(5/2): 7794.
   Profile   *note 13.12(14/3): 5308.
   Queuing_Policy   *note D.4(5): 7857.
   Restrictions   *note 13.12(8/3): 5302.
   Reviewable   *note H.3.1(4): 8438.
   Suppress   *note 11.5(5/2): 4623.
   Task_Dispatching_Policy   *note D.2.2(5/2): 7792.
   Unsuppress   *note 11.5(5/2): 4625.
confirming
   aspect specification   *note 13.1(18.2/3): 4903.
   nonoverridable aspect   *note 13.1.1(18.3/4): 4928.
   representation item   *note 13.1(18.2/3): 4901.
   representation value   *note 13.1(18.2/3): 4902.
conformance   *note 6.3.1(1): 3412.
   of an implementation with the Standard   *note 1.1.3(1): 1050.
   <See also> full conformance, mode conformance, subtype conformance,
type conformance
Conjugate
   <in> Ada.Numerics.Generic_Complex_Arrays   *note G.3.2(13/2): 8400,
*note G.3.2(34/2): 8413.
   <in> Ada.Numerics.Generic_Complex_Types   *note G.1.1(12): 8277,
*note G.1.1(15): 8278.
consistency
   among compilation units   *note 10.1.4(5): 4416.
constant   *note 3.3(13/3): 1456.
   result of a function_call   *note 6.4(12/2): 3469.
   <See also> literal   *note 4.2(1): 2477.
   <See also> static   *note 4.9(1): 3087.
constant indexing   *note 4.1.6(12/3): 2472.
constant object   *note 3.3(13/3): 1458.
constant view   *note 3.3(13/3): 1460.
Constant_Indexing aspect   *note 4.1.6(2/3): 2463.
Constant_Reference
   <in> Ada.Containers.Doubly_Linked_Lists   *note A.18.3(17.3/3): 6837.
   <in> Ada.Containers.Hashed_Maps   *note A.18.5(17.3/3): 6926, *note
A.18.5(17.5/3): 6928.
   <in> Ada.Containers.Hashed_Sets   *note A.18.8(17.2/3): 7057, *note
A.18.8(58.3/3): 7098.
   <in> Ada.Containers.Indefinite_Holders   *note A.18.18(18/3): 7296.
   <in> Ada.Containers.Multiway_Trees   *note A.18.10(30/3): 7223.
   <in> Ada.Containers.Ordered_Maps   *note A.18.6(16.3/3): 6977, *note
A.18.6(16.5/3): 6979.
   <in> Ada.Containers.Ordered_Sets   *note A.18.9(16.2/3): 7128, *note
A.18.9(73.3/3): 7179.
   <in> Ada.Containers.Vectors   *note A.18.2(34.3/3): 6752, *note
A.18.2(34.5/3): 6754.
Constant_Reference_Type
   <in> Ada.Containers.Indefinite_Holders   *note A.18.18(16/3): 7294.
   <in> Ada.Containers.Multiway_Trees   *note A.18.10(28/3): 7221.
Constants
   <child of> Ada.Strings.Maps   *note A.4.6(3/2): 5954.
constituent
   of a construct   *note 1.1.4(17): 1068.
constrained   *note 3.2(9): 1362.
   known to be   *note 3.3(23.1/3): 1471.
   object   *note 3.3.1(9/2): 1508.
   object   *note 6.4.1(16): 3486.
   subtype   *note 3.2(9): 1364, *note 3.4(6): 1541, *note 3.5(7): 1602,
*note 3.5.1(10): 1699, *note 3.5.4(9): 1735, *note 3.5.4(10): 1738,
*note 3.5.7(11): 1813, *note 3.5.9(13): 1851, *note 3.5.9(16): 1855,
*note 3.6(15): 1917, *note 3.6(16): 1920, *note 3.7(26): 1994, *note
3.9(15): 2120.
   subtype   *note 3.10(14/3): 2269.
   subtype   *note K.2(33): 8654.
Constrained attribute   *note 3.7.2(3/3): 2019, *note J.4(2): 8504.
constrained by its initial value   *note 3.3.1(9/2): 1505.
   [<partial>]   *note 4.8(6/3): 3056, *note 6.5(5.11/3): 3518.
constrained_array_definition   *note 3.6(5): 1896.
   <used>   *note 3.6(2): 1889, *note P: 9106.
constraint   *note 3.2.2(5): 1410.
   [<partial>]   *note 3.2(7/2): 1351.
   null   *note 3.2(7/2): 1353.
   of a first array subtype   *note 3.6(16): 1922.
   of a subtype   *note 3.2(8/2): 1357.
   of an object   *note 3.3.1(9/2): 1504.
   <used>   *note 3.2.2(3/2): 1407, *note P: 9046.
Constraint_Error
   raised by failure of run-time check   *note 3.2.2(12): 1426, *note
3.5(24): 1626, *note 3.5(27): 1633, *note 3.5(39.12/3): 1662, *note
3.5(39.4/3): 1656, *note 3.5(39.5/3): 1659, *note 3.5(43/3): 1668, *note
3.5(55/3): 1674, *note 3.5.4(20): 1759, *note 3.5.5(7): 1775, *note
3.5.9(19/4): 1863, *note 3.9.2(16): 2177, *note 4.1(13): 2392, *note
4.1.1(7): 2405, *note 4.1.2(7): 2416, *note 4.1.3(15): 2432, *note
4.1.5(8/3): 2461, *note 4.2(11): 2491, *note 4.3(6): 2504, *note
4.3.2(8/3): 2541, *note 4.3.3(31): 2581, *note 4.4(11): 2721, *note
4.5(10): 2736, *note 4.5(11): 2737, *note 4.5(12): 2738, *note 4.5.1(8):
2757, *note 4.5.3(8): 2825, *note 4.5.5(22): 2857, *note 4.5.6(6): 2868,
*note 4.5.6(12): 2874, *note 4.5.6(13): 2877, *note 4.5.7(21/3): 2904,
*note 4.6(28): 2969, *note 4.6(57/4): 3018, *note 4.6(60): 3023, *note
4.7(4/4): 3039, *note 4.8(10.4/3): 3082, *note 4.8(10/2): 3067, *note
5.2(10): 3164, *note 5.4(13): 3189, *note 6.5(5.11/3): 3519, *note
6.5(8.1/3): 3530, *note 11.1(4): 4519, *note 11.4.1(14/2): 4586, *note
11.5(10): 4628, *note 13.9.1(9): 5174, *note 13.11.2(15.2/4): 5243,
*note 13.13.2(35/3): 5367, *note A.4.3(109): 5842, *note A.4.7(47):
6007, *note A.4.8(51/2): 6048, *note A.5.1(28): 6142, *note A.5.1(34):
6143, *note A.5.2(39): 6177, *note A.5.2(40.1/1): 6179, *note A.5.3(26):
6210, *note A.5.3(29): 6215, *note A.5.3(47): 6233, *note A.5.3(50):
6238, *note A.5.3(53): 6243, *note A.5.3(59): 6248, *note A.5.3(62):
6253, *note A.15(14): 6634, *note B.3(53): 7492, *note B.3(54): 7493,
*note B.4(58): 7596, *note E.4(19): 8197, *note G.1.1(40): 8282, *note
G.1.2(28): 8309, *note G.2.1(12): 8339, *note G.2.2(7): 8348, *note
G.2.3(26): 8357, *note G.2.4(3): 8362, *note G.2.6(4): 8369, *note
K.2(11): 8650, *note K.2(114): 8665, *note K.2(122): 8668, *note
K.2(184): 8672, *note K.2(202): 8677, *note K.2(220): 8681, *note
K.2(241): 8684, *note K.2(261): 8690, *note K.2(41): 8655, *note
K.2(47): 8658.
   <in> Standard   *note A.1(46): 5451.
Construct   *note 1.1.4(16): 1067, *note N(9): 8892.
constructor
   <See> initialization   *note 3.3.1(18/2): 1518.
   <See> initialization   *note 7.6(1): 3654.
   <See> initialization expression   *note 3.3.1(4): 1499.
   <See> Initialize   *note 7.6(1): 3655.
   <See> initialized allocator   *note 4.8(4): 3054.
container   *note N(9.1/3): 8893.
   cursor   *note A.18(2/2): 6710.
   list   *note A.18.3(1/2): 6819.
   map   *note A.18.4(1/2): 6889.
   set   *note A.18.7(1/2): 7019.
   vector   *note A.18.2(1/2): 6720.
container element iterator   *note 5.5.2(3/3): 3247.
Containers
   <child of> Ada   *note A.18.1(3/2): 6715.
Containing_Directory
   <in> Ada.Directories   *note A.16(17/2): 6647.
   <in> Ada.Directories.Hierarchical_File_Names   *note A.16.1(11/3):
6694.
Contains
   <in> Ada.Containers.Doubly_Linked_Lists   *note A.18.3(43/2): 6866.
   <in> Ada.Containers.Hashed_Maps   *note A.18.5(32/2): 6946.
   <in> Ada.Containers.Hashed_Sets   *note A.18.8(44/2): 7082, *note
A.18.8(57/2): 7094.
   <in> Ada.Containers.Multiway_Trees   *note A.18.10(41/3): 7234.
   <in> Ada.Containers.Ordered_Maps   *note A.18.6(42/2): 7008.
   <in> Ada.Containers.Ordered_Sets   *note A.18.9(52/2): 7162, *note
A.18.9(72/2): 7175.
   <in> Ada.Containers.Vectors   *note A.18.2(71/2): 6794.
context free grammar
   complete listing   *note P: 8959.
   cross reference   *note P: 9848.
   notation   *note 1.1.4(3): 1062.
   under Syntax heading   *note 1.1.2(25): 1016.
context_clause   *note 10.1.2(2): 4368.
   <used>   *note 10.1.1(3): 4325, *note P: 9652.
context_item   *note 10.1.2(3): 4370.
   <used>   *note 10.1.2(2): 4369, *note P: 9669.
contiguous representation
   [<partial>]   *note 13.5.2(5): 5086, *note 13.7.1(12): 5141, *note
13.9(9): 5160, *note 13.9(17/3): 5163, *note 13.11(21.6/3): 5217.
Continue
   <in> Ada.Asynchronous_Task_Control   *note D.11(3/2): 7990.
control character
   a category of Character   *note A.3.2(22): 5488.
   a category of Character   *note A.3.3(4): 5499, *note A.3.3(15):
5593.
   <See also> format_effector   *note 2.1(13/3): 1146.
Control_Set
   <in> Ada.Strings.Maps.Constants   *note A.4.6(4): 5955.
Controlled
   <in> Ada.Finalization   *note 7.6(5/2): 3662.
controlled type   *note 7.6(2): 3657, *note 7.6(9/2): 3669, *note N(10):
8894.
controlling access result   *note 3.9.2(2/3): 2165.
controlling formal parameter   *note 3.9.2(2/3): 2162.
controlling operand   *note 3.9.2(2/3): 2161.
controlling result   *note 3.9.2(2/3): 2163.
controlling tag
   for a call on a dispatching operation   *note 3.9.2(1/2): 2153.
controlling tag value   *note 3.9.2(14): 2173.
   for the expression in an assignment_statement   *note 5.2(9): 3161.
controlling type
   of a formal_abstract_subprogram_declaration   *note 12.6(8.4/3):
4848.
convention   *note 6.3.1(2/1): 3417, *note B.1(11/3): 7404.
Convention aspect   *note B.1(2/3): 7398.
Convention pragma   *note J.15.5(4/3): 8577, *note L(8.1/3): 8725.
conversion   *note 4.6(1/3): 2921, *note 4.6(28): 2966.
   access   *note 4.6(24.11/2): 2952, *note 4.6(24.18/2): 2957, *note
4.6(24.19/2): 2959, *note 4.6(47): 2995.
   arbitrary order   *note 1.1.4(18): 1071.
   array   *note 4.6(24.2/2): 2947, *note 4.6(36): 2976.
   composite (non-array)   *note 4.6(21/3): 2941, *note 4.6(40): 2985.
   enumeration   *note 4.6(21.1/2): 2943, *note 4.6(34): 2974.
   numeric   *note 4.6(24.1/2): 2945, *note 4.6(29): 2971.
   unchecked   *note 13.9(1): 5156.
   value   *note 4.6(5/2): 2937.
   view   *note 4.6(5/2): 2935.
Conversion_Error
   <in> Interfaces.COBOL   *note B.4(30): 7578.
Conversions
   <child of> Ada.Characters   *note A.3.4(2/2): 5729.
   <child of> Ada.Strings.UTF_Encoding   *note A.4.11(15/3): 6075.
Convert
   <in> Ada.Strings.UTF_Encoding.Conversions   *note A.4.11(16/3): 6076,
*note A.4.11(17/3): 6077, *note A.4.11(18/3): 6078, *note A.4.11(19/3):
6079, *note A.4.11(20/3): 6080.
convertible   *note 4.6(4/3): 2933.
   required   *note 4.6(24.13/2): 2953, *note 4.6(24.4/2): 2948, *note
8.6(27.1/4): 3869.
Copy
   <in> Ada.Containers.Doubly_Linked_Lists   *note A.18.3(17.6/3): 6840.
   <in> Ada.Containers.Hashed_Maps   *note A.18.5(17.8/3): 6931.
   <in> Ada.Containers.Hashed_Sets   *note A.18.8(17.4/3): 7059.
   <in> Ada.Containers.Indefinite_Holders   *note A.18.18(21/3): 7299,
*note A.18.20(10/3): 7311, *note A.18.21(13/3): 7315, *note
A.18.22(10/3): 7318, *note A.18.23(13/3): 7322, *note A.18.24(10/3):
7325.
   <in> Ada.Containers.Multiway_Trees   *note A.18.10(33/3): 7226.
   <in> Ada.Containers.Ordered_Maps   *note A.18.6(16.8/3): 6982.
   <in> Ada.Containers.Ordered_Sets   *note A.18.9(16.4/3): 7130.
   <in> Ada.Containers.Vectors   *note A.18.2(34.8/3): 6757.
copy back of parameters   *note 6.4.1(17): 3489.
copy parameter passing   *note 6.2(2): 3389.
Copy_Array
   <in> Interfaces.C.Pointers   *note B.3.2(15): 7527.
Copy_File
   <in> Ada.Directories   *note A.16(13/2): 6644.
Copy_Sign attribute   *note A.5.3(51): 6242.
Copy_Subtree
   <in> Ada.Containers.Multiway_Trees   *note A.18.10(54/3): 7247.
Copy_Terminated_Array
   <in> Interfaces.C.Pointers   *note B.3.2(14): 7526.
Copyright_Sign
   <in> Ada.Characters.Latin_1   *note A.3.3(21/3): 5640.
core language   *note 1.1.2(2): 1005.
corresponding constraint   *note 3.4(6): 1543.
corresponding discriminants   *note 3.7(18): 1988.
corresponding expresssion
   class-wide postcondition   *note 6.1.1(18/4): 3366.
   class-wide precondition   *note 6.1.1(18/4): 3365.
corresponding index
   for an array_aggregate   *note 4.3.3(8): 2567.
corresponding subtype   *note 3.4(18/3): 1553.
corresponding value
   of the target type of a conversion   *note 4.6(28): 2965.
Cos
   <in> Ada.Numerics.Generic_Complex_Elementary_Functions   *note
G.1.2(4): 8291.
   <in> Ada.Numerics.Generic_Elementary_Functions   *note A.5.1(5):
6117.
Cosh
   <in> Ada.Numerics.Generic_Complex_Elementary_Functions   *note
G.1.2(6): 8299.
   <in> Ada.Numerics.Generic_Elementary_Functions   *note A.5.1(7):
6132.
Cot
   <in> Ada.Numerics.Generic_Complex_Elementary_Functions   *note
G.1.2(4): 8293.
   <in> Ada.Numerics.Generic_Elementary_Functions   *note A.5.1(5):
6121.
Coth
   <in> Ada.Numerics.Generic_Complex_Elementary_Functions   *note
G.1.2(6): 8301.
   <in> Ada.Numerics.Generic_Elementary_Functions   *note A.5.1(7):
6134.
Count
   <in> Ada.Direct_IO   *note A.8.4(4): 6326.
   <in> Ada.Streams.Stream_IO   *note A.12.1(7): 6572.
   <in> Ada.Strings.Bounded   *note A.4.4(48): 5874, *note A.4.4(49):
5875, *note A.4.4(50): 5876.
   <in> Ada.Strings.Fixed   *note A.4.3(13): 5817, *note A.4.3(14):
5818, *note A.4.3(15): 5819.
   <in> Ada.Strings.Unbounded   *note A.4.5(43): 5928, *note A.4.5(44):
5929, *note A.4.5(45): 5930.
   <in> Ada.Text_IO   *note A.10.1(5): 6377.
Count attribute   *note 9.9(5): 4304.
Count_Type
   <in> Ada.Containers   *note A.18.1(5/2): 6717.
Country
   <in> Ada.Locales   *note A.19(6/3): 7376.
Country code standard   *note 1.2(4.1/3): 1102.
Country_Code
   <in> Ada.Locales   *note A.19(4/4): 7372.
Country_Unknown
   <in> Ada.Locales   *note A.19(5/3): 7374.
cover
   a type   *note 3.4.1(9): 1575.
   of a choice and an exception   *note 11.2(6): 4541.
cover a value
   by a discrete_choice   *note 3.8.1(9): 2074.
   by a discrete_choice_list   *note 3.8.1(13): 2075.
CPU aspect   *note D.16(8/3): 8076.
CPU clock tick   *note D.14(15/2): 8013.
CPU pragma   *note J.15.9(2/3): 8628, *note L(8.2/3): 8729.
CPU <subtype of> CPU_Range
   <in> System.Multiprocessors   *note D.16(4/3): 8073.
CPU time
   of a task   *note D.14(11/3): 8012.
CPU_Range
   <in> System.Multiprocessors   *note D.16(4/3): 8071.
CPU_Set
   <in> System.Multiprocessors.Dispatching_Domains   *note
D.16.1(9.1/4): 8084.
CPU_Tick
   <in> Ada.Execution_Time   *note D.14(4/2): 8004.
CPU_Time
   <in> Ada.Execution_Time   *note D.14(4/2): 8000.
CPU_Time_First
   <in> Ada.Execution_Time   *note D.14(4/2): 8001.
CPU_Time_Last
   <in> Ada.Execution_Time   *note D.14(4/2): 8002.
CPU_Time_Unit
   <in> Ada.Execution_Time   *note D.14(4/2): 8003.
CR
   <in> Ada.Characters.Latin_1   *note A.3.3(5): 5513.
create   *note 3.1(12): 1327.
   <in> Ada.Direct_IO   *note A.8.4(6): 6328.
   <in> Ada.Sequential_IO   *note A.8.1(6): 6301.
   <in> Ada.Streams.Stream_IO   *note A.12.1(8): 6574.
   <in> Ada.Text_IO   *note A.10.1(9): 6383.
   <in> System.Multiprocessors.Dispatching_Domains   *note D.16.1(7/4):
8081, *note D.16.1(9.2/4): 8085.
Create_Directory
   <in> Ada.Directories   *note A.16(7/2): 6638.
Create_Path
   <in> Ada.Directories   *note A.16(9/2): 6640.
Create_Subpool
   <in> System.Storage_Pools.Subpools   *note 13.11.4(7/3): 5260.
creation
   of a protected object   *note C.3.1(10/3): 7646.
   of a return object   *note 6.5(5.11/3): 3517.
   of a tag   *note 13.14(20/2): 5430.
   of a task object   *note D.1(17/4): 7766.
   of an object   *note 3.3(1): 1454.
critical section
   <See> intertask communication   *note 9.5(1): 4011.
CSI
   <in> Ada.Characters.Latin_1   *note A.3.3(19): 5625.
Currency_Sign
   <in> Ada.Characters.Latin_1   *note A.3.3(21/3): 5635.
current column number   *note A.10(9): 6369.
current index
   of an open direct file   *note A.8(4): 6297.
   of an open stream file   *note A.12.1(1.1/1): 6566.
current instance
   of a generic unit   *note 8.6(18): 3858.
   of a type   *note 8.6(17/3): 3857.
current line number   *note A.10(9): 6370.
current mode
   of an open file   *note A.7(7): 6287.
current page number   *note A.10(9): 6371.
Current size
   of a stream file   *note A.12.1(1.1/1): 6567.
   of an external file   *note A.8(3): 6296.
Current_Directory
   <in> Ada.Directories   *note A.16(5/2): 6636.
Current_Error
   <in> Ada.Text_IO   *note A.10.1(17): 6401, *note A.10.1(20): 6408.
Current_Handler
   <in> Ada.Execution_Time.Group_Budgets   *note D.14.2(10/2): 8045.
   <in> Ada.Execution_Time.Timers   *note D.14.1(7/2): 8021.
   <in> Ada.Interrupts   *note C.3.2(6): 7664.
   <in> Ada.Real_Time.Timing_Events   *note D.15(5/2): 8063.
Current_Input
   <in> Ada.Text_IO   *note A.10.1(17): 6399, *note A.10.1(20): 6406.
Current_Output
   <in> Ada.Text_IO   *note A.10.1(17): 6400, *note A.10.1(20): 6407.
Current_State
   <in> Ada.Synchronous_Task_Control   *note D.10(4): 7977.
Current_Task
   <in> Ada.Task_Identification   *note C.7.1(3/3): 7712.
Current_Task_Fallback_Handler
   <in> Ada.Task_Termination   *note C.7.3(5/2): 7744.
Current_Use
   <in> Ada.Containers.Bounded_Priority_Queues   *note A.18.31(7/3):
7367.
   <in> Ada.Containers.Bounded_Synchronized_Queues   *note A.18.29(6/3):
7353.
   <in> Ada.Containers.Synchronized_Queue_Interfaces   *note
A.18.27(7/3): 7340.
   <in> Ada.Containers.Unbounded_Priority_Queues   *note A.18.30(7/3):
7360.
   <in> Ada.Containers.Unbounded_Synchronized_Queues   *note
A.18.28(6/3): 7347.
cursor
   ambiguous   *note A.18.2(240/2): 6812.
   for a container   *note A.18(2/2): 6709.
   invalid   *note A.18.2(248/2): 6815, *note A.18.3(153/2): 6885, *note
A.18.4(76/2): 6905, *note A.18.7(97/2): 7037, *note A.18.10(222/3):
7274.
   <in> Ada.Containers.Doubly_Linked_Lists   *note A.18.3(7/2): 6824.
   <in> Ada.Containers.Hashed_Maps   *note A.18.5(4/2): 6910.
   <in> Ada.Containers.Hashed_Sets   *note A.18.8(4/2): 7042.
   <in> Ada.Containers.Multiway_Trees   *note A.18.10(9/3): 7203.
   <in> Ada.Containers.Ordered_Maps   *note A.18.6(5/2): 6963.
   <in> Ada.Containers.Ordered_Sets   *note A.18.9(5/2): 7115.
   <in> Ada.Containers.Vectors   *note A.18.2(9/2): 6728.



File: arm2012.info,  Node: D,  Next: E,  Prev: C,  Up: Index

D 
==



dangling reference   *note 13.11.2(15.1/4): 5239.
dangling references
   prevention via accessibility rules   *note 3.10.2(3/2): 2293.
Data_Error
   <in> Ada.Direct_IO   *note A.8.4(18): 6353.
   <in> Ada.IO_Exceptions   *note A.13(4): 6620.
   <in> Ada.Sequential_IO   *note A.8.1(15): 6321.
   <in> Ada.Storage_IO   *note A.9(9): 6360.
   <in> Ada.Streams.Stream_IO   *note A.12.1(26): 6601.
   <in> Ada.Text_IO   *note A.10.1(85): 6526.
date and time formatting standard   *note 1.2(5.1/2): 1107.
Day
   <in> Ada.Calendar   *note 9.6(13): 4154.
   <in> Ada.Calendar.Formatting   *note 9.6.1(23/2): 4193.
Day_Count
   <in> Ada.Calendar.Arithmetic   *note 9.6.1(10/2): 4174.
Day_Duration <subtype of> Duration
   <in> Ada.Calendar   *note 9.6(11/2): 4150.
Day_Name
   <in> Ada.Calendar.Formatting   *note 9.6.1(17/2): 4178.
Day_Number <subtype of> Integer
   <in> Ada.Calendar   *note 9.6(11/2): 4149.
Day_of_Week
   <in> Ada.Calendar.Formatting   *note 9.6.1(18/2): 4186.
DC1
   <in> Ada.Characters.Latin_1   *note A.3.3(6): 5517.
DC2
   <in> Ada.Characters.Latin_1   *note A.3.3(6): 5518.
DC3
   <in> Ada.Characters.Latin_1   *note A.3.3(6): 5519.
DC4
   <in> Ada.Characters.Latin_1   *note A.3.3(6): 5520.
DCS
   <in> Ada.Characters.Latin_1   *note A.3.3(18): 5614.
Deadline <subtype of> Time
   <in> Ada.Dispatching.EDF   *note D.2.6(9/2): 7822.
Deallocate
   <in> System.Storage_Pools   *note 13.11(8): 5190.
   <in> System.Storage_Pools.Subpools   *note 13.11.4(15/3): 5267.
Deallocate_Subpool
   <in> System.Storage_Pools.Subpools   *note 13.11.4(12/3): 5264.
deallocation of storage   *note 13.11.2(1): 5225.
Decimal
   <child of> Ada   *note F.2(2): 8223.
decimal digit
   a category of Character   *note A.3.2(28): 5494.
decimal fixed point type   *note 3.5.9(1): 1827, *note 3.5.9(6): 1845.
Decimal_Conversions
   <in> Interfaces.COBOL   *note B.4(31): 7579.
Decimal_Digit_Set
   <in> Ada.Strings.Maps.Constants   *note A.4.6(4): 5961.
Decimal_Element
   <in> Interfaces.COBOL   *note B.4(12/3): 7552.
decimal_fixed_point_definition   *note 3.5.9(4): 1835.
   <used>   *note 3.5.9(2): 1831, *note P: 9097.
Decimal_IO
   <in> Ada.Text_IO   *note A.10.1(73): 6501.
decimal_literal   *note 2.4.1(2): 1211.
   <used>   *note 2.4(2): 1208, *note P: 8975.
Decimal_Output
   <in> Ada.Text_IO.Editing   *note F.3.3(11): 8246.
Declaration   *note 3.1(5): 1308, *note 3.1(6/3): 1311, *note N(11):
8895.
declaration list
   declarative_part   *note 3.11(6.1/2): 2344.
   package_specification   *note 7.1(6/2): 3584.
declarative region
   of a construct   *note 8.1(1): 3713.
declarative_item   *note 3.11(3): 2329.
   <used>   *note 3.11(2): 2328, *note P: 9184.
declarative_part   *note 3.11(2): 2327.
   <used>   *note 5.6(2): 3262, *note 6.3(2/3): 3406, *note 7.2(2/3):
3589, *note 9.1(6/3): 3914, *note 9.5.2(5): 4056, *note P: 9405.
declare   *note 3.1(8): 1320, *note 3.1(12): 1326.
declared pure   *note 10.2.1(17/3): 4485.
Decode
   <in> Ada.Strings.UTF_Encoding.Strings   *note A.4.11(26/3): 6085,
*note A.4.11(27/3): 6086, *note A.4.11(28/3): 6087.
   <in> Ada.Strings.UTF_Encoding.Wide_Strings   *note A.4.11(34/3):
6092, *note A.4.11(35/3): 6093, *note A.4.11(36/3): 6094.
   <in> Ada.Strings.UTF_Encoding.Wide_Wide_Strings   *note A.4.11(42/3):
6099, *note A.4.11(43/3): 6100, *note A.4.11(44/3): 6101.
Decrement
   <in> Interfaces.C.Pointers   *note B.3.2(11/3): 7524.
deeper
   accessibility level   *note 3.10.2(3/2): 2291.
   statically   *note 3.10.2(4): 2296, *note 3.10.2(17): 2303.
default constant indexing function   *note 5.5.1(16/3): 3233.
default cursor subtype   *note 5.5.1(8/3): 3223.
default directory   *note A.16(48/2): 6682.
default element subtype   *note 5.5.1(9/3): 3226.
default entry queuing policy   *note 9.5.3(17): 4112.
default iterator function   *note 5.5.1(8/3): 3221.
default iterator subtype   *note 5.5.1(8/3): 3222.
default pool   *note 13.11.3(4.2/4): 5251.
default treatment   *note C.3(5): 7640.
default variable indexing function   *note 5.5.1(21/3): 3234.
Default_Aft
   <in> Ada.Text_IO   *note A.10.1(64): 6483, *note A.10.1(69): 6493,
*note A.10.1(74): 6503.
   <in> Ada.Text_IO.Complex_IO   *note G.1.3(5): 8316.
Default_Base
   <in> Ada.Text_IO   *note A.10.1(53): 6465, *note A.10.1(58): 6474.
Default_Bit_Order
   <in> System   *note 13.7(15/2): 5126.
Default_Component_Value aspect   *note 3.6(22.2/3): 1930.
Default_Currency
   <in> Ada.Text_IO.Editing   *note F.3.3(10): 8242.
Default_Deadline
   <in> Ada.Dispatching.EDF   *note D.2.6(9/2): 7823.
Default_Exp
   <in> Ada.Text_IO   *note A.10.1(64): 6484, *note A.10.1(69): 6494,
*note A.10.1(74): 6504.
   <in> Ada.Text_IO.Complex_IO   *note G.1.3(5): 8317.
default_expression   *note 3.7(6): 1982.
   <used>   *note 3.7(5/2): 1978, *note 3.8(6/3): 2039, *note 6.1(15/3):
3327, *note 12.4(2/3): 4746, *note P: 9754.
Default_Fill
   <in> Ada.Text_IO.Editing   *note F.3.3(10): 8243.
Default_Fore
   <in> Ada.Text_IO   *note A.10.1(64): 6482, *note A.10.1(69): 6492,
*note A.10.1(74): 6502.
   <in> Ada.Text_IO.Complex_IO   *note G.1.3(5): 8315.
Default_Iterator aspect   *note 5.5.1(8/3): 3225.
Default_Modulus
   <in> Ada.Containers.Indefinite_Holders   *note A.18.21(10/3): 7314,
*note A.18.23(10/3): 7321.
default_name   *note 12.6(4): 4841.
   <used>   *note 12.6(3/2): 4840, *note P: 9788.
Default_Priority
   <in> System   *note 13.7(17): 5130.
Default_Quantum
   <in> Ada.Dispatching.Round_Robin   *note D.2.5(4/2): 7814.
Default_Radix_Mark
   <in> Ada.Text_IO.Editing   *note F.3.3(10): 8245.
Default_Separator
   <in> Ada.Text_IO.Editing   *note F.3.3(10): 8244.
Default_Setting
   <in> Ada.Text_IO   *note A.10.1(80): 6513.
Default_Storage_Pool aspect   *note 13.11.3(5/4): 5255.
Default_Storage_Pool pragma   *note 13.11.3(3/3): 5247, *note L(8.3/3):
8732.
Default_Subpool_for_Pool
   <in> System.Storage_Pools.Subpools   *note 13.11.4(13/3): 5265.
Default_Value aspect   *note 3.5(56.3/3): 1684.
Default_Width
   <in> Ada.Text_IO   *note A.10.1(53): 6464, *note A.10.1(58): 6473,
*note A.10.1(80): 6512.
deferred constant   *note 7.4(2/3): 3641.
deferred constant declaration   *note 3.3.1(6/3): 1501, *note 7.4(2/3):
3640.
defining name   *note 3.1(10): 1321.
defining_character_literal   *note 3.5.1(4): 1693.
   <used>   *note 3.5.1(3): 1692, *note P: 9083.
defining_designator   *note 6.1(6): 3298.
   <used>   *note 6.1(4.2/2): 3292, *note 12.3(2/3): 4705, *note P:
9731.
defining_identifier   *note 3.1(4): 1306.
   <used>   *note 3.2.1(3/3): 1374, *note 3.2.2(2/3): 1401, *note
3.3.1(3): 1495, *note 3.5.1(3): 1691, *note 3.10.1(2/2): 2276, *note
5.5(4): 3200, *note 5.5.2(2/3): 3238, *note 6.1(7): 3303, *note
6.5(2.1/3): 3500, *note 7.3(2/3): 3601, *note 7.3(3/3): 3605, *note
8.5.1(2/3): 3804, *note 8.5.2(2/3): 3813, *note 9.1(2/3): 3894, *note
9.1(3/3): 3900, *note 9.1(6/3): 3912, *note 9.4(2/3): 3956, *note
9.4(3/3): 3962, *note 9.4(7/3): 3978, *note 9.5.2(2/3): 4040, *note
9.5.2(5): 4053, *note 9.5.2(8): 4065, *note 10.1.3(4/3): 4397, *note
10.1.3(5/3): 4400, *note 10.1.3(6/3): 4403, *note 11.2(4): 4538, *note
12.5(2.1/3): 4771, *note 12.5(2.2/3): 4776, *note 12.7(2/3): 4853, *note
P: 9519.
defining_identifier_list   *note 3.3.1(3): 1494.
   <used>   *note 3.3.1(2/3): 1488, *note 3.3.2(2): 1524, *note
3.7(5/2): 1975, *note 3.8(6/3): 2037, *note 6.1(15/3): 3320, *note
11.1(2/3): 4516, *note 12.4(2/3): 4748, *note P: 9071.
defining_operator_symbol   *note 6.1(11): 3306.
   <used>   *note 6.1(6): 3300, *note P: 9424.
defining_program_unit_name   *note 6.1(7): 3301.
   <used>   *note 6.1(4.1/2): 3289, *note 6.1(6): 3299, *note 7.1(3/3):
3574, *note 7.2(2/3): 3587, *note 8.5.3(2/3): 3817, *note 8.5.5(2/3):
3836, *note 12.3(2/3): 4700, *note P: 9483.
Definite attribute   *note 12.5.1(23/3): 4808.
definite subtype   *note 3.3(23/3): 1469.
definition   *note 3.1(7): 1313.
Degree_Sign
   <in> Ada.Characters.Latin_1   *note A.3.3(22): 5647.
DEL
   <in> Ada.Characters.Latin_1   *note A.3.3(14): 5592.
delay_alternative   *note 9.7.1(6): 4230.
   <used>   *note 9.7.1(4): 4225, *note 9.7.2(2): 4243, *note P: 9635.
delay_relative_statement   *note 9.6(4): 4138.
   <used>   *note 9.6(2): 4135, *note P: 9614.
delay_statement   *note 9.6(2): 4133.
   <used>   *note 5.1(4/2): 3130, *note 9.7.1(6): 4231, *note
9.7.4(4/2): 4263, *note P: 9647.
Delay_Until_And_Set_CPU
   <in> System.Multiprocessors.Dispatching_Domains   *note D.16.1(14/3):
8091.
Delay_Until_And_Set_Deadline
   <in> Ada.Dispatching.EDF   *note D.2.6(9/2): 7825.
delay_until_statement   *note 9.6(3): 4136.
   <used>   *note 9.6(2): 4134, *note P: 9613.
Delete
   <in> Ada.Containers.Doubly_Linked_Lists   *note A.18.3(24/2): 6847.
   <in> Ada.Containers.Hashed_Maps   *note A.18.5(25/2): 6939, *note
A.18.5(26/2): 6940.
   <in> Ada.Containers.Hashed_Sets   *note A.18.8(24/2): 7066, *note
A.18.8(25/2): 7067, *note A.18.8(55/2): 7092.
   <in> Ada.Containers.Ordered_Maps   *note A.18.6(24/2): 6990, *note
A.18.6(25/2): 6991.
   <in> Ada.Containers.Ordered_Sets   *note A.18.9(23/2): 7137, *note
A.18.9(24/2): 7138, *note A.18.9(68/2): 7171.
   <in> Ada.Containers.Vectors   *note A.18.2(50/2): 6773, *note
A.18.2(51/2): 6774.
   <in> Ada.Direct_IO   *note A.8.4(8): 6331.
   <in> Ada.Sequential_IO   *note A.8.1(8): 6304.
   <in> Ada.Streams.Stream_IO   *note A.12.1(10): 6577.
   <in> Ada.Strings.Bounded   *note A.4.4(64): 5889, *note A.4.4(65):
5890.
   <in> Ada.Strings.Fixed   *note A.4.3(29): 5832, *note A.4.3(30):
5833.
   <in> Ada.Strings.Unbounded   *note A.4.5(59): 5943, *note A.4.5(60):
5944.
   <in> Ada.Text_IO   *note A.10.1(11): 6386.
Delete_Children
   <in> Ada.Containers.Multiway_Trees   *note A.18.10(53/3): 7246.
Delete_Directory
   <in> Ada.Directories   *note A.16(8/2): 6639.
Delete_File
   <in> Ada.Directories   *note A.16(11/2): 6642.
Delete_First
   <in> Ada.Containers.Doubly_Linked_Lists   *note A.18.3(25/2): 6848.
   <in> Ada.Containers.Ordered_Maps   *note A.18.6(26/2): 6992.
   <in> Ada.Containers.Ordered_Sets   *note A.18.9(25/2): 7139.
   <in> Ada.Containers.Vectors   *note A.18.2(52/2): 6775.
Delete_Last
   <in> Ada.Containers.Doubly_Linked_Lists   *note A.18.3(26/2): 6849.
   <in> Ada.Containers.Ordered_Maps   *note A.18.6(27/2): 6993.
   <in> Ada.Containers.Ordered_Sets   *note A.18.9(26/2): 7140.
   <in> Ada.Containers.Vectors   *note A.18.2(53/2): 6776.
Delete_Leaf
   <in> Ada.Containers.Multiway_Trees   *note A.18.10(35/3): 7228.
Delete_Subtree
   <in> Ada.Containers.Multiway_Trees   *note A.18.10(36/3): 7229.
Delete_Tree
   <in> Ada.Directories   *note A.16(10/2): 6641.
delimiter   *note 2.2(8/2): 1185.
delivery
   of an interrupt   *note C.3(2): 7633.
delta
   of a fixed point type   *note 3.5.9(1): 1828.
Delta attribute   *note 3.5.10(3): 1871.
delta_constraint   *note J.3(2/4): 8495.
   <used>   *note 3.2.2(6): 1416, *note P: 9052.
Denorm attribute   *note A.5.3(9): 6191.
denormalized number   *note A.5.3(10): 6192.
denote   *note 8.6(16): 3856.
   informal definition   *note 3.1(8): 1319.
   name used as a pragma argument   *note 8.6(32): 3873.
depend on a discriminant
   for a component   *note 3.7(20): 1991.
   for a constraint or component_definition   *note 3.7(19): 1990.
dependence
   elaboration   *note 10.2(9): 4453.
   of a task on a master   *note 9.3(1): 3941.
   of a task on another task   *note 9.3(4): 3945.
   semantic   *note 10.1.1(26/2): 4367.
depth
   accessibility level   *note 3.10.2(3/2): 2292.
   <in> Ada.Containers.Multiway_Trees   *note A.18.10(19/3): 7212.
depth-first order   *note A.18.10(5/3): 7200.
Dequeue
   <in> Ada.Containers.Bounded_Priority_Queues   *note A.18.31(5/3):
7365.
   <in> Ada.Containers.Bounded_Synchronized_Queues   *note A.18.29(5/3):
7352.
   <in> Ada.Containers.Synchronized_Queue_Interfaces   *note
A.18.27(6/3): 7339.
   <in> Ada.Containers.Unbounded_Priority_Queues   *note A.18.30(5/3):
7358.
   <in> Ada.Containers.Unbounded_Synchronized_Queues   *note
A.18.28(5/3): 7346.
Dequeue_Only_High_Priority
   <in> Ada.Containers.Bounded_Priority_Queues   *note A.18.31(6/3):
7366.
   <in> Ada.Containers.Unbounded_Priority_Queues   *note A.18.30(6/3):
7359.
dereference   *note 4.1(8): 2382.
Dereference_Error
   <in> Interfaces.C.Strings   *note B.3.1(12): 7505.
derivation class
   for a type   *note 3.4.1(2/2): 1562.
derived from
   directly or indirectly   *note 3.4.1(2/2): 1561.
derived type   *note 3.4(1/2): 1529, *note N(13/2): 8898.
   [<partial>]   *note 3.4(24): 1555.
derived_type_definition   *note 3.4(2/2): 1533.
   <used>   *note 3.2.1(4/2): 1387, *note P: 9039.
descendant   *note 10.1.1(11): 4358, *note N(13.1/2): 8899.
   at run-time   *note 3.9(12.3/3): 2115.
   of a tree node   *note A.18.10(4/3): 7199.
   of a type   *note 3.4.1(10/2): 1576.
   of the full view of a type   *note 7.3.1(5.1/3): 3624.
   relationship with scope   *note 8.2(4): 3722.
Descendant_Tag
   <in> Ada.Tags   *note 3.9(7.1/2): 2108.
designate   *note 3.10(1): 2224.
designated profile
   of an access-to-subprogram type   *note 3.10(11): 2261.
   of an anonymous access type   *note 3.10(12/3): 2266.
designated subtype
   of a named access type   *note 3.10(10): 2256.
   of an anonymous access type   *note 3.10(12/3): 2264.
designated type
   of a named access type   *note 3.10(10): 2257.
   of an anonymous access type   *note 3.10(12/3): 2265.
designator   *note 6.1(5): 3294.
   <used>   *note 6.3(2/3): 3408, *note P: 9450.
destructor
   <See> finalization   *note 7.6(1): 3656.
   <See> finalization   *note 7.6.1(1): 3686.
Detach_Handler
   <in> Ada.Interrupts   *note C.3.2(9): 7667.
Detect_Blocking pragma   *note H.5(3/2): 8485, *note L(8.4/2): 8735.
Determinant
   <in> Ada.Numerics.Generic_Complex_Arrays   *note G.3.2(46/2): 8418.
   <in> Ada.Numerics.Generic_Real_Arrays   *note G.3.1(24/2): 8378.
determined category for a formal type   *note 12.5(6/3): 4798.
determines
   a type by a subtype_mark   *note 3.2.2(8): 1420.
Device_Error
   <in> Ada.Direct_IO   *note A.8.4(18): 6351.
   <in> Ada.Directories   *note A.16(43/2): 6674.
   <in> Ada.IO_Exceptions   *note A.13(4): 6618.
   <in> Ada.Sequential_IO   *note A.8.1(15): 6319.
   <in> Ada.Streams.Stream_IO   *note A.12.1(26): 6599.
   <in> Ada.Text_IO   *note A.10.1(85): 6524.
Diaeresis
   <in> Ada.Characters.Latin_1   *note A.3.3(21/3): 5639.
Difference
   <in> Ada.Calendar.Arithmetic   *note 9.6.1(12/2): 4176.
   <in> Ada.Containers.Hashed_Sets   *note A.18.8(32/2): 7072, *note
A.18.8(33/2): 7073.
   <in> Ada.Containers.Ordered_Sets   *note A.18.9(33/2): 7145, *note
A.18.9(34/2): 7146.
digit   *note 2.4.1(4.1/2): 1222.
   <used>   *note 2.4.1(3): 1218, *note 2.4.2(5): 1245, *note P: 8993.
digits
   of a decimal fixed point subtype   *note 3.5.9(6): 1844, *note
3.5.10(7): 1878.
Digits attribute   *note 3.5.8(2/1): 1823, *note 3.5.10(7): 1877.
digits_constraint   *note 3.5.9(5/4): 1839.
   <used>   *note 3.2.2(6): 1415, *note P: 9051.
dimensionality
   of an array   *note 3.6(12): 1910.
direct access   *note A.8(3): 6294.
direct file   *note A.8(1/2): 6291.
Direct_IO
   <child of> Ada   *note A.8.4(2): 6323.
direct_name   *note 4.1(3): 2372.
   <used>   *note 3.8.1(2): 2059, *note 4.1(2/3): 2360, *note 5.1(8):
3146, *note 9.5.2(3): 4045, *note 10.2.1(4.2/2): 4469, *note 13.1(3):
4878, *note J.7(1): 8506, *note L(25.2/2): 8811, *note P: 9803.
Direction
   <in> Ada.Strings   *note A.4.1(6): 5781.
directly specified
   of a representation aspect of an entity   *note 13.1(8/3): 4888.
   of an operational aspect of an entity   *note 13.1(8.1/3): 4894.
directly visible   *note 8.3(2): 3736, *note 8.3(21): 3759.
   within a pragma in a context_clause   *note 10.1.6(3): 4434.
   within a pragma that appears at the place of a compilation unit  
*note 10.1.6(5): 4438.
   within a use_clause in a context_clause   *note 10.1.6(3): 4432.
   within a with_clause   *note 10.1.6(2/2): 4430.
   within the parent_unit_name of a library unit   *note 10.1.6(2/2):
4428.
   within the parent_unit_name of a subunit   *note 10.1.6(4): 4436.
Directories
   <child of> Ada   *note A.16(3/2): 6635.
directory   *note A.16(45/2): 6675.
directory entry   *note A.16(49/2): 6683.
directory name   *note A.16(46/2): 6678.
Directory_Entry_Type
   <in> Ada.Directories   *note A.16(29/2): 6659.
disabled
   predicate checks   *note 3.2.4(7/3): 1442.
Discard_Names aspect   *note C.5(1.3/4): 7680.
Discard_Names pragma   *note C.5(3): 7682, *note L(9): 8737.
discontiguous representation
   [<partial>]   *note 13.5.2(5): 5087, *note 13.7.1(12): 5142, *note
13.9(9): 5161, *note 13.9(17/3): 5164, *note 13.11(21.6/3): 5218.
discrete array type   *note 4.5.2(1): 2789.
discrete type   *note 3.2(3): 1340, *note 3.5(1): 1582, *note N(14):
8900.
discrete_choice   *note 3.8.1(5/3): 2068.
   <used>   *note 3.8.1(4): 2067, *note P: 9156.
discrete_choice_list   *note 3.8.1(4): 2065.
   <used>   *note 3.8.1(3): 2063, *note 4.3.3(5/2): 2558, *note
4.5.7(6/3): 2894, *note 5.4(3): 3181, *note P: 9263.
Discrete_Random
   <child of> Ada.Numerics   *note A.5.2(17): 6160.
discrete_range   *note 3.6.1(3): 1935.
   <used>   *note 3.6.1(2): 1934, *note 4.1.2(2): 2409, *note P: 9119.
discrete_subtype_definition   *note 3.6(6): 1900.
   <used>   *note 3.6(5): 1898, *note 5.5(4): 3201, *note 9.5.2(2/3):
4041, *note 9.5.2(8): 4066, *note P: 9112.
discriminant   *note 3.2(5/2): 1346, *note 3.7(1/2): 1964, *note
N(15/2): 8901.
   of a variant_part   *note 3.8.1(6): 2072.
   use in a record definition   *note 3.8(12/3): 2043.
discriminant_association   *note 3.7.1(3): 2004.
   <used>   *note 3.7.1(2): 2002, *note P: 9135.
Discriminant_Check   *note 11.5(12): 4630.
   [<partial>]   *note 4.1.3(15): 2429, *note 4.3(6): 2502, *note
4.3.2(8/3): 2539, *note 4.6(43): 2988, *note 4.6(45): 2990, *note
4.6(51/4): 3000, *note 4.6(52): 3013, *note 4.7(4/4): 3034, *note
4.8(10/2): 3065, *note 6.5(5.11/3): 3520.
discriminant_constraint   *note 3.7.1(2): 2001.
   <used>   *note 3.2.2(7): 1419, *note P: 9054.
discriminant_part   *note 3.7(2/2): 1967.
   <used>   *note 3.10.1(2/2): 2277, *note 7.3(2/3): 3602, *note
7.3(3/3): 3606, *note 12.5(2.1/3): 4772, *note 12.5(2.2/3): 4777, *note
P: 9759.
discriminant_specification   *note 3.7(5/2): 1974.
   <used>   *note 3.7(4): 1973, *note P: 9125.
discriminants
   known   *note 3.7(26): 1993.
   unknown   *note 3.7(26): 1997.
discriminated type   *note 3.7(8/2): 1985.
dispatching   *note 3.9(3): 2094.
   <child of> Ada   *note D.2.1(1.2/3): 7769.
dispatching call
   on a dispatching operation   *note 3.9.2(1/2): 2147.
dispatching domain   *note D.16.1(16/4): 8092.
dispatching operation   *note 3.9.2(1/2): 2146, *note 3.9.2(2/3): 2160.
   [<partial>]   *note 3.9(1): 2079.
dispatching point   *note D.2.1(4/2): 7775.
   [<partial>]   *note D.2.3(8/2): 7801, *note D.2.4(9/3): 7810.
dispatching policy for tasks
   [<partial>]   *note D.2.1(5/2): 7781.
dispatching, task   *note D.2.1(4/2): 7773.
Dispatching_Domain
   <in> System.Multiprocessors.Dispatching_Domains   *note D.16.1(5/3):
8079.
Dispatching_Domain aspect   *note D.16.1(18/3): 8094.
Dispatching_Domain pragma   *note J.15.10(2/3): 8632, *note L(9.1/3):
8740.
Dispatching_Domain_Error
   <in> System.Multiprocessors.Dispatching_Domains   *note D.16.1(4/3):
8078.
Dispatching_Domains
   <child of> System.Multiprocessors   *note D.16.1(3/3): 8077.
Dispatching_Policy_Error
   <in> Ada.Dispatching   *note D.2.1(1.4/3): 7771.
Display_Format
   <in> Interfaces.COBOL   *note B.4(22): 7563.
displayed magnitude (of a decimal value)   *note F.3.2(14): 8233.
disruption of an assignment   *note 9.8(21): 4295, *note 13.9.1(5):
5168.
   [<partial>]   *note 11.6(6/3): 4661.
distinct access paths   *note 6.2(12/3): 3397.
distributed accessibility   *note 3.10.2(33.1/3): 2321.
distributed program   *note E(3): 8098.
distributed system   *note E(2): 8097.
distributed systems   *note C(1): 7621.
divide   *note 2.1(15/3): 1168.
   <in> Ada.Decimal   *note F.2(6/3): 8229.
divide operator   *note 4.4(1/3): 2640, *note 4.5.5(1): 2848.
Division_Check   *note 11.5(13/2): 4631.
   [<partial>]   *note 3.5.4(20): 1757, *note 4.5.5(22): 2855, *note
A.5.1(28): 6140, *note A.5.3(47): 6234, *note G.1.1(40): 8280, *note
G.1.2(28): 8307, *note K.2(202): 8678.
Division_Sign
   <in> Ada.Characters.Latin_1   *note A.3.3(26): 5720.
DLE
   <in> Ada.Characters.Latin_1   *note A.3.3(6): 5516.
Do_APC
   <in> System.RPC   *note E.5(10): 8211.
Do_RPC
   <in> System.RPC   *note E.5(9): 8210.
documentation (required of an implementation)   *note 1.1.3(18): 1058,
*note M.1(1/2): 8872, *note M.2(1/2): 8874, *note M.3(1/2): 8877.
documentation requirements   *note 1.1.2(34): 1044, *note M(1/3): 8870.
   summary of requirements   *note M.1(1/2): 8871.
Dollar_Sign
   <in> Ada.Characters.Latin_1   *note A.3.3(8): 5536.
dot   *note 2.1(15/3): 1165.
dot selection
   <See> selected_component   *note 4.1.3(1): 2417.
double
   <in> Interfaces.C   *note B.3(16): 7449.
Double_Precision
   <in> Interfaces.Fortran   *note B.5(6): 7602.
Doubly_Linked_Lists
   <child of> Ada.Containers   *note A.18.3(5/3): 6822.
downward closure   *note 3.10.2(38/2): 2325.
drift rate   *note D.8(41): 7968.
Duration
   <in> Standard   *note A.1(43): 5450.
dynamic binding
   <See> dispatching operation   *note 3.9(1): 2081.
dynamic semantics   *note 1.1.2(30): 1035.
Dynamic_Predicate aspect   *note 3.2.4(1/3): 1439.
Dynamic_Priorities
   <child of> Ada   *note D.5.1(3/2): 7865.
dynamically determined tag   *note 3.9.2(1/2): 2150.
dynamically enclosing
   of one execution by another   *note 11.4(2): 4556.
dynamically tagged   *note 3.9.2(5/2): 2168.



File: arm2012.info,  Node: E,  Next: F,  Prev: D,  Up: Index

E 
==



e
   <in> Ada.Numerics   *note A.5(3/2): 6109.
EDF
   <child of> Ada.Dispatching   *note D.2.6(9/2): 7821.
   <child of> Ada.Synchronous_Task_Control   *note D.10(5.2/3): 7979.
EDF_Across_Priorities task dispatching policy   *note D.2.6(7/2): 7820.
edited output   *note F.3(1/2): 8230.
Editing
   <child of> Ada.Text_IO   *note F.3.3(3): 8234.
   <child of> Ada.Wide_Text_IO   *note F.3.4(1): 8254.
   <child of> Ada.Wide_Wide_Text_IO   *note F.3.5(1/2): 8256.
effect
   external   *note 1.1.3(8): 1052.
efficiency   *note 11.5(29): 4647, *note 11.6(1/3): 4653.
Eigensystem
   <in> Ada.Numerics.Generic_Complex_Arrays   *note G.3.2(49/2): 8420.
   <in> Ada.Numerics.Generic_Real_Arrays   *note G.3.1(27/2): 8380.
Eigenvalues
   <in> Ada.Numerics.Generic_Complex_Arrays   *note G.3.2(48/2): 8419.
   <in> Ada.Numerics.Generic_Real_Arrays   *note G.3.1(26/2): 8379.
Elaborate pragma   *note 10.2.1(20): 4490, *note L(10): 8742.
Elaborate_All pragma   *note 10.2.1(21): 4494, *note L(11): 8746.
Elaborate_Body aspect   *note 10.2.1(26.1/3): 4505.
Elaborate_Body pragma   *note 10.2.1(22): 4498, *note L(12): 8750.
elaborated   *note 3.11(8): 2346.
elaboration   *note 3.1(11): 1324, *note N(15.1/2): 8902, *note N(19):
8910.
   abstract_subprogram_declaration   *note 3.9.3(11.1/2): 2194.
   access_definition   *note 3.10(17/2): 2274.
   access_type_definition   *note 3.10(16): 2273.
   array_type_definition   *note 3.6(21): 1925.
   aspect_clause   *note 13.1(19/1): 4907.
   choice_parameter_specification   *note 11.4(7): 4563.
   component_declaration   *note 3.8(17): 2051.
   component_definition   *note 3.6(22/2): 1927, *note 3.8(18/2): 2055.
   component_list   *note 3.8(17): 2050.
   declaration with a True Import aspect   *note B.1(38/3): 7413.
   declarative_part   *note 3.11(7): 2345.
   deferred constant declaration   *note 7.4(10/3): 3644.
   delta_constraint   *note J.3(11): 8502.
   derived_type_definition   *note 3.4(26): 1556.
   digits_constraint   *note 3.5.9(19/4): 1860.
   discrete_subtype_definition   *note 3.6(22/2): 1926.
   discriminant_constraint   *note 3.7.1(12): 2016.
   entry_declaration   *note 9.5.2(22/1): 4082.
   enumeration_type_definition   *note 3.5.1(10): 1698.
   exception_declaration   *note 11.1(5): 4523.
   expression_function_declaration   *note 6.8(8/3): 3565.
   fixed_point_definition   *note 3.5.9(17): 1858.
   floating_point_definition   *note 3.5.7(13): 1816.
   full type definition   *note 3.2.1(11): 1399.
   full_type_declaration   *note 3.2.1(11): 1398.
   generic body   *note 12.2(2): 4692.
   generic_declaration   *note 12.1(10): 4690.
   generic_instantiation   *note 12.3(20): 4736.
   incomplete_type_declaration   *note 3.10.1(12): 2284.
   index_constraint   *note 3.6.1(8): 1944.
   integer_type_definition   *note 3.5.4(18): 1753.
   loop_parameter_specification   *note 5.5(9/4): 3207.
   nongeneric package_body   *note 7.2(6): 3594.
   nongeneric subprogram_body   *note 6.3(6): 3410.
   null_procedure_declaration   *note 6.7(5/3): 3550.
   number_declaration   *note 3.3.2(7): 1528.
   object_declaration   *note 3.3.1(15): 1513.
   of library units for a foreign language main subprogram   *note
B.1(39/3): 7418.
   package_body of Standard   *note A.1(50): 5455.
   package_declaration   *note 7.1(8): 3585.
   partition   *note E.1(6): 8103.
   partition   *note E.5(21): 8214.
   per-object constraint   *note 3.8(18.1/1): 2056.
   pragma   *note 2.8(12): 1279.
   private_extension_declaration   *note 7.3(17): 3619.
   private_type_declaration   *note 7.3(17): 3618.
   protected declaration   *note 9.4(12): 4001.
   protected_body   *note 9.4(15): 4005.
   protected_definition   *note 9.4(13): 4003.
   range_constraint   *note 3.5(9): 1607.
   real_type_definition   *note 3.5.6(5): 1792.
   record_definition   *note 3.8(16): 2049.
   record_extension_part   *note 3.9.1(5): 2145.
   record_type_definition   *note 3.8(16): 2048.
   renaming_declaration   *note 8.5(3): 3795.
   single_protected_declaration   *note 9.4(12): 4002.
   single_task_declaration   *note 9.1(10): 3928.
   subprogram_declaration   *note 6.1(31/2): 3344.
   subtype_declaration   *note 3.2.2(9): 1421.
   subtype_indication   *note 3.2.2(9): 1422.
   task declaration   *note 9.1(10): 3927.
   task_body   *note 9.1(13): 3931.
   task_definition   *note 9.1(11): 3929.
   use_clause   *note 8.4(12): 3788.
   variant_part   *note 3.8.1(22): 2078.
elaboration control   *note 10.2.1(1): 4461.
elaboration dependence
   library_item on another   *note 10.2(9): 4452.
Elaboration_Check   *note 11.5(20): 4640.
   [<partial>]   *note 3.11(9): 2347.
element
   of a storage pool   *note 13.11(11): 5196.
   <in> Ada.Containers.Doubly_Linked_Lists   *note A.18.3(14/2): 6832.
   <in> Ada.Containers.Hashed_Maps   *note A.18.5(14/2): 6921, *note
A.18.5(31/2): 6945.
   <in> Ada.Containers.Hashed_Sets   *note A.18.8(15/2): 7054, *note
A.18.8(52/2): 7089.
   <in> Ada.Containers.Indefinite_Holders   *note A.18.18(12/3): 7290.
   <in> Ada.Containers.Multiway_Trees   *note A.18.10(24/3): 7217.
   <in> Ada.Containers.Ordered_Maps   *note A.18.6(13/2): 6972, *note
A.18.6(39/2): 7005.
   <in> Ada.Containers.Ordered_Sets   *note A.18.9(14/2): 7125, *note
A.18.9(65/2): 7168.
   <in> Ada.Containers.Vectors   *note A.18.2(27/2): 6743, *note
A.18.2(28/2): 6744.
   <in> Ada.Strings.Bounded   *note A.4.4(26): 5861.
   <in> Ada.Strings.Unbounded   *note A.4.5(20): 5915.
elementary type   *note 3.2(2/2): 1335, *note N(16): 8903.
Elementary_Functions
   <child of> Ada.Numerics   *note A.5.1(9/1): 6139.
eligible
   a type, for a convention   *note B.1(14/3): 7407.
else part
   of a selective_accept   *note 9.7.1(11): 4234.
EM
   <in> Ada.Characters.Latin_1   *note A.3.3(6): 5525.
embedded systems   *note C(1): 7620, *note D(1): 7756.
empty element
   of a vector   *note A.18.2(4/2): 6723.
empty holder   *note A.18.18(3/3): 7283.
Empty_Holder
   <in> Ada.Containers.Indefinite_Holders   *note A.18.18(7/3): 7286.
Empty_List
   <in> Ada.Containers.Doubly_Linked_Lists   *note A.18.3(8/2): 6825.
Empty_Map
   <in> Ada.Containers.Hashed_Maps   *note A.18.5(5/2): 6911.
   <in> Ada.Containers.Ordered_Maps   *note A.18.6(6/2): 6964.
Empty_Set
   <in> Ada.Containers.Hashed_Sets   *note A.18.8(5/2): 7043.
   <in> Ada.Containers.Ordered_Sets   *note A.18.9(6/2): 7116.
Empty_Tree
   <in> Ada.Containers.Multiway_Trees   *note A.18.10(10/3): 7204.
Empty_Vector
   <in> Ada.Containers.Vectors   *note A.18.2(10/2): 6729.
enabled
   invariant expression   *note 7.3.2(21/4): 3638.
   postcondition expression   *note 6.1.1(19/3): 3368.
   precondition expression   *note 6.1.1(19/3): 3367.
   predicate checks   *note 3.2.4(7/3): 1441.
encapsulation
   <See> package   *note 7(1): 3568.
enclosing
   immediately   *note 8.1(13): 3718.
Encode
   <in> Ada.Strings.UTF_Encoding.Strings   *note A.4.11(23/3): 6082,
*note A.4.11(24/3): 6083, *note A.4.11(25/3): 6084.
   <in> Ada.Strings.UTF_Encoding.Wide_Strings   *note A.4.11(31/3):
6089, *note A.4.11(32/3): 6090, *note A.4.11(33/3): 6091.
   <in> Ada.Strings.UTF_Encoding.Wide_Wide_Strings   *note A.4.11(39/3):
6096, *note A.4.11(40/3): 6097, *note A.4.11(41/3): 6098.
Encoding
   <in> Ada.Strings.UTF_Encoding   *note A.4.11(13/3): 6074.
encoding scheme   *note A.4.11(46/3): 6102.
Encoding_Error
   <in> Ada.Strings.UTF_Encoding   *note A.4.11(8/3): 6069.
Encoding_Scheme
   <in> Ada.Strings.UTF_Encoding   *note A.4.11(4/3): 6065.
end of a line   *note 2.2(2/3): 1183.
End_Error
   raised by failure of run-time check   *note 13.13.2(37/1): 5369.
   <in> Ada.Direct_IO   *note A.8.4(18): 6352.
   <in> Ada.IO_Exceptions   *note A.13(4): 6619.
   <in> Ada.Sequential_IO   *note A.8.1(15): 6320.
   <in> Ada.Streams.Stream_IO   *note A.12.1(26): 6600.
   <in> Ada.Text_IO   *note A.10.1(85): 6525.
End_Of_File
   <in> Ada.Direct_IO   *note A.8.4(16): 6346.
   <in> Ada.Sequential_IO   *note A.8.1(13): 6314.
   <in> Ada.Streams.Stream_IO   *note A.12.1(12): 6584.
   <in> Ada.Text_IO   *note A.10.1(34): 6431.
End_Of_Line
   <in> Ada.Text_IO   *note A.10.1(30): 6423.
End_Of_Page
   <in> Ada.Text_IO   *note A.10.1(33): 6429.
End_Search
   <in> Ada.Directories   *note A.16(33/2): 6663.
endian
   big   *note 13.5.3(2): 5091.
   little   *note 13.5.3(2): 5094.
ENQ
   <in> Ada.Characters.Latin_1   *note A.3.3(5): 5505.
Enqueue
   <in> Ada.Containers.Bounded_Priority_Queues   *note A.18.31(5/3):
7364.
   <in> Ada.Containers.Bounded_Synchronized_Queues   *note A.18.29(5/3):
7351.
   <in> Ada.Containers.Synchronized_Queue_Interfaces   *note
A.18.27(5/3): 7338.
   <in> Ada.Containers.Unbounded_Priority_Queues   *note A.18.30(5/3):
7357.
   <in> Ada.Containers.Unbounded_Synchronized_Queues   *note
A.18.28(5/3): 7345.
entity
   [<partial>]   *note 3.1(1): 1290.
entity with runtime name text   *note C.5(1.1/4): 7677.
entry
   closed   *note 9.5.3(5): 4098.
   open   *note 9.5.3(5): 4096.
   single   *note 9.5.2(20): 4080.
entry call   *note 9.5.3(1): 4089.
   simple   *note 9.5.3(1): 4091.
entry calling convention   *note 6.3.1(13/4): 3425.
entry family   *note 9.5.2(20): 4077.
entry index subtype   *note 3.8(18/2): 2054, *note 9.5.2(20): 4078.
entry queue   *note 9.5.3(12): 4107.
entry queuing policy   *note 9.5.3(17): 4111.
   default policy   *note 9.5.3(17): 4113.
entry_barrier   *note 9.5.2(7): 4062.
   <used>   *note 9.5.2(5): 4055, *note P: 9601.
entry_body   *note 9.5.2(5): 4052.
   <used>   *note 9.4(8/4): 3987, *note P: 9586.
entry_body_formal_part   *note 9.5.2(6): 4059.
   <used>   *note 9.5.2(5): 4054, *note P: 9600.
entry_call_alternative   *note 9.7.2(3/2): 4244.
   <used>   *note 9.7.2(2): 4242, *note 9.7.3(2): 4252, *note P: 9640.
entry_call_statement   *note 9.5.3(2): 4092.
   <used>   *note 5.1(4/2): 3128, *note 9.7.2(3.1/2): 4249, *note P:
9363.
entry_declaration   *note 9.5.2(2/3): 4038.
   <used>   *note 9.1(5/1): 3909, *note 9.4(5/1): 3972, *note P: 9574.
entry_index   *note 9.5.2(4): 4050.
   <used>   *note 9.5.2(3): 4046, *note P: 9594.
entry_index_specification   *note 9.5.2(8): 4064.
   <used>   *note 9.5.2(6): 4060, *note P: 9605.
enumeration literal   *note 3.5.1(6/3): 1695.
enumeration type   *note 3.2(3): 1341, *note 3.5.1(1): 1686, *note
N(17): 8904.
enumeration_aggregate   *note 13.4(3): 5041.
   <used>   *note 13.4(2): 5040, *note P: 9822.
Enumeration_IO
   <in> Ada.Text_IO   *note A.10.1(79): 6511.
enumeration_literal_specification   *note 3.5.1(3): 1690.
   <used>   *note 3.5.1(2): 1688, *note P: 9080.
enumeration_representation_clause   *note 13.4(2): 5038.
   <used>   *note 13.1(2/1): 4874, *note P: 9800.
enumeration_type_definition   *note 3.5.1(2): 1687.
   <used>   *note 3.2.1(4/2): 1381, *note P: 9033.
environment   *note 10.1.4(1): 4413.
environment declarative_part   *note 10.1.4(1): 4414.
   for the environment task of a partition   *note 10.2(13): 4454.
environment task   *note 10.2(8): 4451.
environment variable   *note A.17(1/2): 6698.
Environment_Task
   <in> Ada.Task_Identification   *note C.7.1(3/3): 7713.
Environment_Variables
   <child of> Ada   *note A.17(3/2): 6699.
EOT
   <in> Ada.Characters.Latin_1   *note A.3.3(5): 5504.
EPA
   <in> Ada.Characters.Latin_1   *note A.3.3(18): 5621.
epoch   *note D.8(19): 7964.
equal operator   *note 4.4(1/3): 2593, *note 4.5.2(1): 2767.
Equal_Case_Insensitive
   <child of> Ada.Strings   *note A.4.10(2/3): 6056.
   <child of> Ada.Strings.Bounded   *note A.4.10(7/3): 6058.
   <child of> Ada.Strings.Fixed   *note A.4.10(5/3): 6057.
   <child of> Ada.Strings.Unbounded   *note A.4.10(10/3): 6059.
Equal_Subtree
   <in> Ada.Containers.Multiway_Trees   *note A.18.10(14/3): 7208.
equality operator   *note 4.5.2(1): 2761.
   special inheritance rule for tagged types   *note 3.4(17/2): 1551,
*note 4.5.2(14/3): 2797.
equals sign   *note 2.1(15/3): 1172.
Equals_Sign
   <in> Ada.Characters.Latin_1   *note A.3.3(10): 5552.
equivalent element
   of a hashed set   *note A.18.8(64/2): 7101.
   of an ordered set   *note A.18.9(78/2): 7181.
equivalent key
   of a hashed map   *note A.18.5(42/2): 6952.
   of an ordered map   *note A.18.6(55/2): 7011.
Equivalent_Elements
   <in> Ada.Containers.Hashed_Sets   *note A.18.8(46/2): 7083, *note
A.18.8(47/2): 7084, *note A.18.8(48/2): 7085.
   <in> Ada.Containers.Ordered_Sets   *note A.18.9(3/2): 7113.
Equivalent_Keys
   <in> Ada.Containers.Hashed_Maps   *note A.18.5(34/2): 6947, *note
A.18.5(35/2): 6948, *note A.18.5(36/2): 6949.
   <in> Ada.Containers.Ordered_Maps   *note A.18.6(3/2): 6961.
   <in> Ada.Containers.Ordered_Sets   *note A.18.9(63/2): 7166.
Equivalent_Sets
   <in> Ada.Containers.Hashed_Sets   *note A.18.8(8/2): 7047.
   <in> Ada.Containers.Ordered_Sets   *note A.18.9(9/2): 7120.
erroneous execution   *note 1.1.2(32): 1041, *note 1.1.5(10): 1080.
   cause   *note 3.7.2(4): 2020, *note 3.9(25.3/2): 2132, *note
6.4.1(18/3): 3495, *note 9.8(21): 4296, *note 9.10(11): 4309, *note
11.5(26): 4644, *note 13.3(13/3): 4984, *note 13.3(27): 4996, *note
13.3(28/2): 4997, *note 13.9.1(8): 5170, *note 13.9.1(12/3): 5175, *note
13.9.1(13/3): 5176, *note 13.11(21): 5215, *note 13.11.2(16/3): 5245,
*note 13.11.4(31.1/4): 5286, *note 13.13.2(53/2): 5398, *note
A.10.3(22/1): 6529, *note A.12.1(36.1/1): 6603, *note A.13(17): 6622,
*note A.17(28/2): 6708, *note A.18.2(252/2): 6817, *note A.18.3(157/2):
6887, *note A.18.4(80/2): 6907, *note A.18.7(101/2): 7039, *note
A.18.18(70/3): 7308, *note A.18.19(11/3): 7310, *note A.18.20(15/3):
7313, *note A.18.21(16/3): 7317, *note A.18.22(13/3): 7320, *note
A.18.23(16/3): 7324, *note A.18.24(13/3): 7327, *note A.18.25(15/3):
7329, *note B.1(38.1/3): 7415, *note B.3.1(51): 7514, *note B.3.1(55):
7515, *note B.3.1(56): 7516, *note B.3.1(57): 7517, *note B.3.2(35):
7528, *note B.3.2(36): 7529, *note B.3.2(37): 7530, *note B.3.2(38):
7531, *note B.3.2(39): 7532, *note B.3.2(42): 7533, *note C.3.1(14):
7656, *note C.3.1(14.1/3): 7657, *note C.7.1(18): 7727, *note C.7.2(14):
7737, *note C.7.2(15): 7738, *note C.7.2(15.1/2): 7739, *note
D.2.6(31/2): 7830, *note D.5.1(12): 7870, *note D.11(9): 7997, *note
D.14(19/2): 8014, *note D.14.1(25/2): 8029, *note D.14.2(35/2): 8054,
*note H.4(26): 8482, *note H.4(27): 8483.
error
   compile-time   *note 1.1.2(27): 1024, *note 1.1.5(4): 1073.
   link-time   *note 1.1.2(29): 1032, *note 1.1.5(4): 1075.
   run-time   *note 1.1.2(30): 1038, *note 1.1.5(6): 1077, *note
11.5(2/3): 4615, *note 11.6(1/3): 4651.
   <See also> bounded error, erroneous execution
ESA
   <in> Ada.Characters.Latin_1   *note A.3.3(17): 5605.
ESC
   <in> Ada.Characters.Latin_1   *note A.3.3(6): 5527.
Establish_RPC_Receiver
   <in> System.RPC   *note E.5(12): 8213.
ETB
   <in> Ada.Characters.Latin_1   *note A.3.3(6): 5523.
ETX
   <in> Ada.Characters.Latin_1   *note A.3.3(5): 5503.
evaluation   *note 3.1(11): 1325, *note N(17.1/2): 8905, *note N(19):
8911.
   aggregate   *note 4.3(5): 2499.
   allocator   *note 4.8(7/2): 3057.
   array_aggregate   *note 4.3.3(21): 2569.
   attribute_reference   *note 4.1.4(11): 2447.
   case_expression   *note 4.5.7(21/3): 2905.
   concatenation   *note 4.5.3(5): 2822.
   dereference   *note 4.1(13): 2389.
   discrete_range   *note 3.6.1(8): 1945.
   extension_aggregate   *note 4.3.2(7): 2537.
   generalized_reference   *note 4.1.5(8/3): 2458.
   generic_association   *note 12.3(21): 4738.
   generic_association for a formal object of mode in   *note 12.4(11):
4764.
   if_expression   *note 4.5.7(20/3): 2901.
   indexed_component   *note 4.1.1(7): 2400.
   initialized allocator   *note 4.8(7/2): 3058.
   membership test   *note 4.5.2(27/4): 2802.
   name   *note 4.1(11/2): 2386.
   name that has a prefix   *note 4.1(12): 2387.
   null literal   *note 4.2(9): 2485.
   numeric literal   *note 4.2(9): 2484.
   parameter_association   *note 6.4.1(7): 3481.
   prefix   *note 4.1(12): 2388.
   primary that is a name   *note 4.4(10): 2718.
   qualified_expression   *note 4.7(4/4): 3031.
   quantified_expression   *note 4.5.8(6/4): 2918.
   range   *note 3.5(9): 1608.
   range_attribute_reference   *note 4.1.4(11): 2448.
   record_aggregate   *note 4.3.1(18): 2523.
   record_component_association_list   *note 4.3.1(19): 2524.
   selected_component   *note 4.1.3(14): 2428.
   short-circuit control form   *note 4.5.1(7): 2752.
   slice   *note 4.1.2(7): 2411.
   string_literal   *note 4.2(10): 2488.
   uninitialized allocator   *note 4.8(8): 3061.
   Val   *note 3.5.5(7): 1774, *note K.2(261): 8689.
   Value   *note 3.5(55/3): 1673.
   value conversion   *note 4.6(28): 2964.
   view conversion   *note 4.6(52): 3008.
   Wide_Value   *note 3.5(43/3): 1667.
   Wide_Wide_Value   *note 3.5(39.4/3): 1655.
Exception   *note 11(1/3): 4511, *note 11.1(1): 4514, *note N(18): 8906.
exception occurrence   *note 11(1/3): 4506.
exception_choice   *note 11.2(5): 4539.
   <used>   *note 11.2(3): 4534, *note P: 9699.
exception_declaration   *note 11.1(2/3): 4515.
   <used>   *note 3.1(3/3): 1303, *note P: 9019.
exception_handler   *note 11.2(3): 4532.
   <used>   *note 11.2(2): 4531, *note P: 9696.
Exception_Id
   <in> Ada.Exceptions   *note 11.4.1(2/2): 4565.
Exception_Identity
   <in> Ada.Exceptions   *note 11.4.1(5/2): 4576.
Exception_Information
   <in> Ada.Exceptions   *note 11.4.1(5/2): 4580.
Exception_Message
   <in> Ada.Exceptions   *note 11.4.1(4/3): 4574.
Exception_Name
   <in> Ada.Exceptions   *note 11.4.1(2/2): 4567, *note 11.4.1(5/2):
4577.
Exception_Occurrence
   <in> Ada.Exceptions   *note 11.4.1(3/2): 4570.
Exception_Occurrence_Access
   <in> Ada.Exceptions   *note 11.4.1(3/2): 4571.
exception_renaming_declaration   *note 8.5.2(2/3): 3812.
   <used>   *note 8.5(2): 3791, *note P: 9510.
Exceptions
   <child of> Ada   *note 11.4.1(2/2): 4564.
Exchange_Handler
   <in> Ada.Interrupts   *note C.3.2(8): 7666.
Exclamation
   <in> Ada.Characters.Latin_1   *note A.3.3(8): 5533.
exclamation point   *note 2.1(15/3): 1177.
Exclude
   <in> Ada.Containers.Hashed_Maps   *note A.18.5(24/2): 6938.
   <in> Ada.Containers.Hashed_Sets   *note A.18.8(23/2): 7065, *note
A.18.8(54/2): 7091.
   <in> Ada.Containers.Ordered_Maps   *note A.18.6(23/2): 6989.
   <in> Ada.Containers.Ordered_Sets   *note A.18.9(22/2): 7136, *note
A.18.9(67/2): 7170.
excludes null
   subtype   *note 3.10(13.1/2): 2268.
exclusive
   protected operation   *note 9.5.1(2.4/4): 4027.
Exclusive_Functions aspect   *note 9.5.1(2.2/4): 4026.
execution   *note 3.1(11): 1323, *note N(19): 8909.
   abort_statement   *note 9.8(4): 4281.
   aborting the execution of a construct   *note 9.8(5): 4286.
   accept_statement   *note 9.5.2(24): 4083.
   Ada program   *note 9(1/3): 3874.
   assignment_statement   *note 5.2(7): 3159, *note 7.6(17): 3679, *note
7.6.1(12/2): 3705.
   asynchronous_select with a delay_statement trigger   *note 9.7.4(7):
4268.
   asynchronous_select with a procedure call trigger   *note 9.7.4(6/2):
4267.
   asynchronous_select with an entry call trigger   *note 9.7.4(6/2):
4266.
   block_statement   *note 5.6(5): 3265.
   call on a dispatching operation   *note 3.9.2(14): 2172.
   call on an inherited subprogram   *note 3.4(27/2): 1557.
   case_statement   *note 5.4(11/3): 3186.
   conditional_entry_call   *note 9.7.3(3): 4254.
   delay_statement   *note 9.6(20): 4159.
   dynamically enclosing   *note 11.4(2): 4557.
   entry_body   *note 9.5.2(26): 4088.
   entry_call_statement   *note 9.5.3(8): 4104.
   exit_statement   *note 5.7(5): 3270.
   extended_return_statement   *note 6.5(5.11/3): 3515.
   goto_statement   *note 5.8(5): 3274.
   handled_sequence_of_statements   *note 11.2(10): 4543.
   handler   *note 11.4(7): 4562.
   if_statement   *note 5.3(5/3): 3175.
   instance of Unchecked_Deallocation   *note 7.6.1(10): 3699.
   loop_statement   *note 5.5(7): 3204.
   loop_statement with a for iteration_scheme   *note 5.5(9/4): 3206.
   loop_statement with a while iteration_scheme   *note 5.5(8): 3205.
   null_statement   *note 5.1(13): 3147.
   partition   *note 10.2(25): 4456.
   pragma   *note 2.8(12): 1278.
   program   *note 10.2(25): 4455.
   protected subprogram call   *note 9.5.1(3): 4028.
   raise_statement with an exception_name   *note 11.3(4/4): 4552.
   re-raise statement   *note 11.3(4/4): 4553.
   remote subprogram call   *note E.4(9): 8185.
   requeue protected entry   *note 9.5.4(9): 4128.
   requeue task entry   *note 9.5.4(8): 4127.
   requeue_statement   *note 9.5.4(7/4): 4126.
   selective_accept   *note 9.7.1(15): 4236.
   sequence_of_statements   *note 5.1(15): 3149.
   simple_return_statement   *note 6.5(6/2): 3522.
   subprogram call   *note 6.4(10/2): 3465.
   subprogram_body   *note 6.3(7): 3411.
   task   *note 9.2(1): 3932.
   task_body   *note 9.2(1): 3933.
   timed_entry_call   *note 9.7.2(4/2): 4250.
execution resource
   associated with a protected object   *note 9.4(18): 4006.
   required for a task to run   *note 9(10): 3891.
execution time
   of a task   *note D.14(11/3): 8011.
Execution_Time
   <child of> Ada   *note D.14(3/2): 7999.
exhaust
   a budget   *note D.14.2(14/2): 8050.
exist
   cease to   *note 7.6.1(11/3): 3700, *note 13.11.2(10/4): 5232, *note
13.11.5(7.1/4): 5289.
Exists
   <in> Ada.Directories   *note A.16(24/2): 6655.
   <in> Ada.Environment_Variables   *note A.17(5/2): 6702.
exit_statement   *note 5.7(2): 3266.
   <used>   *note 5.1(4/2): 3124, *note P: 9359.
Exit_Status
   <in> Ada.Command_Line   *note A.15(7): 6630.
Exp
   <in> Ada.Numerics.Generic_Complex_Elementary_Functions   *note
G.1.2(3): 8288.
   <in> Ada.Numerics.Generic_Elementary_Functions   *note A.5.1(4):
6114.
expanded name   *note 4.1.3(4): 2425.
Expanded_Name
   <in> Ada.Tags   *note 3.9(7/2): 2103.
expected profile   *note 8.6(26): 3864.
   accept_statement entry_direct_name   *note 9.5.2(11): 4067.
   Access attribute_reference prefix   *note 3.10.2(2.3/2): 2287.
   attribute_definition_clause name   *note 13.3(4): 4953.
   character_literal   *note 4.2(3): 2479.
   formal subprogram actual   *note 12.6(6): 4844.
   formal subprogram default_name   *note 12.6(5): 4843.
   name in an aspect_specification   *note 13.1.1(8/3): 4926.
   subprogram_renaming_declaration   *note 8.5.4(3): 3827.
expected type   *note 8.6(20/2): 3859.
   abort_statement task_name   *note 9.8(3): 4280.
   access attribute_reference   *note 3.10.2(2/2): 2286.
   Access attribute_reference prefix   *note 3.10.2(2.3/2): 2288.
   actual parameter   *note 6.4.1(3): 3476.
   aggregate   *note 4.3(3/2): 2498.
   allocator   *note 4.8(3/3): 3050.
   array_aggregate   *note 4.3.3(7/2): 2564.
   array_aggregate component expression   *note 4.3.3(7/2): 2565.
   array_aggregate discrete_choice   *note 4.3.3(8): 2566.
   assignment_statement expression   *note 5.2(4/2): 3158.
   assignment_statement variable_name   *note 5.2(4/2): 3157.
   Attach_Handler pragma second argument   *note J.15.7(6/3): 8595.
   attribute_definition_clause expression or name   *note 13.3(4): 4952.
   attribute_designator expression   *note 4.1.4(7): 2445.
   case_expression selecting_expression   *note 4.5.7(15/3): 2898.
   case_expression_alternative discrete_choice   *note 4.5.7(15/3):
2899.
   case_statement selecting_expression   *note 5.4(4/3): 3183.
   case_statement_alternative discrete_choice   *note 5.4(4/3): 3185.
   character_literal   *note 4.2(3): 2478.
   code_statement   *note 13.8(4): 5151.
   component_clause expressions   *note 13.5.1(7): 5074.
   component_declaration default_expression   *note 3.8(7): 2041.
   condition   *note 4.5.7(14/3): 2897.
   CPU pragma argument   *note J.15.9(3/3): 8630.
   decimal fixed point type digits   *note 3.5.9(6): 1843.
   delay_relative_statement expression   *note 9.6(5): 4140.
   delay_until_statement expression   *note 9.6(5): 4141.
   delta_constraint expression   *note J.3(3/4): 8498.
   dependent_expression   *note 4.5.7(8/3): 2896.
   dereference name   *note 4.1(8): 2383.
   discrete_subtype_definition range   *note 3.6(8): 1906.
   discriminant default_expression   *note 3.7(7): 1984.
   discriminant_association expression   *note 3.7.1(6): 2012.
   Dispatching_Domains pragma argument   *note J.15.10(3/3): 8633.
   entry_index   *note 9.5.2(11): 4068.
   enumeration_representation_clause expressions   *note 13.4(4): 5043.
   expression in an aspect_specification   *note 13.1.1(7/3): 4925.
   expression of a Default_Component_Value aspect   *note 3.6(22.4/3):
1931.
   expression of a Default_Value aspect   *note 3.5(56.5/3): 1685.
   expression of a predicate aspect   *note 3.2.4(2/3): 1440.
   expression of expression function   *note 6.8(3/4): 3560.
   expression of extended_return_statement   *note 6.5(3/2): 3511.
   expression of simple_return_statement   *note 6.5(3/2): 3510.
   extension_aggregate   *note 4.3.2(4/2): 2533.
   extension_aggregate ancestor expression   *note 4.3.2(4/2): 2534.
   external name   *note J.15.5(6/3): 8581.
   first_bit   *note 13.5.1(7): 5076.
   fixed point type delta   *note 3.5.9(6): 1842.
   generic formal in object actual   *note 12.4(4): 4754.
   generic formal object default_expression   *note 12.4(3): 4753.
   index_constraint discrete_range   *note 3.6.1(4): 1939.
   indexable_container_object_prefix   *note 4.1.6(11/3): 2471.
   indexed_component expression   *note 4.1.1(4): 2398.
   Interrupt_Priority pragma argument   *note J.15.11(5/3): 8639.
   invariant expression   *note 7.3.2(4/3): 3635.
   iterable_name   *note 5.5.2(3/3): 3244.
   iterator_name   *note 5.5.2(3/3): 3243.
   last_bit   *note 13.5.1(7): 5077.
   link name   *note J.15.5(6/3): 8580.
   linker options   *note B.1(10.1/3): 7402.
   membership test simple_expression   *note 4.5.2(3/3): 2793.
   modular_type_definition expression   *note 3.5.4(5): 1730.
   name in an aspect_specification   *note 13.1.1(7/3): 4924.
   number_declaration expression   *note 3.3.2(3): 1526.
   object in an aspect_specification   *note 13.1.1(6/3): 4923.
   object_declaration initialization expression   *note 3.3.1(4): 1497.
   parameter default_expression   *note 6.1(17): 3330.
   position   *note 13.5.1(7): 5075.
   postcondition expression   *note 6.1.1(6/3): 3362.
   precondition expression   *note 6.1.1(6/3): 3361.
   Priority pragma argument   *note J.15.11(5/3): 8638.
   quantified_expression   *note 4.5.8(5/3): 2916.
   range simple_expressions   *note 3.5(5): 1600.
   range_attribute_designator expression   *note 4.1.4(7): 2446.
   range_constraint range   *note 3.5(5): 1599.
   real_range_specification bounds   *note 3.5.7(5): 1803.
   record_aggregate   *note 4.3.1(8/2): 2519.
   record_component_association expression   *note 4.3.1(10): 2521.
   reference_object_name   *note 4.1.5(5/3): 2457.
   Relative_Deadline pragma argument   *note J.15.12(3/3): 8642.
   requested decimal precision   *note 3.5.7(4): 1802.
   restriction parameter expression   *note 13.12(5): 5301.
   selecting_expression case_expression   *note 4.5.7(15/3): 2900.
   selecting_expression case_statement   *note 5.4(4/3): 3184.
   short-circuit control form relation   *note 4.5.1(1): 2742.
   signed_integer_type_definition simple_expression   *note 3.5.4(5):
1729.
   slice discrete_range   *note 4.1.2(4): 2410.
   Storage_Size pragma argument   *note J.15.4(4/3): 8550.
   string_literal   *note 4.2(4): 2480.
   subpool_handle_name   *note 4.8(3/3): 3051.
   type_conversion operand   *note 4.6(6): 2939.
   variant_part discrete_choice   *note 3.8.1(6): 2073.
expiration time
   [<partial>]   *note 9.6(1): 4131.
   for a delay_relative_statement   *note 9.6(20): 4161.
   for a delay_until_statement   *note 9.6(20): 4160.
expires
   execution timer   *note D.14.1(15/3): 8028.
explicit declaration   *note 3.1(5): 1309, *note N(11): 8896.
explicit initial value   *note 3.3.1(1/3): 1474.
explicit_actual_parameter   *note 6.4(6): 3460.
   <used>   *note 6.4(5): 3459, *note P: 9460.
explicit_dereference   *note 4.1(5): 2378.
   <used>   *note 4.1(2/3): 2361, *note P: 9197.
explicit_generic_actual_parameter   *note 12.3(5): 4715.
   <used>   *note 12.3(4): 4714, *note P: 9738.
explicitly aliased parameter   *note 6.1(23.1/3): 3338.
explicitly assign   *note 10.2(2): 4446.
explicitly limited record   *note 3.8(13.1/3): 2044.
exponent   *note 2.4.1(4): 1219, *note 4.5.6(11/3): 2873.
   <used>   *note 2.4.1(2): 1214, *note 2.4.2(2): 1237, *note P: 8979.
Exponent attribute   *note A.5.3(18): 6205.
exponentiation operator   *note 4.4(1/3): 2648, *note 4.5.6(7): 2869.
Export aspect   *note B.1(1/3): 7387.
Export pragma   *note J.15.5(3/3): 8571, *note L(13.1/3): 8753.
exported entity   *note B.1(23/3): 7410.
expression   *note 4.4(1/3): 2582, *note 4.4(2): 2655.
   predicate-static   *note 3.2.4(15/3): 1445.
   <used>   *note 2.8(3/3): 1267, *note 3.3.1(2/3): 1486, *note
3.3.2(2): 1525, *note 3.5.4(4): 1728, *note 3.5.7(2): 1796, *note
3.5.9(3): 1833, *note 3.5.9(4): 1837, *note 3.7(6): 1983, *note
3.7.1(3): 2007, *note 4.1.1(2): 2396, *note 4.1.4(3/2): 2439, *note
4.1.4(5): 2444, *note 4.3.1(4/2): 2512, *note 4.3.2(3): 2531, *note
4.3.3(3/2): 2548, *note 4.3.3(5/2): 2559, *note 4.4(7/3): 2715, *note
4.5.7(3/3): 2885, *note 4.5.7(4/3): 2888, *note 4.5.7(5/3): 2890, *note
4.5.7(6/3): 2895, *note 4.5.8(3/3): 2915, *note 4.6(2): 2927, *note
4.7(2): 3027, *note 5.2(2): 3152, *note 5.4(2/3): 3177, *note 6.4(6):
3461, *note 6.5(2.1/3): 3502, *note 6.5(2/2): 3498, *note 6.8(2/4):
3554, *note 9.5.2(4): 4051, *note 9.6(3): 4137, *note 9.6(4): 4139,
*note 11.3(2/2): 4546, *note 11.4.2(3/2): 4592, *note 12.3(5): 4716,
*note 13.1.1(4/3): 4920, *note 13.3(2): 4948, *note 13.5.1(4): 5069,
*note 13.12(4.1/2): 5300, *note B.1(8): 7401, *note B.1(10.1/3): 7403,
*note D.2.2(3.2/2): 7791, *note J.7(1): 8507, *note J.8(1): 8517, *note
J.15.4(2/3): 8549, *note J.15.5(2/3): 8568, *note J.15.5(3/3): 8574,
*note J.15.7(4/3): 8594, *note J.15.9(2/3): 8629, *note L(2.1/2): 8701,
*note L(6.1/3): 8723, *note L(8.2/3): 8730, *note L(13.1/3): 8757, *note
L(14.1/3): 8762, *note L(19): 8785, *note L(27.2/2): 8820, *note
L(35.1/3): 8851, *note P: 9845.
expression function   *note 6.8(6/4): 3562.
expression_function_declaration   *note 6.8(2/4): 3551.
   <used>   *note 3.1(3/3): 1300, *note 9.4(8/4): 3986, *note P: 9016.
extended_digit   *note 2.4.2(5): 1244.
   <used>   *note 2.4.2(4): 1243, *note P: 8990.
Extended_Index <subtype of> Index_Type'Base
   <in> Ada.Containers.Vectors   *note A.18.2(7/2): 6725.
extended_return_object_declaration   *note 6.5(2.1/3): 3499.
   <used>   *note 6.5(2.2/3): 3504, *note P: 9467.
extended_return_statement   *note 6.5(2.2/3): 3503.
   <used>   *note 5.1(5/2): 3139, *note P: 9373.
extension
   of a private type   *note 3.9(2.1/2): 2092, *note 3.9.1(1/2): 2140.
   of a record type   *note 3.9(2.1/2): 2090, *note 3.9.1(1/2): 2138.
   of a type   *note 3.9(2/2): 2089, *note 3.9.1(1/2): 2136.
   <in> Ada.Directories   *note A.16(18/2): 6648.
extension_aggregate   *note 4.3.2(2): 2527.
   <used>   *note 4.3(2): 2496, *note P: 9235.
external call   *note 9.5(4/3): 4014.
external effect
   of the execution of an Ada program   *note 1.1.3(8): 1051.
   volatile/atomic objects   *note C.6(20): 7707.
external file   *note A.7(1): 6280.
external interaction   *note 1.1.3(8): 1053.
external name   *note B.1(34): 7411.
external requeue   *note 9.5(7): 4017.
external streaming
   type supports   *note 13.13.2(52/3): 5397.
External_Name aspect   *note B.1(1/3): 7391.
External_Tag
   <in> Ada.Tags   *note 3.9(7/2): 2106.
External_Tag aspect   *note 13.3(75/3): 5037, *note K.2(65): 8664.
External_Tag attribute   *note 13.3(75/3): 5033.
External_Tag clause   *note 13.3(7/2): 4963, *note 13.3(75/3): 5034,
*note K.2(65): 8661.
extra permission to avoid raising exceptions   *note 11.6(5): 4655.
extra permission to reorder actions   *note 11.6(6/3): 4657.



File: arm2012.info,  Node: F,  Next: G,  Prev: E,  Up: Index

F 
==



factor   *note 4.4(6): 2704.
   <used>   *note 4.4(5): 2701, *note P: 9302.
factory   *note 3.9(30/2): 2133.
failure
   of a language-defined check   *note 11.5(2/3): 4616.
   <in> Ada.Command_Line   *note A.15(8): 6632.
fall-back handler   *note C.7.3(9/2): 7749.
False   *note 3.5.3(1): 1714.
family
   entry   *note 9.5.2(20): 4076.
Feminine_Ordinal_Indicator
   <in> Ada.Characters.Latin_1   *note A.3.3(21/3): 5641.
FF
   <in> Ada.Characters.Latin_1   *note A.3.3(5): 5512.
Field <subtype of> Integer
   <in> Ada.Text_IO   *note A.10.1(6): 6380.
FIFO_Queuing queuing policy   *note D.4(7/2): 7861.
FIFO_Within_Priorities task dispatching policy   *note D.2.3(2/2): 7799.
file
   as file object   *note A.7(2/3): 6283.
file name   *note A.16(46/2): 6679.
file terminator   *note A.10(7): 6366.
File_Access
   <in> Ada.Text_IO   *note A.10.1(18): 6402.
File_Kind
   <in> Ada.Directories   *note A.16(22/2): 6653.
File_Mode
   <in> Ada.Direct_IO   *note A.8.4(4): 6325.
   <in> Ada.Sequential_IO   *note A.8.1(4): 6300.
   <in> Ada.Streams.Stream_IO   *note A.12.1(6): 6571.
   <in> Ada.Text_IO   *note A.10.1(4): 6376.
File_Size
   <in> Ada.Directories   *note A.16(23/2): 6654.
File_Type
   <in> Ada.Direct_IO   *note A.8.4(3): 6324.
   <in> Ada.Sequential_IO   *note A.8.1(3): 6299.
   <in> Ada.Streams.Stream_IO   *note A.12.1(5/4): 6570.
   <in> Ada.Text_IO   *note A.10.1(3): 6375.
Filter_Type
   <in> Ada.Directories   *note A.16(30/2): 6660.
finalization
   of a master   *note 7.6.1(4): 3696.
   of a protected object   *note 9.4(20): 4007.
   of a protected object   *note C.3.1(12/3): 7655.
   of a task object   *note J.7.1(8): 8514.
   of an object   *note 7.6.1(5): 3697.
   of environment task for a foreign language main subprogram   *note
B.1(39/3): 7419.
   <child of> Ada   *note 7.6(4/3): 3661.
Finalize   *note 7.6(2): 3659.
   <in> Ada.Finalization   *note 7.6(6/2): 3665, *note 7.6(8/2): 3668.
Find
   <in> Ada.Containers.Doubly_Linked_Lists   *note A.18.3(41/2): 6864.
   <in> Ada.Containers.Hashed_Maps   *note A.18.5(30/2): 6944.
   <in> Ada.Containers.Hashed_Sets   *note A.18.8(43/2): 7081, *note
A.18.8(56/2): 7093.
   <in> Ada.Containers.Multiway_Trees   *note A.18.10(38/3): 7231.
   <in> Ada.Containers.Ordered_Maps   *note A.18.6(38/2): 7004.
   <in> Ada.Containers.Ordered_Sets   *note A.18.9(49/2): 7159, *note
A.18.9(69/2): 7172.
   <in> Ada.Containers.Vectors   *note A.18.2(68/2): 6791.
Find_In_Subtree
   <in> Ada.Containers.Multiway_Trees   *note A.18.10(39/3): 7232.
Find_Index
   <in> Ada.Containers.Vectors   *note A.18.2(67/2): 6790.
Find_Token
   <in> Ada.Strings.Bounded   *note A.4.4(50.1/3): 5877, *note
A.4.4(51): 5878.
   <in> Ada.Strings.Fixed   *note A.4.3(15.1/3): 5820, *note A.4.3(16):
5821.
   <in> Ada.Strings.Unbounded   *note A.4.5(45.1/3): 5931, *note
A.4.5(46): 5932.
Fine_Delta
   <in> System   *note 13.7(9): 5115.
First
   <in> Ada.Containers.Doubly_Linked_Lists   *note A.18.3(33/2): 6856.
   <in> Ada.Containers.Hashed_Maps   *note A.18.5(27/2): 6941.
   <in> Ada.Containers.Hashed_Sets   *note A.18.8(40/2): 7078.
   <in> Ada.Containers.Ordered_Maps   *note A.18.6(28/2): 6994.
   <in> Ada.Containers.Ordered_Sets   *note A.18.9(41/2): 7151.
   <in> Ada.Containers.Vectors   *note A.18.2(58/2): 6781.
   <in> Ada.Iterator_Interfaces   *note 5.5.1(3/3): 3211.
First attribute   *note 3.5(12): 1612, *note 3.6.2(3): 1947.
first element
   of a hashed set   *note A.18.8(68/2): 7106.
   of a set   *note A.18.7(6/2): 7023.
   of an ordered set   *note A.18.9(81/3): 7185.
first node
   of a hashed map   *note A.18.5(46/2): 6956.
   of a map   *note A.18.4(6/2): 6894.
   of an ordered map   *note A.18.6(58/3): 7014.
first subtype   *note 3.2.1(6): 1389, *note 3.4.1(5): 1567.
First(N) attribute   *note 3.6.2(4): 1949.
first_bit   *note 13.5.1(5): 5070.
   <used>   *note 13.5.1(3): 5066, *note P: 9829.
First_Bit attribute   *note 13.5.2(3/2): 5083.
First_Child
   <in> Ada.Containers.Multiway_Trees   *note A.18.10(60/3): 7253.
First_Child_Element
   <in> Ada.Containers.Multiway_Trees   *note A.18.10(61/3): 7254.
First_Element
   <in> Ada.Containers.Doubly_Linked_Lists   *note A.18.3(34/2): 6857.
   <in> Ada.Containers.Ordered_Maps   *note A.18.6(29/2): 6995.
   <in> Ada.Containers.Ordered_Sets   *note A.18.9(42/2): 7152.
   <in> Ada.Containers.Vectors   *note A.18.2(59/2): 6782.
First_Index
   <in> Ada.Containers.Vectors   *note A.18.2(57/2): 6780.
First_Key
   <in> Ada.Containers.Ordered_Maps   *note A.18.6(30/2): 6996.
First_Valid attribute   *note 3.5.5(7.2/4): 1779.
Fixed
   <child of> Ada.Strings   *note A.4.3(5): 5807.
fixed point type   *note 3.5.9(1): 1825.
Fixed_IO
   <in> Ada.Text_IO   *note A.10.1(68): 6491.
fixed_point_definition   *note 3.5.9(2): 1829.
   <used>   *note 3.5.6(2): 1787, *note P: 9091.
Float   *note 3.5.7(12): 1815, *note 3.5.7(14): 1817.
   <in> Standard   *note A.1(21): 5441.
Float_IO
   <in> Ada.Text_IO   *note A.10.1(63): 6481.
Float_Random
   <child of> Ada.Numerics   *note A.5.2(5): 6147.
Float_Text_IO
   <child of> Ada   *note A.10.9(33): 6536.
Float_Wide_Text_IO
   <child of> Ada   *note A.11(2/2): 6557.
Float_Wide_Wide_Text_IO
   <child of> Ada   *note A.11(3/2): 6560.
Floating
   <in> Interfaces.COBOL   *note B.4(9): 7546.
floating point type   *note 3.5.7(1): 1794.
floating_point_definition   *note 3.5.7(2): 1795.
   <used>   *note 3.5.6(2): 1786, *note P: 9090.
Floor
   <in> Ada.Containers.Ordered_Maps   *note A.18.6(40/2): 7006.
   <in> Ada.Containers.Ordered_Sets   *note A.18.9(50/2): 7160, *note
A.18.9(70/2): 7173.
Floor attribute   *note A.5.3(30): 6219.
Flush
   <in> Ada.Direct_IO   *note A.8.4(10.1/4): 6338.
   <in> Ada.Sequential_IO   *note A.8.1(10.1/4): 6311.
   <in> Ada.Streams.Stream_IO   *note A.12.1(25/1): 6594.
   <in> Ada.Text_IO   *note A.10.1(21/1): 6410.
Fore attribute   *note 3.5.10(4): 1873.
form
   of an external file   *note A.7(1): 6282.
   <in> Ada.Direct_IO   *note A.8.4(9): 6336.
   <in> Ada.Sequential_IO   *note A.8.1(9): 6309.
   <in> Ada.Streams.Stream_IO   *note A.12.1(11): 6582.
   <in> Ada.Text_IO   *note A.10.1(12): 6391.
formal object, generic   *note 12.4(1): 4740.
formal package, generic   *note 12.7(1): 4851.
formal parameter
   of a subprogram   *note 6.1(17): 3329.
formal subprogram, generic   *note 12.6(1): 4827.
formal subtype   *note 12.5(5): 4797.
formal type   *note 12.5(5): 4795.
formal_abstract_subprogram_declaration   *note 12.6(2.2/3): 4835.
   <used>   *note 12.6(2/2): 4830, *note P: 9781.
formal_access_type_definition   *note 12.5.4(2): 4820.
   <used>   *note 12.5(3/2): 4788, *note P: 9773.
formal_array_type_definition   *note 12.5.3(2): 4816.
   <used>   *note 12.5(3/2): 4787, *note P: 9772.
formal_complete_type_declaration   *note 12.5(2.1/3): 4770.
   <used>   *note 12.5(2/3): 4768, *note P: 9756.
formal_concrete_subprogram_declaration   *note 12.6(2.1/3): 4831.
   <used>   *note 12.6(2/2): 4829, *note P: 9780.
formal_decimal_fixed_point_definition   *note 12.5.2(7): 4815.
   <used>   *note 12.5(3/2): 4786, *note P: 9771.
formal_derived_type_definition   *note 12.5.1(3/2): 4801.
   <used>   *note 12.5(3/2): 4780, *note P: 9765.
formal_discrete_type_definition   *note 12.5.2(2): 4810.
   <used>   *note 12.5(3/2): 4781, *note P: 9766.
formal_floating_point_definition   *note 12.5.2(5): 4813.
   <used>   *note 12.5(3/2): 4784, *note P: 9769.
formal_incomplete_type_declaration   *note 12.5(2.2/3): 4775.
   <used>   *note 12.5(2/3): 4769, *note P: 9757.
formal_interface_type_definition   *note 12.5.5(2/2): 4824.
   <used>   *note 12.5(3/2): 4789, *note P: 9774.
formal_modular_type_definition   *note 12.5.2(4): 4812.
   <used>   *note 12.5(3/2): 4783, *note P: 9768.
formal_object_declaration   *note 12.4(2/3): 4741.
   <used>   *note 12.1(6): 4681, *note P: 9717.
formal_ordinary_fixed_point_definition   *note 12.5.2(6): 4814.
   <used>   *note 12.5(3/2): 4785, *note P: 9770.
formal_package_actual_part   *note 12.7(3/2): 4857.
   <used>   *note 12.7(2/3): 4855, *note P: 9792.
formal_package_association   *note 12.7(3.1/2): 4861.
   <used>   *note 12.7(3/2): 4860, *note P: 9796.
formal_package_declaration   *note 12.7(2/3): 4852.
   <used>   *note 12.1(6): 4684, *note P: 9720.
formal_part   *note 6.1(14): 3316.
   <used>   *note 6.1(12): 3309, *note 6.1(13/2): 3314, *note P: 9430.
formal_private_type_definition   *note 12.5.1(2): 4800.
   <used>   *note 12.5(3/2): 4779, *note P: 9764.
formal_signed_integer_type_definition   *note 12.5.2(3): 4811.
   <used>   *note 12.5(3/2): 4782, *note P: 9767.
formal_subprogram_declaration   *note 12.6(2/2): 4828.
   <used>   *note 12.1(6): 4683, *note P: 9719.
formal_type_declaration   *note 12.5(2/3): 4767.
   <used>   *note 12.1(6): 4682, *note P: 9718.
formal_type_definition   *note 12.5(3/2): 4778.
   <used>   *note 12.5(2.1/3): 4773, *note P: 9760.
format_effector   *note 2.1(13/3): 1145.
Formatting
   <child of> Ada.Calendar   *note 9.6.1(15/2): 4177.
Fortran
   <child of> Interfaces   *note B.5(4): 7599.
Fortran interface   *note B.5(1/3): 7598.
Fortran standard   *note 1.2(3/2): 1096.
Fortran_Character
   <in> Interfaces.Fortran   *note B.5(12/3): 7610.
Fortran_Integer
   <in> Interfaces.Fortran   *note B.5(5): 7600.
forward iterator   *note 5.5.2(4/3): 3251.
Forward_Iterator
   <in> Ada.Iterator_Interfaces   *note 5.5.1(3/3): 3210.
Fraction attribute   *note A.5.3(21): 6207.
Fraction_One_Half
   <in> Ada.Characters.Latin_1   *note A.3.3(22): 5662.
Fraction_One_Quarter
   <in> Ada.Characters.Latin_1   *note A.3.3(22): 5661.
Fraction_Three_Quarters
   <in> Ada.Characters.Latin_1   *note A.3.3(22): 5663.
Free
   <in> Ada.Strings.Unbounded   *note A.4.5(7): 5907.
   <in> Interfaces.C.Strings   *note B.3.1(11): 7504.
freed
   <See> nonexistent   *note 13.11.2(10/4): 5230.
freeing storage   *note 13.11.2(1): 5227.
freezing
   by a constituent of a construct   *note 13.14(4/1): 5405.
   by an expression   *note 13.14(8/4): 5409.
   by an implicit call   *note 13.14(8.1/3): 5411.
   by an object name   *note 13.14(8/4): 5410.
   class-wide type caused by the freezing of the specific type   *note
13.14(15): 5428.
   constituents of a full type definition   *note 13.14(15): 5426.
   designated subtype caused by an allocator   *note 13.14(13): 5423.
   entity   *note 13.14(2): 5399.
   entity caused by a body   *note 13.14(3/4): 5403.
   entity caused by a construct   *note 13.14(4/1): 5404.
   entity caused by a name   *note 13.14(11): 5419.
   entity caused by the end of an enclosing construct   *note
13.14(3/4): 5402.
   expression of an expression function by a call   *note 13.14(10.1/4):
5415.
   expression of an expression function by Access attribute   *note
13.14(10.3/4): 5418.
   expression of an expression function by an instantiation   *note
13.14(10.2/4): 5417.
   first subtype caused by the freezing of the type   *note 13.14(15):
5427.
   generic_instantiation   *note 13.14(5/3): 5406.
   nominal subtype caused by a name   *note 13.14(11): 5420.
   object_declaration   *note 13.14(6): 5407.
   profile   *note 13.14(2.1/3): 5401.
   profile of a callable entity by an instantiation   *note
13.14(10.2/4): 5416.
   profile of a function call   *note 13.14(10.1/4): 5414.
   specific type caused by the freezing of the class-wide type   *note
13.14(15): 5429.
   subtype caused by a record extension   *note 13.14(7): 5408.
   subtype caused by an implicit conversion   *note 13.14(8.2/1): 5412.
   subtype caused by an implicit dereference   *note 13.14(11.1/1):
5421.
   subtypes of the profile of a callable entity   *note 13.14(14/3):
5424.
   type caused by a range   *note 13.14(12): 5422.
   type caused by an expression   *note 13.14(10): 5413.
   type caused by the freezing of a subtype   *note 13.14(15): 5425.
freezing points
   entity   *note 13.14(2): 5400.
Friday
   <in> Ada.Calendar.Formatting   *note 9.6.1(17/2): 4183.
FS
   <in> Ada.Characters.Latin_1   *note A.3.3(6): 5528.
full conformance
   for discrete_subtype_definitions   *note 6.3.1(24): 3441.
   for expressions   *note 6.3.1(19): 3438.
   for known_discriminant_parts   *note 6.3.1(23): 3439.
   for profiles   *note 6.3.1(18/3): 3436.
   required   *note 3.10.1(4/3): 2283, *note 6.3(4): 3409, *note
6.7(2.1/3): 3547, *note 6.8(4/3): 3561, *note 7.3(9): 3614, *note
8.3(12.3/2): 3752, *note 8.5.4(5/3): 3830, *note 9.5.2(14): 4070, *note
9.5.2(16): 4074, *note 9.5.2(17): 4075, *note 10.1.3(11): 4411, *note
10.1.3(12): 4412.
full constant declaration   *note 3.3.1(6/3): 1500.
   corresponding to a formal object of mode in   *note 12.4(10/2): 4761.
full declaration   *note 7.4(2/3): 3643.
full name
   of a file   *note A.16(47/2): 6680.
full stop   *note 2.1(15/3): 1164.
full type   *note 3.2.1(8/2): 1393.
full type definition   *note 3.2.1(8/2): 1394.
full view
   of a type   *note 3.2.1(8/2): 1395.
Full_Name
   <in> Ada.Directories   *note A.16(15/2): 6645, *note A.16(39/2):
6667.
Full_Stop
   <in> Ada.Characters.Latin_1   *note A.3.3(8): 5547.
full_type_declaration   *note 3.2.1(3/3): 1373.
   <used>   *note 3.2.1(2): 1369, *note P: 9023.
function   *note 6(1): 3277, *note N(19.1/2): 8912.
   expression   *note 6.8(6/4): 3563.
   with a controlling access result   *note 3.9.2(2/3): 2166.
   with a controlling result   *note 3.9.2(2/3): 2164.
function call
   master of   *note 3.10.2(10.1/3): 2299.
function instance   *note 12.3(13): 4730.
function_call   *note 6.4(3): 3450.
   <used>   *note 4.1(2/3): 2367, *note P: 9203.
function_specification   *note 6.1(4.2/2): 3291.
   <used>   *note 6.1(4/2): 3287, *note 6.8(2/4): 3553, *note P: 9475.



File: arm2012.info,  Node: G,  Next: H,  Prev: F,  Up: Index

G 
==



general access type   *note 3.10(7/1): 2250, *note 3.10(8): 2254.
general_access_modifier   *note 3.10(4): 2235.
   <used>   *note 3.10(3): 2233, *note P: 9172.
generalized iterator   *note 5.5.2(3/3): 3241.
generalized_indexing   *note 4.1.6(10/3): 2468.
   <used>   *note 4.1(2/3): 2371, *note P: 9207.
generalized_reference   *note 4.1.5(4/3): 2455.
   <used>   *note 4.1(2/3): 2370, *note P: 9206.
generation
   of an interrupt   *note C.3(2): 7632.
Generator
   <in> Ada.Numerics.Discrete_Random   *note A.5.2(19): 6161.
   <in> Ada.Numerics.Float_Random   *note A.5.2(7): 6148.
generic actual   *note 12.3(7/3): 4725.
generic actual parameter   *note 12.3(7/3): 4724.
generic actual subtype   *note 12.5(4): 4790.
generic actual type   *note 12.5(4): 4792.
generic body   *note 12.2(1): 4691.
generic contract issue   *note 10.2.1(10/2): 4471.
   [<partial>]   *note 3.2.4(29/3): 1446, *note 3.4(5.1/3): 1540, *note
3.7(10/3): 1987, *note 3.7.1(7/3): 2013, *note 3.9.1(3/2): 2143, *note
3.9.4(17/2): 2221, *note 3.10.2(29.1/3): 2311, *note 3.10.2(33/3): 2319,
*note 4.5.2(9.8/4): 2795, *note 4.6(24.22/4): 2962, *note 4.8(5.6/3):
3055, *note 4.9(37/2): 3105, *note 6.1.1(17.2/4): 3364, *note
6.4.1(5.4/4): 3477, *note 6.4.1(6.3/4): 3478, *note 6.5.1(6/2): 3537,
*note 7.3(8): 3613, *note 8.3(26/2): 3770, *note 8.3.1(7/2): 3773, *note
8.5.1(4.6/2): 3810, *note 8.5.1(5/3): 3811, *note 8.5.4(4.3/2): 3829,
*note 9.1(9.9/2): 3926, *note 9.4(11.13/2): 4000, *note 9.4(11.8/2):
3999, *note 9.5(17/3): 4021, *note 9.5.2(13.4/2): 4069, *note
10.2.1(11.7/3): 4478, *note 10.2.1(11/3): 4475, *note 10.2.1(17/3):
4488, *note 12.4(8.5/2): 4758, *note 12.6(8.3/2): 4847, *note
13.1.1(18.5/4): 4930, *note 13.11.2(3.1/3): 5229, *note 13.11.4(23/3):
5277, *note 13.13.2(49/4): 5395, *note B.3.3(10/3): 7540, *note
C.3.1(7/3): 7645, *note J.15.7(7/3): 8596.
generic formal   *note 12.1(9): 4689.
generic formal object   *note 12.4(1): 4739.
generic formal package   *note 12.7(1): 4850.
generic formal subprogram   *note 12.6(1): 4826.
generic formal subtype   *note 12.5(5): 4796.
generic formal type   *note 12.5(5): 4794.
generic function   *note 12.1(8/2): 4688.
generic package   *note 12.1(8/2): 4685.
generic procedure   *note 12.1(8/2): 4687.
generic subprogram   *note 12.1(8/2): 4686.
generic unit   *note 12(1): 4662, *note N(20): 8913.
   <See also> dispatching operation   *note 3.9(1): 2082.
generic_actual_part   *note 12.3(3): 4709.
   <used>   *note 12.3(2/3): 4702, *note 12.7(3/2): 4858, *note P: 9728.
Generic_Array_Sort
   <child of> Ada.Containers   *note A.18.26(3/2): 7330.
generic_association   *note 12.3(4): 4712.
   <used>   *note 12.3(3): 4711, *note 12.7(3.1/2): 4862, *note P: 9797.
Generic_Bounded_Length
   <in> Ada.Strings.Bounded   *note A.4.4(4): 5844.
Generic_Complex_Arrays
   <child of> Ada.Numerics   *note G.3.2(2/2): 8386.
Generic_Complex_Elementary_Functions
   <child of> Ada.Numerics   *note G.1.2(2/2): 8285.
Generic_Complex_Types
   <child of> Ada.Numerics   *note G.1.1(2/1): 8258.
Generic_Constrained_Array_Sort
   <child of> Ada.Containers   *note A.18.26(7/2): 7332.
generic_declaration   *note 12.1(2): 4667.
   <used>   *note 3.1(3/3): 1304, *note 10.1.1(5): 4336, *note P: 9020.
Generic_Dispatching_Constructor
   <child of> Ada.Tags   *note 3.9(18.2/3): 2125.
Generic_Elementary_Functions
   <child of> Ada.Numerics   *note A.5.1(3): 6110.
generic_formal_parameter_declaration   *note 12.1(6): 4680.
   <used>   *note 12.1(5): 4678, *note P: 9715.
generic_formal_part   *note 12.1(5): 4677.
   <used>   *note 12.1(3/3): 4671, *note 12.1(4): 4675, *note P: 9713.
generic_instantiation   *note 12.3(2/3): 4694.
   <used>   *note 3.1(3/3): 1305, *note 10.1.1(5): 4337, *note P: 9021.
Generic_Keys
   <in> Ada.Containers.Hashed_Sets   *note A.18.8(50/2): 7087.
   <in> Ada.Containers.Ordered_Sets   *note A.18.9(62/2): 7165.
generic_package_declaration   *note 12.1(4): 4674.
   <used>   *note 12.1(2): 4669, *note P: 9709.
Generic_Real_Arrays
   <child of> Ada.Numerics   *note G.3.1(2/2): 8370.
generic_renaming_declaration   *note 8.5.5(2/3): 3835.
   <used>   *note 8.5(2): 3794, *note 10.1.1(6): 4340, *note P: 9664.
Generic_Sort
   <child of> Ada.Containers   *note A.18.26(9.2/4): 7334.
Generic_Sorting
   <in> Ada.Containers.Doubly_Linked_Lists   *note A.18.3(47/2): 6869.
   <in> Ada.Containers.Vectors   *note A.18.2(75/2): 6797.
generic_subprogram_declaration   *note 12.1(3/3): 4670.
   <used>   *note 12.1(2): 4668, *note P: 9708.
Get
   <in> Ada.Text_IO   *note A.10.1(41): 6443, *note A.10.1(47): 6453,
*note A.10.1(54): 6466, *note A.10.1(55): 6470, *note A.10.1(59): 6476,
*note A.10.1(60): 6479, *note A.10.1(65): 6485, *note A.10.1(67): 6489,
*note A.10.1(70): 6495, *note A.10.1(72): 6499, *note A.10.1(75): 6505,
*note A.10.1(77): 6509, *note A.10.1(81): 6515, *note A.10.1(83): 6518.
   <in> Ada.Text_IO.Complex_IO   *note G.1.3(6): 8318, *note G.1.3(8):
8322.
Get_CPU
   <in> Ada.Interrupts   *note C.3.2(10.1/3): 7669.
   <in> System.Multiprocessors.Dispatching_Domains   *note D.16.1(13/3):
8090.
Get_CPU_Set
   <in> System.Multiprocessors.Dispatching_Domains   *note
D.16.1(9.3/4): 8086.
Get_Deadline
   <in> Ada.Dispatching.EDF   *note D.2.6(9/2): 7826.
Get_Dispatching_Domain
   <in> System.Multiprocessors.Dispatching_Domains   *note D.16.1(10/3):
8087.
Get_First_CPU
   <in> System.Multiprocessors.Dispatching_Domains   *note D.16.1(8/3):
8082.
Get_Immediate
   <in> Ada.Text_IO   *note A.10.1(44): 6450, *note A.10.1(45): 6451.
Get_Last_CPU
   <in> System.Multiprocessors.Dispatching_Domains   *note D.16.1(9/4):
8083.
Get_Line
   <in> Ada.Text_IO   *note A.10.1(49): 6458, *note A.10.1(49.1/2):
6459.
   <in> Ada.Text_IO.Bounded_IO   *note A.10.11(8/2): 6542, *note
A.10.11(9/2): 6543, *note A.10.11(10/2): 6544, *note A.10.11(11/2):
6545.
   <in> Ada.Text_IO.Unbounded_IO   *note A.10.12(8/2): 6551, *note
A.10.12(9/2): 6552, *note A.10.12(10/2): 6553, *note A.10.12(11/2):
6554.
Get_Next_Entry
   <in> Ada.Directories   *note A.16(35/2): 6665.
Get_Priority
   <in> Ada.Dynamic_Priorities   *note D.5.1(5): 7867.
global to   *note 8.1(15): 3720.
Glossary   *note N(1/2): 8878.
goto_statement   *note 5.8(2): 3271.
   <used>   *note 5.1(4/2): 3125, *note P: 9360.
govern a variant   *note 3.8.1(20): 2077.
govern a variant_part   *note 3.8.1(20): 2076.
grammar
   complete listing   *note P: 8958.
   cross reference   *note P: 9847.
   notation   *note 1.1.4(3): 1061.
   resolution of ambiguity   *note 8.6(3): 3847.
   under Syntax heading   *note 1.1.2(25): 1015.
graphic character
   a category of Character   *note A.3.2(23): 5489.
graphic_character   *note 2.1(14/3): 1150.
   <used>   *note 2.5(2): 1248, *note 2.6(3): 1253, *note P: 8994.
Graphic_Set
   <in> Ada.Strings.Maps.Constants   *note A.4.6(4): 5956.
Grave
   <in> Ada.Characters.Latin_1   *note A.3.3(13): 5561.
greater than operator   *note 4.4(1/3): 2609, *note 4.5.2(1): 2783.
greater than or equal operator   *note 4.4(1/3): 2613, *note 4.5.2(1):
2787.
greater-than sign   *note 2.1(15/3): 1173.
Greater_Than_Sign
   <in> Ada.Characters.Latin_1   *note A.3.3(10): 5553.
Group_Budget
   <in> Ada.Execution_Time.Group_Budgets   *note D.14.2(4/3): 8031.
Group_Budget_Error
   <in> Ada.Execution_Time.Group_Budgets   *note D.14.2(11/2): 8047.
Group_Budget_Handler
   <in> Ada.Execution_Time.Group_Budgets   *note D.14.2(5/2): 8032.
Group_Budgets
   <child of> Ada.Execution_Time   *note D.14.2(3/3): 8030.
GS
   <in> Ada.Characters.Latin_1   *note A.3.3(6): 5529.
guard   *note 9.7.1(3): 4221.
   <used>   *note 9.7.1(2): 4218, *note P: 9623.



File: arm2012.info,  Node: H,  Next: I,  Prev: G,  Up: Index

H 
==



handle
   an exception   *note 11(1/3): 4513, *note N(18): 8908.
   an exception occurrence   *note 11.4(1): 4554, *note 11.4(7): 4561.
   subpool   *note 13.11.4(18/3): 5272.
handled_sequence_of_statements   *note 11.2(2): 4528.
   <used>   *note 5.6(2): 3263, *note 6.3(2/3): 3407, *note 6.5(2.2/3):
3505, *note 7.2(2/3): 3590, *note 9.1(6/3): 3915, *note 9.5.2(3): 4048,
*note 9.5.2(5): 4057, *note P: 9406.
handler
   execution timer   *note D.14.1(13/2): 8027.
   group budget   *note D.14.2(14/2): 8051.
   interrupt   *note C.3(2): 7639.
   termination   *note C.7.3(8/3): 7748.
   timing event   *note D.15(10/2): 8069.
Handling
   <child of> Ada.Characters   *note A.3.2(2/2): 5460.
   <child of> Ada.Wide_Characters   *note A.3.5(3/3): 5748.
   <child of> Ada.Wide_Wide_Characters   *note A.3.6(1/3): 5769.
Has_Element
   <in> Ada.Containers.Doubly_Linked_Lists   *note A.18.3(9.1/3): 6827.
   <in> Ada.Containers.Hashed_Maps   *note A.18.5(6.1/3): 6913.
   <in> Ada.Containers.Hashed_Sets   *note A.18.8(6.1/3): 7045.
   <in> Ada.Containers.Multiway_Trees   *note A.18.10(12/3): 7206.
   <in> Ada.Containers.Ordered_Maps   *note A.18.6(7.1/3): 6966.
   <in> Ada.Containers.Ordered_Sets   *note A.18.9(7.1/3): 7118.
   <in> Ada.Containers.Vectors   *note A.18.2(11.1/3): 6731.
Has_Same_Storage attribute   *note 13.3(73.2/4): 5029.
Hash
   <child of> Ada.Strings   *note A.4.9(2/3): 6049.
   <child of> Ada.Strings.Bounded   *note A.4.9(7/3): 6050.
   <child of> Ada.Strings.Unbounded   *note A.4.9(10/3): 6051.
Hash_Case_Insensitive
   <child of> Ada.Strings   *note A.4.9(11.2/3): 6052.
   <child of> Ada.Strings.Bounded   *note A.4.9(11.7/3): 6054.
   <child of> Ada.Strings.Fixed   *note A.4.9(11.5/3): 6053.
   <child of> Ada.Strings.Unbounded   *note A.4.9(11.10/3): 6055.
Hash_Type
   <in> Ada.Containers   *note A.18.1(4/2): 6716.
Hashed_Maps
   <child of> Ada.Containers   *note A.18.5(2/3): 6908.
Hashed_Sets
   <child of> Ada.Containers   *note A.18.8(2/3): 7040.
Head
   <in> Ada.Strings.Bounded   *note A.4.4(70): 5895, *note A.4.4(71):
5896.
   <in> Ada.Strings.Fixed   *note A.4.3(35): 5838, *note A.4.3(36):
5839.
   <in> Ada.Strings.Unbounded   *note A.4.5(65): 5949, *note A.4.5(66):
5950.
head (of a queue)   *note D.2.1(5/2): 7777.
heap management
   user-defined   *note 13.11(1): 5186.
   <See also> allocator   *note 4.8(1): 3042.
held priority   *note D.11(4/2): 7993.
heterogeneous input-output   *note A.12.1(1): 6565.
hexadecimal
   literal   *note 2.4.2(1): 1232.
hexadecimal digit
   a category of Character   *note A.3.2(30): 5495.
hexadecimal literal   *note 2.4.2(1): 1230.
Hexadecimal_Digit_Set
   <in> Ada.Strings.Maps.Constants   *note A.4.6(4): 5962.
hidden from all visibility   *note 8.3(5): 3744, *note 8.3(14): 3754.
   by lack of a with_clause   *note 8.3(20/2): 3758.
   for a declaration completed by a subsequent declaration   *note
8.3(19): 3757.
   for overridden declaration   *note 8.3(15): 3755.
   within the declaration itself   *note 8.3(16): 3756.
hidden from direct visibility   *note 8.3(5): 3745, *note 8.3(21): 3763.
   by an inner homograph   *note 8.3(22): 3764.
   where hidden from all visibility   *note 8.3(23): 3765.
hiding   *note 8.3(5): 3743.
Hierarchical_File_Names
   <child of> Ada.Directories   *note A.16.1(3/3): 6686.
High_Order_First   *note 13.5.3(2): 5089.
   <in> Interfaces.COBOL   *note B.4(25): 7570.
   <in> System   *note 13.7(15/2): 5124.
highest precedence operator   *note 4.5.6(1): 2858.
highest_precedence_operator   *note 4.5(7): 2729.
Hold
   <in> Ada.Asynchronous_Task_Control   *note D.11(3/2): 7989.
Holder
   <in> Ada.Containers.Indefinite_Holders   *note A.18.18(6/3): 7285.
homograph   *note 8.3(8): 3748.
Hour
   <in> Ada.Calendar.Formatting   *note 9.6.1(24/2): 4194.
Hour_Number <subtype of> Natural
   <in> Ada.Calendar.Formatting   *note 9.6.1(20/2): 4187.
HT
   <in> Ada.Characters.Latin_1   *note A.3.3(5): 5509.
HTJ
   <in> Ada.Characters.Latin_1   *note A.3.3(17): 5607.
HTS
   <in> Ada.Characters.Latin_1   *note A.3.3(17): 5606.
Hyphen
   <in> Ada.Characters.Latin_1   *note A.3.3(8): 5545.
hyphen-minus   *note 2.1(15/3): 1162.



File: arm2012.info,  Node: I,  Next: J,  Prev: H,  Up: Index

I 
==



i
   <in> Ada.Numerics.Generic_Complex_Types   *note G.1.1(5): 8261.
   <in> Interfaces.Fortran   *note B.5(10): 7607.
identifier   *note 2.3(2/2): 1187.
   <used>   *note 2.8(2): 1260, *note 2.8(3/3): 1264, *note 2.8(21):
1283, *note 2.8(23): 1288, *note 3.1(4): 1307, *note 4.1(3): 2373, *note
4.1.3(3): 2422, *note 4.1.4(3/2): 2438, *note 5.5(2): 3194, *note
5.6(2): 3264, *note 6.1(5): 3296, *note 7.1(3/3): 3579, *note 7.2(2/3):
3592, *note 9.1(4): 3907, *note 9.1(6/3): 3916, *note 9.4(4): 3969,
*note 9.4(7/3): 3981, *note 9.5.2(3): 4049, *note 9.5.2(5): 4058, *note
11.4.2(6.1/3): 4599, *note 11.4.2(6/2): 4595, *note 11.5(4.1/2): 4622,
*note 11.5(4/2): 4619, *note 13.1.1(3/3): 4917, *note 13.1.1(4/3): 4921,
*note 13.12(4/2): 5295, *note 13.12(11/3): 5306, *note D.2.2(3): 7786,
*note D.2.2(3.2/2): 7789, *note D.3(3): 7833, *note D.3(4): 7834, *note
D.4(3): 7854, *note D.4(4): 7855, *note H.6(3/2): 8490, *note J.10(3/2):
8523, *note J.15.5(2/3): 8566, *note J.15.5(3/3): 8572, *note
J.15.5(4/3): 8578, *note L(2.2/2): 8704, *note L(2.3/3): 8708, *note
L(8.1/3): 8726, *note L(13.1/3): 8754, *note L(14.1/3): 8760, *note
L(20): 8788, *note L(21): 8791, *note L(23): 8800, *note L(25.1/2):
8808, *note L(27.2/2): 8819, *note L(27.3/3): 8824, *note L(29): 8831,
*note L(36): 8854, *note L(37): 8857, *note L(37.3/2): 8863, *note
M.2(98): 8875, *note P: 9560.
identifier specific to a pragma   *note 2.8(10/3): 1276.
identifier_extend   *note 2.3(3.1/3): 1198.
   <used>   *note 2.3(2/2): 1190, *note P: 8964.
identifier_start   *note 2.3(3/2): 1191.
   <used>   *note 2.3(2/2): 1188, *note P: 8962.
Identity
   <in> Ada.Strings.Maps   *note A.4.2(22): 5799.
   <in> Ada.Strings.Wide_Maps   *note A.4.7(22): 6001.
   <in> Ada.Strings.Wide_Wide_Maps   *note A.4.8(22/2): 6040.
Identity attribute   *note 11.4.1(9): 4584, *note C.7.1(12): 7719.
idle task   *note D.11(4/2): 7994.
if_expression   *note 4.5.7(3/3): 2881.
   <used>   *note 4.5.7(2/3): 2879, *note P: 9317.
if_statement   *note 5.3(2): 3169.
   <used>   *note 5.1(5/2): 3135, *note P: 9369.
illegal
   construct   *note 1.1.2(27): 1026.
   partition   *note 1.1.2(29): 1034.
Im
   <in> Ada.Numerics.Generic_Complex_Arrays   *note G.3.2(7/2): 8390,
*note G.3.2(27/2): 8403.
   <in> Ada.Numerics.Generic_Complex_Types   *note G.1.1(6): 8264.
image
   of a value   *note 3.5(27.3/2): 1640, *note 3.5(30/3): 1644, *note
K.2(273/3): 8692, *note K.2(277.4/2): 8693.
   <in> Ada.Calendar.Formatting   *note 9.6.1(35/2): 4205, *note
9.6.1(37/2): 4207.
   <in> Ada.Numerics.Discrete_Random   *note A.5.2(26): 6169.
   <in> Ada.Numerics.Float_Random   *note A.5.2(14): 6157.
   <in> Ada.Task_Identification   *note C.7.1(3/3): 7711.
   <in> Ada.Text_IO.Editing   *note F.3.3(13): 8249.
Image attribute   *note 3.5(35): 1646, *note 3.5(55.4/4): 1682.
Imaginary
   <in> Ada.Numerics.Generic_Complex_Types   *note G.1.1(4/2): 8260.
Imaginary <subtype of> Imaginary
   <in> Interfaces.Fortran   *note B.5(10): 7606.
immediate scope
   of (a view of) an entity   *note 8.2(11): 3731.
   of a declaration   *note 8.2(2): 3721.
   of a pragma   *note 8.2(12/4): 3733.
Immediate_Reclamation restriction   *note H.4(10): 8459.
immediately enclosing   *note 8.1(13): 3717.
immediately visible   *note 8.3(4): 3741, *note 8.3(21): 3760.
immediately within   *note 8.1(13): 3715.
immutably limited   *note 7.5(8.1/3): 3647.
implementation advice   *note 1.1.2(37): 1047.
   summary of advice   *note M.3(1/2): 8876.
implementation defined   *note 1.1.3(18): 1054.
   summary of characteristics   *note M.2(1/2): 8873.
implementation permissions   *note 1.1.2(36): 1046.
implementation requirements   *note 1.1.2(33): 1043.
implementation-dependent
   <See> unspecified   *note 1.1.3(18): 1057.
implemented
   by a protected entry   *note 9.4(11.1/3): 3993.
   by a protected subprogram   *note 9.4(11.1/3): 3992.
   by a task entry   *note 9.1(9.2/3): 3920.
implicit conversion
   legality   *note 8.6(27.1/4): 3868.
implicit declaration   *note 3.1(5): 1310, *note N(11): 8897.
implicit initial values
   for a subtype   *note 3.3.1(10): 1510.
implicit subtype conversion   *note 4.6(59): 3021, *note 4.6(60): 3022.
   Access attribute   *note 3.10.2(31): 2315.
   access discriminant   *note 3.7(27/2): 2000.
   array bounds   *note 4.6(38): 2981.
   array index   *note 4.1.1(7): 2402.
   assignment to view conversion   *note 4.6(55): 3015.
   assignment_statement   *note 5.2(11): 3165.
   bounds of a decimal fixed point type   *note 3.5.9(16): 1857.
   bounds of a fixed point type   *note 3.5.9(14): 1853.
   bounds of a range   *note 3.5(9): 1610, *note 3.6(18): 1923.
   choices of aggregate   *note 4.3.3(22): 2571.
   component defaults   *note 3.3.1(13/3): 1512.
   default value of a scalar   *note 3.3.1(11.1/3): 1511.
   delay expression   *note 9.6(20): 4162.
   derived type discriminants   *note 3.4(21): 1554.
   discriminant values   *note 3.7.1(12): 2017.
   entry index   *note 9.5.2(24): 4084.
   expressions in aggregate   *note 4.3.1(19): 2525.
   expressions of aggregate   *note 4.3.3(23): 2572.
   function return   *note 6.5(5.11/3): 3516, *note 6.5(6/2): 3524.
   generic formal object of mode in   *note 12.4(11): 4766.
   inherited enumeration literal   *note 3.4(29): 1560.
   initialization expression   *note 3.3.1(17): 1514.
   initialization expression of allocator   *note 4.8(7/2): 3060.
   Interrupt_Priority aspect   *note D.1(17/4): 7768, *note D.3(6.1/3):
7841.
   named number value   *note 3.3.2(6): 1527.
   operand of concatenation   *note 4.5.3(9): 2826.
   parameter passing   *note 6.4.1(10): 3482, *note 6.4.1(11): 3484,
*note 6.4.1(17): 3493.
   Priority aspect   *note D.1(17/4): 7767, *note D.3(6.1/3): 7840.
   qualified_expression   *note 4.7(4/4): 3038.
   reading a view conversion   *note 4.6(56/4): 3016.
   result of inherited function   *note 3.4(27/2): 1558.
implicit_dereference   *note 4.1(6): 2380.
   <used>   *note 4.1(4): 2377, *note P: 9211.
Implicit_Dereference aspect   *note 4.1.5(2/3): 2451.
Import aspect   *note B.1(1/3): 7385.
Import pragma   *note J.15.5(2/3): 8565, *note L(14.1/3): 8759.
imported entity   *note B.1(23/3): 7409.
in (membership test)   *note 4.4(1/3): 2615, *note 4.5.2(2/3): 2791.
inaccessible partition   *note E.1(7): 8106.
inactive
   a task state   *note 9(10): 3884.
Include
   <in> Ada.Containers.Hashed_Maps   *note A.18.5(22/2): 6936.
   <in> Ada.Containers.Hashed_Sets   *note A.18.8(21/2): 7063.
   <in> Ada.Containers.Ordered_Maps   *note A.18.6(21/2): 6987.
   <in> Ada.Containers.Ordered_Sets   *note A.18.9(20/2): 7134.
included
   one range in another   *note 3.5(4): 1598.
incomplete type   *note 3.2(4.1/2): 1343, *note 3.10.1(2.1/4): 2278,
*note N(20.1/2): 8914.
incomplete view   *note 3.10.1(2.1/4): 2279.
   tagged   *note 3.10.1(2.1/4): 2280.
incomplete_type_declaration   *note 3.10.1(2/2): 2275.
   <used>   *note 3.2.1(2): 1370, *note P: 9024.
Increment
   <in> Interfaces.C.Pointers   *note B.3.2(11/3): 7523.
indefinite subtype   *note 3.3(23/3): 1468, *note 3.7(26): 1999.
Indefinite_Doubly_Linked_Lists
   <child of> Ada.Containers   *note A.18.12(2/3): 7277.
Indefinite_Hashed_Maps
   <child of> Ada.Containers   *note A.18.13(2/3): 7278.
Indefinite_Hashed_Sets
   <child of> Ada.Containers   *note A.18.15(2/3): 7280.
Indefinite_Holders
   <child of> Ada.Containers   *note A.18.18(5/3): 7284.
Indefinite_Multiway_Trees
   <child of> Ada.Containers   *note A.18.17(2/3): 7282.
Indefinite_Ordered_Maps
   <child of> Ada.Containers   *note A.18.14(2/3): 7279.
Indefinite_Ordered_Sets
   <child of> Ada.Containers   *note A.18.16(2/3): 7281.
Indefinite_Vectors
   <child of> Ada.Containers   *note A.18.11(2/3): 7276.
Independent aspect   *note C.6(6.3/3): 7691.
Independent pragma   *note J.15.8(4/3): 8604, *note L(14.2/3): 8765.
independent subprogram   *note 11.6(6/3): 4658.
Independent_Components aspect   *note C.6(6.9/3): 7699.
Independent_Components pragma   *note J.15.8(7/3): 8613, *note
L(14.3/3): 8768.
independently addressable   *note 9.10(1/3): 4306.
   specified   *note C.6(8.1/4): 7703.
index
   of an element of an open direct file   *note A.8(3): 6295.
   <in> Ada.Direct_IO   *note A.8.4(15): 6344.
   <in> Ada.Streams.Stream_IO   *note A.12.1(23): 6591.
   <in> Ada.Strings.Bounded   *note A.4.4(43.1/2): 5866, *note
A.4.4(43.2/2): 5867, *note A.4.4(44): 5868, *note A.4.4(45): 5869, *note
A.4.4(45.1/2): 5870, *note A.4.4(46): 5871.
   <in> Ada.Strings.Fixed   *note A.4.3(8.1/2): 5809, *note
A.4.3(8.2/2): 5810, *note A.4.3(9): 5811, *note A.4.3(10): 5812, *note
A.4.3(10.1/2): 5813, *note A.4.3(11): 5814.
   <in> Ada.Strings.Unbounded   *note A.4.5(38.1/2): 5920, *note
A.4.5(38.2/2): 5921, *note A.4.5(39): 5922, *note A.4.5(40): 5923, *note
A.4.5(40.1/2): 5924, *note A.4.5(41): 5925.
index range   *note 3.6(13): 1913.
index subtype   *note 3.6(9): 1907.
index type   *note 3.6(9): 1908.
Index_Check   *note 11.5(14): 4632.
   [<partial>]   *note 4.1.1(7): 2403, *note 4.1.2(7): 2413, *note
4.3.3(29/3): 2577, *note 4.3.3(30): 2579, *note 4.5.3(8): 2823, *note
4.6(51/4): 3002, *note 4.7(4/4): 3036, *note 4.8(10/2): 3063.
index_constraint   *note 3.6.1(2): 1932.
   <used>   *note 3.2.2(7): 1418, *note P: 9053.
Index_Error
   <in> Ada.Strings   *note A.4.1(5): 5776.
Index_Non_Blank
   <in> Ada.Strings.Bounded   *note A.4.4(46.1/2): 5872, *note
A.4.4(47): 5873.
   <in> Ada.Strings.Fixed   *note A.4.3(11.1/2): 5815, *note A.4.3(12):
5816.
   <in> Ada.Strings.Unbounded   *note A.4.5(41.1/2): 5926, *note
A.4.5(42): 5927.
index_subtype_definition   *note 3.6(4): 1894.
   <used>   *note 3.6(3): 1892, *note P: 9108.
indexable container object   *note 4.1.6(5/3): 2467.
indexable container type   *note 4.1.6(5/3): 2466, *note N(20.2/3):
8915.
indexed_component   *note 4.1.1(2): 2394.
   <used>   *note 4.1(2/3): 2362, *note P: 9198.
indexing
   constant   *note 4.1.6(12/3): 2473.
   variable   *note 4.1.6(16/3): 2475.
individual membership test   *note 4.5.2(26.1/3): 2801.
indivisible   *note C.6(10/4): 7704.
inferable discriminants   *note B.3.3(20/2): 7541.
Information
   <child of> Ada.Directories   *note A.16(124/2): 6685.
information hiding
   <See> package   *note 7(1): 3567.
   <See> private types and private extensions   *note 7.3(1): 3596.
information systems   *note C(1): 7622, *note F(1): 8218.
informative   *note 1.1.2(18): 1011.
inherently mutable object   *note 3.3(13/3): 1462.
inheritance
   <See> derived types and classes   *note 3.4(1/2): 1530.
   <See also> tagged types and type extension   *note 3.9(1): 2086.
inherited
   from an ancestor type   *note 3.4.1(11): 1580.
inherited component   *note 3.4(11): 1546, *note 3.4(12): 1547.
inherited discriminant   *note 3.4(11): 1545.
inherited entry   *note 3.4(12): 1549.
inherited protected subprogram   *note 3.4(12): 1548.
inherited subprogram   *note 3.4(17/2): 1550.
Initial_Directory
   <in> Ada.Directories.Hierarchical_File_Names   *note A.16.1(12/3):
6695.
initialization
   of a protected object   *note 9.4(14): 4004.
   of a protected object   *note C.3.1(10/3): 7647, *note C.3.1(11/3):
7651.
   of a task object   *note 9.1(12/1): 3930, *note J.7.1(7): 8512.
   of an object   *note 3.3.1(18/2): 1516.
initialization expression   *note 3.3.1(1/3): 1475, *note 3.3.1(4):
1498.
Initialize   *note 7.6(2): 3658.
   <in> Ada.Finalization   *note 7.6(6/2): 3663, *note 7.6(8/2): 3667.
initialized allocator   *note 4.8(4): 3052.
initialized by default   *note 3.3.1(18/2): 1515.
Inline aspect   *note 6.3.2(5.1/3): 3444.
Inline pragma   *note J.15.1(2/3): 8533, *note L(15.1/3): 8771.
innermost dynamically enclosing   *note 11.4(2): 4558.
input   *note A.6(1/2): 6278.
Input aspect   *note 13.13.2(38/4): 5383.
Input attribute   *note 13.13.2(22): 5360, *note 13.13.2(32): 5364.
Input clause   *note 13.3(7/2): 4971, *note 13.13.2(38/4): 5376.
Input'Class aspect   *note 13.13.2(38/4): 5391.
input-output
   unspecified for access types   *note A.7(6): 6285.
Insert
   <in> Ada.Containers.Doubly_Linked_Lists   *note A.18.3(19/2): 6842,
*note A.18.3(20/2): 6843, *note A.18.3(21/2): 6844.
   <in> Ada.Containers.Hashed_Maps   *note A.18.5(19/2): 6933, *note
A.18.5(20/2): 6934, *note A.18.5(21/2): 6935.
   <in> Ada.Containers.Hashed_Sets   *note A.18.8(19/2): 7061, *note
A.18.8(20/2): 7062.
   <in> Ada.Containers.Ordered_Maps   *note A.18.6(18/2): 6984, *note
A.18.6(19/2): 6985, *note A.18.6(20/2): 6986.
   <in> Ada.Containers.Ordered_Sets   *note A.18.9(18/2): 7132, *note
A.18.9(19/2): 7133.
   <in> Ada.Containers.Vectors   *note A.18.2(36/2): 6759, *note
A.18.2(37/2): 6760, *note A.18.2(38/2): 6761, *note A.18.2(39/2): 6762,
*note A.18.2(40/2): 6763, *note A.18.2(41/2): 6764, *note A.18.2(42/2):
6765, *note A.18.2(43/2): 6766.
   <in> Ada.Strings.Bounded   *note A.4.4(60): 5885, *note A.4.4(61):
5886.
   <in> Ada.Strings.Fixed   *note A.4.3(25): 5828, *note A.4.3(26):
5829.
   <in> Ada.Strings.Unbounded   *note A.4.5(55): 5939, *note A.4.5(56):
5940.
Insert_Child
   <in> Ada.Containers.Multiway_Trees   *note A.18.10(48/3): 7241, *note
A.18.10(49/3): 7242, *note A.18.10(50/3): 7243.
Insert_Space
   <in> Ada.Containers.Vectors   *note A.18.2(48/2): 6771, *note
A.18.2(49/2): 6772.
inspectable object   *note H.3.2(5/2): 8445.
inspection point   *note H.3.2(5/2): 8444.
Inspection_Point pragma   *note H.3.2(3): 8441, *note L(16): 8775.
instance
   of a generic function   *note 12.3(13): 4734.
   of a generic package   *note 12.3(13): 4731.
   of a generic procedure   *note 12.3(13): 4733.
   of a generic subprogram   *note 12.3(13): 4732.
   of a generic unit   *note 12.3(1): 4693.
instructions for comment submission   *note 0.3(58/1): 1003.
int
   <in> Interfaces.C   *note B.3(7): 7437.
Integer   *note 3.5.4(11): 1740, *note 3.5.4(21): 1760.
   <in> Standard   *note A.1(12): 5438.
integer literal   *note 2.4(1): 1206.
integer literals   *note 3.5.4(14): 1747, *note 3.5.4(30): 1769.
integer type   *note 3.5.4(1): 1717, *note N(21): 8916.
Integer_Address
   <in> System.Storage_Elements   *note 13.7.1(10/3): 5138.
Integer_IO
   <in> Ada.Text_IO   *note A.10.1(52): 6463.
Integer_N   *note B.2(8): 7427.
Integer_Text_IO
   <child of> Ada   *note A.10.8(21): 6535.
integer_type_definition   *note 3.5.4(2): 1721.
   <used>   *note 3.2.1(4/2): 1382, *note P: 9034.
Integer_Wide_Text_IO
   <child of> Ada   *note A.11(2/2): 6556.
Integer_Wide_Wide_Text_IO
   <child of> Ada   *note A.11(3/2): 6559.
interaction
   between tasks   *note 9(1/3): 3876.
interface   *note 3.9.4(4/2): 2200.
   limited   *note 3.9.4(5/2): 2205.
   nonlimited   *note 3.9.4(5/2): 2206.
   protected   *note 3.9.4(5/2): 2203.
   synchronized   *note 3.9.4(5/2): 2202.
   task   *note 3.9.4(5/2): 2204.
   type   *note 3.9.4(4/2): 2201.
interface to assembly language   *note C.1(4/3): 7624.
interface to C   *note B.3(1/4): 7430.
interface to COBOL   *note B.4(1/3): 7543.
interface to Fortran   *note B.5(1/3): 7597.
interface to other languages   *note B(1): 7379.
interface type   *note N(21.1/2): 8917.
Interface_Ancestor_Tags
   <in> Ada.Tags   *note 3.9(7.4/2): 2112.
interface_list   *note 3.9.4(3/2): 2197.
   <used>   *note 3.4(2/2): 1535, *note 3.9.4(2/2): 2196, *note
7.3(3/3): 3608, *note 9.1(2/3): 3897, *note 9.1(3/3): 3902, *note
9.4(2/3): 3959, *note 9.4(3/3): 3964, *note 12.5.1(3/2): 4803, *note P:
9074.
interface_type_definition   *note 3.9.4(2/2): 2195.
   <used>   *note 3.2.1(4/2): 1388, *note 12.5.5(2/2): 4825, *note P:
9779.
Interfaces   *note B.2(3): 7420.
Interfaces.C   *note B.3(4): 7432.
Interfaces.C.Pointers   *note B.3.2(4): 7518.
Interfaces.C.Strings   *note B.3.1(3): 7496.
Interfaces.COBOL   *note B.4(7): 7545.
Interfaces.Fortran   *note B.5(4): 7599.
interfacing aspect   *note B.1(0.1/3): 7382.
interfacing pragma   *note J.15.5(1/3): 8551.
   Convention   *note J.15.5(1/3): 8556.
   Export   *note J.15.5(1/3): 8554.
   Import   *note J.15.5(1/3): 8552.
internal call   *note 9.5(3/3): 4013.
internal code   *note 13.4(7): 5045.
internal node
   of a tree   *note A.18.10(2/4): 7192.
internal requeue   *note 9.5(7): 4016.
Internal_Tag
   <in> Ada.Tags   *note 3.9(7/2): 2107.
interpretation
   of a complete context   *note 8.6(10): 3849.
   of a constituent of a complete context   *note 8.6(15): 3855.
   overload resolution   *note 8.6(14): 3854.
interrupt   *note C.3(2): 7630.
   example using asynchronous_select   *note 9.7.4(10): 4270, *note
9.7.4(12): 4275.
interrupt entry   *note J.7.1(5): 8508.
interrupt handler   *note C.3(2): 7638.
Interrupt_Clocks_Supported
   <in> Ada.Execution_Time   *note D.14(9.1/3): 8008.
Interrupt_Handler aspect   *note C.3.1(6.2/3): 7642.
Interrupt_Handler pragma   *note J.15.7(2/3): 8589, *note L(17.1/3):
8779.
Interrupt_Id
   <in> Ada.Interrupts   *note C.3.2(2/3): 7660.
Interrupt_Priority aspect   *note D.1(6.3/3): 7760.
Interrupt_Priority pragma   *note J.15.11(4/3): 8637, *note L(18.1/3):
8782.
Interrupt_Priority <subtype of> Any_Priority
   <in> System   *note 13.7(16): 5129.
Interrupts
   <child of> Ada   *note C.3.2(2/3): 7659.
   <child of> Ada.Execution_Time   *note D.14.3(3/3): 8055.
Intersection
   <in> Ada.Containers.Hashed_Sets   *note A.18.8(29/2): 7070, *note
A.18.8(30/2): 7071.
   <in> Ada.Containers.Ordered_Sets   *note A.18.9(30/2): 7143, *note
A.18.9(31/2): 7144.
intertask communication   *note 9.5(1): 4010.
   <See also> task   *note 9(1/3): 3880.
Intrinsic calling convention   *note 6.3.1(4): 3421.
invalid cursor
   of a list container   *note A.18.3(153/2): 6884.
   of a map   *note A.18.4(76/2): 6904.
   of a set   *note A.18.7(97/2): 7036.
   of a tree   *note A.18.10(222/3): 7273.
   of a vector   *note A.18.2(248/2): 6814.
invalid representation   *note 13.9.1(9): 5171.
invariant   *note N(21.2/4): 8918.
   class-wide   *note 7.3.2(3/4): 3634.
invariant check   *note 7.3.2(9/4): 3636.
invariant expression   *note 7.3.2(2/3): 3627.
Inverse
   <in> Ada.Numerics.Generic_Complex_Arrays   *note G.3.2(46/2): 8417.
   <in> Ada.Numerics.Generic_Real_Arrays   *note G.3.1(24/2): 8377.
Inverted_Exclamation
   <in> Ada.Characters.Latin_1   *note A.3.3(21/3): 5632.
Inverted_Question
   <in> Ada.Characters.Latin_1   *note A.3.3(22): 5664.
involve an inner product
   complex   *note G.3.2(56/2): 8423.
   real   *note G.3.1(34/2): 8383.
IO_Exceptions
   <child of> Ada   *note A.13(3): 6613.
IS1
   <in> Ada.Characters.Latin_1   *note A.3.3(16): 5597.
IS2
   <in> Ada.Characters.Latin_1   *note A.3.3(16): 5596.
IS3
   <in> Ada.Characters.Latin_1   *note A.3.3(16): 5595.
IS4
   <in> Ada.Characters.Latin_1   *note A.3.3(16): 5594.
Is_A_Group_Member
   <in> Ada.Execution_Time.Group_Budgets   *note D.14.2(8/2): 8038.
Is_Abstract
   <in> Ada.Tags   *note 3.9(7.5/3): 2113.
Is_Alphanumeric
   <in> Ada.Characters.Handling   *note A.3.2(4/3): 5470.
   <in> Ada.Wide_Characters.Handling   *note A.3.5(12/3): 5757.
Is_Attached
   <in> Ada.Interrupts   *note C.3.2(5): 7663.
Is_Basic
   <in> Ada.Characters.Handling   *note A.3.2(4/3): 5466.
Is_Callable
   <in> Ada.Task_Identification   *note C.7.1(4/3): 7716.
Is_Character
   <in> Ada.Characters.Conversions   *note A.3.4(3/2): 5730.
Is_Control
   <in> Ada.Characters.Handling   *note A.3.2(4/3): 5461.
   <in> Ada.Wide_Characters.Handling   *note A.3.5(5/3): 5750.
Is_Current_Directory_Name
   <in> Ada.Directories.Hierarchical_File_Names   *note A.16.1(7/3):
6690.
Is_Decimal_Digit
   <in> Ada.Characters.Handling   *note A.3.2(4/3): 5468.
   <in> Ada.Wide_Characters.Handling   *note A.3.5(10/3): 5755.
Is_Descendant_At_Same_Level
   <in> Ada.Tags   *note 3.9(7.1/2): 2109.
Is_Digit
   <in> Ada.Characters.Handling   *note A.3.2(4/3): 5467.
   <in> Ada.Wide_Characters.Handling   *note A.3.5(9/3): 5754.
Is_Empty
   <in> Ada.Containers.Doubly_Linked_Lists   *note A.18.3(12/2): 6830.
   <in> Ada.Containers.Hashed_Maps   *note A.18.5(11/2): 6918.
   <in> Ada.Containers.Hashed_Sets   *note A.18.8(13/2): 7052.
   <in> Ada.Containers.Indefinite_Holders   *note A.18.18(10/3): 7288.
   <in> Ada.Containers.Multiway_Trees   *note A.18.10(16/3): 7209.
   <in> Ada.Containers.Ordered_Maps   *note A.18.6(10/2): 6969.
   <in> Ada.Containers.Ordered_Sets   *note A.18.9(12/2): 7123.
   <in> Ada.Containers.Vectors   *note A.18.2(23/2): 6739.
Is_Full_Name
   <in> Ada.Directories.Hierarchical_File_Names   *note A.16.1(8/3):
6691.
Is_Graphic
   <in> Ada.Characters.Handling   *note A.3.2(4/3): 5462.
   <in> Ada.Wide_Characters.Handling   *note A.3.5(19/3): 5764.
Is_Held
   <in> Ada.Asynchronous_Task_Control   *note D.11(3/2): 7991.
Is_Hexadecimal_Digit
   <in> Ada.Characters.Handling   *note A.3.2(4/3): 5469.
   <in> Ada.Wide_Characters.Handling   *note A.3.5(11/3): 5756.
Is_In
   <in> Ada.Strings.Maps   *note A.4.2(13): 5791.
   <in> Ada.Strings.Wide_Maps   *note A.4.7(13): 5993.
   <in> Ada.Strings.Wide_Wide_Maps   *note A.4.8(13/2): 6032.
Is_ISO_646
   <in> Ada.Characters.Handling   *note A.3.2(10): 5484.
Is_Leaf
   <in> Ada.Containers.Multiway_Trees   *note A.18.10(21/3): 7214.
Is_Letter
   <in> Ada.Characters.Handling   *note A.3.2(4/3): 5463.
   <in> Ada.Wide_Characters.Handling   *note A.3.5(6/3): 5751.
Is_Line_Terminator
   <in> Ada.Characters.Handling   *note A.3.2(4/3): 5472.
   <in> Ada.Wide_Characters.Handling   *note A.3.5(14/3): 5759.
Is_Lower
   <in> Ada.Characters.Handling   *note A.3.2(4/3): 5464.
   <in> Ada.Wide_Characters.Handling   *note A.3.5(7/3): 5752.
Is_Mark
   <in> Ada.Characters.Handling   *note A.3.2(4/3): 5473.
   <in> Ada.Wide_Characters.Handling   *note A.3.5(15/3): 5760.
Is_Member
   <in> Ada.Execution_Time.Group_Budgets   *note D.14.2(8/2): 8037.
Is_Nul_Terminated
   <in> Interfaces.C   *note B.3(24): 7456, *note B.3(35): 7466, *note
B.3(39.16/2): 7486, *note B.3(39.7/2): 7476.
Is_Open
   <in> Ada.Direct_IO   *note A.8.4(10): 6337.
   <in> Ada.Sequential_IO   *note A.8.1(10): 6310.
   <in> Ada.Streams.Stream_IO   *note A.12.1(12): 6583.
   <in> Ada.Text_IO   *note A.10.1(13): 6392.
Is_Other_Format
   <in> Ada.Characters.Handling   *note A.3.2(4/3): 5474.
   <in> Ada.Wide_Characters.Handling   *note A.3.5(16/3): 5761.
Is_Parent_Directory_Name
   <in> Ada.Directories.Hierarchical_File_Names   *note A.16.1(6/3):
6689.
Is_Punctuation_Connector
   <in> Ada.Characters.Handling   *note A.3.2(4/3): 5475.
   <in> Ada.Wide_Characters.Handling   *note A.3.5(17/3): 5762.
Is_Relative_Name
   <in> Ada.Directories.Hierarchical_File_Names   *note A.16.1(9/3):
6692.
Is_Reserved
   <in> Ada.Interrupts   *note C.3.2(4): 7662.
Is_Root
   <in> Ada.Containers.Multiway_Trees   *note A.18.10(20/3): 7213.
Is_Root_Directory_Name
   <in> Ada.Directories.Hierarchical_File_Names   *note A.16.1(5/3):
6688.
Is_Round_Robin
   <in> Ada.Dispatching.Round_Robin   *note D.2.5(4/2): 7818.
Is_Simple_Name
   <in> Ada.Directories.Hierarchical_File_Names   *note A.16.1(4/3):
6687.
Is_Sorted
   <in> Ada.Containers.Doubly_Linked_Lists   *note A.18.3(48/2): 6870.
   <in> Ada.Containers.Vectors   *note A.18.2(76/2): 6798.
Is_Space
   <in> Ada.Characters.Handling   *note A.3.2(4/3): 5476.
   <in> Ada.Wide_Characters.Handling   *note A.3.5(18/3): 5763.
Is_Special
   <in> Ada.Characters.Handling   *note A.3.2(4/3): 5471.
   <in> Ada.Wide_Characters.Handling   *note A.3.5(13/3): 5758.
Is_String
   <in> Ada.Characters.Conversions   *note A.3.4(3/2): 5733.
Is_Subset
   <in> Ada.Containers.Hashed_Sets   *note A.18.8(39/2): 7077.
   <in> Ada.Containers.Ordered_Sets   *note A.18.9(40/2): 7150.
   <in> Ada.Strings.Maps   *note A.4.2(14): 5792.
   <in> Ada.Strings.Wide_Maps   *note A.4.7(14): 5994.
   <in> Ada.Strings.Wide_Wide_Maps   *note A.4.8(14/2): 6033.
Is_Terminated
   <in> Ada.Task_Identification   *note C.7.1(4/3): 7715.
Is_Upper
   <in> Ada.Characters.Handling   *note A.3.2(4/3): 5465.
   <in> Ada.Wide_Characters.Handling   *note A.3.5(8/3): 5753.
Is_Wide_Character
   <in> Ada.Characters.Conversions   *note A.3.4(3/2): 5734.
Is_Wide_String
   <in> Ada.Characters.Conversions   *note A.3.4(3/2): 5735.
ISO 1989:2002   *note 1.2(4/2): 1097.
ISO 639-3:2007   *note 1.2(1.1/3): 1088.
ISO 8601:2004   *note 1.2(5.1/2): 1106.
ISO/IEC 10646:2011   *note 1.2(8/3): 1114, *note 3.5.2(2/3): 1704, *note
3.5.2(3/3): 1710, *note 3.5.2(4/3): 1712.
ISO/IEC 14882:2011   *note 1.2(9/3): 1117.
ISO/IEC 1539-1:2004   *note 1.2(3/2): 1094.
ISO/IEC 3166-1:2006   *note 1.2(4.1/3): 1100.
ISO/IEC 6429:1992   *note 1.2(5): 1103.
ISO/IEC 646:1991   *note 1.2(2): 1091.
ISO/IEC 8859-1:1998   *note 1.2(6/3): 1108.
ISO/IEC 9899:2011   *note 1.2(7/3): 1111.
ISO/IEC TR 19769:2004   *note 1.2(10/2): 1120.
ISO_646 <subtype of> Character
   <in> Ada.Characters.Handling   *note A.3.2(9): 5483.
ISO_646_Set
   <in> Ada.Strings.Maps.Constants   *note A.4.6(4): 5965.
issue
   an entry call   *note 9.5.3(8): 4105.
italics
   nongraphic characters   *note 3.5.2(2/3): 1706.
   pseudo-names of anonymous types   *note 3.2.1(7/2): 1392, *note
A.1(2): 5435.
   syntax rules   *note 1.1.4(14): 1065.
   terms introduced or defined   *note 1.3(1/2): 1122.
iterable container object   *note 5.5.1(11/3): 3231.
iterable container object for a loop   *note 5.5.2(12/3): 3257.
iterable container type   *note 5.5.1(11/3): 3229, *note N(21.3/3):
8919.
Iterate
   <in> Ada.Containers.Doubly_Linked_Lists   *note A.18.3(45/2): 6867.
   <in> Ada.Containers.Hashed_Maps   *note A.18.5(37/2): 6950.
   <in> Ada.Containers.Hashed_Sets   *note A.18.8(49/2): 7086.
   <in> Ada.Containers.Multiway_Trees   *note A.18.10(42/3): 7235, *note
A.18.10(44/3): 7237.
   <in> Ada.Containers.Ordered_Maps   *note A.18.6(50/2): 7009.
   <in> Ada.Containers.Ordered_Sets   *note A.18.9(60/2): 7163.
   <in> Ada.Containers.Vectors   *note A.18.2(73/2): 6795.
   <in> Ada.Environment_Variables   *note A.17(8/3): 6706.
Iterate_Children
   <in> Ada.Containers.Multiway_Trees   *note A.18.10(68/3): 7261, *note
A.18.10(70/3): 7263.
Iterate_Subtree
   <in> Ada.Containers.Multiway_Trees   *note A.18.10(43/3): 7236, *note
A.18.10(45/3): 7238.
iteration cursor subtype   *note 5.5.1(6/3): 3220.
iteration_scheme   *note 5.5(3/3): 3195.
   <used>   *note 5.5(2): 3192, *note P: 9391.
iterator   *note N(21.4/3): 8920.
   array component   *note 5.5.2(3/3): 3246.
   container element   *note 5.5.2(3/3): 3248.
   forward   *note 5.5.2(4/3): 3252.
   generalized   *note 5.5.2(3/3): 3242.
   reverse   *note 5.5.2(4/3): 3250.
iterator object   *note 5.5.1(6/3): 3218.
iterator type   *note 5.5.1(6/3): 3216.
Iterator_Element aspect   *note 5.5.1(9/3): 3228.
Iterator_Interfaces
   <child of> Ada   *note 5.5.1(2/3): 3209.
iterator_specification   *note 5.5.2(2/3): 3235.
   <used>   *note 4.5.8(1/3): 2911, *note 5.5(3/3): 3198, *note P: 9334.



File: arm2012.info,  Node: J,  Next: K,  Prev: I,  Up: Index

J 
==



j
   <in> Ada.Numerics.Generic_Complex_Types   *note G.1.1(5): 8262.
   <in> Interfaces.Fortran   *note B.5(10): 7608.



File: arm2012.info,  Node: K,  Next: L,  Prev: J,  Up: Index

K 
==



Key
   <in> Ada.Containers.Hashed_Maps   *note A.18.5(13/2): 6920.
   <in> Ada.Containers.Hashed_Sets   *note A.18.8(51/2): 7088.
   <in> Ada.Containers.Ordered_Maps   *note A.18.6(12/2): 6971.
   <in> Ada.Containers.Ordered_Sets   *note A.18.9(64/2): 7167.
Kind
   <in> Ada.Directories   *note A.16(25/2): 6656, *note A.16(40/2):
6668.
known discriminants   *note 3.7(26): 1992.
known to be constrained   *note 3.3(23.1/3): 1470.
known to denote the same object   *note 6.4.1(6.5/3): 3479.
known to refer to the same object   *note 6.4.1(6.12/3): 3480.
known_discriminant_part   *note 3.7(4): 1971.
   <used>   *note 3.2.1(3/3): 1375, *note 3.7(2/2): 1969, *note
9.1(2/3): 3895, *note 9.4(2/3): 3957, *note P: 9543.



File: arm2012.info,  Node: L,  Next: M,  Prev: K,  Up: Index

L 
==



label   *note 5.1(7): 3143.
   <used>   *note 5.1(2/3): 3115, *note 5.1(3): 3119, *note P: 9353.
Landau symbol O(X)   *note A.18(3/2): 6711.
language
   interface to assembly   *note C.1(4/3): 7625.
   interface to non-Ada   *note B(1): 7380.
   <in> Ada.Locales   *note A.19(6/3): 7375.
Language code standard   *note 1.2(1.1/3): 1090.
language-defined categories
   [<partial>]   *note 3.2(10/2): 1367.
language-defined category
   of types   *note 3.2(2/2): 1334.
language-defined check   *note 11.5(2/3): 4611, *note 11.6(1/3): 4648.
language-defined class
   [<partial>]   *note 3.2(10/2): 1366.
   of types   *note 3.2(2/2): 1333.
Language-defined constants   *note Q.5(1/3): 9857.
Language-defined exceptions   *note Q.4(1/3): 9855.
Language-Defined Library Units   *note A(1): 5431.
Language-defined objects   *note Q.5(1/3): 9856.
Language-defined packages   *note Q.1(1/3): 9851.
Language-defined subprograms   *note Q.3(1/3): 9854.
Language-defined subtypes   *note Q.2(1/3): 9853.
Language-defined types   *note Q.2(1/3): 9852.
Language-defined values   *note Q.5(1/3): 9858.
Language_Code
   <in> Ada.Locales   *note A.19(4/4): 7371.
Language_Unknown
   <in> Ada.Locales   *note A.19(5/3): 7373.
Last
   <in> Ada.Containers.Doubly_Linked_Lists   *note A.18.3(35/2): 6858.
   <in> Ada.Containers.Ordered_Maps   *note A.18.6(31/2): 6997.
   <in> Ada.Containers.Ordered_Sets   *note A.18.9(43/2): 7153.
   <in> Ada.Containers.Vectors   *note A.18.2(61/2): 6784.
   <in> Ada.Iterator_Interfaces   *note 5.5.1(4/3): 3214.
Last attribute   *note 3.5(13): 1614, *note 3.6.2(5): 1951.
last element
   of a hashed set   *note A.18.8(68/2): 7107.
   of a set   *note A.18.7(6/2): 7024.
   of an ordered set   *note A.18.9(81/3): 7186.
last node
   of a hashed map   *note A.18.5(46/2): 6957.
   of a map   *note A.18.4(6/2): 6895.
   of an ordered map   *note A.18.6(58/3): 7015.
Last(N) attribute   *note 3.6.2(6): 1953.
last_bit   *note 13.5.1(6): 5072.
   <used>   *note 13.5.1(3): 5067, *note P: 9830.
Last_Bit attribute   *note 13.5.2(4/2): 5085.
Last_Child
   <in> Ada.Containers.Multiway_Trees   *note A.18.10(62/3): 7255.
Last_Child_Element
   <in> Ada.Containers.Multiway_Trees   *note A.18.10(63/3): 7256.
Last_Element
   <in> Ada.Containers.Doubly_Linked_Lists   *note A.18.3(36/2): 6859.
   <in> Ada.Containers.Ordered_Maps   *note A.18.6(32/2): 6998.
   <in> Ada.Containers.Ordered_Sets   *note A.18.9(44/2): 7154.
   <in> Ada.Containers.Vectors   *note A.18.2(62/2): 6785.
Last_Index
   <in> Ada.Containers.Vectors   *note A.18.2(60/2): 6783.
Last_Key
   <in> Ada.Containers.Ordered_Maps   *note A.18.6(33/2): 6999.
Last_Valid attribute   *note 3.5.5(7.3/4): 1781.
lateness   *note D.9(12): 7971.
Latin-1   *note 3.5.2(2/3): 1702.
Latin_1
   <child of> Ada.Characters   *note A.3.3(3): 5498.
Layout aspect   *note 13.5(1): 5050.
Layout_Error
   <in> Ada.IO_Exceptions   *note A.13(4): 6621.
   <in> Ada.Text_IO   *note A.10.1(85): 6527.
LC_A
   <in> Ada.Characters.Latin_1   *note A.3.3(13): 5562.
LC_A_Acute
   <in> Ada.Characters.Latin_1   *note A.3.3(25): 5698.
LC_A_Circumflex
   <in> Ada.Characters.Latin_1   *note A.3.3(25): 5699.
LC_A_Diaeresis
   <in> Ada.Characters.Latin_1   *note A.3.3(25): 5701.
LC_A_Grave
   <in> Ada.Characters.Latin_1   *note A.3.3(25): 5697.
LC_A_Ring
   <in> Ada.Characters.Latin_1   *note A.3.3(25): 5702.
LC_A_Tilde
   <in> Ada.Characters.Latin_1   *note A.3.3(25): 5700.
LC_AE_Diphthong
   <in> Ada.Characters.Latin_1   *note A.3.3(25): 5703.
LC_B
   <in> Ada.Characters.Latin_1   *note A.3.3(13): 5563.
LC_C
   <in> Ada.Characters.Latin_1   *note A.3.3(13): 5564.
LC_C_Cedilla
   <in> Ada.Characters.Latin_1   *note A.3.3(25): 5704.
LC_D
   <in> Ada.Characters.Latin_1   *note A.3.3(13): 5565.
LC_E
   <in> Ada.Characters.Latin_1   *note A.3.3(13): 5566.
LC_E_Acute
   <in> Ada.Characters.Latin_1   *note A.3.3(25): 5706.
LC_E_Circumflex
   <in> Ada.Characters.Latin_1   *note A.3.3(25): 5707.
LC_E_Diaeresis
   <in> Ada.Characters.Latin_1   *note A.3.3(25): 5708.
LC_E_Grave
   <in> Ada.Characters.Latin_1   *note A.3.3(25): 5705.
LC_F
   <in> Ada.Characters.Latin_1   *note A.3.3(13): 5567.
LC_G
   <in> Ada.Characters.Latin_1   *note A.3.3(13): 5568.
LC_German_Sharp_S
   <in> Ada.Characters.Latin_1   *note A.3.3(24): 5696.
LC_H
   <in> Ada.Characters.Latin_1   *note A.3.3(13): 5569.
LC_I
   <in> Ada.Characters.Latin_1   *note A.3.3(13): 5570.
LC_I_Acute
   <in> Ada.Characters.Latin_1   *note A.3.3(25): 5710.
LC_I_Circumflex
   <in> Ada.Characters.Latin_1   *note A.3.3(25): 5711.
LC_I_Diaeresis
   <in> Ada.Characters.Latin_1   *note A.3.3(25): 5712.
LC_I_Grave
   <in> Ada.Characters.Latin_1   *note A.3.3(25): 5709.
LC_Icelandic_Eth
   <in> Ada.Characters.Latin_1   *note A.3.3(26): 5713.
LC_Icelandic_Thorn
   <in> Ada.Characters.Latin_1   *note A.3.3(26): 5727.
LC_J
   <in> Ada.Characters.Latin_1   *note A.3.3(13): 5571.
LC_K
   <in> Ada.Characters.Latin_1   *note A.3.3(13): 5572.
LC_L
   <in> Ada.Characters.Latin_1   *note A.3.3(13): 5573.
LC_M
   <in> Ada.Characters.Latin_1   *note A.3.3(13): 5574.
LC_N
   <in> Ada.Characters.Latin_1   *note A.3.3(13): 5575.
LC_N_Tilde
   <in> Ada.Characters.Latin_1   *note A.3.3(26): 5714.
LC_O
   <in> Ada.Characters.Latin_1   *note A.3.3(13): 5576.
LC_O_Acute
   <in> Ada.Characters.Latin_1   *note A.3.3(26): 5716.
LC_O_Circumflex
   <in> Ada.Characters.Latin_1   *note A.3.3(26): 5717.
LC_O_Diaeresis
   <in> Ada.Characters.Latin_1   *note A.3.3(26): 5719.
LC_O_Grave
   <in> Ada.Characters.Latin_1   *note A.3.3(26): 5715.
LC_O_Oblique_Stroke
   <in> Ada.Characters.Latin_1   *note A.3.3(26): 5721.
LC_O_Tilde
   <in> Ada.Characters.Latin_1   *note A.3.3(26): 5718.
LC_P
   <in> Ada.Characters.Latin_1   *note A.3.3(14): 5577.
LC_Q
   <in> Ada.Characters.Latin_1   *note A.3.3(14): 5578.
LC_R
   <in> Ada.Characters.Latin_1   *note A.3.3(14): 5579.
LC_S
   <in> Ada.Characters.Latin_1   *note A.3.3(14): 5580.
LC_T
   <in> Ada.Characters.Latin_1   *note A.3.3(14): 5581.
LC_U
   <in> Ada.Characters.Latin_1   *note A.3.3(14): 5582.
LC_U_Acute
   <in> Ada.Characters.Latin_1   *note A.3.3(26): 5723.
LC_U_Circumflex
   <in> Ada.Characters.Latin_1   *note A.3.3(26): 5724.
LC_U_Diaeresis
   <in> Ada.Characters.Latin_1   *note A.3.3(26): 5725.
LC_U_Grave
   <in> Ada.Characters.Latin_1   *note A.3.3(26): 5722.
LC_V
   <in> Ada.Characters.Latin_1   *note A.3.3(14): 5583.
LC_W
   <in> Ada.Characters.Latin_1   *note A.3.3(14): 5584.
LC_X
   <in> Ada.Characters.Latin_1   *note A.3.3(14): 5585.
LC_Y
   <in> Ada.Characters.Latin_1   *note A.3.3(14): 5586.
LC_Y_Acute
   <in> Ada.Characters.Latin_1   *note A.3.3(26): 5726.
LC_Y_Diaeresis
   <in> Ada.Characters.Latin_1   *note A.3.3(26): 5728.
LC_Z
   <in> Ada.Characters.Latin_1   *note A.3.3(14): 5587.
Leading_Nonseparate
   <in> Interfaces.COBOL   *note B.4(23): 7567.
Leading_Part attribute   *note A.5.3(54): 6247.
Leading_Separate
   <in> Interfaces.COBOL   *note B.4(23): 7565.
leaf node
   of a tree   *note A.18.10(4/3): 7197.
Leap_Seconds_Count <subtype of> Integer
   <in> Ada.Calendar.Arithmetic   *note 9.6.1(11/2): 4175.
leaving   *note 7.6.1(3/2): 3693.
left   *note 7.6.1(3/2): 3694.
left parenthesis   *note 2.1(15/3): 1156.
Left_Angle_Quotation
   <in> Ada.Characters.Latin_1   *note A.3.3(21/3): 5642.
Left_Curly_Bracket
   <in> Ada.Characters.Latin_1   *note A.3.3(14): 5588.
Left_Parenthesis
   <in> Ada.Characters.Latin_1   *note A.3.3(8): 5540.
Left_Square_Bracket
   <in> Ada.Characters.Latin_1   *note A.3.3(12): 5556.
legal
   construct   *note 1.1.2(27): 1025.
   partition   *note 1.1.2(29): 1033.
legality rules   *note 1.1.2(27): 1022.
length
   of a dimension of an array   *note 3.6(13): 1915.
   of a list container   *note A.18.3(3/2): 6821.
   of a map   *note A.18.4(5/2): 6893.
   of a one-dimensional array   *note 3.6(13): 1916.
   of a set   *note A.18.7(5/2): 7022.
   of a vector container   *note A.18.2(2/2): 6721.
   <in> Ada.Containers.Doubly_Linked_Lists   *note A.18.3(11/2): 6829.
   <in> Ada.Containers.Hashed_Maps   *note A.18.5(10/2): 6917.
   <in> Ada.Containers.Hashed_Sets   *note A.18.8(12/2): 7051.
   <in> Ada.Containers.Ordered_Maps   *note A.18.6(9/2): 6968.
   <in> Ada.Containers.Ordered_Sets   *note A.18.9(11/2): 7122.
   <in> Ada.Containers.Vectors   *note A.18.2(21/2): 6737.
   <in> Ada.Strings.Bounded   *note A.4.4(9): 5849.
   <in> Ada.Strings.Unbounded   *note A.4.5(6): 5905.
   <in> Ada.Text_IO.Editing   *note F.3.3(11): 8247.
   <in> Interfaces.COBOL   *note B.4(34): 7581, *note B.4(39): 7585,
*note B.4(44): 7589.
Length attribute   *note 3.6.2(9): 1959.
Length(N) attribute   *note 3.6.2(10): 1961.
Length_Check   *note 11.5(15): 4633.
   [<partial>]   *note 4.5.1(8): 2753, *note 4.6(37): 2977, *note
4.6(52): 3009.
Length_Error
   <in> Ada.Strings   *note A.4.1(5): 5774.
Length_Range <subtype of> Natural
   <in> Ada.Strings.Bounded   *note A.4.4(8): 5848.
less than operator   *note 4.4(1/3): 2601, *note 4.5.2(1): 2775.
less than or equal operator   *note 4.4(1/3): 2605, *note 4.5.2(1):
2779.
less-than sign   *note 2.1(15/3): 1171.
Less_Case_Insensitive
   <child of> Ada.Strings   *note A.4.10(13/3): 6060.
   <child of> Ada.Strings.Bounded   *note A.4.10(18/3): 6062.
   <child of> Ada.Strings.Fixed   *note A.4.10(16/3): 6061.
   <child of> Ada.Strings.Unbounded   *note A.4.10(21/3): 6063.
Less_Than_Sign
   <in> Ada.Characters.Latin_1   *note A.3.3(10): 5551.
letter
   a category of Character   *note A.3.2(24): 5490.
letter_lowercase   *note 2.1(9/2): 1132.
   <used>   *note 2.3(3/2): 1193, *note P: 8966.
letter_modifier   *note 2.1(9.2/2): 1134.
   <used>   *note 2.3(3/2): 1195, *note P: 8968.
letter_other   *note 2.1(9.3/2): 1135.
   <used>   *note 2.3(3/2): 1196, *note P: 8969.
Letter_Set
   <in> Ada.Strings.Maps.Constants   *note A.4.6(4): 5957.
letter_titlecase   *note 2.1(9.1/2): 1133.
   <used>   *note 2.3(3/2): 1194, *note P: 8967.
letter_uppercase   *note 2.1(8/2): 1131.
   <used>   *note 2.3(3/2): 1192, *note P: 8965.
level
   accessibility   *note 3.10.2(3/2): 2290.
   library   *note 3.10.2(23): 2305.
lexical element   *note 2.2(1): 1180.
lexicographic order   *note 4.5.2(26/3): 2800.
LF
   <in> Ada.Characters.Latin_1   *note A.3.3(5): 5510.
library   *note 10.1.4(9): 4417.
   [<partial>]   *note 10.1.1(9): 4348.
   informal introduction   *note 10(2): 4313.
   <See also> library level, library unit, library_item
library level   *note 3.10.2(23): 2304.
Library unit   *note 10.1(3): 4319, *note 10.1.1(9): 4347, *note N(22):
8921.
   informal introduction   *note 10(2): 4311.
   <See also> language-defined library units
library unit pragma   *note 10.1.5(7/3): 4422.
   All_Calls_Remote   *note E.2.3(6): 8155.
   categorization pragmas   *note E.2(2/3): 8114.
   Elaborate_Body   *note 10.2.1(24): 4500.
   Preelaborate   *note 10.2.1(4): 4465.
   Pure   *note 10.2.1(15): 4482.
library_item   *note 10.1.1(4): 4329.
   informal introduction   *note 10(2): 4312.
   <used>   *note 10.1.1(3): 4326, *note P: 9653.
library_unit_body   *note 10.1.1(7): 4342.
   <used>   *note 10.1.1(4): 4331, *note P: 9657.
library_unit_declaration   *note 10.1.1(5): 4333.
   <used>   *note 10.1.1(4): 4330, *note P: 9656.
library_unit_renaming_declaration   *note 10.1.1(6): 4338.
   <used>   *note 10.1.1(4): 4332, *note P: 9658.
lifetime   *note 3.10.2(3/2): 2294.
limited interface   *note 3.9.4(5/2): 2210.
limited type   *note 7.5(3/3): 3645, *note N(23/2): 8923.
   becoming nonlimited   *note 7.3.1(5/1): 3623, *note 7.5(16): 3651.
   immutably   *note 7.5(8.1/3): 3648.
limited view   *note 10.1.1(12.1/2): 4365.
Limited_Controlled
   <in> Ada.Finalization   *note 7.6(7/2): 3666.
limited_with_clause   *note 10.1.2(4.1/2): 4376.
   <used>   *note 10.1.2(4/2): 4374, *note P: 9672.
line   *note 2.2(2/3): 1182.
   <in> Ada.Text_IO   *note A.10.1(38): 6440.
line terminator   *note A.10(7): 6364.
Line_Length
   <in> Ada.Text_IO   *note A.10.1(25): 6415.
link name   *note B.1(35): 7412.
link-time error
   <See> post-compilation error   *note 1.1.2(29): 1031.
   <See> post-compilation error   *note 1.1.5(4): 1074.
Link_Name aspect   *note B.1(1/3): 7389.
Linker_Options pragma   *note B.1(8): 7400, *note L(19): 8784.
linking
   <See> partition building   *note 10.2(2): 4447.
List
   <in> Ada.Containers.Doubly_Linked_Lists   *note A.18.3(6/3): 6823.
list container   *note A.18.3(1/2): 6818.
List pragma   *note 2.8(21): 1282, *note L(20): 8787.
List_Iterator_Interfaces
   <in> Ada.Containers.Doubly_Linked_Lists   *note A.18.3(9.2/3): 6828.
literal   *note 4.2(1): 2476.
   based   *note 2.4.2(1): 1223.
   decimal   *note 2.4.1(1): 1210.
   numeric   *note 2.4(1): 1204.
   <See also> aggregate   *note 4.3(1): 2493.
little endian   *note 13.5.3(2): 5093.
load time   *note C.4(3): 7676.
local to   *note 8.1(14): 3719.
local_name   *note 13.1(3): 4877.
   <used>   *note 13.3(2): 4949, *note 13.4(2): 5039, *note 13.5.1(2):
5060, *note 13.5.1(3): 5064, *note C.5(3): 7683, *note J.15.2(2/3):
8540, *note J.15.3(2/3): 8546, *note J.15.5(2/3): 8567, *note
J.15.5(3/3): 8573, *note J.15.5(4/3): 8579, *note J.15.6(2/3): 8587,
*note J.15.8(2/3): 8599, *note J.15.8(3/3): 8602, *note J.15.8(4/3):
8605, *note J.15.8(5/3): 8608, *note J.15.8(6/3): 8611, *note
J.15.8(7/3): 8614, *note J.15.13(2/3): 8647, *note L(3.1/3): 8713, *note
L(4.1/3): 8716, *note L(5.1/3): 8719, *note L(8.1/3): 8727, *note L(9):
8738, *note L(13.1/3): 8755, *note L(14.1/3): 8761, *note L(14.2/3):
8766, *note L(14.3/3): 8769, *note L(21.2/3): 8795, *note L(24.1/3):
8803, *note L(37.2/3): 8860, *note L(38.1/3): 8866, *note L(39.1/3):
8869, *note P: 9815.
locale   *note A.19(1/3): 7369.
   active   *note A.19(8/3): 7378.
Locales
   <child of> Ada   *note A.19(3/3): 7370.
locking policy   *note D.3(6/2): 7838.
   Ceiling_Locking   *note D.3(7): 7842.
Locking_Policy pragma   *note D.3(3): 7832, *note L(21): 8790.
Log
   <in> Ada.Numerics.Generic_Complex_Elementary_Functions   *note
G.1.2(3): 8287.
   <in> Ada.Numerics.Generic_Elementary_Functions   *note A.5.1(4):
6113.
Logical
   <in> Interfaces.Fortran   *note B.5(7): 7603.
logical operator   *note 4.5.1(2): 2743.
   <See also> not operator   *note 4.5.6(3): 2865.
logical_operator   *note 4.5(2): 2724.
long
   <in> Interfaces.C   *note B.3(7): 7439.
Long_Binary
   <in> Interfaces.COBOL   *note B.4(10): 7549.
long_double
   <in> Interfaces.C   *note B.3(17): 7450.
Long_Float   *note 3.5.7(15): 1818, *note 3.5.7(16): 1820, *note
3.5.7(17): 1821.
Long_Floating
   <in> Interfaces.COBOL   *note B.4(9): 7547.
Long_Integer   *note 3.5.4(22): 1761, *note 3.5.4(25): 1762, *note
3.5.4(28): 1766.
Look_Ahead
   <in> Ada.Text_IO   *note A.10.1(43): 6448.
loop cursor   *note 5.5.2(12/3): 3259.
loop iterator   *note 5.5.2(10/3): 3254.
   container element iterator   *note 5.5.2(12/3): 3258.
loop parameter   *note 5.5(6): 3202, *note 5.5.2(7/3): 3253.
loop_parameter_specification   *note 5.5(4): 3199.
   <used>   *note 4.5.8(1/3): 2908, *note 5.5(3/3): 3197, *note P: 9395.
loop_statement   *note 5.5(2): 3190.
   <used>   *note 5.1(5/2): 3137, *note P: 9371.
low line   *note 2.1(15/3): 1174.
low-level programming   *note C(1): 7618.
Low_Line
   <in> Ada.Characters.Latin_1   *note A.3.3(12): 5560.
Low_Order_First   *note 13.5.3(2): 5092.
   <in> Interfaces.COBOL   *note B.4(25): 7571.
   <in> System   *note 13.7(15/2): 5125.
lower bound
   of a range   *note 3.5(4): 1592.
lower-case letter
   a category of Character   *note A.3.2(25): 5491.
Lower_Case_Map
   <in> Ada.Strings.Maps.Constants   *note A.4.6(5): 5966.
Lower_Set
   <in> Ada.Strings.Maps.Constants   *note A.4.6(4): 5958.



File: arm2012.info,  Node: M,  Next: N,  Prev: L,  Up: Index

M 
==



Machine attribute   *note A.5.3(60): 6252.
machine code insertion   *note 13.8(1): 5148, *note C.1(2): 7623.
machine numbers
   of a fixed point type   *note 3.5.9(8/2): 1847.
   of a floating point type   *note 3.5.7(8): 1806.
machine scalar   *note 13.3(8.1/3): 4977.
Machine_Code
   <child of> System   *note 13.8(7): 5153.
Machine_Emax attribute   *note A.5.3(8): 6189.
Machine_Emin attribute   *note A.5.3(7): 6187.
Machine_Mantissa attribute   *note A.5.3(6): 6185.
Machine_Overflows attribute   *note A.5.3(12): 6199, *note A.5.4(4):
6277.
Machine_Radix aspect   *note F.1(1): 8222.
Machine_Radix attribute   *note A.5.3(2): 6182, *note A.5.4(2): 6273.
Machine_Radix clause   *note 13.3(7/2): 4973, *note F.1(1): 8220.
Machine_Rounding attribute   *note A.5.3(41.1/2): 6227.
Machine_Rounds attribute   *note A.5.3(11): 6197, *note A.5.4(3): 6275.
macro
   <See> generic unit   *note 12(1): 4665.
Macron
   <in> Ada.Characters.Latin_1   *note A.3.3(21/3): 5646.
main subprogram
   for a partition   *note 10.2(7): 4450.
malloc
   <See> allocator   *note 4.8(1): 3041.
Map
   <in> Ada.Containers.Hashed_Maps   *note A.18.5(3/3): 6909.
   <in> Ada.Containers.Ordered_Maps   *note A.18.6(4/3): 6962.
map container   *note A.18.4(1/2): 6888.
Map_Iterator_Interfaces
   <in> Ada.Containers.Hashed_Maps   *note A.18.5(6.2/3): 6914.
   <in> Ada.Containers.Ordered_Maps   *note A.18.6(7.2/3): 6967.
Maps
   <child of> Ada.Strings   *note A.4.2(3/2): 5783.
mark_non_spacing   *note 2.1(9.4/2): 1136, *note 2.1(9.5/2): 1137.
   <used>   *note 2.3(3.1/3): 1199, *note P: 8971.
mark_spacing_combining
   <used>   *note 2.3(3.1/3): 1200, *note P: 8972.
marshalling   *note E.4(9): 8183.
Masculine_Ordinal_Indicator
   <in> Ada.Characters.Latin_1   *note A.3.3(22): 5659.
master   *note 7.6.1(3/2): 3695.
master of a call   *note 3.10.2(10.1/3): 2297.
match
   a character to a pattern character   *note A.4.2(54): 5804.
   a character to a pattern character, with respect to a character
mapping function   *note A.4.2(64): 5806.
   a string to a pattern string   *note A.4.2(54): 5805.
   value of nonoverridable aspect   *note 13.1.1(18.3/4): 4929.
matching components   *note 4.5.2(16): 2798.
Max attribute   *note 3.5(19): 1623.
Max_Alignment_For_Allocation attribute   *note 13.11.1(4/3): 5222.
Max_Asynchronous_Select_Nesting restriction   *note D.7(18/1): 7926.
Max_Base_Digits   *note 3.5.7(6): 1804.
   <in> System   *note 13.7(8): 5112.
Max_Binary_Modulus   *note 3.5.4(7): 1732.
   <in> System   *note 13.7(7): 5110.
Max_Decimal_Digits
   <in> Ada.Decimal   *note F.2(5): 8228.
Max_Delta
   <in> Ada.Decimal   *note F.2(4): 8227.
Max_Digits   *note 3.5.7(6): 1805.
   <in> System   *note 13.7(8): 5113.
Max_Digits_Binary
   <in> Interfaces.COBOL   *note B.4(11): 7550.
Max_Digits_Long_Binary
   <in> Interfaces.COBOL   *note B.4(11): 7551.
Max_Entry_Queue_Length restriction   *note D.7(19.1/2): 7936.
Max_Image_Width
   <in> Ada.Numerics.Discrete_Random   *note A.5.2(25): 6168.
   <in> Ada.Numerics.Float_Random   *note A.5.2(13): 6156.
Max_Int   *note 3.5.4(14): 1745.
   <in> System   *note 13.7(6): 5109.
Max_Length
   <in> Ada.Strings.Bounded   *note A.4.4(5): 5845.
Max_Mantissa
   <in> System   *note 13.7(9): 5114.
Max_Nonbinary_Modulus   *note 3.5.4(7): 1733.
   <in> System   *note 13.7(7): 5111.
Max_Picture_Length
   <in> Ada.Text_IO.Editing   *note F.3.3(8): 8240.
Max_Protected_Entries restriction   *note D.7(14): 7917.
Max_Scale
   <in> Ada.Decimal   *note F.2(3): 8224.
Max_Select_Alternatives restriction   *note D.7(12): 7913.
Max_Size_In_Storage_Elements attribute   *note 13.11.1(3/3): 5220.
Max_Storage_At_Blocking restriction   *note D.7(17/1): 7921.
Max_Task_Entries restriction   *note D.7(13): 7915.
Max_Tasks restriction   *note D.7(19/1): 7931.
maximum box error
   for a component of the result of evaluating a complex function  
*note G.2.6(3): 8366.
maximum line length   *note A.10(11): 6372.
maximum page length   *note A.10(11): 6373.
maximum relative error
   for a component of the result of evaluating a complex function  
*note G.2.6(3): 8365.
   for the evaluation of an elementary function   *note G.2.4(2): 8359.
Members
   <in> Ada.Execution_Time.Group_Budgets   *note D.14.2(8/2): 8039.
Membership
   <in> Ada.Strings   *note A.4.1(6): 5780.
membership test   *note 4.5.2(2/3): 2790.
membership_choice   *note 4.4(3.2/4): 2691.
   <used>   *note 4.4(3.1/3): 2689, *note P: 9294.
membership_choice_list   *note 4.4(3.1/3): 2688.
   <used>   *note 4.4(3/4): 2686, *note P: 9291.
Memory_Size
   <in> System   *note 13.7(13): 5121.
mentioned
   in a with_clause   *note 10.1.2(6/2): 4383.
Merge
   <in> Ada.Containers.Doubly_Linked_Lists   *note A.18.3(50/2): 6872.
   <in> Ada.Containers.Vectors   *note A.18.2(78/2): 6800.
message
   <See> dispatching call   *note 3.9.2(1/2): 2156.
method
   <See> dispatching subprogram   *note 3.9.2(1/2): 2157.
metrics   *note 1.1.2(35): 1045.
Micro_Sign
   <in> Ada.Characters.Latin_1   *note A.3.3(22): 5653.
Microseconds
   <in> Ada.Real_Time   *note D.8(14/2): 7956.
Middle_Dot
   <in> Ada.Characters.Latin_1   *note A.3.3(22): 5656.
Milliseconds
   <in> Ada.Real_Time   *note D.8(14/2): 7957.
Min attribute   *note 3.5(16): 1621.
Min_Delta
   <in> Ada.Decimal   *note F.2(4): 8226.
Min_Handler_Ceiling
   <in> Ada.Execution_Time.Group_Budgets   *note D.14.2(7/2): 8034.
   <in> Ada.Execution_Time.Timers   *note D.14.1(6/2): 8018.
Min_Int   *note 3.5.4(14): 1744.
   <in> System   *note 13.7(6): 5108.
Min_Scale
   <in> Ada.Decimal   *note F.2(3): 8225.
minus   *note 2.1(15/3): 1163.
minus operator   *note 4.4(1/3): 2623, *note 4.5.3(1): 2813, *note
4.5.4(1): 2836.
Minus_Sign
   <in> Ada.Characters.Latin_1   *note A.3.3(8): 5546.
Minute
   <in> Ada.Calendar.Formatting   *note 9.6.1(25/2): 4195.
Minute_Number <subtype of> Natural
   <in> Ada.Calendar.Formatting   *note 9.6.1(20/2): 4188.
Minutes
   <in> Ada.Real_Time   *note D.8(14/2): 7959.
mixed-language programs   *note B(1): 7381, *note C.1(4/3): 7626.
Mod attribute   *note 3.5.4(16.1/2): 1750.
mod operator   *note 4.4(1/3): 2642, *note 4.5.5(1): 2850.
mod_clause   *note J.8(1): 8516.
   <used>   *note 13.5.1(2): 5061, *note P: 9825.
mode   *note 6.1(16): 3328.
   <used>   *note 6.1(15/3): 3321, *note 12.4(2/3): 4743, *note P: 9438.
   <in> Ada.Direct_IO   *note A.8.4(9): 6334.
   <in> Ada.Sequential_IO   *note A.8.1(9): 6307.
   <in> Ada.Streams.Stream_IO   *note A.12.1(11): 6580.
   <in> Ada.Text_IO   *note A.10.1(12): 6389.
mode conformance   *note 6.3.1(16/3): 3430.
   required   *note 8.5.4(4/3): 3828, *note 8.5.4(5/3): 3831, *note
12.6(7/3): 4845, *note 12.6(8/3): 4846, *note 13.3(6): 4958.
mode of operation
   nonstandard   *note 1.1.5(11): 1081.
   standard   *note 1.1.5(11): 1083.
Mode_Error
   <in> Ada.Direct_IO   *note A.8.4(18): 6348.
   <in> Ada.IO_Exceptions   *note A.13(4): 6615.
   <in> Ada.Sequential_IO   *note A.8.1(15): 6316.
   <in> Ada.Streams.Stream_IO   *note A.12.1(26): 6596.
   <in> Ada.Text_IO   *note A.10.1(85): 6521.
Model attribute   *note A.5.3(68): 6266, *note G.2.2(7): 8350.
model interval   *note G.2.1(4): 8333.
   associated with a value   *note G.2.1(4): 8334.
model number   *note G.2.1(3): 8332.
model-oriented attributes
   of a floating point subtype   *note A.5.3(63): 6256.
Model_Emin attribute   *note A.5.3(65): 6260, *note G.2.2(4): 8343.
Model_Epsilon attribute   *note A.5.3(66): 6262.
Model_Mantissa attribute   *note A.5.3(64): 6258, *note G.2.2(3/2):
8341.
Model_Small attribute   *note A.5.3(67): 6264.
Modification_Time
   <in> Ada.Directories   *note A.16(27/2): 6658, *note A.16(42/2):
6670.
modular type   *note 3.5.4(1): 1719.
Modular_IO
   <in> Ada.Text_IO   *note A.10.1(57): 6472.
modular_type_definition   *note 3.5.4(4): 1727.
   <used>   *note 3.5.4(2): 1723, *note P: 9086.
module
   <See> package   *note 7(1): 3569.
modulus
   of a modular type   *note 3.5.4(7): 1731.
   <in> Ada.Numerics.Generic_Complex_Arrays   *note G.3.2(10/2): 8395,
*note G.3.2(30/2): 8408.
   <in> Ada.Numerics.Generic_Complex_Types   *note G.1.1(9): 8272.
Modulus attribute   *note 3.5.4(17): 1752.
Monday
   <in> Ada.Calendar.Formatting   *note 9.6.1(17/2): 4179.
Month
   <in> Ada.Calendar   *note 9.6(13): 4153.
   <in> Ada.Calendar.Formatting   *note 9.6.1(22/2): 4192.
Month_Number <subtype of> Integer
   <in> Ada.Calendar   *note 9.6(11/2): 4148.
More_Entries
   <in> Ada.Directories   *note A.16(34/2): 6664.
Move
   <in> Ada.Containers.Doubly_Linked_Lists   *note A.18.3(18/2): 6841.
   <in> Ada.Containers.Hashed_Maps   *note A.18.5(18/2): 6932.
   <in> Ada.Containers.Hashed_Sets   *note A.18.8(18/2): 7060.
   <in> Ada.Containers.Indefinite_Holders   *note A.18.18(22/3): 7300.
   <in> Ada.Containers.Multiway_Trees   *note A.18.10(34/3): 7227.
   <in> Ada.Containers.Ordered_Maps   *note A.18.6(17/2): 6983.
   <in> Ada.Containers.Ordered_Sets   *note A.18.9(17/2): 7131.
   <in> Ada.Containers.Vectors   *note A.18.2(35/2): 6758.
   <in> Ada.Strings.Fixed   *note A.4.3(7): 5808.
multi-dimensional array   *note 3.6(12): 1912.
Multiplication_Sign
   <in> Ada.Characters.Latin_1   *note A.3.3(24): 5688.
multiply   *note 2.1(15/3): 1159.
multiply operator   *note 4.4(1/3): 2634, *note 4.5.5(1): 2842.
multiplying operator   *note 4.5.5(1): 2838.
multiplying_operator   *note 4.5(6): 2728.
   <used>   *note 4.4(5): 2702, *note P: 9303.
Multiprocessors
   <child of> System   *note D.16(3/3): 8070.
Multiway_Trees
   <child of> Ada.Containers   *note A.18.10(7/3): 7201.
mutates   *note 7.6(17.6/3): 3684.
MW
   <in> Ada.Characters.Latin_1   *note A.3.3(18): 5619.



File: arm2012.info,  Node: N,  Next: O,  Prev: M,  Up: Index

N 
==



n-dimensional array_aggregate   *note 4.3.3(6): 2561.
NAK
   <in> Ada.Characters.Latin_1   *note A.3.3(6): 5521.
name   *note 4.1(2/3): 2359.
   [<partial>]   *note 3.1(1): 1291.
   of (a view of) an entity   *note 3.1(8): 1318.
   of a pragma   *note 2.8(9): 1272.
   of an external file   *note A.7(1): 6281.
   <used>   *note 2.8(3/3): 1269, *note 3.2.2(4): 1409, *note 4.1(4):
2376, *note 4.1(5): 2379, *note 4.1(6): 2381, *note 4.1.5(4/3): 2456,
*note 4.4(7/3): 2713, *note 4.6(2): 2929, *note 4.8(2.1/3): 3049, *note
5.2(2): 3151, *note 5.5.2(2/3): 3237, *note 5.7(2): 3267, *note 5.8(2):
3272, *note 6.4(2): 3447, *note 6.4(3): 3451, *note 6.4(6): 3462, *note
8.4(3): 3778, *note 8.5.1(2/3): 3806, *note 8.5.2(2/3): 3814, *note
8.5.3(2/3): 3818, *note 8.5.4(2/3): 3825, *note 8.5.5(2/3): 3837, *note
9.5.3(2): 4093, *note 9.5.4(2/3): 4121, *note 9.8(2): 4279, *note
10.1.1(8): 4346, *note 10.1.2(4.1/2): 4378, *note 10.1.2(4.2/2): 4381,
*note 10.2.1(3): 4464, *note 10.2.1(14): 4481, *note 10.2.1(20): 4492,
*note 10.2.1(21): 4495, *note 10.2.1(22): 4499, *note 11.2(5): 4540,
*note 11.3(2.1/4): 4548, *note 11.3(2/2): 4545, *note 12.3(2/3): 4701,
*note 12.3(5): 4717, *note 12.6(4): 4842, *note 12.7(2/3): 4854, *note
13.1(3): 4881, *note 13.1.1(4/3): 4919, *note 13.3(2): 4951, *note
13.11.3(3.1/4): 5250, *note 13.12(4.1/2): 5299, *note E.2.1(3): 8126,
*note E.2.2(3): 8140, *note E.2.3(3): 8151, *note E.2.3(5): 8154, *note
H.3.2(3): 8443, *note J.10(3/2): 8524, *note J.15.1(2/3): 8535, *note
J.15.7(2/3): 8590, *note J.15.7(4/3): 8593, *note L(2): 8697, *note
L(6.1/3): 8722, *note L(10): 8744, *note L(11): 8748, *note L(12): 8751,
*note L(15.1/3): 8773, *note L(16): 8776, *note L(17.1/3): 8780, *note
L(26): 8814, *note L(28): 8828, *note L(30): 8836, *note L(31): 8839,
*note L(34): 8848, *note P: 9462.
   <in> Ada.Direct_IO   *note A.8.4(9): 6335.
   <in> Ada.Sequential_IO   *note A.8.1(9): 6308.
   <in> Ada.Streams.Stream_IO   *note A.12.1(11): 6581.
   <in> Ada.Text_IO   *note A.10.1(12): 6390.
   <in> System   *note 13.7(4): 5106.
name resolution rules   *note 1.1.2(26/3): 1019.
Name_Case_Equivalence
   <in> Ada.Directories   *note A.16(20.2/3): 6652.
Name_Case_Kind
   <in> Ada.Directories   *note A.16(20.1/3): 6651.
Name_Error
   <in> Ada.Direct_IO   *note A.8.4(18): 6349.
   <in> Ada.Directories   *note A.16(43/2): 6672.
   <in> Ada.IO_Exceptions   *note A.13(4): 6616.
   <in> Ada.Sequential_IO   *note A.8.1(15): 6317.
   <in> Ada.Streams.Stream_IO   *note A.12.1(26): 6597.
   <in> Ada.Text_IO   *note A.10.1(85): 6522.
named
   in a use clause   *note 8.4(7.1/2): 3784.
   in a with_clause   *note 10.1.2(6/2): 4385.
named association   *note 6.4(7): 3463, *note 6.4.1(2/3): 3471, *note
12.3(6): 4722.
named component association   *note 4.3.1(6): 2517.
named discriminant association   *note 3.7.1(4): 2008.
named entry index   *note 9.5.2(21): 4081.
named number   *note 3.3(24): 1472.
named parameter association   *note 6.4.1(2/3): 3473.
named type   *note 3.2.1(7/2): 1390.
named_array_aggregate   *note 4.3.3(4): 2554.
   <used>   *note 4.3.3(2): 2544, *note P: 9250.
Names
   <child of> Ada.Interrupts   *note C.3.2(12): 7670.
Nanoseconds
   <in> Ada.Real_Time   *note D.8(14/2): 7955.
Native_Binary
   <in> Interfaces.COBOL   *note B.4(25): 7572.
Natural   *note 3.5.4(12): 1741.
Natural <subtype of> Integer
   <in> Standard   *note A.1(13): 5439.
NBH
   <in> Ada.Characters.Latin_1   *note A.3.3(17): 5601.
NBSP
   <in> Ada.Characters.Latin_1   *note A.3.3(21/3): 5631.
needed
   of a compilation unit by another   *note 10.2(2): 4449.
   remote call interface   *note E.2.3(18): 8167.
   shared passive library unit   *note E.2.1(11): 8134.
needed component
   extension_aggregate record_component_association_list   *note
4.3.2(6): 2536.
   record_aggregate record_component_association_list   *note 4.3.1(9):
2520.
needs finalization   *note 7.6(9.1/2): 3670.
   language-defined type   *note A.4.5(72.1/2): 5953, *note
A.5.2(15.1/2): 6159, *note A.5.2(27.1/2): 6171, *note A.8.1(17/2): 6322,
*note A.8.4(20/2): 6354, *note A.10.1(86/2): 6528, *note A.12.1(27.1/2):
6602, *note A.16(102/2): 6684, *note A.18.2(147.3/3): 6807, *note
A.18.2(84/2): 6802, *note A.18.3(56/2): 6874, *note A.18.3(86.3/3):
6879, *note A.18.4(4/2): 6891, *note A.18.4(41.3/3): 6901, *note
A.18.7(4/2): 7021, *note A.18.7(36.2/3): 7030, *note A.18.7(96.2/3):
7033, *note A.18.10(124/3): 7270, *note A.18.10(73/3): 7265, *note
A.18.18(27/3): 7301, *note A.18.18(54/3): 7305, *note D.14.2(13/2):
8048, *note D.15(8/2): 8066.
NEL
   <in> Ada.Characters.Latin_1   *note A.3.3(17): 5603.
new
   <See> allocator   *note 4.8(1): 3040.
New_Char_Array
   <in> Interfaces.C.Strings   *note B.3.1(9): 7502.
New_Line
   <in> Ada.Text_IO   *note A.10.1(28): 6419.
New_Page
   <in> Ada.Text_IO   *note A.10.1(31): 6426.
New_String
   <in> Interfaces.C.Strings   *note B.3.1(10): 7503.
Next
   <in> Ada.Containers.Doubly_Linked_Lists   *note A.18.3(37/2): 6860,
*note A.18.3(39/2): 6862.
   <in> Ada.Containers.Hashed_Maps   *note A.18.5(28/2): 6942, *note
A.18.5(29/2): 6943.
   <in> Ada.Containers.Hashed_Sets   *note A.18.8(41/2): 7079, *note
A.18.8(42/2): 7080.
   <in> Ada.Containers.Ordered_Maps   *note A.18.6(34/2): 7000, *note
A.18.6(35/2): 7001.
   <in> Ada.Containers.Ordered_Sets   *note A.18.9(45/2): 7155, *note
A.18.9(46/2): 7156.
   <in> Ada.Containers.Vectors   *note A.18.2(63/2): 6786, *note
A.18.2(64/2): 6787.
   <in> Ada.Iterator_Interfaces   *note 5.5.1(3/3): 3212.
Next_Sibling
   <in> Ada.Containers.Multiway_Trees   *note A.18.10(64/3): 7257, *note
A.18.10(66/3): 7259.
No_Abort_Statements restriction   *note D.7(5/3): 7879.
No_Access_Parameter_Allocators restriction   *note H.4(8.3/3): 8457.
No_Access_Subprograms restriction   *note H.4(17): 8467.
No_Allocators restriction   *note H.4(7): 8449.
No_Anonymous_Allocators restriction   *note H.4(8.1/3): 8453.
No_Break_Space
   <in> Ada.Characters.Latin_1   *note A.3.3(21/3): 5630.
No_Coextensions restriction   *note H.4(8.2/3): 8455.
No_Delay restriction   *note H.4(21): 8477.
No_Dependence restriction   *note 13.12.1(6/2): 5323.
No_Dispatch restriction   *note H.4(19): 8473.
No_Dynamic_Attachment restriction   *note D.7(10/3): 7890.
No_Dynamic_CPU_Assigmment restriction   *note D.7(10.1/4): 7892.
No_Dynamic_Priorities restriction   *note D.7(9/2): 7888.
No_Element
   <in> Ada.Containers.Doubly_Linked_Lists   *note A.18.3(9/2): 6826.
   <in> Ada.Containers.Hashed_Maps   *note A.18.5(6/2): 6912.
   <in> Ada.Containers.Hashed_Sets   *note A.18.8(6/2): 7044.
   <in> Ada.Containers.Multiway_Trees   *note A.18.10(11/3): 7205.
   <in> Ada.Containers.Ordered_Maps   *note A.18.6(7/2): 6965.
   <in> Ada.Containers.Ordered_Sets   *note A.18.9(7/2): 7117.
   <in> Ada.Containers.Vectors   *note A.18.2(11/2): 6730.
No_Exceptions restriction   *note H.4(12): 8461.
No_Fixed_Point restriction   *note H.4(15): 8465.
No_Floating_Point restriction   *note H.4(14): 8463.
No_Implementation_Aspect_Specifications restriction   *note
13.12.1(1.1/3): 5311.
No_Implementation_Attributes restriction   *note 13.12.1(2/2): 5313.
No_Implementation_Identifiers restriction   *note 13.12.1(2.1/3): 5315.
No_Implementation_Pragmas restriction   *note 13.12.1(3/2): 5317.
No_Implementation_Units restriction   *note 13.12.1(3.1/3): 5319.
No_Implicit_Heap_Allocations restriction   *note D.7(8): 7886.
No_Index
   <in> Ada.Containers.Vectors   *note A.18.2(7/2): 6726.
No_IO restriction   *note H.4(20/2): 8475.
No_Local_Allocators restriction   *note H.4(8/1): 8451.
No_Local_Protected_Objects restriction   *note D.7(10.2/3): 7894.
No_Local_Timing_Events restriction   *note D.7(10.3/3): 7896.
No_Nested_Finalization restriction   *note D.7(4/3): 7877.
No_Obsolescent_Features restriction   *note 13.12.1(4/3): 5321.
No_Protected_Type_Allocators restriction   *note D.7(10.4/2): 7898.
No_Protected_Types restriction   *note H.4(5): 8447.
No_Recursion restriction   *note H.4(22): 8479.
No_Reentrancy restriction   *note H.4(23): 8481.
No_Relative_Delay restriction   *note D.7(10.6/3): 7901.
No_Requeue_Statements restriction   *note D.7(10.7/3): 7903.
No_Return aspect   *note 6.5.1(3.2/3): 3536.
No_Return pragma   *note J.15.2(2/3): 8539, *note L(21.2/3): 8793.
No_Select_Statements restriction   *note D.7(10.8/3): 7905.
No_Specific_Termination_Handlers restriction   *note D.7(10.9/3): 7907.
No_Specification_of_Aspect restriction   *note 13.12.1(6.1/3): 5325.
No_Standard_Allocators_After_Elaboration restriction   *note
D.7(19.2/3): 7939.
No_Tag
   <in> Ada.Tags   *note 3.9(6.1/2): 2102.
No_Task_Allocators restriction   *note D.7(7): 7883.
No_Task_Hierarchy restriction   *note D.7(3/3): 7875.
No_Task_Termination restriction   *note D.7(15.1/2): 7919.
No_Tasks_Unassigned_To_CPU restriction   *note D.7(10.10/4): 7909.
No_Terminate_Alternatives restriction   *note D.7(6): 7881.
No_Unchecked_Access restriction   *note H.4(18): 8469.
No_Use_Of_Attribute restriction   *note 13.12.1(6.2/3): 5327.
No_Use_Of_Pragma restriction   *note 13.12.1(6.3/3): 5329.
node
   of a list   *note A.18.3(2/2): 6820.
   of a map   *note A.18.4(5/2): 6892.
   of a tree   *note A.18.10(2/4): 7193.
Node_Count
   <in> Ada.Containers.Multiway_Trees   *note A.18.10(17/3): 7210.
nominal subtype   *note 3.3(23/3): 1465, *note 3.3.1(8/2): 1502.
   associated with a dereference   *note 4.1(9/3): 2384.
   associated with a type_conversion   *note 4.6(27): 2963.
   associated with an indexed_component   *note 4.1.1(5): 2399.
   of a component   *note 3.6(20): 1924.
   of a formal parameter   *note 6.1(23/2): 3336.
   of a function result   *note 6.1(23/2): 3337.
   of a generic formal object   *note 12.4(9/2): 4759.
   of a record component   *note 3.8(14): 2046.
   of the result of a function_call   *note 6.4(12/2): 3468.
Non_Preemptive
   <child of> Ada.Dispatching   *note D.2.4(2.2/3): 7806.
Non_Preemptive_FIFO_Within_Priorities task disp.  policy   *note
D.2.4(2/2): 7805.
nonconfirming
   aspect specification   *note 13.1(18.2/3): 4906.
   representation item   *note 13.1(18.2/3): 4905.
   representation value   *note 13.1(18.2/3): 4904.
nondispatching call
   on a dispatching operation   *note 3.9.2(1/2): 2148.
nonexistent   *note 13.11.2(10/4): 5231, *note 13.11.2(16/3): 5244.
nongraphic character   *note 3.5(27.5/2): 1641.
nonlimited interface   *note 3.9.4(5/2): 2211.
nonlimited type   *note 7.5(7): 3646.
   becoming nonlimited   *note 7.3.1(5/1): 3622, *note 7.5(16): 3650.
nonlimited_with_clause   *note 10.1.2(4.2/2): 4379.
   <used>   *note 10.1.2(4/2): 4375, *note P: 9673.
nonnormative
   <See> informative   *note 1.1.2(18): 1012.
nonoverridable
   aspect   *note 13.1.1(18.2/4): 4927.
nonreturning   *note 6.5.1(3.2/3): 3534.
nonstandard integer type   *note 3.5.4(26): 1764.
nonstandard mode   *note 1.1.5(11): 1082.
nonstandard real type   *note 3.5.6(8): 1793.
normal completion   *note 7.6.1(2/2): 3689.
normal library unit   *note E.2(4/3): 8121.
normal state of an object   *note 11.6(6/3): 4659, *note 13.9.1(4):
5166.
   [<partial>]   *note 9.8(21): 4293, *note A.13(17): 6623.
Normalize_Scalars pragma   *note H.1(3): 8432, *note L(22): 8797.
normalized exponent   *note A.5.3(14): 6202.
normalized number   *note A.5.3(10): 6193.
normative   *note 1.1.2(14): 1009.
not equal operator   *note 4.4(1/3): 2597, *note 4.5.2(1): 2771.
not in (membership test)   *note 4.4(1/3): 2616, *note 4.5.2(2/3): 2792.
not operator   *note 4.4(1/3): 2653, *note 4.5.6(3): 2863.
Not_A_Specific_CPU
   <in> System.Multiprocessors   *note D.16(4/3): 8072.
Not_Sign
   <in> Ada.Characters.Latin_1   *note A.3.3(21/3): 5643.
notes   *note 1.1.2(38): 1049.
notwithstanding   *note 7.6(17.5/3): 3683, *note 10.1.6(6/2): 4440,
*note 13.1.1(32/4): 4937, *note B.1(22/3): 7408, *note B.1(38/3): 7414,
*note C.3.1(19/3): 7658, *note E.2.1(8): 8131, *note E.2.1(11): 8135,
*note E.2.3(18): 8168, *note H.6(7/2): 8493, *note J.3(6): 8499.
   [<partial>]   *note J.15.5(8/3): 8582.
NUL
   <in> Ada.Characters.Latin_1   *note A.3.3(5): 5500.
   <in> Interfaces.C   *note B.3(20/1): 7452.
null access value   *note 4.2(9): 2486.
null array   *note 3.6.1(7): 1942.
null constraint   *note 3.2(7/2): 1352.
null extension   *note 3.9.1(4.1/2): 2144.
null pointer
   <See> null access value   *note 4.2(9): 2487.
null procedure   *note 6.7(3/3): 3548.
null range   *note 3.5(4): 1595.
null record   *note 3.8(15): 2047.
null slice   *note 4.1.2(7): 2415.
null string literal   *note 2.6(6): 1255.
null value
   of an access type   *note 3.10(13/2): 2267.
Null_Address
   <in> System   *note 13.7(12): 5118.
Null_Bounded_String
   <in> Ada.Strings.Bounded   *note A.4.4(7): 5847.
null_exclusion   *note 3.10(5.1/2): 2239.
   <used>   *note 3.2.2(3/2): 1405, *note 3.7(5/2): 1976, *note
3.10(2/2): 2230, *note 3.10(6/2): 2241, *note 6.1(13/2): 3312, *note
6.1(15/3): 3322, *note 8.5.1(2/3): 3800, *note 12.4(2/3): 4744, *note P:
9431.
Null_Id
   <in> Ada.Exceptions   *note 11.4.1(2/2): 4566.
Null_Occurrence
   <in> Ada.Exceptions   *note 11.4.1(3/2): 4572.
null_procedure_declaration   *note 6.7(2/3): 3543.
   <used>   *note 3.1(3/3): 1299, *note 9.4(8/4): 3985, *note P: 9015.
Null_Ptr
   <in> Interfaces.C.Strings   *note B.3.1(7): 7500.
Null_Set
   <in> Ada.Strings.Maps   *note A.4.2(5): 5785.
   <in> Ada.Strings.Wide_Maps   *note A.4.7(5): 5987.
   <in> Ada.Strings.Wide_Wide_Maps   *note A.4.8(5/2): 6026.
null_statement   *note 5.1(6): 3142.
   <used>   *note 5.1(4/2): 3122, *note P: 9357.
Null_Task_Id
   <in> Ada.Task_Identification   *note C.7.1(2/2): 7710.
Null_Unbounded_String
   <in> Ada.Strings.Unbounded   *note A.4.5(5): 5904.
number sign   *note 2.1(15/3): 1152.
Number_Base <subtype of> Integer
   <in> Ada.Text_IO   *note A.10.1(6): 6381.
number_decimal   *note 2.1(10/2): 1138.
   <used>   *note 2.3(3.1/3): 1201, *note P: 8973.
number_declaration   *note 3.3.2(2): 1523.
   <used>   *note 3.1(3/3): 1296, *note P: 9012.
number_letter   *note 2.1(10.1/2): 1139.
   <used>   *note 2.3(3/2): 1197, *note P: 8970.
Number_Of_CPUs
   <in> System.Multiprocessors   *note D.16(5/3): 8074.
Number_Sign
   <in> Ada.Characters.Latin_1   *note A.3.3(8): 5535.
numeral   *note 2.4.1(3): 1215.
   <used>   *note 2.4.1(2): 1212, *note 2.4.1(4): 1221, *note 2.4.2(3):
1239, *note P: 8989.
Numeric
   <in> Interfaces.COBOL   *note B.4(20/3): 7562.
numeric type   *note 3.5(1): 1584.
numeric_literal   *note 2.4(2): 1207.
   <used>   *note 4.4(7/3): 2710, *note P: 9309.
numerics   *note G(1): 8257.
   <child of> Ada   *note A.5(3/2): 6106.



File: arm2012.info,  Node: O,  Next: P,  Prev: N,  Up: Index

O 
==



O(f(N))   *note A.18(3/2): 6712.
object   *note 3.3(2): 1455, *note N(24): 8924.
   [<partial>]   *note 3.2(1): 1330.
object-oriented programming (OOP)
   <See> dispatching operations of tagged types   *note 3.9.2(1/2):
2154.
   <See> tagged types and type extensions   *note 3.9(1): 2084.
object_declaration   *note 3.3.1(2/3): 1479.
   <used>   *note 3.1(3/3): 1295, *note P: 9011.
object_renaming_declaration   *note 8.5.1(2/3): 3798.
   <used>   *note 8.5(2): 3790, *note P: 9509.
obsolescent feature   *note J(1/2): 8494.
occur immediately within   *note 8.1(13): 3714.
occurrence
   of an interrupt   *note C.3(2): 7631.
octal
   literal   *note 2.4.2(1): 1229.
octal literal   *note 2.4.2(1): 1227.
Old attribute   *note 6.1.1(26/4): 3371.
one's complement
   modular types   *note 3.5.4(27): 1765.
one-dimensional array   *note 3.6(12): 1911.
only as a completion
   entry_body   *note 9.5.2(16): 4072.
OOP (object-oriented programming)
   <See> dispatching operations of tagged types   *note 3.9.2(1/2):
2155.
   <See> tagged types and type extensions   *note 3.9(1): 2085.
opaque type
   <See> private types and private extensions   *note 7.3(1): 3597.
Open
   <in> Ada.Direct_IO   *note A.8.4(7): 6329.
   <in> Ada.Sequential_IO   *note A.8.1(7): 6302.
   <in> Ada.Streams.Stream_IO   *note A.12.1(9): 6575.
   <in> Ada.Text_IO   *note A.10.1(10): 6384.
open alternative   *note 9.7.1(14): 4235.
open entry   *note 9.5.3(5): 4095.
   of a protected object   *note 9.5.3(7/3): 4101.
   of a task   *note 9.5.3(6/3): 4099.
operand
   of a qualified_expression   *note 4.7(3): 3030.
   of a type_conversion   *note 4.6(3): 2931.
operand interval   *note G.2.1(6): 8335.
operand type
   of a type_conversion   *note 4.6(3): 2932.
operates on a type   *note 3.2.3(1/2): 1427.
operational aspect   *note 13.1(8.1/3): 4893.
   specifiable attributes   *note 13.3(5/3): 4957.
operational item   *note 13.1(1.1/1): 4871.
operator   *note 6.6(1): 3539.
   &   *note 4.4(1/3): 2626, *note 4.5.3(3): 2816.
   *   *note 4.4(1/3): 2633, *note 4.5.5(1): 2841.
   **   *note 4.4(1/3): 2647, *note 4.5.6(7): 2872.
   +   *note 4.4(1/3): 2618, *note 4.5.3(1): 2808, *note 4.5.4(1): 2831.
   -   *note 4.4(1/3): 2622, *note 4.5.3(1): 2812, *note 4.5.4(1): 2835.
   /   *note 4.4(1/3): 2639, *note 4.5.5(1): 2847.
   /=   *note 4.4(1/3): 2596, *note 4.5.2(1): 2770.
   <   *note 4.4(1/3): 2600, *note 4.5.2(1): 2774.
   <=   *note 4.4(1/3): 2604, *note 4.5.2(1): 2778.
   =   *note 4.4(1/3): 2592, *note 4.5.2(1): 2766.
   >   *note 4.4(1/3): 2608, *note 4.5.2(1): 2782.
   >=   *note 4.4(1/3): 2612, *note 4.5.2(1): 2786.
   abs   *note 4.4(1/3): 2651, *note 4.5.6(1): 2861.
   ampersand   *note 4.4(1/3): 2628, *note 4.5.3(3): 2818.
   and   *note 4.4(1/3): 2584, *note 4.5.1(2): 2746.
   binary   *note 4.5(9): 2733.
   binary adding   *note 4.5.3(1): 2806.
   concatenation   *note 4.4(1/3): 2630, *note 4.5.3(3): 2820.
   divide   *note 4.4(1/3): 2641, *note 4.5.5(1): 2849.
   equal   *note 4.4(1/3): 2594, *note 4.5.2(1): 2768.
   equality   *note 4.5.2(1): 2762.
   exponentiation   *note 4.4(1/3): 2649, *note 4.5.6(7): 2870.
   greater than   *note 4.4(1/3): 2610, *note 4.5.2(1): 2784.
   greater than or equal   *note 4.4(1/3): 2614, *note 4.5.2(1): 2788.
   highest precedence   *note 4.5.6(1): 2859.
   less than   *note 4.4(1/3): 2602, *note 4.5.2(1): 2776.
   less than or equal   *note 4.4(1/3): 2606, *note 4.5.2(1): 2780.
   logical   *note 4.5.1(2): 2744.
   minus   *note 4.4(1/3): 2624, *note 4.5.3(1): 2814, *note 4.5.4(1):
2837.
   mod   *note 4.4(1/3): 2643, *note 4.5.5(1): 2851.
   multiply   *note 4.4(1/3): 2635, *note 4.5.5(1): 2843.
   multiplying   *note 4.5.5(1): 2839.
   not   *note 4.4(1/3): 2654, *note 4.5.6(3): 2864.
   not equal   *note 4.4(1/3): 2598, *note 4.5.2(1): 2772.
   or   *note 4.4(1/3): 2586, *note 4.5.1(2): 2748.
   ordering   *note 4.5.2(1): 2764.
   plus   *note 4.4(1/3): 2620, *note 4.5.3(1): 2810, *note 4.5.4(1):
2833.
   predefined   *note 4.5(9): 2731.
   relational   *note 4.5.2(1): 2759.
   rem   *note 4.4(1/3): 2645, *note 4.5.5(1): 2853.
   times   *note 4.4(1/3): 2637, *note 4.5.5(1): 2845.
   unary   *note 4.5(9): 2735.
   unary adding   *note 4.5.4(1): 2829.
   user-defined   *note 6.6(1): 3541.
   xor   *note 4.4(1/3): 2588, *note 4.5.1(2): 2750.
operator precedence   *note 4.5(1): 2723.
operator_symbol   *note 6.1(9): 3304.
   <used>   *note 4.1(3): 2374, *note 4.1.3(3): 2424, *note 6.1(5):
3297, *note 6.1(11): 3307, *note P: 9209.
optimization   *note 11.5(29): 4646, *note 11.6(1/3): 4652.
Optimize pragma   *note 2.8(23): 1287, *note L(23): 8799.
or else (short-circuit control form)   *note 4.4(1/3): 2590, *note
4.5.1(1): 2741.
or operator   *note 4.4(1/3): 2585, *note 4.5.1(2): 2747.
Ordered_Maps
   <child of> Ada.Containers   *note A.18.6(2/3): 6960.
Ordered_Sets
   <child of> Ada.Containers   *note A.18.9(2/3): 7112.
ordering operator   *note 4.5.2(1): 2763.
ordinary file   *note A.16(45/2): 6677.
ordinary fixed point type   *note 3.5.9(1): 1826, *note 3.5.9(8/2):
1848.
ordinary_fixed_point_definition   *note 3.5.9(3): 1832.
   <used>   *note 3.5.9(2): 1830, *note P: 9096.
OSC
   <in> Ada.Characters.Latin_1   *note A.3.3(19): 5627.
other_control   *note 2.1(13.1/2): 1147.
other_format   *note 2.1(10.3/2): 1141.
other_private_use   *note 2.1(13.2/2): 1148.
other_surrogate   *note 2.1(13.3/2): 1149.
output   *note A.6(1/2): 6279.
Output aspect   *note 13.13.2(38/4): 5385.
Output attribute   *note 13.13.2(19): 5358, *note 13.13.2(29): 5362.
Output clause   *note 13.3(7/2): 4972, *note 13.13.2(38/4): 5377.
Output'Class aspect   *note 13.13.2(38/4): 5393.
overall interpretation
   of a complete context   *note 8.6(10): 3850.
Overflow_Check   *note 11.5(16): 4634.
   [<partial>]   *note 3.5.4(20): 1754, *note 4.4(11): 2719, *note
4.5.7(21/3): 2902, *note 5.4(13): 3187, *note G.2.1(11): 8337, *note
G.2.2(7): 8351, *note G.2.3(25): 8355, *note G.2.4(2): 8360, *note
G.2.6(3): 8367.
Overlap
   <in> Ada.Containers.Hashed_Sets   *note A.18.8(38/2): 7076.
   <in> Ada.Containers.Ordered_Sets   *note A.18.9(39/2): 7149.
Overlaps_Storage attribute   *note 13.3(73.6/3): 5031.
overload resolution   *note 8.6(1/3): 3845.
overloadable   *note 8.3(7): 3747.
overloaded   *note 8.3(6): 3746.
   enumeration literal   *note 3.5.1(9): 1697.
overloading rules   *note 1.1.2(26/3): 1020, *note 8.6(2): 3846.
overridable   *note 8.3(9/1): 3751.
override   *note 8.3(9/1): 3750, *note 12.3(17): 4735.
   a primitive subprogram   *note 3.2.3(7/2): 1431.
   when implemented by   *note 9.1(9.2/3): 3919, *note 9.4(11.1/3):
3991.
overriding operation   *note N(24.1/2): 8925.
overriding_indicator   *note 8.3.1(2/2): 3772.
   <used>   *note 3.9.3(1.1/3): 2186, *note 6.1(2/3): 3282, *note
6.3(2/3): 3403, *note 6.7(2/3): 3544, *note 6.8(2/4): 3552, *note
8.5.4(2/3): 3823, *note 9.5.2(2/3): 4039, *note 10.1.3(3/3): 4393, *note
12.3(2/3): 4699, *note P: 9529.
Overwrite
   <in> Ada.Strings.Bounded   *note A.4.4(62): 5887, *note A.4.4(63):
5888.
   <in> Ada.Strings.Fixed   *note A.4.3(27): 5830, *note A.4.3(28):
5831.
   <in> Ada.Strings.Unbounded   *note A.4.5(57): 5941, *note A.4.5(58):
5942.



File: arm2012.info,  Node: P,  Next: Q,  Prev: O,  Up: Index

P 
==



Pack aspect   *note 13.2(5.1/3): 4940.
Pack pragma   *note J.15.3(2/3): 8545, *note L(24.1/3): 8802.
Package   *note 7(1): 3566, *note N(25): 8926.
package instance   *note 12.3(13): 4727.
package_body   *note 7.2(2/3): 3586.
   <used>   *note 3.11(6): 2341, *note 10.1.1(7): 4344, *note P: 9193.
package_body_stub   *note 10.1.3(4/3): 4396.
   <used>   *note 10.1.3(2): 4389, *note P: 9679.
package_declaration   *note 7.1(2): 3571.
   <used>   *note 3.1(3/3): 1301, *note 10.1.1(5): 4335, *note P: 9660.
package_renaming_declaration   *note 8.5.3(2/3): 3816.
   <used>   *note 8.5(2): 3792, *note 10.1.1(6): 4339, *note P: 9663.
package_specification   *note 7.1(3/3): 3573.
   <used>   *note 7.1(2): 3572, *note 12.1(4): 4676, *note P: 9482.
packed   *note 13.2(5.1/3): 4938.
Packed_Decimal
   <in> Interfaces.COBOL   *note B.4(12/3): 7553.
Packed_Format
   <in> Interfaces.COBOL   *note B.4(26): 7573.
Packed_Signed
   <in> Interfaces.COBOL   *note B.4(27): 7575.
Packed_Unsigned
   <in> Interfaces.COBOL   *note B.4(27): 7574.
padding bits   *note 13.1(7/2): 4885.
Page
   <in> Ada.Text_IO   *note A.10.1(39): 6442.
Page pragma   *note 2.8(22): 1285, *note L(25): 8805.
page terminator   *note A.10(7): 6365.
Page_Length
   <in> Ada.Text_IO   *note A.10.1(26): 6417.
Paragraph_Sign
   <in> Ada.Characters.Latin_1   *note A.3.3(22): 5655.
parallel processing
   <See> task   *note 9(1/3): 3877.
parameter
   explicitly aliased   *note 6.1(23.1/3): 3339.
   <See> formal parameter   *note 6.1(17): 3331.
   <See> generic formal parameter   *note 12(1): 4666.
   <See also> discriminant   *note 3.7(1/2): 1966.
   <See also> loop parameter   *note 5.5(6): 3203.
parameter assigning back   *note 6.4.1(17): 3490.
parameter copy back   *note 6.4.1(17): 3488.
parameter mode   *note 6.1(18/3): 3332.
parameter passing   *note 6.4.1(1): 3470.
parameter_and_result_profile   *note 6.1(13/2): 3310.
   <used>   *note 3.10(5): 2238, *note 3.10(6/2): 2246, *note
6.1(4.2/2): 3293, *note P: 9181.
parameter_association   *note 6.4(5): 3457.
   <used>   *note 6.4(4): 3456, *note P: 9458.
parameter_profile   *note 6.1(12): 3308.
   <used>   *note 3.10(5): 2237, *note 3.10(6/2): 2244, *note
6.1(4.1/2): 3290, *note 9.5.2(2/3): 4042, *note 9.5.2(3): 4047, *note
9.5.2(6): 4061, *note P: 9417.
parameter_specification   *note 6.1(15/3): 3319.
   <used>   *note 6.1(14): 3318, *note P: 9435.
Parameterless_Handler
   <in> Ada.Interrupts   *note C.3.2(2/3): 7661.
Params_Stream_Type
   <in> System.RPC   *note E.5(6): 8207.
parent   *note N(25.1/2): 8927.
   <in> Ada.Containers.Multiway_Trees   *note A.18.10(59/3): 7252.
parent body
   of a subunit   *note 10.1.3(8/2): 4408.
parent declaration
   of a library unit   *note 10.1.1(10): 4354.
   of a library_item   *note 10.1.1(10): 4353.
parent subtype   *note 3.4(3/2): 1537.
parent type   *note 3.4(3/2): 1538.
parent unit
   of a library unit   *note 10.1.1(10): 4356.
Parent_Tag
   <in> Ada.Tags   *note 3.9(7.2/2): 2110.
parent_unit_name   *note 10.1.1(8): 4345.
   <used>   *note 6.1(5): 3295, *note 6.1(7): 3302, *note 7.1(3/3):
3578, *note 7.2(2/3): 3591, *note 10.1.3(7): 4406, *note P: 9487.
part
   of a type   *note 3.2(6/2): 1349.
   of an object or value   *note 3.2(6/2): 1348.
partial view
   of a type   *note 7.3(4): 3610.
partition   *note 10.2(2): 4444, *note N(26): 8928.
partition building   *note 10.2(2): 4445.
partition communication subsystem (PCS)   *note E.5(1/2): 8202.
Partition_Check
   [<partial>]   *note E.4(19): 8195.
Partition_Elaboration_Policy pragma   *note H.6(3/2): 8489, *note
L(25.1/2): 8807.
Partition_Id
   <in> System.RPC   *note E.5(4): 8205.
Partition_Id attribute   *note E.1(9): 8109.
pass by copy   *note 6.2(2): 3387.
pass by reference   *note 6.2(2): 3390.
passive partition   *note E.1(2): 8101.
Pattern_Error
   <in> Ada.Strings   *note A.4.1(5): 5775.
PCS (partition communication subsystem)   *note E.5(1/2): 8203.
Peak_Use
   <in> Ada.Containers.Bounded_Priority_Queues   *note A.18.31(7/3):
7368.
   <in> Ada.Containers.Bounded_Synchronized_Queues   *note A.18.29(6/3):
7354.
   <in> Ada.Containers.Synchronized_Queue_Interfaces   *note
A.18.27(7/3): 7341.
   <in> Ada.Containers.Unbounded_Priority_Queues   *note A.18.30(7/3):
7361.
   <in> Ada.Containers.Unbounded_Synchronized_Queues   *note
A.18.28(6/3): 7348.
pending interrupt occurrence   *note C.3(2): 7634.
per-object constraint   *note 3.8(18/2): 2053.
per-object expression   *note 3.8(18/2): 2052.
percent sign   *note 2.1(15/3): 1178.
Percent_Sign
   <in> Ada.Characters.Latin_1   *note A.3.3(8): 5537.
perfect result set   *note G.2.3(5): 8353.
perform indefinite insertion   *note A.18(6/4): 6714.
periodic task
   example   *note 9.6(39): 4167.
   <See> delay_until_statement   *note 9.6(39): 4168.
Pi
   <in> Ada.Numerics   *note A.5(3/2): 6108.
Pic_String
   <in> Ada.Text_IO.Editing   *note F.3.3(7): 8238.
Picture
   <in> Ada.Text_IO.Editing   *note F.3.3(4): 8235.
picture String
   for edited output   *note F.3.1(1/3): 8231.
Picture_Error
   <in> Ada.Text_IO.Editing   *note F.3.3(9): 8241.
Pilcrow_Sign
   <in> Ada.Characters.Latin_1   *note A.3.3(22): 5654.
plain_char
   <in> Interfaces.C   *note B.3(11): 7445.
plane
   character   *note 2.1(1/3): 1128.
PLD
   <in> Ada.Characters.Latin_1   *note A.3.3(17): 5609.
PLU
   <in> Ada.Characters.Latin_1   *note A.3.3(17): 5610.
plus operator   *note 4.4(1/3): 2619, *note 4.5.3(1): 2809, *note
4.5.4(1): 2832.
plus sign   *note 2.1(15/3): 1160.
Plus_Minus_Sign
   <in> Ada.Characters.Latin_1   *note A.3.3(22): 5649.
Plus_Sign
   <in> Ada.Characters.Latin_1   *note A.3.3(8): 5543.
PM
   <in> Ada.Characters.Latin_1   *note A.3.3(19): 5628.
point   *note 2.1(15/3): 1166.
Pointer
   <in> Interfaces.C.Pointers   *note B.3.2(5): 7519.
   <See> access value   *note 3.10(1): 2225.
   <See> type System.Address   *note 13.7(34/2): 5131.
pointer type
   <See> access type   *note 3.10(1): 2226.
Pointer_Error
   <in> Interfaces.C.Pointers   *note B.3.2(8): 7522.
Pointers
   <child of> Interfaces.C   *note B.3.2(4): 7518.
polymorphism   *note 3.9(1): 2080, *note 3.9.2(1/2): 2151.
pool
   default   *note 13.11.3(4.2/4): 5253.
   subpool   *note 13.11.4(18/3): 5270.
pool element   *note 3.10(7/1): 2252, *note 13.11(11): 5195.
pool type   *note 13.11(11): 5193.
pool-specific access type   *note 3.10(7/1): 2249, *note 3.10(8): 2253.
Pool_of_Subpool
   <in> System.Storage_Pools.Subpools   *note 13.11.4(9/3): 5261.
Pos attribute   *note 3.5.5(2): 1771.
position   *note 13.5.1(4): 5068.
   <used>   *note 13.5.1(3): 5065, *note P: 9828.
Position attribute   *note 13.5.2(2/2): 5081.
position number   *note 3.5(1): 1583.
   of an enumeration value   *note 3.5.1(7): 1696.
   of an integer value   *note 3.5.4(15): 1748.
positional association   *note 6.4(7): 3464, *note 6.4.1(2/3): 3472,
*note 12.3(6): 4723.
positional component association   *note 4.3.1(6): 2518.
positional discriminant association   *note 3.7.1(4): 2009.
positional parameter association   *note 6.4.1(2/3): 3474.
positional_array_aggregate   *note 4.3.3(3/2): 2545.
   <used>   *note 4.3.3(2): 2543, *note P: 9249.
Positive   *note 3.5.4(12): 1742.
Positive <subtype of> Integer
   <in> Standard   *note A.1(13): 5440.
Positive_Count <subtype of> Count
   <in> Ada.Direct_IO   *note A.8.4(4): 6327.
   <in> Ada.Streams.Stream_IO   *note A.12.1(7): 6573.
   <in> Ada.Text_IO   *note A.10.1(5): 6378.
possible interpretation   *note 8.6(14): 3851.
   for direct_names   *note 8.3(24): 3768.
   for selector_names   *note 8.3(24): 3769.
Post aspect   *note 6.1.1(4/3): 3356.
Post'Class aspect   *note 6.1.1(5/3): 3360.
post-compilation error   *note 1.1.2(29): 1029.
post-compilation rules   *note 1.1.2(29): 1030.
postcondition   *note N(26.1/3): 8929.
postcondition check   *note 6.1.1(35/3): 3382.
postcondition expression
   class-wide   *note 6.1.1(5/3): 3358.
   specific   *note 6.1.1(4/3): 3354.
potentially blocking operation   *note 9.5.1(8): 4035.
   Abort_Task   *note C.7.1(16): 7723.
   delay_statement   *note 9.6(34): 4165, *note D.9(5): 7969.
   remote subprogram call   *note E.4(17): 8190.
   RPC operations   *note E.5(23): 8216.
   Suspend_Until_True   *note D.10(10): 7981.
potentially unevaluated expression   *note 6.1.1(20/3): 3369.
potentially use-visible   *note 8.4(8/3): 3785.
   [<partial>]   *note 12.6(9.2/3): 4849.
Pound_Sign
   <in> Ada.Characters.Latin_1   *note A.3.3(21/3): 5634.
Pragma   *note 2.8(1): 1258, *note 2.8(2): 1259, *note L(1): 8694, *note
N(27): 8930.
pragma argument   *note 2.8(9): 1274.
pragma name   *note 2.8(9): 1273.
pragma, categorization   *note E.2(2/3): 8113.
   Remote_Call_Interface   *note E.2.3(2): 8148.
   Remote_Types   *note E.2.2(2): 8137.
   Shared_Passive   *note E.2.1(2): 8123.
pragma, configuration   *note 10.1.5(8): 4427.
   Assertion_Policy   *note 11.4.2(7/3): 4603.
   Detect_Blocking   *note H.5(4/2): 8487.
   Discard_Names   *note C.5(4): 7685.
   Locking_Policy   *note D.3(5): 7837.
   Normalize_Scalars   *note H.1(4): 8434.
   Partition_Elaboration_Policy   *note H.6(5/2): 8492.
   Priority_Specific_Dispatching   *note D.2.2(5/2): 7795.
   Profile   *note 13.12(14/3): 5309.
   Queuing_Policy   *note D.4(5): 7858.
   Restrictions   *note 13.12(8/3): 5303.
   Reviewable   *note H.3.1(4): 8439.
   Suppress   *note 11.5(5/2): 4624.
   Task_Dispatching_Policy   *note D.2.2(5/2): 7793.
   Unsuppress   *note 11.5(5/2): 4626.
pragma, identifier specific to   *note 2.8(10/3): 1277.
pragma, interfacing
   Convention   *note J.15.5(1/3): 8557.
   Export   *note J.15.5(1/3): 8555.
   Import   *note J.15.5(1/3): 8553.
pragma, library unit   *note 10.1.5(7/3): 4423.
   All_Calls_Remote   *note E.2.3(6): 8156.
   categorization pragmas   *note E.2(2/3): 8115.
   Elaborate_Body   *note 10.2.1(24): 4501.
   Preelaborate   *note 10.2.1(4): 4466.
   Pure   *note 10.2.1(15): 4483.
pragma, program unit   *note 10.1.5(2): 4420.
   Inline   *note J.15.1(1/3): 8531.
   library unit pragmas   *note 10.1.5(7/3): 4425.
pragma, representation   *note 13.1(1/1): 4870.
   Asynchronous   *note J.15.13(1/3): 8644.
   Atomic   *note J.15.8(9/3): 8616.
   Atomic_Components   *note J.15.8(9/3): 8620.
   Convention   *note J.15.5(1/3): 8563.
   Discard_Names   *note C.5(6): 7687.
   Export   *note J.15.5(1/3): 8561.
   Import   *note J.15.5(1/3): 8559.
   Independent   *note J.15.8(9/3): 8624.
   Independent_Components   *note J.15.8(9/3): 8626.
   No_Return   *note J.15.2(1/3): 8537.
   Pack   *note J.15.3(1/3): 8543.
   Unchecked_Union   *note J.15.6(1/3): 8584.
   Volatile   *note J.15.8(9/3): 8618.
   Volatile_Components   *note J.15.8(9/3): 8622.
pragma_argument_association   *note 2.8(3/3): 1263.
   <used>   *note 2.8(2): 1261, *note 13.12(11/3): 5307, *note
L(27.3/3): 8825, *note P: 8999.
pragmas
   All_Calls_Remote   *note E.2.3(5): 8152, *note L(2): 8695.
   Assert   *note 11.4.2(3/2): 4589, *note L(2.1/2): 8698.
   Assertion_Policy   *note 11.4.2(6.1/3): 4596, *note 11.4.2(6/2):
4593, *note L(2.2/2): 8702, *note L(2.3/3): 8705.
   Asynchronous   *note J.15.13(2/3): 8645, *note L(3.1/3): 8711.
   Atomic   *note J.15.8(2/3): 8597, *note L(4.1/3): 8714.
   Atomic_Components   *note J.15.8(5/3): 8606, *note L(5.1/3): 8717.
   Attach_Handler   *note J.15.7(4/3): 8591, *note L(6.1/3): 8720.
   Convention   *note J.15.5(4/3): 8576, *note L(8.1/3): 8724.
   CPU   *note J.15.9(2/3): 8627, *note L(8.2/3): 8728.
   Default_Storage_Pool   *note 13.11.3(3/3): 5246, *note L(8.3/3):
8731.
   Detect_Blocking   *note H.5(3/2): 8484, *note L(8.4/2): 8734.
   Discard_Names   *note C.5(3): 7681, *note L(9): 8736.
   Dispatching_Domain   *note J.15.10(2/3): 8631, *note L(9.1/3): 8739.
   Elaborate   *note 10.2.1(20): 4489, *note L(10): 8741.
   Elaborate_All   *note 10.2.1(21): 4493, *note L(11): 8745.
   Elaborate_Body   *note 10.2.1(22): 4497, *note L(12): 8749.
   Export   *note J.15.5(3/3): 8570, *note L(13.1/3): 8752.
   Import   *note J.15.5(2/3): 8564, *note L(14.1/3): 8758.
   Independent   *note J.15.8(4/3): 8603, *note L(14.2/3): 8764.
   Independent_Components   *note J.15.8(7/3): 8612, *note L(14.3/3):
8767.
   Inline   *note J.15.1(2/3): 8532, *note L(15.1/3): 8770.
   Inspection_Point   *note H.3.2(3): 8440, *note L(16): 8774.
   Interrupt_Handler   *note J.15.7(2/3): 8588, *note L(17.1/3): 8778.
   Interrupt_Priority   *note J.15.11(4/3): 8636, *note L(18.1/3): 8781.
   Linker_Options   *note B.1(8): 7399, *note L(19): 8783.
   List   *note 2.8(21): 1281, *note L(20): 8786.
   Locking_Policy   *note D.3(3): 7831, *note L(21): 8789.
   No_Return   *note J.15.2(2/3): 8538, *note L(21.2/3): 8792.
   Normalize_Scalars   *note H.1(3): 8431, *note L(22): 8796.
   Optimize   *note 2.8(23): 1286, *note L(23): 8798.
   Pack   *note J.15.3(2/3): 8544, *note L(24.1/3): 8801.
   Page   *note 2.8(22): 1284, *note L(25): 8804.
   Partition_Elaboration_Policy   *note H.6(3/2): 8488, *note L(25.1/2):
8806.
   Preelaborable_Initialization   *note 10.2.1(4.2/2): 4467, *note
L(25.2/2): 8809.
   Preelaborate   *note 10.2.1(3): 4462, *note L(26): 8812.
   Priority   *note J.15.11(2/3): 8634, *note L(27.1/3): 8815.
   Priority_Specific_Dispatching   *note D.2.2(3.2/2): 7787, *note
L(27.2/2): 8817.
   Profile   *note 13.12(11/3): 5304, *note L(27.3/3): 8822.
   Pure   *note 10.2.1(14): 4479, *note L(28): 8826.
   Queuing_Policy   *note D.4(3): 7852, *note L(29): 8829.
   Relative_Deadline   *note J.15.12(2/3): 8640, *note L(29.2/3): 8832.
   Remote_Call_Interface   *note E.2.3(3): 8149, *note L(30): 8834.
   Remote_Types   *note E.2.2(3): 8138, *note L(31): 8837.
   Restrictions   *note 13.12(3): 5290, *note L(32): 8840.
   Reviewable   *note H.3.1(3): 8436, *note L(33): 8844.
   Shared_Passive   *note E.2.1(3): 8124, *note L(34): 8846.
   Storage_Size   *note J.15.4(2/3): 8547, *note L(35.1/3): 8849.
   Suppress   *note 11.5(4/2): 4617, *note J.10(3/2): 8521, *note L(36):
8852.
   Task_Dispatching_Policy   *note D.2.2(3): 7784, *note L(37): 8855.
   Unchecked_Union   *note J.15.6(2/3): 8585, *note L(37.2/3): 8858.
   Unsuppress   *note 11.5(4.1/2): 4620, *note L(37.3/2): 8861.
   Volatile   *note J.15.8(3/3): 8600, *note L(38.1/3): 8864.
   Volatile_Components   *note J.15.8(6/3): 8609, *note L(39.1/3): 8867.
Pre aspect   *note 6.1.1(2/3): 3348.
Pre'Class aspect   *note 6.1.1(3/3): 3352.
precedence of operators   *note 4.5(1): 2722.
precondition   *note N(27.1/3): 8931.
precondition check
   class-wide   *note 6.1.1(33/3): 3379.
   specific   *note 6.1.1(32/3): 3376.
precondition expression
   class-wide   *note 6.1.1(3/3): 3350.
   specific   *note 6.1.1(2/3): 3346.
Pred attribute   *note 3.5(25): 1632.
predecessor element
   of an ordered set   *note A.18.9(81/3): 7188.
predecessor node
   of an ordered map   *note A.18.6(58/3): 7017.
predefined environment   *note A(1): 5432.
predefined exception   *note 11.1(4): 4518.
predefined library unit
   <See> language-defined library units
predefined operation
   of a type   *note 3.2.3(1/2): 1428.
predefined operations
   of a discrete type   *note 3.5.5(10/3): 1783.
   of a fixed point type   *note 3.5.10(17): 1884.
   of a floating point type   *note 3.5.8(3): 1824.
   of a record type   *note 3.8(24): 2057.
   of an access type   *note 3.10.2(35/2): 2323.
   of an array type   *note 3.6.2(15): 1962.
predefined operator   *note 4.5(9): 2730.
   [<partial>]   *note 3.2.1(9): 1396.
predefined type   *note 3.2.1(10): 1397.
   <See> language-defined types
predicate   *note 4.5.8(3/3): 2914, *note N(27.2/3): 8932.
   <used>   *note 4.5.8(1/3): 2909, *note P: 9332.
predicate aspect   *note 3.2.4(1/3): 1433.
predicate check
   allocator   *note 3.2.4(31/4): 1451.
   enabled   *note 3.2.4(7/3): 1443.
   in out parameters   *note 3.2.4(31/4): 1449.
   object_declaration   *note 3.2.4(31/4): 1450.
   subtype conversion   *note 4.6(51/4): 3006.
predicate specification   *note 3.2.4(1/3): 1434.
predicate-static   *note 3.2.4(15/3): 1444.
predicates satisfied   *note 3.2.4(29.2/4): 1448.
predicates satisfied required
   membership   *note 4.5.2(29/4): 2804.
   Valid attribute   *note 13.9.2(3/4): 5179, *note K.2(263/4): 8691.
preelaborable
   of an elaborable construct   *note 10.2.1(5): 4470.
preelaborable initialization   *note 10.2.1(11.1/2): 4477.
Preelaborable_Initialization pragma   *note 10.2.1(4.2/2): 4468, *note
L(25.2/2): 8810.
Preelaborate aspect   *note 10.2.1(11/3): 4474.
Preelaborate pragma   *note 10.2.1(3): 4463, *note L(26): 8813.
preelaborated   *note 10.2.1(11/3): 4476.
   [<partial>]   *note 10.2.1(11/3): 4472, *note E.2.1(9): 8132.
   implementation requirements   *note C.4(2): 7675.
preempt
   a running task   *note D.2.3(9/2): 7802.
preference
   for root numeric operators and ranges   *note 8.6(29): 3870.
   for universal access equality operators   *note 8.6(29.1/3): 3871.
preference control
   <See> requeue   *note 9.5.4(1): 4118.
prefix   *note 4.1(4): 2375.
   of a prefixed view   *note 4.1.3(9.2/3): 2427.
   <used>   *note 4.1.1(2): 2395, *note 4.1.2(2): 2408, *note 4.1.3(2):
2419, *note 4.1.4(2): 2435, *note 4.1.4(4): 2441, *note 4.1.6(10/3):
2469, *note 6.4(2): 3448, *note 6.4(3): 3452, *note P: 9228.
prefixed view   *note 4.1.3(9.2/3): 2426.
prefixed view profile   *note 6.3.1(24.1/2): 3442.
Prepend
   <in> Ada.Containers.Doubly_Linked_Lists   *note A.18.3(22/2): 6845.
   <in> Ada.Containers.Vectors   *note A.18.2(44/2): 6767, *note
A.18.2(45/2): 6768.
Prepend_Child
   <in> Ada.Containers.Multiway_Trees   *note A.18.10(51/3): 7244.
prescribed result
   for the evaluation of a complex arithmetic operation   *note
G.1.1(42): 8284.
   for the evaluation of a complex elementary function   *note
G.1.2(35): 8311.
   for the evaluation of an elementary function   *note A.5.1(37): 6145.
Previous
   <in> Ada.Containers.Doubly_Linked_Lists   *note A.18.3(38/2): 6861,
*note A.18.3(40/2): 6863.
   <in> Ada.Containers.Ordered_Maps   *note A.18.6(36/2): 7002, *note
A.18.6(37/2): 7003.
   <in> Ada.Containers.Ordered_Sets   *note A.18.9(47/2): 7157, *note
A.18.9(48/2): 7158.
   <in> Ada.Containers.Vectors   *note A.18.2(65/2): 6788, *note
A.18.2(66/2): 6789.
   <in> Ada.Iterator_Interfaces   *note 5.5.1(4/3): 3215.
Previous_Sibling
   <in> Ada.Containers.Multiway_Trees   *note A.18.10(65/3): 7258, *note
A.18.10(67/3): 7260.
primary   *note 4.4(7/3): 2709.
   <used>   *note 4.4(6): 2708, *note P: 9308.
primitive function   *note A.5.3(17): 6203.
primitive operation
   [<partial>]   *note 3.2(1): 1329.
primitive operations   *note N(28): 8933.
   of a type   *note 3.2.3(1/2): 1429.
primitive operator
   of a type   *note 3.2.3(8): 1432.
primitive subprograms
   of a type   *note 3.2.3(2): 1430.
priority   *note D.1(15): 7762.
   of a protected object   *note D.3(6/2): 7839.
Priority aspect   *note D.1(6.2/3): 7758.
Priority attribute   *note D.5.2(3/2): 7872.
priority inheritance   *note D.1(15): 7763.
priority inversion   *note D.2.3(11/2): 7803.
priority of an entry call   *note D.4(9): 7864.
Priority pragma   *note J.15.11(2/3): 8635, *note L(27.1/3): 8816.
Priority <subtype of> Any_Priority
   <in> System   *note 13.7(16): 5128.
Priority_Queuing queuing policy   *note D.4(8): 7863.
Priority_Specific_Dispatching pragma   *note D.2.2(3.2/2): 7788, *note
L(27.2/2): 8818.
private declaration of a library unit   *note 10.1.1(12): 4362.
private descendant
   of a library unit   *note 10.1.1(12): 4364.
private extension   *note 3.2(4.1/2): 1345, *note 3.9(2.1/2): 2091,
*note 3.9.1(1/2): 2139, *note N(29/2): 8934.
   [<partial>]   *note 7.3(14): 3617, *note 12.5.1(5/3): 4805.
private library unit   *note 10.1.1(12): 4361.
private operations   *note 7.3.1(1): 3620.
private part   *note 8.2(5): 3724.
   of a package   *note 7.1(6/2): 3583.
   of a protected unit   *note 9.4(11/2): 3990.
   of a task unit   *note 9.1(9): 3918.
private type   *note 3.2(4.1/2): 1344, *note N(30/2): 8935.
   [<partial>]   *note 7.3(14): 3616.
private types and private extensions   *note 7.3(1): 3595.
private_extension_declaration   *note 7.3(3/3): 3604.
   <used>   *note 3.2.1(2): 1372, *note P: 9026.
private_type_declaration   *note 7.3(2/3): 3600.
   <used>   *note 3.2.1(2): 1371, *note P: 9025.
procedure   *note 6(1): 3276, *note N(30.1/2): 8936.
   null   *note 6.7(3/3): 3549.
procedure instance   *note 12.3(13): 4729.
procedure_call_statement   *note 6.4(2): 3446.
   <used>   *note 5.1(4/2): 3126, *note 9.7.2(3.1/2): 4248, *note P:
9638.
procedure_or_entry_call   *note 9.7.2(3.1/2): 4247.
   <used>   *note 9.7.2(3/2): 4245, *note 9.7.4(4/2): 4262, *note P:
9646.
procedure_specification   *note 6.1(4.1/2): 3288.
   <used>   *note 6.1(4/2): 3286, *note 6.7(2/3): 3545, *note P: 9472.
processing node   *note E(2): 8095.
profile   *note 6.1(22): 3335.
   associated with a dereference   *note 4.1(10): 2385.
   fully conformant   *note 6.3.1(18/3): 3437.
   mode conformant   *note 6.3.1(16/3): 3431.
   No_Implementation_Extensions   *note 13.12.1(10/3): 5330.
   subtype conformant   *note 6.3.1(17/3): 3434.
   type conformant   *note 6.3.1(15/2): 3428.
Profile pragma   *note 13.12(11/3): 5305, *note L(27.3/3): 8823.
profile resolution rule
   name with a given expected profile   *note 8.6(26): 3865.
progenitor   *note N(30.2/2): 8937.
progenitor subtype   *note 3.9.4(9/2): 2219.
progenitor type   *note 3.9.4(9/2): 2220.
program   *note 10.2(1): 4441, *note N(31): 8938.
program execution   *note 10.2(1): 4442.
program library
   <See> library   *note 10(2): 4314.
   <See> library   *note 10.1.4(9): 4418.
Program unit   *note 10.1(1): 4317, *note N(32): 8939.
program unit pragma   *note 10.1.5(2): 4419.
   Inline   *note J.15.1(1/3): 8530.
   library unit pragmas   *note 10.1.5(7/3): 4424.
Program_Error
   raised by failure of run-time check   *note 1.1.3(20): 1059, *note
1.1.5(8): 1079, *note 1.1.5(12): 1085, *note 3.5.5(8): 1782, *note
3.10.2(30): 2314, *note 3.11(14): 2352, *note 4.6(57/4): 3017, *note
4.8(10.1/3): 3071, *note 4.8(10.2/2): 3074, *note 4.8(10.3/2): 3077,
*note 4.8(10.4/3): 3083, *note 6.2(12/3): 3401, *note 6.4(11/2): 3467,
*note 6.4.1(13.4/4): 3485, *note 6.5(8/4): 3525, *note 6.5(21/3): 3531,
*note 6.5.1(9/2): 3538, *note 7.6.1(15): 3707, *note 7.6.1(16/2): 3708,
*note 7.6.1(17): 3709, *note 7.6.1(17.2/1): 3710, *note 7.6.1(18/2):
3711, *note 8.5.4(8.1/1): 3833, *note 9.4(20): 4008, *note 9.5.1(17):
4037, *note 9.5.3(7/3): 4103, *note 9.7.1(21): 4239, *note 9.8(20/3):
4292, *note 10.2(26): 4458, *note 11.1(4): 4520, *note 11.5(19): 4637,
*note 12.5.1(23.3/2): 4809, *note 13.7.1(16): 5143, *note 13.9.1(9):
5173, *note 13.11.2(13): 5235, *note 13.11.2(14): 5237, *note
13.11.2(15.2/4): 5242, *note 13.11.4(27/3): 5282, *note 13.11.4(30/3):
5285, *note A.5.2(40.1/1): 6178, *note A.7(14/3): 6289, *note
B.3.3(22/2): 7542, *note C.3.1(10/3): 7650, *note C.3.1(11/3): 7654,
*note C.3.2(17/3): 7671, *note C.3.2(20): 7672, *note C.3.2(21/3): 7673,
*note C.3.2(22/2): 7674, *note C.7.1(15): 7722, *note C.7.1(17/3): 7726,
*note C.7.2(13): 7735, *note D.3(13): 7847, *note D.3(13.2/2): 7849,
*note D.3(13.4/2): 7850, *note D.5.1(9): 7869, *note D.5.2(6/3): 7873,
*note D.7(7.1/3): 7884, *note D.7(10.5/3): 7899, *note D.7(19.1/2):
7937, *note D.10(10): 7983, *note D.11(8): 7996, *note E.1(10/2): 8111,
*note E.3(6): 8177, *note E.4(18/1): 8194, *note J.7.1(7): 8513.
   <in> Standard   *note A.1(46): 5452.
prohibited
   tampering with a holder   *note A.18.18(35/4): 7303.
   tampering with a list   *note A.18.3(69.1/4): 6877.
   tampering with a map   *note A.18.4(15.1/4): 6899.
   tampering with a set   *note A.18.7(14.1/4): 7028.
   tampering with a tree   *note A.18.10(90/4): 7268.
   tampering with a vector   *note A.18.2(97.1/4): 6805.
propagate   *note 11.4(1): 4555.
   an exception occurrence by an execution, to a dynamically enclosing
execution   *note 11.4(6): 4560.
proper_body   *note 3.11(6): 2339.
   <used>   *note 3.11(5): 2337, *note 10.1.3(7): 4407, *note P: 9692.
protected action   *note 9.5.1(4/4): 4029.
   complete   *note 9.5.1(6): 4032.
   start   *note 9.5.1(5/4): 4030.
protected calling convention   *note 6.3.1(12/4): 3423.
protected declaration   *note 9.4(1): 3953.
protected entry   *note 9.4(1): 3950.
protected function   *note 9.5.1(1): 4024.
protected interface   *note 3.9.4(5/2): 2208.
protected object   *note 9(3): 3881, *note 9.4(1): 3947.
protected operation   *note 9.4(1): 3948.
protected procedure   *note 9.5.1(1): 4023.
protected subprogram   *note 9.4(1): 3949, *note 9.5.1(1): 4022.
protected tagged type   *note 3.9.4(6/2): 2218.
protected type   *note N(33/2): 8940.
protected unit   *note 9.4(1): 3952.
protected_body   *note 9.4(7/3): 3977.
   <used>   *note 3.11(6): 2343, *note P: 9195.
protected_body_stub   *note 10.1.3(6/3): 4402.
   <used>   *note 10.1.3(2): 4391, *note P: 9681.
protected_definition   *note 9.4(4): 3966.
   <used>   *note 9.4(2/3): 3960, *note 9.4(3/3): 3965, *note P: 9569.
protected_element_declaration   *note 9.4(6): 3974.
   <used>   *note 9.4(4): 3968, *note P: 9571.
protected_operation_declaration   *note 9.4(5/1): 3970.
   <used>   *note 9.4(4): 3967, *note 9.4(6): 3975, *note P: 9570.
protected_operation_item   *note 9.4(8/4): 3982.
   <used>   *note 9.4(7/3): 3980, *note P: 9580.
protected_type_declaration   *note 9.4(2/3): 3955.
   <used>   *note 3.2.1(3/3): 1379, *note P: 9032.
ptrdiff_t
   <in> Interfaces.C   *note B.3(12): 7446.
PU1
   <in> Ada.Characters.Latin_1   *note A.3.3(18): 5615.
PU2
   <in> Ada.Characters.Latin_1   *note A.3.3(18): 5616.
public declaration of a library unit   *note 10.1.1(12): 4360.
public descendant
   of a library unit   *note 10.1.1(12): 4363.
public library unit   *note 10.1.1(12): 4359.
punctuation_connector   *note 2.1(10.2/2): 1140.
   <used>   *note 2.3(3.1/3): 1202, *note P: 8974.
pure   *note 10.2.1(15.1/3): 4484.
Pure aspect   *note 10.2.1(17/3): 4487.
Pure pragma   *note 10.2.1(14): 4480, *note L(28): 8827.
Put
   <in> Ada.Text_IO   *note A.10.1(42): 6446, *note A.10.1(48): 6456,
*note A.10.1(55): 6471, *note A.10.1(60): 6480, *note A.10.1(66): 6488,
*note A.10.1(67): 6490, *note A.10.1(71): 6498, *note A.10.1(72): 6500,
*note A.10.1(76): 6508, *note A.10.1(77): 6510, *note A.10.1(82): 6517,
*note A.10.1(83): 6519.
   <in> Ada.Text_IO.Bounded_IO   *note A.10.11(4/2): 6538, *note
A.10.11(5/2): 6539.
   <in> Ada.Text_IO.Complex_IO   *note G.1.3(7): 8321, *note G.1.3(8):
8323.
   <in> Ada.Text_IO.Editing   *note F.3.3(14): 8250, *note F.3.3(15):
8251, *note F.3.3(16): 8252.
   <in> Ada.Text_IO.Unbounded_IO   *note A.10.12(4/2): 6547, *note
A.10.12(5/2): 6548.
Put_Line
   <in> Ada.Text_IO   *note A.10.1(50): 6461.
   <in> Ada.Text_IO.Bounded_IO   *note A.10.11(6/2): 6540, *note
A.10.11(7/2): 6541.
   <in> Ada.Text_IO.Unbounded_IO   *note A.10.12(6/2): 6549, *note
A.10.12(7/2): 6550.



File: arm2012.info,  Node: Q,  Next: R,  Prev: P,  Up: Index

Q 
==



qualified_expression   *note 4.7(2): 3025.
   <used>   *note 4.1(2/3): 2369, *note 4.8(2/3): 3047, *note 13.8(2):
5150, *note P: 9834.
quantified expressions   *note 4.5.8(5/3): 2917.
quantified_expression   *note 4.5.8(1/3): 2906.
   <used>   *note 4.4(7/3): 2717, *note P: 9316.
quantifier   *note 4.5.8(2/3): 2913.
   <used>   *note 4.5.8(1/3): 2910, *note P: 9333.
Query_Element
   <in> Ada.Containers.Doubly_Linked_Lists   *note A.18.3(16/2): 6834.
   <in> Ada.Containers.Hashed_Maps   *note A.18.5(16/2): 6923.
   <in> Ada.Containers.Hashed_Sets   *note A.18.8(17/2): 7056.
   <in> Ada.Containers.Indefinite_Holders   *note A.18.18(14/3): 7292.
   <in> Ada.Containers.Multiway_Trees   *note A.18.10(26/3): 7219.
   <in> Ada.Containers.Ordered_Maps   *note A.18.6(15/2): 6974.
   <in> Ada.Containers.Ordered_Sets   *note A.18.9(16/2): 7127.
   <in> Ada.Containers.Vectors   *note A.18.2(31/2): 6747, *note
A.18.2(32/2): 6748.
Question
   <in> Ada.Characters.Latin_1   *note A.3.3(10): 5554.
Queue
   <in> Ada.Containers.Bounded_Priority_Queues   *note A.18.31(4/3):
7363.
   <in> Ada.Containers.Bounded_Synchronized_Queues   *note A.18.29(4/3):
7350.
   <in> Ada.Containers.Synchronized_Queue_Interfaces   *note
A.18.27(4/3): 7337.
   <in> Ada.Containers.Unbounded_Priority_Queues   *note A.18.30(4/3):
7356.
   <in> Ada.Containers.Unbounded_Synchronized_Queues   *note
A.18.28(4/3): 7344.
queuing policy   *note D.4(1/3): 7851, *note D.4(6): 7859.
   FIFO_Queuing   *note D.4(7/2): 7860.
   Priority_Queuing   *note D.4(8): 7862.
Queuing_Policy pragma   *note D.4(3): 7853, *note L(29): 8830.
Quotation
   <in> Ada.Characters.Latin_1   *note A.3.3(8): 5534.
quotation mark   *note 2.1(15/3): 1151.
quoted string
   <See> string_literal   *note 2.6(1): 1249.



File: arm2012.info,  Node: R,  Next: S,  Prev: Q,  Up: Index

R 
==



raise
   an exception   *note 11(1/3): 4512.
   an exception   *note 11.3(4/4): 4551.
   an exception   *note N(18): 8907.
   an exception occurrence   *note 11.4(3): 4559.
Raise_Exception
   <in> Ada.Exceptions   *note 11.4.1(4/3): 4573.
raise_expression   *note 11.3(2.1/4): 4547.
   <used>   *note 4.4(3/4): 2687, *note P: 9292.
raise_statement   *note 11.3(2/2): 4544.
   <used>   *note 5.1(4/2): 3132, *note P: 9367.
Random
   <in> Ada.Numerics.Discrete_Random   *note A.5.2(20): 6162.
   <in> Ada.Numerics.Float_Random   *note A.5.2(8): 6150.
random number   *note A.5.2(1): 6146.
range   *note 3.5(3): 1587, *note 3.5(4): 1591.
   of a scalar subtype   *note 3.5(7): 1604.
   <used>   *note 3.5(2): 1586, *note 3.6(6): 1902, *note 3.6.1(3):
1937, *note 3.8.1(5/3): 2071, *note 4.4(3.2/4): 2693, *note P: 9076.
Range attribute   *note 3.5(14): 1616, *note 3.6.2(7): 1955.
Range(N) attribute   *note 3.6.2(8): 1957.
range_attribute_designator   *note 4.1.4(5): 2443.
   <used>   *note 4.1.4(4): 2442, *note P: 9229.
range_attribute_reference   *note 4.1.4(4): 2440.
   <used>   *note 3.5(3): 1588, *note P: 9077.
Range_Check   *note 11.5(17): 4635.
   [<partial>]   *note 3.2.2(11): 1423, *note 3.5(24): 1629, *note
3.5(27): 1636, *note 3.5(39.12/3): 1663, *note 3.5(39.4/3): 1657, *note
3.5(39.5/3): 1660, *note 3.5(43/3): 1669, *note 3.5(55/3): 1675, *note
3.5.5(7): 1776, *note 3.5.9(19/4): 1861, *note 4.2(11): 2489, *note
4.3.3(28): 2575, *note 4.5.1(8): 2755, *note 4.5.6(6): 2866, *note
4.5.6(13): 2875, *note 4.6(28): 2967, *note 4.6(38): 2979, *note
4.6(46): 2992, *note 4.6(51/4): 2998, *note 4.7(4/4): 3032, *note
13.13.2(35/3): 5365, *note A.5.2(39): 6175, *note A.5.3(26): 6211, *note
A.5.3(29): 6216, *note A.5.3(50): 6239, *note A.5.3(53): 6244, *note
A.5.3(59): 6249, *note A.5.3(62): 6254, *note K.2(11): 8651, *note
K.2(114): 8666, *note K.2(122): 8669, *note K.2(184): 8675, *note
K.2(220): 8682, *note K.2(241): 8685, *note K.2(41): 8656, *note
K.2(47): 8659.
range_constraint   *note 3.5(2): 1585.
   <used>   *note 3.2.2(6): 1414, *note 3.5.9(5/4): 1841, *note
J.3(2/4): 8497, *note P: 9050.
Ravenscar   *note D.13(1/3): 7998.
RCI
   generic   *note E.2.3(7/3): 8160.
   library unit   *note E.2.3(7/3): 8158.
   package   *note E.2.3(7/3): 8159.
Re
   <in> Ada.Numerics.Generic_Complex_Arrays   *note G.3.2(7/2): 8389,
*note G.3.2(27/2): 8402.
   <in> Ada.Numerics.Generic_Complex_Types   *note G.1.1(6): 8263.
re-raise statement   *note 11.3(3/4): 4550.
read
   the value of an object   *note 3.3(14): 1463.
   <in> Ada.Direct_IO   *note A.8.4(12): 6339.
   <in> Ada.Sequential_IO   *note A.8.1(12): 6312.
   <in> Ada.Storage_IO   *note A.9(6): 6358.
   <in> Ada.Streams   *note 13.13.1(5): 5340.
   <in> Ada.Streams.Stream_IO   *note A.12.1(15): 6586, *note
A.12.1(16): 6587.
   <in> System.RPC   *note E.5(7): 8208.
Read aspect   *note 13.13.2(38/4): 5379.
Read attribute   *note 13.13.2(6): 5352, *note 13.13.2(14): 5356.
Read clause   *note 13.3(7/2): 4969, *note 13.13.2(38/4): 5374.
Read'Class aspect   *note 13.13.2(38/4): 5387.
ready
   a task state   *note 9(10): 3888.
ready queue   *note D.2.1(5/2): 7776.
ready task   *note D.2.1(5/2): 7779.
Real
   <in> Interfaces.Fortran   *note B.5(6): 7601.
real literal   *note 2.4(1): 1205.
real literals   *note 3.5.6(4): 1790.
real time   *note D.8(18): 7963.
real type   *note 3.2(3): 1342, *note 3.5.6(1): 1784, *note N(34): 8941.
real-time systems   *note C(1): 7619, *note D(1): 7755.
Real_Arrays
   <child of> Ada.Numerics   *note G.3.1(31/2): 8382.
Real_Matrix
   <in> Ada.Numerics.Generic_Real_Arrays   *note G.3.1(4/2): 8372.
real_range_specification   *note 3.5.7(3): 1798.
   <used>   *note 3.5.7(2): 1797, *note 3.5.9(3): 1834, *note 3.5.9(4):
1838, *note P: 9093.
Real_Time
   <child of> Ada   *note D.8(3): 7941.
real_type_definition   *note 3.5.6(2): 1785.
   <used>   *note 3.2.1(4/2): 1383, *note P: 9035.
Real_Vector
   <in> Ada.Numerics.Generic_Real_Arrays   *note G.3.1(4/2): 8371.
receiving stub   *note E.4(10): 8187.
reclamation of storage   *note 13.11.2(1): 5226.
recommended level of support   *note 13.1(20/3): 4908.
   Address attribute   *note 13.3(15): 4985.
   Alignment attribute for objects   *note 13.3(33): 4999.
   Alignment attribute for subtypes   *note 13.3(29): 4998.
   aspect Pack   *note 13.2(7/3): 4941.
   bit ordering   *note 13.5.3(7): 5102.
   Component_Size attribute   *note 13.3(71): 5027.
   enumeration_representation_clause   *note 13.4(9): 5048.
   record_representation_clause   *note 13.5.1(17): 5078.
   required in Systems Programming Annex   *note C.2(2/3): 7628.
   Size attribute   *note 13.3(42/2): 5006, *note 13.3(54): 5013.
   Stream_Size attribute   *note 13.13.2(1.7/2): 5348.
   unchecked conversion   *note 13.9(16): 5162.
   with respect to nonstatic expressions   *note 13.1(21/3): 4909.
record   *note 3.8(1): 2021.
   explicitly limited   *note 3.8(13.1/3): 2045.
record extension   *note 3.4(5/2): 1539, *note 3.9.1(1/2): 2137, *note
N(35): 8942.
Record layout aspect   *note 13.5(1): 5054.
record type   *note 3.8(1): 2022, *note N(36): 8943.
record_aggregate   *note 4.3.1(2): 2505.
   <used>   *note 4.3(2): 2495, *note P: 9234.
record_component_association   *note 4.3.1(4/2): 2510.
   <used>   *note 4.3.1(3): 2508, *note P: 9238.
record_component_association_list   *note 4.3.1(3): 2507.
   <used>   *note 4.3.1(2): 2506, *note 4.3.2(2): 2529, *note P: 9246.
record_definition   *note 3.8(3): 2026.
   <used>   *note 3.8(2): 2025, *note 3.9.1(2): 2142, *note P: 9139.
record_extension_part   *note 3.9.1(2): 2141.
   <used>   *note 3.4(2/2): 1536, *note P: 9075.
record_representation_clause   *note 13.5.1(2): 5059.
   <used>   *note 13.1(2/1): 4875, *note P: 9801.
record_type_definition   *note 3.8(2): 2024.
   <used>   *note 3.2.1(4/2): 1385, *note P: 9037.
reentrant   *note A(3/4): 5433.
reference
   dangling   *note 13.11.2(15.1/4): 5240.
   <in> Ada.Containers.Doubly_Linked_Lists   *note A.18.3(17.4/3): 6838.
   <in> Ada.Containers.Hashed_Maps   *note A.18.5(17.4/3): 6927, *note
A.18.5(17.6/3): 6929.
   <in> Ada.Containers.Indefinite_Holders   *note A.18.18(19/3): 7297.
   <in> Ada.Containers.Multiway_Trees   *note A.18.10(31/3): 7224.
   <in> Ada.Containers.Ordered_Maps   *note A.18.6(16.4/3): 6978, *note
A.18.6(16.6/3): 6980.
   <in> Ada.Containers.Vectors   *note A.18.2(34.4/3): 6753, *note
A.18.2(34.6/3): 6755.
   <in> Ada.Interrupts   *note C.3.2(10): 7668.
   <in> Ada.Task_Attributes   *note C.7.2(5): 7731.
reference discriminant   *note 4.1.5(3/3): 2454.
reference object   *note 4.1.5(3/3): 2453.
reference parameter passing   *note 6.2(2): 3392.
reference type   *note 4.1.5(3/3): 2452, *note N(36.1/3): 8944.
Reference_Preserving_Key
   <in> Ada.Containers.Hashed_Sets   *note A.18.8(58.2/3): 7097, *note
A.18.8(58.4/3): 7099.
   <in> Ada.Containers.Ordered_Sets   *note A.18.9(73.2/3): 7178, *note
A.18.9(73.4/3): 7180.
Reference_Type
   <in> Ada.Containers.Doubly_Linked_Lists   *note A.18.3(17.2/3): 6836.
   <in> Ada.Containers.Hashed_Maps   *note A.18.5(17.2/3): 6925.
   <in> Ada.Containers.Hashed_Sets   *note A.18.8(58.1/3): 7096.
   <in> Ada.Containers.Indefinite_Holders   *note A.18.18(17/3): 7295.
   <in> Ada.Containers.Multiway_Trees   *note A.18.10(29/3): 7222.
   <in> Ada.Containers.Ordered_Maps   *note A.18.6(16.2/3): 6976.
   <in> Ada.Containers.Ordered_Sets   *note A.18.9(73.1/3): 7177.
   <in> Ada.Containers.Vectors   *note A.18.2(34.2/3): 6751.
references   *note 1.2(1/3): 1086.
Registered_Trade_Mark_Sign
   <in> Ada.Characters.Latin_1   *note A.3.3(21/3): 5645.
Reinitialize
   <in> Ada.Task_Attributes   *note C.7.2(6): 7733.
relation   *note 4.4(3/4): 2681.
   <used>   *note 4.4(2): 2656, *note P: 9266.
relational operator   *note 4.5.2(1): 2758.
relational_operator   *note 4.5(3): 2725.
   <used>   *note 4.4(2.2/3): 2679, *note 4.4(3/4): 2683, *note P: 9285.
Relative_Deadline aspect   *note D.2.6(9.2/3): 7828.
Relative_Deadline pragma   *note J.15.12(2/3): 8641, *note L(29.2/3):
8833.
Relative_Name
   <in> Ada.Directories.Hierarchical_File_Names   *note A.16.1(13/3):
6696.
relaxed mode   *note G.2(1): 8331.
release
   execution resource associated with protected object   *note 9.5.1(6):
4033.
rem operator   *note 4.4(1/3): 2644, *note 4.5.5(1): 2852.
Remainder attribute   *note A.5.3(45): 6232.
remote access   *note E.1(5): 8102.
remote access type   *note E.2.2(9/3): 8144.
remote access-to-class-wide type   *note E.2.2(9/3): 8146.
remote access-to-subprogram type   *note E.2.2(9/3): 8145.
remote call interface   *note E.2(4/3): 8120, *note E.2.3(7/3): 8157.
remote procedure call
   asynchronous   *note E.4.1(9/3): 8200.
remote subprogram   *note E.2.3(7/3): 8161.
remote subprogram binding   *note E.4(1): 8182.
remote subprogram call   *note E.4(1): 8178.
remote types library unit   *note E.2(4/3): 8119, *note E.2.2(4/3):
8141.
Remote_Call_Interface aspect   *note E.2.3(7/3): 8163.
Remote_Call_Interface pragma   *note E.2.3(3): 8150, *note L(30): 8835.
Remote_Types aspect   *note E.2.2(4/3): 8143.
Remote_Types pragma   *note E.2.2(3): 8139, *note L(31): 8838.
Remove_Task
   <in> Ada.Execution_Time.Group_Budgets   *note D.14.2(8/2): 8036.
Rename
   <in> Ada.Directories   *note A.16(12/2): 6643.
renamed entity   *note 8.5(3): 3797.
renamed view   *note 8.5(3): 3796.
renaming   *note N(36.2/2): 8945.
renaming-as-body   *note 8.5.4(1/3): 3820.
renaming-as-declaration   *note 8.5.4(1/3): 3821.
renaming_declaration   *note 8.5(2): 3789.
   <used>   *note 3.1(3/3): 1302, *note P: 9018.
rendezvous   *note 9.5.2(25): 4087.
Replace
   <in> Ada.Containers.Hashed_Maps   *note A.18.5(23/2): 6937.
   <in> Ada.Containers.Hashed_Sets   *note A.18.8(22/2): 7064, *note
A.18.8(53/2): 7090.
   <in> Ada.Containers.Ordered_Maps   *note A.18.6(22/2): 6988.
   <in> Ada.Containers.Ordered_Sets   *note A.18.9(21/2): 7135, *note
A.18.9(66/2): 7169.
Replace_Element
   <in> Ada.Containers.Doubly_Linked_Lists   *note A.18.3(15/2): 6833.
   <in> Ada.Containers.Hashed_Maps   *note A.18.5(15/2): 6922.
   <in> Ada.Containers.Hashed_Sets   *note A.18.8(16/2): 7055.
   <in> Ada.Containers.Indefinite_Holders   *note A.18.18(13/3): 7291.
   <in> Ada.Containers.Multiway_Trees   *note A.18.10(25/3): 7218.
   <in> Ada.Containers.Ordered_Maps   *note A.18.6(14/2): 6973.
   <in> Ada.Containers.Ordered_Sets   *note A.18.9(15/2): 7126.
   <in> Ada.Containers.Vectors   *note A.18.2(29/2): 6745, *note
A.18.2(30/2): 6746.
   <in> Ada.Strings.Bounded   *note A.4.4(27): 5862.
   <in> Ada.Strings.Unbounded   *note A.4.5(21): 5916.
Replace_Slice
   <in> Ada.Strings.Bounded   *note A.4.4(58): 5883, *note A.4.4(59):
5884.
   <in> Ada.Strings.Fixed   *note A.4.3(23): 5826, *note A.4.3(24):
5827.
   <in> Ada.Strings.Unbounded   *note A.4.5(53): 5937, *note A.4.5(54):
5938.
Replenish
   <in> Ada.Execution_Time.Group_Budgets   *note D.14.2(9/2): 8040.
Replicate
   <in> Ada.Strings.Bounded   *note A.4.4(78): 5899, *note A.4.4(79):
5900, *note A.4.4(80): 5901.
representation
   change of   *note 13.6(1/3): 5104.
representation aspect   *note 13.1(8/3): 4887.
   coding   *note 13.4(7): 5044.
   convention, calling convention   *note B.1(1/3): 7392.
   export   *note B.1(1/3): 7394.
   external_name   *note B.1(1/3): 7395.
   import   *note B.1(1/3): 7393.
   layout   *note 13.5(1): 5051.
   link_name   *note B.1(1/3): 7396.
   record layout   *note 13.5(1): 5052.
   specifiable attributes   *note 13.3(5/3): 4956.
   storage place   *note 13.5(1): 5055.
representation attribute   *note 13.3(1/1): 4942.
representation item   *note 13.1(1/1): 4868.
representation of an object   *note 13.1(7/2): 4883.
representation pragma   *note 13.1(1/1): 4869.
   Asynchronous   *note J.15.13(1/3): 8643.
   Atomic   *note J.15.8(9/3): 8615.
   Atomic_Components   *note J.15.8(9/3): 8619.
   Convention   *note J.15.5(1/3): 8562.
   Discard_Names   *note C.5(6): 7686.
   Export   *note J.15.5(1/3): 8560.
   Import   *note J.15.5(1/3): 8558.
   Independent   *note J.15.8(9/3): 8623.
   Independent_Components   *note J.15.8(9/3): 8625.
   No_Return   *note J.15.2(1/3): 8536.
   Pack   *note J.15.3(1/3): 8542.
   Unchecked_Union   *note J.15.6(1/3): 8583.
   Volatile   *note J.15.8(9/3): 8617.
   Volatile_Components   *note J.15.8(9/3): 8621.
representation-oriented attributes
   of a fixed point subtype   *note A.5.4(1): 6271.
   of a floating point subtype   *note A.5.3(1): 6180.
representation_clause
   <See> aspect_clause   *note 13.1(4/1): 4882.
represented in canonical form   *note A.5.3(10): 6194.
requested decimal precision
   of a floating point type   *note 3.5.7(4): 1801.
requeue   *note 9.5.4(1): 4117.
requeue target   *note 9.5.4(3/3): 4122.
requeue-with-abort   *note 9.5.4(13): 4129.
requeue_statement   *note 9.5.4(2/3): 4120.
   <used>   *note 5.1(4/2): 3129, *note P: 9364.
require overriding   *note 3.9.3(6/4): 2193.
requires a completion   *note 3.11.1(1/3): 2353, *note 3.11.1(6/3):
2357.
   declaration for which aspect Elaborate_Body is True   *note
10.2.1(25/3): 4503.
   declaration of a partial view   *note 7.3(4): 3611.
   declaration to which a pragma Elaborate_Body applies   *note
10.2.1(25/3): 4502.
   deferred constant declaration   *note 7.4(2/3): 3642.
   generic_package_declaration   *note 7.1(5/2): 3581.
   generic_subprogram_declaration   *note 6.1(20/3): 3334.
   incomplete_type_declaration   *note 3.10.1(3/3): 2282.
   package_declaration   *note 7.1(5/2): 3580.
   protected entry_declaration   *note 9.5.2(16): 4071.
   protected_declaration   *note 9.4(11.2/2): 3995.
   subprogram_declaration   *note 6.1(20/3): 3333.
   task_declaration   *note 9.1(9.3/2): 3922.
requires late initialization   *note 3.3.1(8.1/2): 1503.
requires overriding
   [<partial>]   *note 6.1.1(16/3): 3363.
Reraise_Occurrence
   <in> Ada.Exceptions   *note 11.4.1(4/3): 4575.
Reserve_Capacity
   <in> Ada.Containers.Hashed_Maps   *note A.18.5(9/2): 6916.
   <in> Ada.Containers.Hashed_Sets   *note A.18.8(11/2): 7050.
   <in> Ada.Containers.Vectors   *note A.18.2(20/2): 6736.
reserved interrupt   *note C.3(2): 7637.
reserved word   *note 2.9(2/3): 1289.
Reserved_128
   <in> Ada.Characters.Latin_1   *note A.3.3(17): 5598.
Reserved_129
   <in> Ada.Characters.Latin_1   *note A.3.3(17): 5599.
Reserved_132
   <in> Ada.Characters.Latin_1   *note A.3.3(17): 5602.
Reserved_153
   <in> Ada.Characters.Latin_1   *note A.3.3(19): 5623.
Reserved_Check
   [<partial>]   *note C.3.1(10/3): 7648.
Reset
   <in> Ada.Direct_IO   *note A.8.4(8): 6332.
   <in> Ada.Numerics.Discrete_Random   *note A.5.2(21): 6164, *note
A.5.2(24): 6167.
   <in> Ada.Numerics.Float_Random   *note A.5.2(9): 6151, *note
A.5.2(12): 6155.
   <in> Ada.Sequential_IO   *note A.8.1(8): 6305.
   <in> Ada.Streams.Stream_IO   *note A.12.1(10): 6579.
   <in> Ada.Text_IO   *note A.10.1(11): 6387.
resolution rules   *note 1.1.2(26/3): 1021.
resolve
   overload resolution   *note 8.6(14): 3853.
restriction   *note 13.12(4/2): 5294.
   <used>   *note 13.12(3): 5293, *note L(32): 8842.
restriction_parameter_argument   *note 13.12(4.1/2): 5298.
   <used>   *note 13.12(4/2): 5297, *note P: 9838.
restrictions
   Immediate_Reclamation   *note H.4(10): 8458.
   Max_Asynchronous_Select_Nesting   *note D.7(18/1): 7925.
   Max_Entry_Queue_Length   *note D.7(19.1/2): 7935.
   Max_Protected_Entries   *note D.7(14): 7916.
   Max_Select_Alternatives   *note D.7(12): 7912.
   Max_Storage_At_Blocking   *note D.7(17/1): 7920.
   Max_Task_Entries   *note D.7(13): 7914.
   Max_Tasks   *note D.7(19/1): 7930.
   No_Abort_Statements   *note D.7(5/3): 7878.
   No_Access_Parameter_Allocators   *note H.4(8.3/3): 8456.
   No_Access_Subprograms   *note H.4(17): 8466.
   No_Allocators   *note H.4(7): 8448.
   No_Anonymous_Allocators   *note H.4(8.1/3): 8452.
   No_Asynchronous_Control   *note J.13(3/2): 8527.
   No_Coextensions   *note H.4(8.2/3): 8454.
   No_Delay   *note H.4(21): 8476.
   No_Dependence   *note 13.12.1(6/2): 5322.
   No_Dispatch   *note H.4(19): 8472.
   No_Dynamic_Attachment   *note D.7(10/3): 7889.
   No_Dynamic_CPU_Assignment   *note D.7(10.1/4): 7891.
   No_Dynamic_Priorities   *note D.7(9/2): 7887.
   No_Exceptions   *note H.4(12): 8460.
   No_Fixed_Point   *note H.4(15): 8464.
   No_Floating_Point   *note H.4(14): 8462.
   No_Implementation_Aspect_Specifications   *note 13.12.1(1.1/3): 5310.
   No_Implementation_Attributes   *note 13.12.1(2/2): 5312.
   No_Implementation_Identifiers   *note 13.12.1(2.1/3): 5314.
   No_Implementation_Pragmas   *note 13.12.1(3/2): 5316.
   No_Implementation_Units   *note 13.12.1(3.1/3): 5318.
   No_Implicit_Heap_Allocations   *note D.7(8): 7885.
   No_IO   *note H.4(20/2): 8474.
   No_Local_Allocators   *note H.4(8/1): 8450.
   No_Local_Protected_Objects   *note D.7(10.2/3): 7893.
   No_Local_Timing_Events   *note D.7(10.3/3): 7895.
   No_Nested_Finalization   *note D.7(4/3): 7876.
   No_Obsolescent_Features   *note 13.12.1(4/3): 5320.
   No_Protected_Type_Allocators   *note D.7(10.4/2): 7897.
   No_Protected_Types   *note H.4(5): 8446.
   No_Recursion   *note H.4(22): 8478.
   No_Reentrancy   *note H.4(23): 8480.
   No_Relative_Delay   *note D.7(10.6/3): 7900.
   No_Requeue_Statements   *note D.7(10.7/3): 7902.
   No_Select_Statements   *note D.7(10.8/3): 7904.
   No_Specific_Termination_Handlers   *note D.7(10.9/3): 7906.
   No_Specification_of_Aspect   *note 13.12.1(6.1/3): 5324.
   No_Standard_Allocators_After_Elaboration   *note D.7(19.2/3): 7938.
   No_Task_Allocators   *note D.7(7): 7882.
   No_Task_Hierarchy   *note D.7(3/3): 7874.
   No_Task_Termination   *note D.7(15.1/2): 7918.
   No_Tasks_Unassigned_To_CPU   *note D.7(10.10/4): 7908.
   No_Terminate_Alternatives   *note D.7(6): 7880.
   No_Unchecked_Access   *note H.4(18): 8468.
   No_Unchecked_Conversion   *note J.13(4/2): 8528.
   No_Unchecked_Deallocation   *note J.13(5/2): 8529.
   No_Use_Of_Attribute   *note 13.12.1(6.2/3): 5326.
   No_Use_Of_Pragma   *note 13.12.1(6.3/3): 5328.
   Simple_Barriers   *note D.7(10.11/3): 7910.
Restrictions pragma   *note 13.12(3): 5291, *note L(32): 8841.
Result attribute   *note 6.1.1(29/3): 3373.
result interval
   for a component of the result of evaluating a complex function  
*note G.2.6(3): 8364.
   for the evaluation of a predefined arithmetic operation   *note
G.2.1(8): 8336.
   for the evaluation of an elementary function   *note G.2.4(2): 8358.
result subtype
   of a function   *note 6.5(3/2): 3509.
return expression
   of expression function   *note 6.8(6/4): 3564.
return object
   extended_return_statement   *note 6.5(5.10/3): 3514.
   simple_return_statement   *note 6.5(6/2): 3523.
return statement   *note 6.5(1/2): 3496.
return_subtype_indication   *note 6.5(2.3/2): 3506.
   <used>   *note 6.5(2.1/3): 3501, *note P: 9465.
reverse iterator   *note 5.5.2(4/3): 3249.
Reverse_Elements
   <in> Ada.Containers.Doubly_Linked_Lists   *note A.18.3(27/2): 6850.
   <in> Ada.Containers.Vectors   *note A.18.2(54/2): 6777.
Reverse_Find
   <in> Ada.Containers.Doubly_Linked_Lists   *note A.18.3(42/2): 6865.
   <in> Ada.Containers.Vectors   *note A.18.2(70/2): 6793.
Reverse_Find_Index
   <in> Ada.Containers.Vectors   *note A.18.2(69/2): 6792.
Reverse_Iterate
   <in> Ada.Containers.Doubly_Linked_Lists   *note A.18.3(46/2): 6868.
   <in> Ada.Containers.Ordered_Maps   *note A.18.6(51/2): 7010.
   <in> Ada.Containers.Ordered_Sets   *note A.18.9(61/2): 7164.
   <in> Ada.Containers.Vectors   *note A.18.2(74/2): 6796.
Reverse_Iterate_Children
   <in> Ada.Containers.Multiway_Trees   *note A.18.10(69/3): 7262.
Reverse_Solidus
   <in> Ada.Characters.Latin_1   *note A.3.3(12): 5557.
reversible iterable container object   *note 5.5.1(11/3): 3232.
reversible iterable container type   *note 5.5.1(11/3): 3230.
reversible iterator object   *note 5.5.1(6/3): 3219.
reversible iterator type   *note 5.5.1(6/3): 3217.
Reversible_Iterator
   <in> Ada.Iterator_Interfaces   *note 5.5.1(4/3): 3213.
Reviewable pragma   *note H.3.1(3): 8437, *note L(33): 8845.
RI
   <in> Ada.Characters.Latin_1   *note A.3.3(17): 5611.
right parenthesis   *note 2.1(15/3): 1157.
Right_Angle_Quotation
   <in> Ada.Characters.Latin_1   *note A.3.3(22): 5660.
Right_Curly_Bracket
   <in> Ada.Characters.Latin_1   *note A.3.3(14): 5590.
Right_Parenthesis
   <in> Ada.Characters.Latin_1   *note A.3.3(8): 5541.
Right_Square_Bracket
   <in> Ada.Characters.Latin_1   *note A.3.3(12): 5558.
Ring_Above
   <in> Ada.Characters.Latin_1   *note A.3.3(22): 5648.
root
   of a tree   *note A.18.10(2/4): 7190.
   <in> Ada.Containers.Multiway_Trees   *note A.18.10(22/3): 7215.
root library unit   *note 10.1.1(10): 4355.
root node
   of a tree   *note A.18.10(2/4): 7191.
root type
   of a class   *note 3.4.1(2/2): 1563.
root_integer   *note 3.5.4(14): 1743.
   [<partial>]   *note 3.4.1(8): 1573.
root_real   *note 3.5.6(3): 1788.
   [<partial>]   *note 3.4.1(8): 1574.
Root_Storage_Pool
   <in> System.Storage_Pools   *note 13.11(6/2): 5188.
Root_Storage_Pool_With_Subpools
   <in> System.Storage_Pools.Subpools   *note 13.11.4(4/3): 5257.
Root_Stream_Type
   <in> Ada.Streams   *note 13.13.1(3/2): 5335.
Root_Subpool
   <in> System.Storage_Pools.Subpools   *note 13.11.4(5/3): 5258.
rooted at a type   *note 3.4.1(2/2): 1564.
roots the subtree   *note A.18.10(3/4): 7195.
rotate   *note B.2(9): 7429.
Rotate_Left   *note B.2(6): 7424.
Rotate_Right   *note B.2(6): 7425.
Round attribute   *note 3.5.10(12): 1883.
Round_Robin
   <child of> Ada.Dispatching   *note D.2.5(4/2): 7813.
Round_Robin_Within_Priorities task dispatching policy   *note
D.2.5(2/2): 7812.
Rounding attribute   *note A.5.3(36): 6223.
RPC
   <child of> System   *note E.5(3): 8204.
RPC-receiver   *note E.5(21): 8215.
RPC_Receiver
   <in> System.RPC   *note E.5(11): 8212.
RS
   <in> Ada.Characters.Latin_1   *note A.3.3(6): 5530.
run-time check
   <See> language-defined check   *note 11.5(2/3): 4613.
run-time error   *note 1.1.2(30): 1037, *note 1.1.5(6): 1076, *note
11.5(2/3): 4614, *note 11.6(1/3): 4650.
run-time polymorphism   *note 3.9.2(1/2): 2152.
run-time semantics   *note 1.1.2(30): 1036.
run-time type
   <See> tag   *note 3.9(3): 2096.
running a program
   <See> program execution   *note 10.2(1): 4443.
running task   *note D.2.1(6/2): 7782.
runtime name text
   entity with   *note C.5(1.1/4): 7678.



File: arm2012.info,  Node: S,  Next: T,  Prev: R,  Up: Index

S 
==



safe range
   of a floating point type   *note 3.5.7(9): 1809.
   of a floating point type   *note 3.5.7(10): 1811.
Safe_First attribute   *note A.5.3(71): 6268, *note G.2.2(5): 8345.
Safe_Last attribute   *note A.5.3(72): 6270, *note G.2.2(6): 8347.
safety-critical systems   *note H(1/2): 8426.
satisfies
   a discriminant constraint   *note 3.7.1(11): 2015.
   a range constraint   *note 3.5(4): 1597.
   an index constraint   *note 3.6.1(7): 1943.
   for an access value   *note 3.10(15/2): 2272.
satisfies the predicates
   of a subtype   *note 3.2.4(29.2/4): 1447.
Saturday
   <in> Ada.Calendar.Formatting   *note 9.6.1(17/2): 4184.
Save
   <in> Ada.Numerics.Discrete_Random   *note A.5.2(24): 6166.
   <in> Ada.Numerics.Float_Random   *note A.5.2(12): 6154.
Save_Occurrence
   <in> Ada.Exceptions   *note 11.4.1(6/2): 4582.
scalar type   *note 3.2(3): 1339, *note 3.5(1): 1581, *note N(37): 8946.
scalar_constraint   *note 3.2.2(6): 1413.
   <used>   *note 3.2.2(5): 1411, *note P: 9048.
scale
   of a decimal fixed point subtype   *note 3.5.10(11): 1881, *note
K.2(216): 8680.
Scale attribute   *note 3.5.10(11): 1880.
Scaling attribute   *note A.5.3(27): 6214.
SCHAR_MAX
   <in> Interfaces.C   *note B.3(6): 7435.
SCHAR_MIN
   <in> Interfaces.C   *note B.3(6): 7434.
SCI
   <in> Ada.Characters.Latin_1   *note A.3.3(19): 5624.
scope
   informal definition   *note 3.1(8): 1317.
   of (a view of) an entity   *note 8.2(11): 3732.
   of a declaration   *note 8.2(10): 3728.
   of a use_clause   *note 8.4(6): 3783.
   of a with_clause   *note 10.1.2(5): 4382.
   of an aspect_specification   *note 8.2(10.1/3): 3730.
   of an attribute_definition_clause   *note 8.2(10.1/3): 3729.
Search_Type
   <in> Ada.Directories   *note A.16(31/2): 6661.
Second
   <in> Ada.Calendar.Formatting   *note 9.6.1(26/2): 4196.
Second_Duration <subtype of> Day_Duration
   <in> Ada.Calendar.Formatting   *note 9.6.1(20/2): 4190.
Second_Number <subtype of> Natural
   <in> Ada.Calendar.Formatting   *note 9.6.1(20/2): 4189.
Seconds
   <in> Ada.Calendar   *note 9.6(13): 4155.
   <in> Ada.Real_Time   *note D.8(14/2): 7958.
Seconds_Count
   <in> Ada.Real_Time   *note D.8(15): 7960.
Seconds_Of
   <in> Ada.Calendar.Formatting   *note 9.6.1(28/2): 4198.
Section_Sign
   <in> Ada.Characters.Latin_1   *note A.3.3(21/3): 5638.
secure systems   *note H(1/2): 8427.
select an entry call
   from an entry queue   *note 9.5.3(13): 4109, *note 9.5.3(16): 4110.
   immediately   *note 9.5.3(8): 4106.
select_alternative   *note 9.7.1(4): 4223.
   <used>   *note 9.7.1(2): 4217, *note P: 9624.
select_statement   *note 9.7(2): 4209.
   <used>   *note 5.1(5/2): 3141, *note P: 9375.
selected_component   *note 4.1.3(2): 2418.
   <used>   *note 4.1(2/3): 2364, *note P: 9200.
selection
   of an entry caller   *note 9.5.2(24): 4086.
selective_accept   *note 9.7.1(2): 4215.
   <used>   *note 9.7(2): 4210, *note P: 9617.
selector_name   *note 4.1.3(3): 2421.
   <used>   *note 3.7.1(3): 2005, *note 4.1.3(2): 2420, *note 4.3.1(5):
2516, *note 6.4(5): 3458, *note 12.3(4): 4713, *note 12.7(3.1/2): 4863,
*note P: 9136.
semantic dependence
   of one compilation unit upon another   *note 10.1.1(26/2): 4366.
semicolon   *note 2.1(15/3): 1170.
   <in> Ada.Characters.Latin_1   *note A.3.3(10): 5550.
separate compilation   *note 10.1(1): 4315.
Separate_Interrupt_Clocks_Supported
   <in> Ada.Execution_Time   *note D.14(9.2/3): 8009.
separator   *note 2.2(3/2): 1184.
separator_line   *note 2.1(12/2): 1143.
separator_paragraph   *note 2.1(12.1/2): 1144.
separator_space   *note 2.1(11/2): 1142.
sequence of characters
   of a string_literal   *note 2.6(5): 1254.
sequence_of_statements   *note 5.1(2/3): 3112.
   <used>   *note 5.3(2): 3171, *note 5.4(3): 3182, *note 5.5(2): 3193,
*note 9.7.1(2): 4220, *note 9.7.1(5): 4229, *note 9.7.1(6): 4232, *note
9.7.2(3/2): 4246, *note 9.7.3(2): 4253, *note 9.7.4(3): 4260, *note
9.7.4(5): 4265, *note 11.2(2): 4529, *note 11.2(3): 4536, *note P: 9631.
sequential
   actions   *note 9.10(11): 4310, *note C.6(17): 7705.
sequential access   *note A.8(2): 6293.
sequential file   *note A.8(1/2): 6290.
Sequential_IO
   <child of> Ada   *note A.8.1(2): 6298.
service
   an entry queue   *note 9.5.3(13): 4108.
set
   execution timer object   *note D.14.1(12/2): 8025.
   group budget object   *note D.14.2(15/2): 8052.
   termination handler   *note C.7.3(9/2): 7753.
   timing event object   *note D.15(9/2): 8067.
   <in> Ada.Containers.Hashed_Sets   *note A.18.8(3/3): 7041.
   <in> Ada.Containers.Ordered_Sets   *note A.18.9(4/3): 7114.
   <in> Ada.Environment_Variables   *note A.17(6/2): 6703.
set container   *note A.18.7(1/2): 7018.
Set_Bounded_String
   <in> Ada.Strings.Bounded   *note A.4.4(12.1/2): 5852.
Set_Col
   <in> Ada.Text_IO   *note A.10.1(35): 6434.
Set_CPU
   <in> System.Multiprocessors.Dispatching_Domains   *note D.16.1(12/3):
8089.
Set_Deadline
   <in> Ada.Dispatching.EDF   *note D.2.6(9/2): 7824.
Set_Dependents_Fallback_Handler
   <in> Ada.Task_Termination   *note C.7.3(5/2): 7743.
Set_Directory
   <in> Ada.Directories   *note A.16(6/2): 6637.
Set_Error
   <in> Ada.Text_IO   *note A.10.1(15): 6395.
Set_Exit_Status
   <in> Ada.Command_Line   *note A.15(9): 6633.
Set_False
   <in> Ada.Synchronous_Task_Control   *note D.10(4): 7976.
Set_Handler
   <in> Ada.Execution_Time.Group_Budgets   *note D.14.2(10/2): 8044.
   <in> Ada.Execution_Time.Timers   *note D.14.1(7/2): 8019.
   <in> Ada.Real_Time.Timing_Events   *note D.15(5/2): 8061.
Set_Im
   <in> Ada.Numerics.Generic_Complex_Arrays   *note G.3.2(8/2): 8392,
*note G.3.2(28/2): 8405.
   <in> Ada.Numerics.Generic_Complex_Types   *note G.1.1(7): 8268.
Set_Index
   <in> Ada.Direct_IO   *note A.8.4(14): 6343.
   <in> Ada.Streams.Stream_IO   *note A.12.1(22): 6590.
Set_Input
   <in> Ada.Text_IO   *note A.10.1(15): 6393.
Set_Iterator_Interfaces
   <in> Ada.Containers.Hashed_Sets   *note A.18.8(6.2/3): 7046.
   <in> Ada.Containers.Ordered_Sets   *note A.18.9(7.2/3): 7119.
Set_Length
   <in> Ada.Containers.Vectors   *note A.18.2(22/2): 6738.
Set_Line
   <in> Ada.Text_IO   *note A.10.1(36): 6436.
Set_Line_Length
   <in> Ada.Text_IO   *note A.10.1(23): 6411.
Set_Mode
   <in> Ada.Streams.Stream_IO   *note A.12.1(24): 6593.
Set_Output
   <in> Ada.Text_IO   *note A.10.1(15): 6394.
Set_Page_Length
   <in> Ada.Text_IO   *note A.10.1(24): 6413.
Set_Pool_of_Subpool
   <in> System.Storage_Pools.Subpools   *note 13.11.4(10/3): 5262.
Set_Priority
   <in> Ada.Dynamic_Priorities   *note D.5.1(4): 7866.
Set_Quantum
   <in> Ada.Dispatching.Round_Robin   *note D.2.5(4/2): 7816.
Set_Re
   <in> Ada.Numerics.Generic_Complex_Arrays   *note G.3.2(8/2): 8391,
*note G.3.2(28/2): 8404.
   <in> Ada.Numerics.Generic_Complex_Types   *note G.1.1(7): 8266.
Set_Specific_Handler
   <in> Ada.Task_Termination   *note C.7.3(6/2): 7745.
Set_True
   <in> Ada.Synchronous_Task_Control   *note D.10(4): 7975.
Set_Unbounded_String
   <in> Ada.Strings.Unbounded   *note A.4.5(11.1/2): 5911.
Set_Value
   <in> Ada.Task_Attributes   *note C.7.2(6): 7732.
shared passive library unit   *note E.2(4/3): 8118, *note E.2.1(4/3):
8127.
shared variable
   protection of   *note 9.10(1/3): 4305.
Shared_Passive aspect   *note E.2.1(4/3): 8129.
Shared_Passive pragma   *note E.2.1(3): 8125, *note L(34): 8847.
shift   *note B.2(9): 7428.
Shift_Left   *note B.2(6): 7421.
Shift_Right   *note B.2(6): 7422.
Shift_Right_Arithmetic   *note B.2(6): 7423.
short
   <in> Interfaces.C   *note B.3(7): 7438.
short-circuit control form   *note 4.5.1(1): 2739.
Short_Float   *note 3.5.7(16): 1819.
Short_Integer   *note 3.5.4(25): 1763.
SI
   <in> Ada.Characters.Latin_1   *note A.3.3(5): 5515.
signal
   as defined between actions   *note 9.10(2): 4308.
   <See> interrupt   *note C.3(1/3): 7629.
signal (an exception)
   <See> raise   *note 11(1/3): 4508.
signal handling
   example   *note 9.7.4(10): 4269.
signed integer type   *note 3.5.4(1): 1718.
signed_char
   <in> Interfaces.C   *note B.3(8): 7440.
signed_integer_type_definition   *note 3.5.4(3): 1724.
   <used>   *note 3.5.4(2): 1722, *note P: 9085.
Signed_Zeros attribute   *note A.5.3(13): 6201.
simple entry call   *note 9.5.3(1): 4090.
simple name
   of a file   *note A.16(47/2): 6681.
Simple_Barriers restriction   *note D.7(10.11/3): 7911.
simple_expression   *note 4.4(4): 2695.
   <used>   *note 3.5(3): 1589, *note 3.5.4(3): 1725, *note 3.5.7(3):
1799, *note 3.5.9(5/4): 1840, *note 4.4(2.2/3): 2680, *note 4.4(3.2/4):
2692, *note 4.4(3/4): 2685, *note 11.3(2.1/4): 4549, *note 13.5.1(5):
5071, *note 13.5.1(6): 5073, *note J.3(2/4): 8496, *note P: 9078.
Simple_Name
   <in> Ada.Directories   *note A.16(16/2): 6646, *note A.16(38/2):
6666.
   <in> Ada.Directories.Hierarchical_File_Names   *note A.16.1(10/3):
6693.
simple_return_statement   *note 6.5(2/2): 3497.
   <used>   *note 5.1(4/2): 3127, *note P: 9362.
simple_statement   *note 5.1(4/2): 3121.
   <used>   *note 5.1(3): 3118, *note P: 9354.
Sin
   <in> Ada.Numerics.Generic_Complex_Elementary_Functions   *note
G.1.2(4): 8290.
   <in> Ada.Numerics.Generic_Elementary_Functions   *note A.5.1(5):
6116.
single
   class expected type   *note 8.6(27/2): 3867.
single entry   *note 9.5.2(20): 4079.
Single_Precision_Complex_Types
   <in> Interfaces.Fortran   *note B.5(8): 7604.
single_protected_declaration   *note 9.4(3/3): 3961.
   <used>   *note 3.3.1(2/3): 1493, *note P: 9068.
single_task_declaration   *note 9.1(3/3): 3899.
   <used>   *note 3.3.1(2/3): 1492, *note P: 9067.
Sinh
   <in> Ada.Numerics.Generic_Complex_Elementary_Functions   *note
G.1.2(6): 8298.
   <in> Ada.Numerics.Generic_Elementary_Functions   *note A.5.1(7):
6131.
size
   of an object   *note 13.1(7/2): 4884.
   <in> Ada.Direct_IO   *note A.8.4(15): 6345.
   <in> Ada.Directories   *note A.16(26/2): 6657, *note A.16(41/2):
6669.
   <in> Ada.Streams.Stream_IO   *note A.12.1(23): 6592.
Size (object) aspect   *note 13.3(41): 5005.
Size (subtype) aspect   *note 13.3(48): 5012.
Size attribute   *note 13.3(40): 5001, *note 13.3(45): 5008.
Size clause   *note 13.3(7/2): 4961, *note 13.3(41): 5003, *note
13.3(48): 5010.
size_t
   <in> Interfaces.C   *note B.3(13): 7447.
Skip_Line
   <in> Ada.Text_IO   *note A.10.1(29): 6421.
Skip_Page
   <in> Ada.Text_IO   *note A.10.1(32): 6428.
slice   *note 4.1.2(2): 2407.
   <used>   *note 4.1(2/3): 2363, *note P: 9199.
   <in> Ada.Strings.Bounded   *note A.4.4(28): 5863.
   <in> Ada.Strings.Unbounded   *note A.4.5(22): 5917.
small
   of a fixed point type   *note 3.5.9(8/2): 1846.
Small aspect   *note 3.5.10(2/1): 1869.
Small attribute   *note 3.5.10(2/1): 1865.
Small clause   *note 3.5.10(2/1): 1867, *note 13.3(7/2): 4964.
SO
   <in> Ada.Characters.Latin_1   *note A.3.3(5): 5514.
Soft_Hyphen
   <in> Ada.Characters.Latin_1   *note A.3.3(21/3): 5644.
SOH
   <in> Ada.Characters.Latin_1   *note A.3.3(5): 5501.
solidus   *note 2.1(15/3): 1167.
   <in> Ada.Characters.Latin_1   *note A.3.3(8): 5548.
Solve
   <in> Ada.Numerics.Generic_Complex_Arrays   *note G.3.2(46/2): 8415.
   <in> Ada.Numerics.Generic_Real_Arrays   *note G.3.1(24/2): 8375.
Sort
   <in> Ada.Containers.Doubly_Linked_Lists   *note A.18.3(49/2): 6871.
   <in> Ada.Containers.Vectors   *note A.18.2(77/2): 6799.
SOS
   <in> Ada.Characters.Latin_1   *note A.3.3(19): 5622.
SPA
   <in> Ada.Characters.Latin_1   *note A.3.3(18): 5620.
Space
   <in> Ada.Characters.Latin_1   *note A.3.3(8): 5532.
   <in> Ada.Strings   *note A.4.1(4/2): 5771.
special file   *note A.16(45/2): 6676.
special graphic character
   a category of Character   *note A.3.2(32): 5497.
Special_Set
   <in> Ada.Strings.Maps.Constants   *note A.4.6(4): 5964.
Specialized Needs Annexes   *note 1.1.2(7): 1006.
specifiable
   of Address for entries   *note J.7.1(6): 8511.
   of Address for stand-alone objects and for program units   *note
13.3(12): 4980.
   of Alignment for first subtypes   *note 13.3(26.4/2): 4992.
   of Alignment for objects   *note 13.3(25/2): 4988.
   of Bit_Order for record types and record extensions   *note
13.5.3(4): 5097.
   of Component_Size for array types   *note 13.3(70): 5023.
   of External_Tag for a tagged type   *note 13.3(75/3): 5035, *note
K.2(65): 8662.
   of Input for a type   *note 13.13.2(38/4): 5372.
   of Machine_Radix for decimal first subtypes   *note F.1(1): 8219.
   of Output for a type   *note 13.13.2(38/4): 5373.
   of Read for a type   *note 13.13.2(38/4): 5370.
   of Size for first subtypes   *note 13.3(48): 5009.
   of Size for stand-alone objects   *note 13.3(41): 5002.
   of Small for fixed point types   *note 3.5.10(2/1): 1866.
   of Storage_Pool for a nonderived access-to-object type   *note
13.11(15): 5202.
   of Storage_Size for a nonderived access-to-object type   *note
13.11(15): 5201.
   of Storage_Size for a task first subtype   *note J.9(3/3): 8520.
   of Write for a type   *note 13.13.2(38/4): 5371.
specifiable (of an attribute and for an entity)   *note 13.3(5/3): 4954.
specific handler   *note C.7.3(9/2): 7751.
specific postcondition expression   *note 6.1.1(4/3): 3353.
specific precondition expression   *note 6.1.1(2/3): 3345.
specific type   *note 3.4.1(3/2): 1565.
Specific_Handler
   <in> Ada.Task_Termination   *note C.7.3(6/2): 7746.
specified
   of an aspect of representation of an entity   *note 13.1(17): 4898.
   of an operational aspect of an entity   *note 13.1(18.1/1): 4900.
specified (not!)    *note 1.1.3(18): 1056.
specified as independently addressable   *note C.6(8.1/4): 7702.
specified discriminant   *note 3.7(18): 1989.
Splice
   <in> Ada.Containers.Doubly_Linked_Lists   *note A.18.3(30/2): 6853,
*note A.18.3(31/2): 6854, *note A.18.3(32/2): 6855.
Splice_Children
   <in> Ada.Containers.Multiway_Trees   *note A.18.10(57/3): 7250, *note
A.18.10(58/3): 7251.
Splice_Subtree
   <in> Ada.Containers.Multiway_Trees   *note A.18.10(55/3): 7248, *note
A.18.10(56/3): 7249.
Split
   <in> Ada.Calendar   *note 9.6(14): 4156.
   <in> Ada.Calendar.Formatting   *note 9.6.1(29/2): 4199, *note
9.6.1(32/2): 4202, *note 9.6.1(33/2): 4203, *note 9.6.1(34/2): 4204.
   <in> Ada.Execution_Time   *note D.14(8/2): 8006.
   <in> Ada.Real_Time   *note D.8(16): 7961.
Sqrt
   <in> Ada.Numerics.Generic_Complex_Elementary_Functions   *note
G.1.2(3): 8286.
   <in> Ada.Numerics.Generic_Elementary_Functions   *note A.5.1(4):
6111.
SS2
   <in> Ada.Characters.Latin_1   *note A.3.3(17): 5612.
SS3
   <in> Ada.Characters.Latin_1   *note A.3.3(17): 5613.
SSA
   <in> Ada.Characters.Latin_1   *note A.3.3(17): 5604.
ST
   <in> Ada.Characters.Latin_1   *note A.3.3(19): 5626.
stand-alone constant   *note 3.3.1(23/3): 1521.
   corresponding to a formal object of mode in   *note 12.4(10/2): 4762.
stand-alone object   *note 3.3.1(1/3): 1473.
   [<partial>]   *note 12.4(10/2): 4763.
stand-alone variable   *note 3.3.1(23/3): 1522.
Standard   *note A.1(4): 5436.
standard error file   *note A.10(6): 6363.
standard input file   *note A.10(5): 6361.
standard mode   *note 1.1.5(11): 1084.
standard output file   *note A.10(5): 6362.
standard storage pool   *note 13.11(17): 5209.
Standard_Error
   <in> Ada.Text_IO   *note A.10.1(16): 6398, *note A.10.1(19): 6405.
Standard_Input
   <in> Ada.Text_IO   *note A.10.1(16): 6396, *note A.10.1(19): 6403.
Standard_Output
   <in> Ada.Text_IO   *note A.10.1(16): 6397, *note A.10.1(19): 6404.
Start_Search
   <in> Ada.Directories   *note A.16(32/2): 6662.
State
   <in> Ada.Numerics.Discrete_Random   *note A.5.2(23): 6165.
   <in> Ada.Numerics.Float_Random   *note A.5.2(11): 6153.
statement   *note 5.1(3): 3116.
   <used>   *note 5.1(2/3): 3114, *note P: 9350.
statement_identifier   *note 5.1(8): 3145.
   <used>   *note 5.1(7): 3144, *note 5.5(2): 3191, *note 5.6(2): 3261,
*note P: 9390.
static   *note 4.9(1): 3086.
   constant   *note 4.9(24): 3091.
   constraint   *note 4.9(27): 3097.
   delta constraint   *note 4.9(29): 3100.
   digits constraint   *note 4.9(29): 3099.
   discrete_range   *note 4.9(25): 3093.
   discriminant constraint   *note 4.9(31): 3102.
   expression   *note 4.9(2): 3088.
   function   *note 4.9(18): 3090.
   index constraint   *note 4.9(30): 3101.
   range   *note 4.9(25): 3092.
   range constraint   *note 4.9(29): 3098.
   scalar subtype   *note 4.9(26/3): 3095.
   string subtype   *note 4.9(26/3): 3096.
   subtype   *note 4.9(26/3): 3094.
   subtype   *note 12.4(9/2): 4760.
static semantics   *note 1.1.2(28): 1027.
Static_Predicate aspect   *note 3.2.4(1/3): 1437.
statically
   constrained   *note 4.9(32): 3103.
   denote   *note 4.9(14): 3089.
statically compatible
   for a constraint and a scalar subtype   *note 4.9.1(4/3): 3109.
   for a constraint and an access or composite subtype   *note
4.9.1(4/3): 3110.
   for two subtypes   *note 4.9.1(5/3): 3111.
statically deeper   *note 3.10.2(4): 2295, *note 3.10.2(17): 2302.
statically determined tag   *note 3.9.2(1/2): 2149.
   [<partial>]   *note 3.9.2(15): 2174, *note 3.9.2(19): 2178.
statically matching
   effect on subtype-specific aspects   *note 13.1(14): 4897.
   for constraints   *note 4.9.1(1/2): 3106.
   for ranges   *note 4.9.1(3): 3108.
   for subtypes   *note 4.9.1(2/3): 3107.
   required   *note 3.9.2(10/2): 2170, *note 3.10.2(28.1/2): 2309, *note
4.6(24.15/2): 2954, *note 4.6(24.5/2): 2949, *note 6.3.1(16.3/3): 3432,
*note 6.3.1(17/3): 3435, *note 6.3.1(23): 3440, *note 6.5(5.2/3): 3513,
*note 7.3(13): 3615, *note 8.5.1(4.2/2): 3808, *note 12.4(8.1/2): 4756,
*note 12.5.1(14): 4806, *note 12.5.3(6): 4818, *note 12.5.3(7): 4819,
*note 12.5.4(3): 4822, *note 12.7(7): 4865.
statically tagged   *note 3.9.2(4/2): 2167.
statically unevaluated   *note 4.9(32.1/3): 3104.
Status_Error
   <in> Ada.Direct_IO   *note A.8.4(18): 6347.
   <in> Ada.Directories   *note A.16(43/2): 6671.
   <in> Ada.IO_Exceptions   *note A.13(4): 6614.
   <in> Ada.Sequential_IO   *note A.8.1(15): 6315.
   <in> Ada.Streams.Stream_IO   *note A.12.1(26): 6595.
   <in> Ada.Text_IO   *note A.10.1(85): 6520.
storage deallocation
   unchecked   *note 13.11.2(1): 5224.
storage element   *note 13.3(8): 4974.
storage management
   user-defined   *note 13.11(1): 5184.
storage node   *note E(2): 8096.
storage place
   of a component   *note 13.5(1): 5057.
   representation aspect   *note 13.5(1): 5056.
storage place attributes
   of a component   *note 13.5.2(1): 5079.
storage pool   *note 3.10(7/1): 2251, *note N(37.1/3): 8947.
   default   *note 13.11.3(4.2/4): 5252.
storage pool element   *note 13.11(11): 5194.
storage pool that supports subpools   *note 13.11.4(18/3): 5273.
storage pool type   *note 13.11(11): 5192.
Storage_Array
   <in> System.Storage_Elements   *note 13.7.1(5): 5136.
Storage_Check   *note 11.5(23): 4641.
   [<partial>]   *note 11.1(6): 4524, *note 13.3(67): 5018, *note
13.11(17): 5210, *note D.7(17/1): 7922, *note D.7(18/1): 7927, *note
D.7(19/1): 7932.
Storage_Count <subtype of> Storage_Offset
   <in> System.Storage_Elements   *note 13.7.1(4): 5134.
Storage_Element
   <in> System.Storage_Elements   *note 13.7.1(5): 5135.
Storage_Elements
   <child of> System   *note 13.7.1(2/2): 5132.
Storage_Error
   raised by failure of run-time check   *note 4.8(14): 3085, *note
8.5.4(8.1/1): 3834, *note 11.1(4): 4521, *note 11.1(6): 4526, *note
11.5(23): 4642, *note 13.3(67): 5020, *note 13.11(17): 5212, *note
13.11(18/4): 5213, *note A.7(14/3): 6288, *note D.7(17/1): 7924, *note
D.7(18/1): 7929, *note D.7(19.3/3): 7940, *note D.7(19/1): 7934.
   <in> Standard   *note A.1(46): 5453.
Storage_IO
   <child of> Ada   *note A.9(3): 6355.
Storage_Offset
   <in> System.Storage_Elements   *note 13.7.1(3): 5133.
Storage_Pool aspect   *note 13.11(15): 5206.
Storage_Pool attribute   *note 13.11(13): 5198.
Storage_Pool clause   *note 13.3(7/2): 4966, *note 13.11(15): 5203.
storage_pool_indicator   *note 13.11.3(3.1/4): 5249.
   <used>   *note 13.11.3(3/3): 5248, *note L(8.3/3): 8733.
Storage_Pools
   <child of> System   *note 13.11(5): 5187.
Storage_Size
   <in> System.Storage_Pools   *note 13.11(9): 5191.
   <in> System.Storage_Pools.Subpools   *note 13.11.4(16/3): 5268.
Storage_Size (access) aspect   *note 13.11(15): 5208.
Storage_Size (task) aspect   *note 13.3(65.2/3): 5017.
Storage_Size attribute   *note 13.3(60/3): 5015, *note 13.11(14): 5200,
*note J.9(2): 8519.
Storage_Size clause   *note 13.3(7/2): 4967, *note 13.11(15): 5204.
Storage_Size pragma   *note J.15.4(2/3): 8548, *note L(35.1/3): 8850.
Storage_Unit
   <in> System   *note 13.7(13): 5119.
stream   *note 13.13(1): 5331, *note N(37.2/3): 8948.
   <in> Ada.Streams.Stream_IO   *note A.12.1(13): 6585.
   <in> Ada.Text_IO.Text_Streams   *note A.12.2(4): 6606.
   <in> Ada.Wide_Text_IO.Text_Streams   *note A.12.3(4): 6609.
   <in> Ada.Wide_Wide_Text_IO.Text_Streams   *note A.12.4(4/2): 6612.
stream file   *note A.8(1/2): 6292.
stream type   *note 13.13(1): 5332.
stream-oriented attributes   *note 13.13.2(1/3): 5342.
Stream_Access
   <in> Ada.Streams.Stream_IO   *note A.12.1(4): 6569.
   <in> Ada.Text_IO.Text_Streams   *note A.12.2(3): 6605.
   <in> Ada.Wide_Text_IO.Text_Streams   *note A.12.3(3): 6608.
   <in> Ada.Wide_Wide_Text_IO.Text_Streams   *note A.12.4(3/2): 6611.
Stream_Element
   <in> Ada.Streams   *note 13.13.1(4/1): 5336.
Stream_Element_Array
   <in> Ada.Streams   *note 13.13.1(4/1): 5339.
Stream_Element_Count <subtype of> Stream_Element_Offset
   <in> Ada.Streams   *note 13.13.1(4/1): 5338.
Stream_Element_Offset
   <in> Ada.Streams   *note 13.13.1(4/1): 5337.
Stream_IO
   <child of> Ada.Streams   *note A.12.1(3/3): 6568.
Stream_Size aspect   *note 13.13.2(1.5/2): 5347.
Stream_Size attribute   *note 13.13.2(1.2/3): 5345.
Stream_Size clause   *note 13.3(7/2): 4968.
Streams
   <child of> Ada   *note 13.13.1(2): 5333.
strict mode   *note G.2(1): 8330.
strict weak ordering   *note A.18(5/3): 6713.
String
   <in> Standard   *note A.1(37/3): 5447.
string type   *note 3.6.3(1): 1963.
String_Access
   <in> Ada.Strings.Unbounded   *note A.4.5(7): 5906.
string_element   *note 2.6(3): 1252.
   <used>   *note 2.6(2): 1251, *note P: 8995.
string_literal   *note 2.6(2): 1250.
   <used>   *note 4.4(7/3): 2711, *note 6.1(9): 3305, *note P: 9310.
Strings
   <child of> Ada   *note A.4.1(3): 5770.
   <child of> Ada.Strings.UTF_Encoding   *note A.4.11(22/3): 6081.
   <child of> Interfaces.C   *note B.3.1(3): 7496.
Strlen
   <in> Interfaces.C.Strings   *note B.3.1(17): 7510.
structure
   <See> record type   *note 3.8(1): 2023.
STS
   <in> Ada.Characters.Latin_1   *note A.3.3(18): 5617.
STX
   <in> Ada.Characters.Latin_1   *note A.3.3(5): 5502.
SUB
   <in> Ada.Characters.Latin_1   *note A.3.3(6): 5526.
Sub_Second
   <in> Ada.Calendar.Formatting   *note 9.6.1(27/2): 4197.
subaggregate
   of an array_aggregate   *note 4.3.3(6): 2562.
subcomponent   *note 3.2(6/2): 1347.
subpool   *note 13.11.4(18/3): 5269.
subpool access type   *note 13.11.4(22/3): 5275.
subpool handle   *note 13.11.4(18/3): 5271.
Subpool_Handle
   <in> System.Storage_Pools.Subpools   *note 13.11.4(6/3): 5259.
subpool_specification   *note 4.8(2.1/3): 3048.
   <used>   *note 4.8(2/3): 3044, *note P: 9347.
Subpools
   <child of> System.Storage_Pools   *note 13.11.4(3/3): 5256.
subprogram   *note 6(1): 3275, *note N(37.3/2): 8949.
   abstract   *note 3.9.3(3/2): 2192.
subprogram call   *note 6.4(1): 3445.
subprogram instance   *note 12.3(13): 4728.
subprogram_body   *note 6.3(2/3): 3402.
   <used>   *note 3.11(6): 2340, *note 9.4(8/4): 3984, *note 10.1.1(7):
4343, *note P: 9666.
subprogram_body_stub   *note 10.1.3(3/3): 4392.
   <used>   *note 10.1.3(2): 4388, *note P: 9678.
subprogram_declaration   *note 6.1(2/3): 3281.
   <used>   *note 3.1(3/3): 1297, *note 9.4(5/1): 3971, *note 9.4(8/4):
3983, *note 10.1.1(5): 4334, *note P: 9659.
subprogram_default   *note 12.6(3/2): 4839.
   <used>   *note 12.6(2.1/3): 4833, *note 12.6(2.2/3): 4837, *note P:
9786.
subprogram_renaming_declaration   *note 8.5.4(2/3): 3822.
   <used>   *note 8.5(2): 3793, *note 10.1.1(6): 4341, *note P: 9512.
subprogram_specification   *note 6.1(4/2): 3285.
   <used>   *note 3.9.3(1.1/3): 2187, *note 6.1(2/3): 3283, *note
6.3(2/3): 3404, *note 8.5.4(2/3): 3824, *note 10.1.3(3/3): 4394, *note
12.1(3/3): 4672, *note 12.6(2.1/3): 4832, *note 12.6(2.2/3): 4836, *note
P: 9412.
subsystem   *note 10.1(3): 4320, *note N(22): 8922.
subtree
   node which roots   *note A.18.10(3/4): 7196.
   of a tree   *note A.18.10(3/4): 7194.
Subtree_Node_Count
   <in> Ada.Containers.Multiway_Trees   *note A.18.10(18/3): 7211.
subtype   *note 3.2(8/2): 1354, *note N(38/3): 8950.
   constraint of   *note 3.2(8/2): 1358.
   type of   *note 3.2(8/2): 1356.
   values belonging to   *note 3.2(8/2): 1361.
subtype (of an object)
   <See> actual subtype of an object   *note 3.3(23/3): 1467.
   <See> actual subtype of an object   *note 3.3.1(9/2): 1507.
subtype conformance   *note 6.3.1(17/3): 3433.
   [<partial>]   *note 3.10.2(35/2): 2324, *note 9.5.4(17): 4130.
   required   *note 3.9.2(10/2): 2171, *note 3.10.2(33/3): 2320, *note
4.6(24.20/3): 2960, *note 8.5.1(4.3/2): 3809, *note 8.5.4(5/3): 3832,
*note 9.1(9.7/2): 3924, *note 9.1(9.8/2): 3925, *note 9.4(11.6/2): 3997,
*note 9.4(11.7/2): 3998, *note 9.5.4(5/3): 4124, *note 12.4(8.2/2):
4757, *note 12.5.4(5/3): 4823.
subtype conversion
   <See> type conversion   *note 4.6(1/3): 2919.
   <See also> implicit subtype conversion   *note 4.6(1/3): 2923.
subtype-specific
   of a representation item   *note 13.1(8/3): 4890.
   of an aspect   *note 13.1(8/3): 4892.
subtype_declaration   *note 3.2.2(2/3): 1400.
   <used>   *note 3.1(3/3): 1294, *note P: 9010.
subtype_indication   *note 3.2.2(3/2): 1404.
   <used>   *note 3.2.2(2/3): 1402, *note 3.3.1(2/3): 1481, *note
3.4(2/2): 1534, *note 3.6(6): 1901, *note 3.6(7/2): 1904, *note
3.6.1(3): 1936, *note 3.8.1(5/3): 2070, *note 3.10(3): 2234, *note
4.8(2/3): 3045, *note 5.5.2(2/3): 3239, *note 6.5(2.3/2): 3507, *note
7.3(3/3): 3607, *note P: 9346.
subtype_mark   *note 3.2.2(4): 1408.
   <used>   *note 3.2.2(3/2): 1406, *note 3.6(4): 1895, *note 3.7(5/2):
1977, *note 3.9.4(3/2): 2198, *note 3.10(6/2): 2242, *note 4.3.2(3):
2532, *note 4.4(3.2/4): 2694, *note 4.6(2): 2928, *note 4.7(2): 3028,
*note 6.1(13/2): 3313, *note 6.1(15/3): 3323, *note 8.4(4/3): 3781,
*note 8.5.1(2/3): 3801, *note 12.3(5): 4720, *note 12.4(2/3): 4745,
*note 12.5.1(3/2): 4802, *note P: 9748.
subtypes
   of a profile   *note 6.1(25): 3342.
subunit   *note 10.1.3(7): 4405, *note 10.1.3(8/2): 4409.
   of a program unit   *note 10.1.3(8/2): 4410.
   <used>   *note 10.1.1(3): 4328, *note P: 9655.
Succ attribute   *note 3.5(22): 1625.
Success
   <in> Ada.Command_Line   *note A.15(8): 6631.
successor element
   of a hashed set   *note A.18.8(68/2): 7108.
   of a set   *note A.18.7(6/2): 7025.
   of an ordered set   *note A.18.9(81/3): 7187.
successor node
   of a hashed map   *note A.18.5(46/2): 6958.
   of a map   *note A.18.4(6/2): 6896.
   of an ordered map   *note A.18.6(58/3): 7016.
Sunday
   <in> Ada.Calendar.Formatting   *note 9.6.1(17/2): 4185.
super
   <See> view conversion   *note 4.6(5/2): 2938.
Superscript_One
   <in> Ada.Characters.Latin_1   *note A.3.3(22): 5658.
Superscript_Three
   <in> Ada.Characters.Latin_1   *note A.3.3(22): 5651.
Superscript_Two
   <in> Ada.Characters.Latin_1   *note A.3.3(22): 5650.
support external streaming   *note 13.13.2(52/3): 5396.
Supported
   <in> Ada.Execution_Time.Interrupts   *note D.14.3(3/3): 8057.
Suppress pragma   *note 11.5(4/2): 4618, *note J.10(3/2): 8522, *note
L(36): 8853.
suppressed check   *note 11.5(8/2): 4627.
Suspend_Until_True
   <in> Ada.Synchronous_Task_Control   *note D.10(4): 7978.
Suspend_Until_True_And_Set_Deadline
   <in> Ada.Synchronous_Task_Control.EDF   *note D.10(5.2/3): 7980.
Suspension_Object
   <in> Ada.Synchronous_Task_Control   *note D.10(4): 7974.
Swap
   <in> Ada.Containers.Doubly_Linked_Lists   *note A.18.3(28/2): 6851.
   <in> Ada.Containers.Multiway_Trees   *note A.18.10(37/3): 7230.
   <in> Ada.Containers.Vectors   *note A.18.2(55/2): 6778, *note
A.18.2(56/2): 6779.
Swap_Links
   <in> Ada.Containers.Doubly_Linked_Lists   *note A.18.3(29/2): 6852.
Symmetric_Difference
   <in> Ada.Containers.Hashed_Sets   *note A.18.8(35/2): 7074, *note
A.18.8(36/2): 7075.
   <in> Ada.Containers.Ordered_Sets   *note A.18.9(36/2): 7147, *note
A.18.9(37/2): 7148.
SYN
   <in> Ada.Characters.Latin_1   *note A.3.3(6): 5522.
synchronization   *note 9(1/3): 3878.
Synchronization aspect   *note 9.5(12/3): 4020.
synchronization_kind   *note 9.5(10/3): 4018.
synchronized   *note N(38.1/2): 8951.
synchronized interface   *note 3.9.4(5/2): 2207.
synchronized tagged type   *note 3.9.4(6/2): 2212.
Synchronized_Queue_Interfaces
   <child of> Ada.Containers   *note A.18.27(3/3): 7336.
Synchronous_Barrier
   <in> Ada.Synchronous_Barriers   *note D.10.1(5/3): 7986.
Synchronous_Barriers
   <child of> Ada   *note D.10.1(3/3): 7984.
Synchronous_Task_Control
   <child of> Ada   *note D.10(3/2): 7973.
syntactic category   *note 1.1.4(15): 1066.
syntax
   complete listing   *note P(1): 8957.
   cross reference   *note P(1): 9846.
   notation   *note 1.1.4(3): 1060.
   under Syntax heading   *note 1.1.2(25): 1014.
System   *note 13.7(3/2): 5105.
System.Address_To_Access_Conversions   *note 13.7.2(2): 5144.
System.Machine_Code   *note 13.8(7): 5153.
System.Multiprocessors   *note D.16(3/3): 8070.
System.Multiprocessors.Dispatching_Domains   *note D.16.1(3/3): 8077.
System.RPC   *note E.5(3): 8204.
System.Storage_Elements   *note 13.7.1(2/2): 5132.
System.Storage_Pools   *note 13.11(5): 5187.
System.Storage_Pools.Subpools   *note 13.11.4(3/3): 5256.
System_Dispatching_Domain
   <in> System.Multiprocessors.Dispatching_Domains   *note D.16.1(6/3):
8080.
System_Name
   <in> System   *note 13.7(4): 5107.
systems programming   *note C(1): 7617.



File: arm2012.info,  Node: T,  Next: U,  Prev: S,  Up: Index

T 
==



Tag
   <in> Ada.Tags   *note 3.9(6/2): 2101.
Tag attribute   *note 3.9(16): 2122, *note 3.9(18): 2124.
tag indeterminate   *note 3.9.2(6/2): 2169.
tag of an object   *note 3.9(3): 2093.
   class-wide object   *note 3.9(22): 2128.
   object created by an allocator   *note 3.9(21): 2127.
   preserved by type conversion and parameter passing   *note 3.9(25):
2131.
   returned by a function   *note 3.9(23): 2129, *note 3.9(24/2): 2130.
   stand-alone object, component, or aggregate   *note 3.9(20): 2126.
Tag_Array
   <in> Ada.Tags   *note 3.9(7.3/2): 2111.
Tag_Check   *note 11.5(18): 4636.
   [<partial>]   *note 3.9.2(16): 2175, *note 4.6(42): 2986, *note
4.6(52): 3011, *note 5.2(10): 3162, *note 6.5(8.1/3): 3528.
Tag_Error
   <in> Ada.Tags   *note 3.9(8): 2114.
tagged incomplete view   *note 3.10.1(2.1/4): 2281.
tagged type   *note 3.9(2/2): 2087, *note N(39): 8952.
   protected   *note 3.9.4(6/2): 2216.
   synchronized   *note 3.9.4(6/2): 2214.
   task   *note 3.9.4(6/2): 2215.
Tags
   <child of> Ada   *note 3.9(6/2): 2100.
Tail
   <in> Ada.Strings.Bounded   *note A.4.4(72): 5897, *note A.4.4(73):
5898.
   <in> Ada.Strings.Fixed   *note A.4.3(37): 5840, *note A.4.3(38):
5841.
   <in> Ada.Strings.Unbounded   *note A.4.5(67): 5951, *note A.4.5(68):
5952.
tail (of a queue)   *note D.2.1(5/2): 7778.
tamper with cursors
   of a list   *note A.18.3(62/2): 6875.
   of a map   *note A.18.4(8/2): 6897.
   of a set   *note A.18.7(8/2): 7026.
   of a tree   *note A.18.10(81/3): 7266.
   of a vector   *note A.18.2(91/2): 6803.
tamper with elements
   of a holder   *note A.18.18(30/3): 7302.
   of a list   *note A.18.3(67/2): 6876.
   of a map   *note A.18.4(13/2): 6898.
   of a set   *note A.18.7(13/2): 7027.
   of a tree   *note A.18.10(87/3): 7267.
   of a vector   *note A.18.2(95/2): 6804.
tampering
   prohibited for a holder   *note A.18.18(35/4): 7304.
   prohibited for a list   *note A.18.3(69.1/4): 6878.
   prohibited for a map   *note A.18.4(15.1/4): 6900.
   prohibited for a set   *note A.18.7(14.1/4): 7029.
   prohibited for a tree   *note A.18.10(90/4): 7269.
   prohibited for a vector   *note A.18.2(97.1/4): 6806.
Tan
   <in> Ada.Numerics.Generic_Complex_Elementary_Functions   *note
G.1.2(4): 8292.
   <in> Ada.Numerics.Generic_Elementary_Functions   *note A.5.1(5):
6119.
Tanh
   <in> Ada.Numerics.Generic_Complex_Elementary_Functions   *note
G.1.2(6): 8300.
   <in> Ada.Numerics.Generic_Elementary_Functions   *note A.5.1(7):
6133.
target
   of an assignment operation   *note 5.2(3): 3155.
   of an assignment_statement   *note 5.2(3): 3156.
target object
   of a requeue_statement   *note 9.5(7): 4015.
   of the name of an entry or a protected subprogram   *note 9.5(2/3):
4012.
target statement
   of a goto_statement   *note 5.8(3): 3273.
target subtype
   of a type_conversion   *note 4.6(3): 2930.
task   *note 9(1/3): 3875.
   activation   *note 9.2(1): 3936.
   completion   *note 9.3(1): 3943.
   dependence   *note 9.3(1): 3942.
   execution   *note 9.2(1): 3934.
   termination   *note 9.3(1): 3944.
task declaration   *note 9.1(1): 3892.
task dispatching   *note D.2.1(4/2): 7772.
task dispatching point   *note D.2.1(4/2): 7774.
   [<partial>]   *note D.2.3(8/2): 7800, *note D.2.4(9/3): 7809.
task dispatching policy   *note D.2.2(7/2): 7796.
   [<partial>]   *note D.2.1(5/2): 7780.
   EDF_Across_Priorities   *note D.2.6(7/2): 7819.
   FIFO_Within_Priorities   *note D.2.3(2/2): 7798.
   Non_Preemptive_FIFO_Within_Priorities   *note D.2.4(2/2): 7804.
   Round_Robin_Within_Priorities   *note D.2.5(2/2): 7811.
task interface   *note 3.9.4(5/2): 2209.
task priority   *note D.1(15): 7761.
task state
   abnormal   *note 9.8(4): 4285.
   blocked   *note 9(10): 3885.
   callable   *note 9.9(2): 4299.
   held   *note D.11(4/2): 7992.
   inactive   *note 9(10): 3883.
   ready   *note 9(10): 3887.
   terminated   *note 9(10): 3889.
task tagged type   *note 3.9.4(6/2): 2217.
task type   *note N(40/2): 8953.
task unit   *note 9(9): 3882.
Task_Array
   <in> Ada.Execution_Time.Group_Budgets   *note D.14.2(6/2): 8033.
Task_Attributes
   <child of> Ada   *note C.7.2(2): 7728.
task_body   *note 9.1(6/3): 3911.
   <used>   *note 3.11(6): 2342, *note P: 9194.
task_body_stub   *note 10.1.3(5/3): 4399.
   <used>   *note 10.1.3(2): 4390, *note P: 9680.
task_definition   *note 9.1(4): 3904.
   <used>   *note 9.1(2/3): 3898, *note 9.1(3/3): 3903, *note P: 9550.
Task_Dispatching_Policy pragma   *note D.2.2(3): 7785, *note L(37):
8856.
Task_Id
   <in> Ada.Task_Identification   *note C.7.1(2/2): 7709.
Task_Identification
   <child of> Ada   *note C.7.1(2/2): 7708.
task_item   *note 9.1(5/1): 3908.
   <used>   *note 9.1(4): 3906, *note P: 9551.
Task_Termination
   <child of> Ada   *note C.7.3(2/2): 7740.
task_type_declaration   *note 9.1(2/3): 3893.
   <used>   *note 3.2.1(3/3): 1378, *note P: 9031.
Tasking_Error
   raised by failure of run-time check   *note 9.2(5): 3940, *note
9.5.3(21): 4116, *note 11.1(4): 4522, *note 13.11.2(13): 5236, *note
13.11.2(14): 5238, *note C.7.2(13): 7734, *note D.5.1(8): 7868, *note
D.11(8): 7995.
   <in> Standard   *note A.1(46): 5454.
template   *note 12(1): 4663.
   for a formal package   *note 12.7(4): 4864.
   <See> generic unit   *note 12(1): 4664.
term   *note 4.4(5): 2700.
   <used>   *note 4.4(4): 2697, *note P: 9301.
terminal interrupt
   example   *note 9.7.4(10): 4271.
terminate_alternative   *note 9.7.1(7): 4233.
   <used>   *note 9.7.1(4): 4226, *note P: 9629.
terminated
   a task state   *note 9(10): 3890.
Terminated attribute   *note 9.9(3): 4302.
termination
   of a partition   *note E.1(7): 8104.
termination handler   *note C.7.3(8/3): 7747.
   fall-back   *note C.7.3(9/2): 7750.
   specific   *note C.7.3(9/2): 7752.
Termination_Handler
   <in> Ada.Task_Termination   *note C.7.3(4/2): 7742.
Terminator_Error
   <in> Interfaces.C   *note B.3(40): 7491.
tested type
   of a membership test   *note 4.5.2(3/3): 2794.
text of a program   *note 2.2(1): 1179.
Text_IO
   <child of> Ada   *note A.10.1(2): 6374.
Text_Streams
   <child of> Ada.Text_IO   *note A.12.2(3): 6604.
   <child of> Ada.Wide_Text_IO   *note A.12.3(3): 6607.
   <child of> Ada.Wide_Wide_Text_IO   *note A.12.4(3/2): 6610.
throw (an exception)
   <See> raise   *note 11(1/3): 4509.
Thursday
   <in> Ada.Calendar.Formatting   *note 9.6.1(17/2): 4182.
tick   *note 2.1(15/3): 1155.
   <in> Ada.Real_Time   *note D.8(6): 7951.
   <in> System   *note 13.7(10): 5116.
Tilde
   <in> Ada.Characters.Latin_1   *note A.3.3(14): 5591.
Time
   <in> Ada.Calendar   *note 9.6(10): 4146.
   <in> Ada.Real_Time   *note D.8(4): 7942.
time base   *note 9.6(6/3): 4143.
time limit
   example   *note 9.7.4(12): 4274.
time type   *note 9.6(6/3): 4142.
Time-dependent Reset procedure
   of the random number generator   *note A.5.2(34): 6174.
time-out
   example   *note 9.7.4(12): 4273.
   <See> asynchronous_select   *note 9.7.4(12): 4272.
   <See> selective_accept   *note 9.7.1(1): 4214.
   <See> timed_entry_call   *note 9.7.2(1/2): 4240.
Time_Error
   <in> Ada.Calendar   *note 9.6(18): 4158.
Time_First
   <in> Ada.Real_Time   *note D.8(4): 7943.
Time_Last
   <in> Ada.Real_Time   *note D.8(4): 7944.
Time_Of
   <in> Ada.Calendar   *note 9.6(15): 4157.
   <in> Ada.Calendar.Formatting   *note 9.6.1(30/2): 4200, *note
9.6.1(31/2): 4201.
   <in> Ada.Execution_Time   *note D.14(9/2): 8007.
   <in> Ada.Real_Time   *note D.8(16): 7962.
Time_Of_Event
   <in> Ada.Real_Time.Timing_Events   *note D.15(6/2): 8065.
Time_Offset
   <in> Ada.Calendar.Time_Zones   *note 9.6.1(4/2): 4170.
Time_Remaining
   <in> Ada.Execution_Time.Timers   *note D.14.1(8/2): 8023.
Time_Span
   <in> Ada.Real_Time   *note D.8(5): 7946.
Time_Span_First
   <in> Ada.Real_Time   *note D.8(5): 7947.
Time_Span_Last
   <in> Ada.Real_Time   *note D.8(5): 7948.
Time_Span_Unit
   <in> Ada.Real_Time   *note D.8(5): 7950.
Time_Span_Zero
   <in> Ada.Real_Time   *note D.8(5): 7949.
Time_Unit
   <in> Ada.Real_Time   *note D.8(4): 7945.
Time_Zones
   <child of> Ada.Calendar   *note 9.6.1(2/2): 4169.
timed_entry_call   *note 9.7.2(2): 4241.
   <used>   *note 9.7(2): 4211, *note P: 9618.
Timer
   <in> Ada.Execution_Time.Timers   *note D.14.1(4/2): 8016.
timer interrupt
   example   *note 9.7.4(12): 4276.
Timer_Handler
   <in> Ada.Execution_Time.Timers   *note D.14.1(5/2): 8017.
Timer_Resource_Error
   <in> Ada.Execution_Time.Timers   *note D.14.1(9/2): 8024.
Timers
   <child of> Ada.Execution_Time   *note D.14.1(3/2): 8015.
times operator   *note 4.4(1/3): 2636, *note 4.5.5(1): 2844.
timing
   <See> delay_statement   *note 9.6(1): 4132.
Timing_Event
   <in> Ada.Real_Time.Timing_Events   *note D.15(4/2): 8059.
Timing_Event_Handler
   <in> Ada.Real_Time.Timing_Events   *note D.15(4/2): 8060.
Timing_Events
   <child of> Ada.Real_Time   *note D.15(3/2): 8058.
To_Ada
   <in> Interfaces.C   *note B.3(22): 7454, *note B.3(26): 7458, *note
B.3(28): 7460, *note B.3(32): 7464, *note B.3(37): 7468, *note B.3(39):
7470, *note B.3(39.10/2): 7480, *note B.3(39.13/2): 7484, *note
B.3(39.17/2): 7488, *note B.3(39.19/2): 7490, *note B.3(39.4/2): 7474,
*note B.3(39.8/2): 7478.
   <in> Interfaces.COBOL   *note B.4(17): 7559, *note B.4(19): 7561.
   <in> Interfaces.Fortran   *note B.5(13): 7612, *note B.5(14): 7614,
*note B.5(16): 7616.
To_Address
   <in> System.Address_To_Access_Conversions   *note 13.7.2(3/3): 5146.
   <in> System.Storage_Elements   *note 13.7.1(10/3): 5139.
To_Basic
   <in> Ada.Characters.Handling   *note A.3.2(6): 5479, *note A.3.2(7):
5482.
To_Binary
   <in> Interfaces.COBOL   *note B.4(45): 7591, *note B.4(48): 7594.
To_Bounded_String
   <in> Ada.Strings.Bounded   *note A.4.4(11): 5850.
To_C
   <in> Interfaces.C   *note B.3(21): 7453, *note B.3(25): 7457, *note
B.3(27): 7459, *note B.3(32): 7463, *note B.3(36): 7467, *note B.3(38):
7469, *note B.3(39.13/2): 7483, *note B.3(39.16/2): 7487, *note
B.3(39.18/2): 7489, *note B.3(39.4/2): 7473, *note B.3(39.7/2): 7477,
*note B.3(39.9/2): 7479.
To_Character
   <in> Ada.Characters.Conversions   *note A.3.4(5/2): 5744.
To_Chars_Ptr
   <in> Interfaces.C.Strings   *note B.3.1(8): 7501.
To_COBOL
   <in> Interfaces.COBOL   *note B.4(17): 7558, *note B.4(18): 7560.
To_Cursor
   <in> Ada.Containers.Vectors   *note A.18.2(25/2): 6741.
To_Decimal
   <in> Interfaces.COBOL   *note B.4(35): 7582, *note B.4(40): 7586,
*note B.4(44): 7590, *note B.4(47): 7593.
To_Display
   <in> Interfaces.COBOL   *note B.4(36): 7583.
To_Domain
   <in> Ada.Strings.Maps   *note A.4.2(24): 5801.
   <in> Ada.Strings.Wide_Maps   *note A.4.7(24): 6003.
   <in> Ada.Strings.Wide_Wide_Maps   *note A.4.8(24/2): 6042.
To_Duration
   <in> Ada.Real_Time   *note D.8(13): 7953.
To_Fortran
   <in> Interfaces.Fortran   *note B.5(13): 7611, *note B.5(14): 7613,
*note B.5(15): 7615.
To_Holder
   <in> Ada.Containers.Indefinite_Holders   *note A.18.18(9/3): 7287.
To_Index
   <in> Ada.Containers.Vectors   *note A.18.2(26/2): 6742.
To_Integer
   <in> System.Storage_Elements   *note 13.7.1(10/3): 5140.
To_ISO_646
   <in> Ada.Characters.Handling   *note A.3.2(11): 5486, *note
A.3.2(12): 5487.
To_Long_Binary
   <in> Interfaces.COBOL   *note B.4(48): 7595.
To_Lower
   <in> Ada.Characters.Handling   *note A.3.2(6): 5477, *note A.3.2(7):
5480.
   <in> Ada.Wide_Characters.Handling   *note A.3.5(20/3): 5765, *note
A.3.5(21/3): 5767.
To_Mapping
   <in> Ada.Strings.Maps   *note A.4.2(23): 5800.
   <in> Ada.Strings.Wide_Maps   *note A.4.7(23): 6002.
   <in> Ada.Strings.Wide_Wide_Maps   *note A.4.8(23/2): 6041.
To_Packed
   <in> Interfaces.COBOL   *note B.4(41): 7587.
To_Picture
   <in> Ada.Text_IO.Editing   *note F.3.3(6): 8237.
To_Pointer
   <in> System.Address_To_Access_Conversions   *note 13.7.2(3/3): 5145.
To_Range
   <in> Ada.Strings.Maps   *note A.4.2(24): 5802.
   <in> Ada.Strings.Wide_Maps   *note A.4.7(25): 6004.
   <in> Ada.Strings.Wide_Wide_Maps   *note A.4.8(25/2): 6043.
To_Ranges
   <in> Ada.Strings.Maps   *note A.4.2(10): 5790.
   <in> Ada.Strings.Wide_Maps   *note A.4.7(10): 5992.
   <in> Ada.Strings.Wide_Wide_Maps   *note A.4.8(10/2): 6031.
To_Sequence
   <in> Ada.Strings.Maps   *note A.4.2(19): 5796.
   <in> Ada.Strings.Wide_Maps   *note A.4.7(19): 5998.
   <in> Ada.Strings.Wide_Wide_Maps   *note A.4.8(19/2): 6037.
To_Set
   <in> Ada.Containers.Hashed_Sets   *note A.18.8(9/2): 7048.
   <in> Ada.Containers.Ordered_Sets   *note A.18.9(10/2): 7121.
   <in> Ada.Strings.Maps   *note A.4.2(8): 5788, *note A.4.2(9): 5789,
*note A.4.2(17): 5794, *note A.4.2(18): 5795.
   <in> Ada.Strings.Wide_Maps   *note A.4.7(8): 5990, *note A.4.7(9):
5991, *note A.4.7(17): 5996, *note A.4.7(18): 5997.
   <in> Ada.Strings.Wide_Wide_Maps   *note A.4.8(8/2): 6029, *note
A.4.8(9/2): 6030, *note A.4.8(17/2): 6035, *note A.4.8(18/2): 6036.
To_String
   <in> Ada.Characters.Conversions   *note A.3.4(5/2): 5745.
   <in> Ada.Strings.Bounded   *note A.4.4(12): 5851.
   <in> Ada.Strings.Unbounded   *note A.4.5(11): 5910.
To_Time_Span
   <in> Ada.Real_Time   *note D.8(13): 7954.
To_Unbounded_String
   <in> Ada.Strings.Unbounded   *note A.4.5(9): 5908, *note A.4.5(10):
5909.
To_Upper
   <in> Ada.Characters.Handling   *note A.3.2(6): 5478, *note A.3.2(7):
5481.
   <in> Ada.Wide_Characters.Handling   *note A.3.5(20/3): 5766, *note
A.3.5(21/3): 5768.
To_Vector
   <in> Ada.Containers.Vectors   *note A.18.2(13/2): 6733, *note
A.18.2(14/2): 6734.
To_Wide_Character
   <in> Ada.Characters.Conversions   *note A.3.4(4/2): 5736, *note
A.3.4(5/2): 5746.
To_Wide_String
   <in> Ada.Characters.Conversions   *note A.3.4(4/2): 5737, *note
A.3.4(5/2): 5747.
To_Wide_Wide_Character
   <in> Ada.Characters.Conversions   *note A.3.4(4/2): 5738.
To_Wide_Wide_String
   <in> Ada.Characters.Conversions   *note A.3.4(4/2): 5739.
token
   <See> lexical element   *note 2.2(1): 1181.
Trailing_Nonseparate
   <in> Interfaces.COBOL   *note B.4(23): 7568.
Trailing_Separate
   <in> Interfaces.COBOL   *note B.4(23): 7566.
transfer of control   *note 5.1(14/2): 3148.
Translate
   <in> Ada.Strings.Bounded   *note A.4.4(53): 5879, *note A.4.4(54):
5880, *note A.4.4(55): 5881, *note A.4.4(56): 5882.
   <in> Ada.Strings.Fixed   *note A.4.3(18): 5822, *note A.4.3(19):
5823, *note A.4.3(20): 5824, *note A.4.3(21): 5825.
   <in> Ada.Strings.Unbounded   *note A.4.5(48): 5933, *note A.4.5(49):
5934, *note A.4.5(50): 5935, *note A.4.5(51): 5936.
Translation_Error
   <in> Ada.Strings   *note A.4.1(5): 5777.
Transpose
   <in> Ada.Numerics.Generic_Complex_Arrays   *note G.3.2(34/2): 8414.
   <in> Ada.Numerics.Generic_Real_Arrays   *note G.3.1(17/2): 8374.
Tree
   <in> Ada.Containers.Multiway_Trees   *note A.18.10(8/3): 7202.
Tree_Iterator_Interfaces
   <in> Ada.Containers.Multiway_Trees   *note A.18.10(13/3): 7207.
triggering_alternative   *note 9.7.4(3): 4258.
   <used>   *note 9.7.4(2): 4256, *note P: 9642.
triggering_statement   *note 9.7.4(4/2): 4261.
   <used>   *note 9.7.4(3): 4259, *note P: 9644.
Trim
   <in> Ada.Strings.Bounded   *note A.4.4(67): 5891, *note A.4.4(68):
5893, *note A.4.4(69): 5894.
   <in> Ada.Strings.Fixed   *note A.4.3(31): 5834, *note A.4.3(32):
5835, *note A.4.3(33): 5836, *note A.4.3(34): 5837.
   <in> Ada.Strings.Unbounded   *note A.4.5(61): 5945, *note A.4.5(62):
5946, *note A.4.5(63): 5947, *note A.4.5(64): 5948.
Trim_End
   <in> Ada.Strings   *note A.4.1(6): 5782.
True   *note 3.5.3(1): 1715.
Truncation
   <in> Ada.Strings   *note A.4.1(6): 5779.
Truncation attribute   *note A.5.3(42): 6230.
Tuesday
   <in> Ada.Calendar.Formatting   *note 9.6.1(17/2): 4180.
two's complement
   modular types   *note 3.5.4(29): 1767.
type   *note 3.2(1): 1328, *note N(41/2): 8954.
   abstract   *note 3.9.3(1.2/2): 2190.
   needs finalization   *note 7.6(9.1/2): 3671.
   of a subtype   *note 3.2(8/2): 1355.
   synchronized tagged   *note 3.9.4(6/2): 2213.
   <See also> tag   *note 3.9(3): 2097.
   <See also> language-defined types
type conformance   *note 6.3.1(15/2): 3427.
   [<partial>]   *note 3.4(17/2): 1552, *note 8.3(8): 3749, *note
8.3(26/2): 3771, *note 10.1.4(4/3): 4415.
   required   *note 3.11.1(5): 2356, *note 4.1.4(14/2): 2449, *note
8.6(26): 3866, *note 9.1(9.2/3): 3921, *note 9.1(9.5/3): 3923, *note
9.4(11.1/3): 3994, *note 9.4(11.4/3): 3996, *note 9.5.4(3/3): 4123,
*note 12.4(5/2): 4755.
type conversion   *note 4.6(1/3): 2920.
   access   *note 4.6(24.11/2): 2951, *note 4.6(24.18/2): 2956, *note
4.6(24.19/2): 2958, *note 4.6(47): 2994.
   arbitrary order   *note 1.1.4(18): 1070.
   array   *note 4.6(24.2/2): 2946, *note 4.6(36): 2975.
   composite (non-array)   *note 4.6(21/3): 2940, *note 4.6(40): 2984.
   enumeration   *note 4.6(21.1/2): 2942, *note 4.6(34): 2973.
   numeric   *note 4.6(24.1/2): 2944, *note 4.6(29): 2970.
   unchecked   *note 13.9(1): 5155.
   <See also> qualified_expression   *note 4.7(1): 3024.
type conversion, implicit
   <See> implicit subtype conversion   *note 4.6(1/3): 2924.
type extension   *note 3.9(2/2): 2088, *note 3.9.1(1/2): 2135.
type invariant   *note N(41.1/4): 8955.
   class-wide   *note 7.3.2(3/4): 3633.
type of a discrete_range   *note 3.6.1(4): 1938.
type of a range   *note 3.5(4): 1594.
type parameter
   <See> discriminant   *note 3.7(1/2): 1965.
type profile
   <See> profile, type conformant   *note 6.3.1(15/2): 3429.
type resolution rules   *note 8.6(20/2): 3860.
   if any type in a specified class of types is expected   *note
8.6(21): 3861.
   if expected type is specific   *note 8.6(22): 3863.
   if expected type is universal or class-wide   *note 8.6(21): 3862.
type tag
   <See> tag   *note 3.9(3): 2095.
type-related
   aspect   *note 13.1(8.1/3): 4896, *note 13.1(8/3): 4891.
   operational item   *note 13.1(8.1/3): 4895.
   representation item   *note 13.1(8/3): 4889.
type_conversion   *note 4.6(2): 2925.
   <used>   *note 4.1(2/3): 2366, *note P: 9202.
   <See also> unchecked type conversion   *note 13.9(1): 5157.
type_declaration   *note 3.2.1(2): 1368.
   <used>   *note 3.1(3/3): 1293, *note P: 9009.
type_definition   *note 3.2.1(4/2): 1380.
   <used>   *note 3.2.1(3/3): 1376, *note P: 9029.
Type_Invariant aspect   *note 7.3.2(2/3): 3629.
Type_Invariant'Class aspect   *note 7.3.2(3/4): 3631.
Type_Set
   <in> Ada.Text_IO   *note A.10.1(7): 6382.
types
   of a profile   *note 6.1(29): 3343.



File: arm2012.info,  Node: U,  Next: V,  Prev: T,  Up: Index

U 
==



UC_A_Acute
   <in> Ada.Characters.Latin_1   *note A.3.3(23): 5666.
UC_A_Circumflex
   <in> Ada.Characters.Latin_1   *note A.3.3(23): 5667.
UC_A_Diaeresis
   <in> Ada.Characters.Latin_1   *note A.3.3(23): 5669.
UC_A_Grave
   <in> Ada.Characters.Latin_1   *note A.3.3(23): 5665.
UC_A_Ring
   <in> Ada.Characters.Latin_1   *note A.3.3(23): 5670.
UC_A_Tilde
   <in> Ada.Characters.Latin_1   *note A.3.3(23): 5668.
UC_AE_Diphthong
   <in> Ada.Characters.Latin_1   *note A.3.3(23): 5671.
UC_C_Cedilla
   <in> Ada.Characters.Latin_1   *note A.3.3(23): 5672.
UC_E_Acute
   <in> Ada.Characters.Latin_1   *note A.3.3(23): 5674.
UC_E_Circumflex
   <in> Ada.Characters.Latin_1   *note A.3.3(23): 5675.
UC_E_Diaeresis
   <in> Ada.Characters.Latin_1   *note A.3.3(23): 5676.
UC_E_Grave
   <in> Ada.Characters.Latin_1   *note A.3.3(23): 5673.
UC_I_Acute
   <in> Ada.Characters.Latin_1   *note A.3.3(23): 5678.
UC_I_Circumflex
   <in> Ada.Characters.Latin_1   *note A.3.3(23): 5679.
UC_I_Diaeresis
   <in> Ada.Characters.Latin_1   *note A.3.3(23): 5680.
UC_I_Grave
   <in> Ada.Characters.Latin_1   *note A.3.3(23): 5677.
UC_Icelandic_Eth
   <in> Ada.Characters.Latin_1   *note A.3.3(24): 5681.
UC_Icelandic_Thorn
   <in> Ada.Characters.Latin_1   *note A.3.3(24): 5695.
UC_N_Tilde
   <in> Ada.Characters.Latin_1   *note A.3.3(24): 5682.
UC_O_Acute
   <in> Ada.Characters.Latin_1   *note A.3.3(24): 5684.
UC_O_Circumflex
   <in> Ada.Characters.Latin_1   *note A.3.3(24): 5685.
UC_O_Diaeresis
   <in> Ada.Characters.Latin_1   *note A.3.3(24): 5687.
UC_O_Grave
   <in> Ada.Characters.Latin_1   *note A.3.3(24): 5683.
UC_O_Oblique_Stroke
   <in> Ada.Characters.Latin_1   *note A.3.3(24): 5689.
UC_O_Tilde
   <in> Ada.Characters.Latin_1   *note A.3.3(24): 5686.
UC_U_Acute
   <in> Ada.Characters.Latin_1   *note A.3.3(24): 5691.
UC_U_Circumflex
   <in> Ada.Characters.Latin_1   *note A.3.3(24): 5692.
UC_U_Diaeresis
   <in> Ada.Characters.Latin_1   *note A.3.3(24): 5693.
UC_U_Grave
   <in> Ada.Characters.Latin_1   *note A.3.3(24): 5690.
UC_Y_Acute
   <in> Ada.Characters.Latin_1   *note A.3.3(24): 5694.
UCHAR_MAX
   <in> Interfaces.C   *note B.3(6): 7436.
ultimate ancestor
   of a type   *note 3.4.1(10/2): 1578.
unary adding operator   *note 4.5.4(1): 2828.
unary operator   *note 4.5(9): 2734.
unary_adding_operator   *note 4.5(5): 2727.
   <used>   *note 4.4(4): 2696, *note P: 9298.
Unbiased_Rounding attribute   *note A.5.3(39): 6225.
Unbounded
   <child of> Ada.Strings   *note A.4.5(3): 5902.
   <in> Ada.Text_IO   *note A.10.1(5): 6379.
Unbounded_IO
   <child of> Ada.Text_IO   *note A.10.12(3/2): 6546.
   <child of> Ada.Wide_Text_IO   *note A.11(5/3): 6563.
   <child of> Ada.Wide_Wide_Text_IO   *note A.11(5/3): 6564.
Unbounded_Priority_Queues
   <child of> Ada.Containers   *note A.18.30(2/3): 7355.
Unbounded_Slice
   <in> Ada.Strings.Unbounded   *note A.4.5(22.1/2): 5918, *note
A.4.5(22.2/2): 5919.
Unbounded_String
   <in> Ada.Strings.Unbounded   *note A.4.5(4/2): 5903.
Unbounded_Synchronized_Queues
   <child of> Ada.Containers   *note A.18.28(2/3): 7343.
unchecked storage deallocation   *note 13.11.2(1): 5223.
unchecked type conversion   *note 13.9(1): 5154.
unchecked union object   *note B.3.3(6/3): 7539.
unchecked union subtype   *note B.3.3(6/3): 7538.
unchecked union type   *note B.3.3(6/3): 7537.
Unchecked_Access attribute   *note 13.10(3): 5181, *note H.4(18): 8471.
   <See also> Access attribute   *note 3.10.2(25/1): 2308.
Unchecked_Conversion
   <child of> Ada   *note 13.9(3/3): 5159.
Unchecked_Deallocation
   <child of> Ada   *note 13.11.2(3/3): 5228.
Unchecked_Union aspect   *note B.3.3(3.2/3): 7536.
Unchecked_Union pragma   *note J.15.6(2/3): 8586, *note L(37.2/3): 8859.
unconstrained   *note 3.2(9): 1363.
   object   *note 3.3.1(9/2): 1509.
   object   *note 6.4.1(16): 3487.
   subtype   *note 3.2(9): 1365, *note 3.4(6): 1542, *note 3.5(7): 1603,
*note 3.5.1(10): 1700, *note 3.5.4(9): 1736, *note 3.5.4(10): 1739,
*note 3.5.7(11): 1814, *note 3.5.9(13): 1852, *note 3.5.9(16): 1856,
*note 3.6(15): 1918, *note 3.6(16): 1921, *note 3.7(26): 1995, *note
3.9(15): 2119.
   subtype   *note 3.10(14/3): 2270.
   subtype   *note K.2(33): 8653.
unconstrained_array_definition   *note 3.6(3): 1890.
   <used>   *note 3.6(2): 1888, *note P: 9105.
undefined result   *note 11.6(5): 4656.
underline   *note 2.1(15/3): 1175.
   <used>   *note 2.4.1(3): 1217, *note 2.4.2(4): 1242, *note P: 8981.
Uniformly_Distributed <subtype of> Float
   <in> Ada.Numerics.Float_Random   *note A.5.2(8): 6149.
uninitialized allocator   *note 4.8(4): 3053.
uninitialized variables   *note 13.9.1(2): 5165.
   [<partial>]   *note 3.3.1(21/3): 1520.
union
   C   *note B.3.3(1/3): 7534.
   <in> Ada.Containers.Hashed_Sets   *note A.18.8(26/2): 7068, *note
A.18.8(27/2): 7069.
   <in> Ada.Containers.Ordered_Sets   *note A.18.9(27/2): 7141, *note
A.18.9(28/2): 7142.
unit consistency   *note E.3(6): 8176.
unit matrix
   complex matrix   *note G.3.2(148/2): 8425.
   real matrix   *note G.3.1(80/2): 8385.
unit vector
   complex vector   *note G.3.2(90/2): 8424.
   real vector   *note G.3.1(48/2): 8384.
Unit_Matrix
   <in> Ada.Numerics.Generic_Complex_Arrays   *note G.3.2(51/2): 8421.
   <in> Ada.Numerics.Generic_Real_Arrays   *note G.3.1(29/2): 8381.
Unit_Vector
   <in> Ada.Numerics.Generic_Complex_Arrays   *note G.3.2(24/2): 8401.
   <in> Ada.Numerics.Generic_Real_Arrays   *note G.3.1(14/2): 8373.
universal type   *note 3.4.1(6/2): 1568.
universal_access
   [<partial>]   *note 3.4.1(6/2): 1572, *note 4.2(8/2): 2483.
universal_fixed
   [<partial>]   *note 3.4.1(6/2): 1571, *note 3.5.6(4): 1791.
universal_integer
   [<partial>]   *note 3.4.1(6/2): 1569, *note 3.5.4(14): 1746, *note
3.5.4(30): 1768, *note 4.2(8/2): 2481.
universal_real
   [<partial>]   *note 3.4.1(6/2): 1570, *note 3.5.6(4): 1789, *note
4.2(8/2): 2482.
unknown discriminants   *note 3.7(26): 1996.
unknown_discriminant_part   *note 3.7(3): 1970.
   <used>   *note 3.7(2/2): 1968, *note P: 9122.
Unknown_Zone_Error
   <in> Ada.Calendar.Time_Zones   *note 9.6.1(5/2): 4171.
unmarshalling   *note E.4(9): 8184.
unpolluted   *note 13.13.1(2): 5334.
unsigned
   <in> Interfaces.C   *note B.3(9): 7441.
   <in> Interfaces.COBOL   *note B.4(23): 7564.
unsigned type
   <See> modular type   *note 3.5.4(1): 1720.
unsigned_char
   <in> Interfaces.C   *note B.3(10): 7444.
unsigned_long
   <in> Interfaces.C   *note B.3(9): 7443.
Unsigned_N   *note B.2(8): 7426.
unsigned_short
   <in> Interfaces.C   *note B.3(9): 7442.
unspecified   *note 1.1.3(18): 1055.
   [<partial>]   *note 2.1(5/3): 1130, *note 3.9(4/2): 2099, *note
3.9(12.5/3): 2116, *note 4.5.2(13): 2796, *note 4.5.2(24.2/1): 2799,
*note 4.5.5(21): 2854, *note 4.6(58.4/4): 3020, *note 6.1.1(34/3): 3381,
*note 6.1.1(35/3): 3386, *note 6.2(11/3): 3396, *note 7.2(5/3): 3593,
*note 7.6(17.4/3): 3682, *note 9.8(14): 4289, *note 9.10(1/3): 4307,
*note 10.2(26): 4459, *note 11.1(6): 4527, *note 11.4.1(10.1/4): 4585,
*note 11.5(27/2): 4645, *note 13.1(18): 4899, *note 13.7.2(5/2): 5147,
*note 13.9.1(7): 5169, *note 13.11(20): 5214, *note 13.11(21.6/3): 5216,
*note 13.13.2(36/2): 5368, *note A.1(1/3): 5434, *note A.5.1(34): 6144,
*note A.5.2(28): 6172, *note A.5.2(34): 6173, *note A.5.3(41.3/2): 6228,
*note A.7(6): 6286, *note A.10(8): 6367, *note A.10.7(8/3): 6531, *note
A.10.7(12/3): 6532, *note A.10.7(17.3/2): 6533, *note A.10.7(19): 6534,
*note A.14(1): 6625, *note A.18.2(231/3): 6808, *note A.18.2(252/2):
6816, *note A.18.2(83/2): 6801, *note A.18.3(145/3): 6880, *note
A.18.3(157/2): 6886, *note A.18.3(55/2): 6873, *note A.18.4(3/2): 6890,
*note A.18.4(80/2): 6906, *note A.18.5(43/2): 6953, *note A.18.5(44/2):
6954, *note A.18.5(45/2): 6955, *note A.18.5(46/2): 6959, *note
A.18.6(56/3): 7012, *note A.18.6(57/2): 7013, *note A.18.7(3/2): 7020,
*note A.18.7(101/2): 7038, *note A.18.7(87/2): 7031, *note A.18.7(88/2):
7032, *note A.18.8(65/2): 7102, *note A.18.8(66.1/3): 7104, *note
A.18.8(66/2): 7103, *note A.18.8(67/2): 7105, *note A.18.8(68/2): 7109,
*note A.18.8(86/2): 7110, *note A.18.8(87/2): 7111, *note A.18.9(114/2):
7189, *note A.18.9(79.1/3): 7183, *note A.18.9(79/3): 7182, *note
A.18.9(80/2): 7184, *note A.18.10(227/3): 7275, *note A.18.10(72/3):
7264, *note A.18.26(5/3): 7331, *note A.18.26(9.4/3): 7335, *note
A.18.26(9/3): 7333, *note D.2.2(7.1/2): 7797, *note D.8(19): 7965, *note
E.3(5/1): 8174, *note G.1.1(40): 8283, *note G.1.2(33): 8310, *note
G.1.2(48): 8313, *note H(4.1): 8428, *note H.2(1): 8435, *note
K.2(136.4/2): 8671.
Unsuppress pragma   *note 11.5(4.1/2): 4621, *note L(37.3/2): 8862.
update
   the value of an object   *note 3.3(14): 1464.
   <in> Interfaces.C.Strings   *note B.3.1(18): 7511, *note B.3.1(19):
7512.
Update_Element
   <in> Ada.Containers.Doubly_Linked_Lists   *note A.18.3(17/2): 6835.
   <in> Ada.Containers.Hashed_Maps   *note A.18.5(17/2): 6924.
   <in> Ada.Containers.Indefinite_Holders   *note A.18.18(15/3): 7293.
   <in> Ada.Containers.Multiway_Trees   *note A.18.10(27/3): 7220.
   <in> Ada.Containers.Ordered_Maps   *note A.18.6(16/2): 6975.
   <in> Ada.Containers.Vectors   *note A.18.2(33/2): 6749, *note
A.18.2(34/2): 6750.
Update_Element_Preserving_Key
   <in> Ada.Containers.Hashed_Sets   *note A.18.8(58/2): 7095.
   <in> Ada.Containers.Ordered_Sets   *note A.18.9(73/2): 7176.
Update_Error
   <in> Interfaces.C.Strings   *note B.3.1(20): 7513.
upper bound
   of a range   *note 3.5(4): 1593.
upper-case letter
   a category of Character   *note A.3.2(26): 5492.
Upper_Case_Map
   <in> Ada.Strings.Maps.Constants   *note A.4.6(5): 5967.
Upper_Set
   <in> Ada.Strings.Maps.Constants   *note A.4.6(4): 5959.
US
   <in> Ada.Characters.Latin_1   *note A.3.3(6): 5531.
usage name   *note 3.1(10): 1322.
use-visible   *note 8.3(4): 3742, *note 8.4(9): 3786.
use_clause   *note 8.4(2): 3774.
   <used>   *note 3.11(4/1): 2335, *note 10.1.2(3): 4372, *note 12.1(5):
4679, *note P: 9716.
Use_Error
   <in> Ada.Direct_IO   *note A.8.4(18): 6350.
   <in> Ada.Directories   *note A.16(43/2): 6673.
   <in> Ada.IO_Exceptions   *note A.13(4): 6617.
   <in> Ada.Sequential_IO   *note A.8.1(15): 6318.
   <in> Ada.Streams.Stream_IO   *note A.12.1(26): 6598.
   <in> Ada.Text_IO   *note A.10.1(85): 6523.
use_package_clause   *note 8.4(3): 3777.
   <used>   *note 8.4(2): 3775, *note P: 9503.
use_type_clause   *note 8.4(4/3): 3780.
   <used>   *note 8.4(2): 3776, *note P: 9504.
user-defined assignment   *note 7.6(1): 3652.
user-defined heap management   *note 13.11(1): 5185.
user-defined operator   *note 6.6(1): 3540.
user-defined storage management   *note 13.11(1): 5183.
UTC_Time_Offset
   <in> Ada.Calendar.Time_Zones   *note 9.6.1(6/2): 4172.
UTF-16   *note A.4.11(46/3): 6105.
UTF-8   *note A.4.11(46/3): 6104.
UTF_16_Wide_String <subtype of> Wide_String
   <in> Ada.Strings.UTF_Encoding   *note A.4.11(7/3): 6068.
UTF_8_String <subtype of> String
   <in> Ada.Strings.UTF_Encoding   *note A.4.11(6/3): 6067.
UTF_Encoding
   <child of> Ada.Strings   *note A.4.11(3/3): 6064.
UTF_String <subtype of> String
   <in> Ada.Strings.UTF_Encoding   *note A.4.11(5/3): 6066.



File: arm2012.info,  Node: V,  Next: W,  Prev: U,  Up: Index

V 
==



Val attribute   *note 3.5.5(5): 1773.
Valid
   <in> Ada.Text_IO.Editing   *note F.3.3(5): 8236, *note F.3.3(12):
8248.
   <in> Interfaces.COBOL   *note B.4(33): 7580, *note B.4(38): 7584,
*note B.4(43): 7588.
Valid attribute   *note 13.9.2(3/4): 5178, *note H(6): 8430.
Value
   <in> Ada.Calendar.Formatting   *note 9.6.1(36/2): 4206, *note
9.6.1(38/2): 4208.
   <in> Ada.Environment_Variables   *note A.17(4.1/3): 6701, *note
A.17(4/2): 6700.
   <in> Ada.Numerics.Discrete_Random   *note A.5.2(26): 6170.
   <in> Ada.Numerics.Float_Random   *note A.5.2(14): 6158.
   <in> Ada.Strings.Maps   *note A.4.2(21): 5798.
   <in> Ada.Strings.Wide_Maps   *note A.4.7(21): 6000.
   <in> Ada.Strings.Wide_Wide_Maps   *note A.4.8(21/2): 6039.
   <in> Ada.Task_Attributes   *note C.7.2(4): 7730.
   <in> Interfaces.C.Pointers   *note B.3.2(6): 7520, *note B.3.2(7):
7521.
   <in> Interfaces.C.Strings   *note B.3.1(13): 7506, *note B.3.1(14):
7507, *note B.3.1(15): 7508, *note B.3.1(16): 7509.
Value attribute   *note 3.5(52): 1672.
value conversion   *note 4.6(5/2): 2936.
values
   belonging to a subtype   *note 3.2(8/2): 1360.
variable   *note 3.3(13/3): 1457.
variable indexing   *note 4.1.6(16/3): 2474.
variable object   *note 3.3(13/3): 1459.
variable view   *note 3.3(13/3): 1461.
Variable_Indexing aspect   *note 4.1.6(3/3): 2465.
variadic
   C   *note B.3(60.16/4): 7495.
variant   *note 3.8.1(3): 2062.
   <used>   *note 3.8.1(2): 2061, *note P: 9152.
   <See also> tagged type   *note 3.9(1): 2083.
variant_part   *note 3.8.1(2): 2058.
   <used>   *note 3.8(4): 2032, *note P: 9144.
Vector
   <in> Ada.Containers.Vectors   *note A.18.2(8/3): 6727.
vector container   *note A.18.2(1/2): 6719.
Vector_Iterator_Interfaces
   <in> Ada.Containers.Vectors   *note A.18.2(11.2/3): 6732.
Vectors
   <child of> Ada.Containers   *note A.18.2(6/3): 6724.
version
   of a compilation unit   *note E.3(5/1): 8173.
Version attribute   *note E.3(3): 8170.
vertical line   *note 2.1(15/3): 1176.
Vertical_Line
   <in> Ada.Characters.Latin_1   *note A.3.3(14): 5589.
view   *note 3.1(7): 1312, *note N(42/2): 8956.
   of a subtype (implied)   *note 3.1(7.1/3): 1316.
   of a type (implied)   *note 3.1(7.1/3): 1315.
   of an object (implied)   *note 3.1(7.1/3): 1314.
view conversion   *note 4.6(5/2): 2934.
virtual function
   <See> dispatching subprogram   *note 3.9.2(1/2): 2158.
Virtual_Length
   <in> Interfaces.C.Pointers   *note B.3.2(13): 7525.
visibility
   direct   *note 8.3(2): 3735, *note 8.3(21): 3761.
   immediate   *note 8.3(4): 3739, *note 8.3(21): 3762.
   use clause   *note 8.3(4): 3740, *note 8.4(9): 3787.
visibility rules   *note 8.3(1): 3734.
visible   *note 8.3(2): 3738, *note 8.3(14): 3753.
   aspect_specification   *note 8.3(23.1/3): 3767.
   attribute_definition_clause   *note 8.3(23.1/3): 3766.
   within a pragma in a context_clause   *note 10.1.6(3): 4435.
   within a pragma that appears at the place of a compilation unit  
*note 10.1.6(5): 4439.
   within a use_clause in a context_clause   *note 10.1.6(3): 4433.
   within a with_clause   *note 10.1.6(2/2): 4431.
   within the parent_unit_name of a library unit   *note 10.1.6(2/2):
4429.
   within the parent_unit_name of a subunit   *note 10.1.6(4): 4437.
visible part   *note 8.2(5): 3723.
   of a formal package   *note 12.7(10/2): 4866.
   of a generic unit   *note 8.2(8): 3727.
   of a package (other than a generic formal package)   *note 7.1(6/2):
3582.
   of a protected unit   *note 9.4(11/2): 3989.
   of a task unit   *note 9.1(9): 3917.
   of a view of a callable entity   *note 8.2(6): 3725.
   of a view of a composite type   *note 8.2(7): 3726.
volatile   *note C.6(8/3): 7701.
Volatile aspect   *note C.6(6.4/3): 7693.
Volatile pragma   *note J.15.8(3/3): 8601, *note L(38.1/3): 8865.
Volatile_Components aspect   *note C.6(6.7/3): 7697.
Volatile_Components pragma   *note J.15.8(6/3): 8610, *note L(39.1/3):
8868.
VT
   <in> Ada.Characters.Latin_1   *note A.3.3(5): 5511.
VTS
   <in> Ada.Characters.Latin_1   *note A.3.3(17): 5608.



File: arm2012.info,  Node: W,  Next: X,  Prev: V,  Up: Index

W 
==



Wait_For_Release
   <in> Ada.Synchronous_Barriers   *note D.10.1(6/3): 7987.
wchar_array
   <in> Interfaces.C   *note B.3(33/3): 7465.
wchar_t
   <in> Interfaces.C   *note B.3(30/1): 7461.
Wednesday
   <in> Ada.Calendar.Formatting   *note 9.6.1(17/2): 4181.
well-formed picture String
   for edited output   *note F.3.1(1/3): 8232.
Wide_Bounded
   <child of> Ada.Strings   *note A.4.7(1/3): 5970.
Wide_Character   *note 3.5.2(3/3): 1708.
   <in> Standard   *note A.1(36.1/3): 5443.
Wide_Character_Mapping
   <in> Ada.Strings.Wide_Maps   *note A.4.7(20/2): 5999.
Wide_Character_Mapping_Function
   <in> Ada.Strings.Wide_Maps   *note A.4.7(26): 6005.
Wide_Character_Range
   <in> Ada.Strings.Wide_Maps   *note A.4.7(6): 5988.
Wide_Character_Ranges
   <in> Ada.Strings.Wide_Maps   *note A.4.7(7): 5989.
Wide_Character_Sequence <subtype of> Wide_String
   <in> Ada.Strings.Wide_Maps   *note A.4.7(16): 5995.
Wide_Character_Set
   <in> Ada.Strings.Wide_Maps   *note A.4.7(4/2): 5986.
   <in> Ada.Strings.Wide_Maps.Wide_Constants   *note A.4.8(48/2): 6047.
Wide_Characters
   <child of> Ada   *note A.3.1(4/2): 5458.
Wide_Constants
   <child of> Ada.Strings.Wide_Maps   *note A.4.7(1/3): 5984, *note
A.4.8(28/2): 6045.
Wide_Equal_Case_Insensitive
   <child of> Ada.Strings   *note A.4.7(1/3): 5976.
   <child of> Ada.Strings.Wide_Bounded   *note A.4.7(1/3): 5978.
   <child of> Ada.Strings.Wide_Fixed   *note A.4.7(1/3): 5977.
   <child of> Ada.Strings.Wide_Unbounded   *note A.4.7(1/3): 5979.
Wide_Exception_Name
   <in> Ada.Exceptions   *note 11.4.1(2/2): 4568, *note 11.4.1(5/2):
4578.
Wide_Expanded_Name
   <in> Ada.Tags   *note 3.9(7/2): 2104.
Wide_Fixed
   <child of> Ada.Strings   *note A.4.7(1/3): 5969.
Wide_Hash
   <child of> Ada.Strings   *note A.4.7(1/3): 5972.
   <child of> Ada.Strings.Wide_Bounded   *note A.4.7(1/3): 5974.
   <child of> Ada.Strings.Wide_Fixed   *note A.4.7(1/3): 5973.
   <child of> Ada.Strings.Wide_Unbounded   *note A.4.7(1/3): 5975.
Wide_Hash_Case_Insensitive
   <child of> Ada.Strings   *note A.4.7(1/3): 5980.
   <child of> Ada.Strings.Wide_Bounded   *note A.4.7(1/3): 5982.
   <child of> Ada.Strings.Wide_Fixed   *note A.4.7(1/3): 5981.
   <child of> Ada.Strings.Wide_Unbounded   *note A.4.7(1/3): 5983.
Wide_Image attribute   *note 3.5(28): 1643, *note 3.5(55.3/4): 1680.
Wide_Maps
   <child of> Ada.Strings   *note A.4.7(3): 5985.
wide_nul
   <in> Interfaces.C   *note B.3(31/1): 7462.
Wide_Space
   <in> Ada.Strings   *note A.4.1(4/2): 5772.
Wide_String
   <in> Standard   *note A.1(41/3): 5448.
Wide_Strings
   <child of> Ada.Strings.UTF_Encoding   *note A.4.11(30/3): 6088.
Wide_Text_IO
   <child of> Ada   *note A.11(2/2): 6555.
Wide_Unbounded
   <child of> Ada.Strings   *note A.4.7(1/3): 5971.
Wide_Value attribute   *note 3.5(40): 1666.
Wide_Wide_Bounded
   <child of> Ada.Strings   *note A.4.8(1/3): 6009.
Wide_Wide_Character   *note 3.5.2(4/3): 1711.
   <in> Standard   *note A.1(36.2/3): 5444.
Wide_Wide_Character_Mapping
   <in> Ada.Strings.Wide_Wide_Maps   *note A.4.8(20/2): 6038.
Wide_Wide_Character_Mapping_Function
   <in> Ada.Strings.Wide_Wide_Maps   *note A.4.8(26/2): 6044.
Wide_Wide_Character_Range
   <in> Ada.Strings.Wide_Wide_Maps   *note A.4.8(6/2): 6027.
Wide_Wide_Character_Ranges
   <in> Ada.Strings.Wide_Wide_Maps   *note A.4.8(7/2): 6028.
Wide_Wide_Character_Sequence <subtype of> Wide_Wide_String
   <in> Ada.Strings.Wide_Wide_Maps   *note A.4.8(16/2): 6034.
Wide_Wide_Character_Set
   <in> Ada.Strings.Wide_Wide_Maps   *note A.4.8(4/2): 6025.
Wide_Wide_Characters
   <child of> Ada   *note A.3.1(6/2): 5459.
Wide_Wide_Constants
   <child of> Ada.Strings.Wide_Wide_Maps   *note A.4.8(1/3): 6023.
Wide_Wide_Equal_Case_Insensitive
   <child of> Ada.Strings   *note A.4.8(1/3): 6015.
   <child of> Ada.Strings.Wide_Wide_Bounded   *note A.4.8(1/3): 6017.
   <child of> Ada.Strings.Wide_Wide_Fixed   *note A.4.8(1/3): 6016.
   <child of> Ada.Strings.Wide_Wide_Unbounded   *note A.4.8(1/3): 6018.
Wide_Wide_Exception_Name
   <in> Ada.Exceptions   *note 11.4.1(2/2): 4569, *note 11.4.1(5/2):
4579.
Wide_Wide_Expanded_Name
   <in> Ada.Tags   *note 3.9(7/2): 2105.
Wide_Wide_Fixed
   <child of> Ada.Strings   *note A.4.8(1/3): 6008.
Wide_Wide_Hash
   <child of> Ada.Strings   *note A.4.8(1/3): 6011.
   <child of> Ada.Strings.Wide_Wide_Bounded   *note A.4.8(1/3): 6013.
   <child of> Ada.Strings.Wide_Wide_Fixed   *note A.4.8(1/3): 6012.
   <child of> Ada.Strings.Wide_Wide_Unbounded   *note A.4.8(1/3): 6014.
Wide_Wide_Hash_Case_Insensitive
   <child of> Ada.Strings   *note A.4.8(1/3): 6019.
   <child of> Ada.Strings.Wide_Wide_Bounded   *note A.4.8(1/3): 6021.
   <child of> Ada.Strings.Wide_Wide_Fixed   *note A.4.8(1/3): 6020.
   <child of> Ada.Strings.Wide_Wide_Unbounded   *note A.4.8(1/3): 6022.
Wide_Wide_Image attribute   *note 3.5(27.1/2): 1639, *note 3.5(55.2/4):
1678.
Wide_Wide_Maps
   <child of> Ada.Strings   *note A.4.8(3/2): 6024.
Wide_Wide_Space
   <in> Ada.Strings   *note A.4.1(4/2): 5773.
Wide_Wide_String
   <in> Standard   *note A.1(42.1/3): 5449.
Wide_Wide_Strings
   <child of> Ada.Strings.UTF_Encoding   *note A.4.11(38/3): 6095.
Wide_Wide_Text_IO
   <child of> Ada   *note A.11(3/2): 6558.
Wide_Wide_Unbounded
   <child of> Ada.Strings   *note A.4.8(1/3): 6010.
Wide_Wide_Value attribute   *note 3.5(39.1/2): 1654.
Wide_Wide_Width attribute   *note 3.5(37.1/2): 1648.
Wide_Width attribute   *note 3.5(38): 1650.
Width attribute   *note 3.5(39): 1652.
with_clause   *note 10.1.2(4/2): 4373.
   mentioned in   *note 10.1.2(6/2): 4384.
   named in   *note 10.1.2(6/2): 4386.
   <used>   *note 10.1.2(3): 4371, *note P: 9670.
within
   immediately   *note 8.1(13): 3716.
word   *note 13.3(8): 4976.
Word_Size
   <in> System   *note 13.7(13): 5120.
Write
   <in> Ada.Direct_IO   *note A.8.4(13): 6341.
   <in> Ada.Sequential_IO   *note A.8.1(12): 6313.
   <in> Ada.Storage_IO   *note A.9(7): 6359.
   <in> Ada.Streams   *note 13.13.1(6): 5341.
   <in> Ada.Streams.Stream_IO   *note A.12.1(18): 6588, *note
A.12.1(19): 6589.
   <in> System.RPC   *note E.5(8): 8209.
Write aspect   *note 13.13.2(38/4): 5381.
Write attribute   *note 13.13.2(3): 5350, *note 13.13.2(11): 5354.
Write clause   *note 13.3(7/2): 4970, *note 13.13.2(38/4): 5375.
Write'Class aspect   *note 13.13.2(38/4): 5389.



File: arm2012.info,  Node: X,  Next: Y,  Prev: W,  Up: Index

X 
==



xor operator   *note 4.4(1/3): 2587, *note 4.5.1(2): 2749.



File: arm2012.info,  Node: Y,  Prev: X,  Up: Index

Y 
==



Year
   <in> Ada.Calendar   *note 9.6(13): 4152.
   <in> Ada.Calendar.Formatting   *note 9.6.1(21/2): 4191.
Year_Number <subtype of> Integer
   <in> Ada.Calendar   *note 9.6(11/2): 4147.
Yen_Sign
   <in> Ada.Characters.Latin_1   *note A.3.3(21/3): 5636.
Yield
   <in> Ada.Dispatching   *note D.2.1(1.3/3): 7770.
Yield_To_Higher
   <in> Ada.Dispatching.Non_Preemptive   *note D.2.4(2.2/3): 7807.
Yield_To_Same_Or_Higher
   <in> Ada.Dispatching.Non_Preemptive   *note D.2.4(2.2/3): 7808.


Tag Table:
Node: Top221
Node: Front Matter1632
Node: 0.18786
Node: 0.211486
Node: 0.313265
Ref: 100113854
Ref: 100213854
Ref: 100336779
Ref: 100436779
Node: 0.9953283
Node: 153507
Node: 1.153702
Node: 1.1.155611
Node: 1.1.257175
Ref: 100557375
Ref: 100657664
Ref: 100757664
Ref: 100857664
Ref: 100958144
Ref: 101058144
Ref: 101158585
Ref: 101258585
Ref: 101358585
Ref: 101459308
Ref: 101559313
Ref: 101659313
Ref: 101759313
Ref: 101859313
Ref: 101959393
Ref: 102059393
Ref: 102159393
Ref: 102259526
Ref: 102359526
Ref: 102459526
Ref: 102559566
Ref: 102659568
Ref: 102759680
Ref: 102859680
Ref: 102959792
Ref: 103059792
Ref: 103159792
Ref: 103259792
Ref: 103359843
Ref: 103459845
Ref: 103560000
Ref: 103660000
Ref: 103760000
Ref: 103860000
Ref: 103960110
Ref: 104060110
Ref: 104160235
Ref: 104260235
Ref: 104360358
Ref: 104460469
Ref: 104560574
Ref: 104660735
Ref: 104760837
Ref: 104860837
Ref: 104961077
Node: 1.1.361343
Ref: 105061584
Ref: 105162495
Ref: 105262495
Ref: 105362622
Ref: 105464831
Ref: 105564831
Ref: 105664831
Ref: 105764831
Ref: 105864831
Ref: 105965539
Node: 1.1.466122
Ref: 106066605
Ref: 106166605
Ref: 106266605
Ref: 106366605
Ref: 106466605
Ref: 106567875
Ref: 106668946
Ref: 106769107
Ref: 106869235
Ref: 106969333
Ref: 107069910
Ref: 107169912
Node: 1.1.570784
Ref: 107271625
Ref: 107371630
Ref: 107471630
Ref: 107571630
Ref: 107672058
Ref: 107772063
Ref: 107872741
Ref: 107972804
Ref: 108073037
Ref: 108173495
Ref: 108273495
Ref: 108374121
Ref: 108474121
Ref: 108574387
Node: 1.274488
Ref: 108674609
Ref: 108774609
Ref: 108874911
Ref: 108974911
Ref: 109074911
Ref: 109175048
Ref: 109275048
Ref: 109375048
Ref: 109475158
Ref: 109575158
Ref: 109675158
Ref: 109775271
Ref: 109875271
Ref: 109975271
Ref: 110075357
Ref: 110175357
Ref: 110275357
Ref: 110375483
Ref: 110475483
Ref: 110575483
Ref: 110675589
Ref: 110775589
Ref: 110875714
Ref: 110975714
Ref: 111075714
Ref: 111175849
Ref: 111275849
Ref: 111375849
Ref: 111475929
Ref: 111575929
Ref: 111675929
Ref: 111776034
Ref: 111876034
Ref: 111976034
Ref: 112076118
Ref: 112176118
Node: 1.376325
Ref: 112276436
Ref: 112377084
Ref: 112477086
Ref: 112577086
Ref: 112677086
Node: 277088
Node: 2.177796
Ref: 112777891
Ref: 112878149
Ref: 112978149
Ref: 113079474
Ref: 113179577
Ref: 113279704
Ref: 113379833
Ref: 113479962
Ref: 113580089
Ref: 113680210
Ref: 113780339
Ref: 113880479
Ref: 113980605
Ref: 114080729
Ref: 114180869
Ref: 114280989
Ref: 114381115
Ref: 114481241
Ref: 114581375
Ref: 114681718
Ref: 114781729
Ref: 114881918
Ref: 114982050
Ref: 115082176
Ref: 115182568
Ref: 115282569
Ref: 115382569
Ref: 115482569
Ref: 115582569
Ref: 115682569
Ref: 115782569
Ref: 115882569
Ref: 115982569
Ref: 116082569
Ref: 116182569
Ref: 116282569
Ref: 116382569
Ref: 116482569
Ref: 116582569
Ref: 116682569
Ref: 116782569
Ref: 116882569
Ref: 116982569
Ref: 117082569
Ref: 117182569
Ref: 117282569
Ref: 117382569
Ref: 117482569
Ref: 117582569
Ref: 117682569
Ref: 117782569
Ref: 117882569
Node: 2.284319
Ref: 117984532
Ref: 118084605
Ref: 118184605
Ref: 118285054
Ref: 118385063
Ref: 118485311
Ref: 118586235
Ref: 118686381
Node: 2.387643
Ref: 118787836
Ref: S000287836
Ref: 118887849
Ref: 118987867
Ref: 119087886
Ref: 119187931
Ref: S000387931
Ref: S000487931
Ref: 119287946
Ref: 119387973
Ref: 119488000
Ref: 119588027
Ref: 119688053
Ref: 119788076
Ref: 119888119
Ref: S000588119
Ref: 119988134
Ref: 120088161
Ref: 120188194
Ref: 120288219
Ref: 120388675
Node: 2.489612
Ref: 120489723
Ref: 120589803
Ref: 120689863
Ref: 120789985
Ref: S000689985
Ref: 120889989
Ref: 120990008
Node: 2.4.190225
Ref: 121090334
Ref: 121190502
Ref: S000790502
Ref: 121290506
Ref: 121390517
Ref: 121490527
Ref: 121590552
Ref: S000890552
Ref: 121690556
Ref: 121790565
Ref: 121890576
Ref: 121990599
Ref: S000990599
Ref: 122090610
Ref: 122190624
Ref: 122290649
Ref: S001090649
Node: 2.4.291383
Ref: 122391488
Ref: 122491488
Ref: 122591488
Ref: 122691488
Ref: 122791488
Ref: 122891488
Ref: 122991488
Ref: 123091488
Ref: 123191488
Ref: 123291488
Ref: 123391643
Ref: S001191643
Ref: 123491656
Ref: 123591663
Ref: 123691679
Ref: 123791697
Ref: 123891719
Ref: S001291719
Ref: 123991723
Ref: 124091753
Ref: S001391753
Ref: 124191766
Ref: 124291783
Ref: 124391794
Ref: 124491832
Ref: S001491832
Ref: 124591836
Ref: 124691915
Node: 2.592985
Ref: 124793264
Ref: S001593264
Ref: 124893270
Node: 2.693686
Ref: 124994086
Ref: 125094152
Ref: S001694152
Ref: 125194159
Ref: 125294198
Ref: S001794198
Ref: 125394229
Ref: 125494427
Ref: 125594746
Node: 2.795463
Ref: 125695696
Ref: S001895696
Ref: 125795722
Node: 2.896402
Ref: 125896495
Ref: 125996759
Ref: S001996759
Ref: 126096779
Ref: 126196792
Ref: 126296823
Ref: 126396898
Ref: S002096898
Ref: 126496932
Ref: 126596947
Ref: 126696981
Ref: 126796996
Ref: 126897035
Ref: 126997051
Ref: 127097084
Ref: 127197100
Ref: 127298214
Ref: 127398214
Ref: 127498290
Ref: 127598292
Ref: 127698378
Ref: 127798378
Ref: 127898810
Ref: 127998810
Ref: 128099038
Ref: 1281100284
Ref: 1282100285
Ref: 1283100290
Ref: 1284100320
Ref: 1285100321
Ref: 1286100344
Ref: 1287100345
Ref: 1288100354
Node: 2.9102014
Ref: 1289102192
Node: 3103658
Node: 3.1104257
Ref: 1290104348
Ref: 1291104437
Ref: 1292104838
Ref: S0021104838
Ref: 1293104853
Ref: 1294104874
Ref: 1295104904
Ref: 1296104927
Ref: 1297104956
Ref: 1298104983
Ref: 1299105025
Ref: 1300105056
Ref: 1301105098
Ref: 1302105122
Ref: 1303105153
Ref: 1304105179
Ref: 1305105209
Ref: 1306105258
Ref: S0022105258
Ref: 1307105262
Ref: 1308105323
Ref: 1309105413
Ref: 1310105415
Ref: 1311105646
Ref: 1312106359
Ref: 1313106359
Ref: 1314107181
Ref: 1315107181
Ref: 1316107181
Ref: 1317107185
Ref: 1318107621
Ref: 1319107725
Ref: 1320107826
Ref: 1321108149
Ref: 1322108386
Ref: 1323108614
Ref: 1324108698
Ref: 1325108700
Ref: 1326108962
Ref: 1327109035
Node: 3.2109113
Ref: 1328109274
Ref: 1329109274
Ref: 1330109413
Ref: 1331109509
Ref: 1332109509
Ref: 1333109554
Ref: 1334109701
Ref: 1335109752
Ref: 1336109822
Ref: 1337109823
Ref: 1338109899
Ref: 1339109905
Ref: 1340110052
Ref: 1341110054
Ref: 1342110164
Ref: 1343110383
Ref: 1344110383
Ref: 1345110383
Ref: 1346110930
Ref: 1347111172
Ref: 1348111414
Ref: 1349111684
Ref: 1350111684
Ref: 1351111690
Ref: 1352111808
Ref: 1353111809
Ref: 1354112237
Ref: 1355112430
Ref: 1356112430
Ref: 1357112511
Ref: 1358112511
Ref: 1359112644
Ref: 1360112682
Ref: 1361112682
Ref: 1362112688
Ref: 1363112688
Ref: 1364112688
Ref: 1365112688
Ref: 1366113530
Ref: 1367114138
Node: 3.2.1115771
Ref: 1368116005
Ref: S0023116005
Ref: 1369116011
Ref: 1370116043
Ref: 1371116081
Ref: 1372116116
Ref: 1373116177
Ref: S0024116177
Ref: 1374116197
Ref: 1375116218
Ref: 1376116246
Ref: 1377116282
Ref: 1378116315
Ref: 1379116347
Ref: 1380116399
Ref: S0025116399
Ref: 1381116414
Ref: 1382116446
Ref: 1383116480
Ref: 1384116505
Ref: 1385116537
Ref: 1386116564
Ref: 1387116597
Ref: 1388116625
Ref: 1389116828
Ref: 1390117232
Ref: 1391117356
Ref: 1392117551
Ref: 1393117905
Ref: 1394118117
Ref: 1395118191
Ref: 1396118574
Ref: 1397118804
Ref: 1398119192
Ref: 1399119291
Node: 3.2.2120422
Ref: 1400120734
Ref: S0026120734
Ref: 1401120755
Ref: 1402120778
Ref: 1403120811
Ref: 1404120862
Ref: S0027120862
Ref: 1405120869
Ref: 1406120885
Ref: 1407120899
Ref: 1408120931
Ref: S0028120931
Ref: 1409120946
Ref: 1410120969
Ref: S0029120969
Ref: 1411120973
Ref: 1412120994
Ref: 1413121040
Ref: S0030121040
Ref: 1414121055
Ref: 1415121074
Ref: 1416121094
Ref: 1417121139
Ref: S0031121139
Ref: 1418121154
Ref: 1419121173
Ref: 1420121298
Ref: 1421121446
Ref: 1422121541
Ref: 1423121900
Ref: 1424121900
Ref: 1425122112
Ref: 1426122412
Node: 3.2.3123535
Ref: 1427123730
Ref: 1428123958
Ref: 1429124132
Ref: 1430124262
Ref: 1431125067
Ref: 1432125326
Node: 3.2.4125423
Ref: 1433125757
Ref: 1434125757
Ref: 1435125757
Ref: 1436125757
Ref: 1437125757
Ref: 1438125757
Ref: 1439125757
Ref: 1440126016
Ref: 1441126645
Ref: 1442126645
Ref: 1443126645
Ref: 1444128847
Ref: 1445128847
Ref: 1446130785
Ref: 1447131302
Ref: 1448131302
Ref: 1449133062
Ref: 1450133062
Ref: 1451133062
Ref: 1452133062
Ref: 1453133900
Node: 3.3136767
Ref: 1454136964
Ref: 1455137278
Ref: 1456137912
Ref: 1457137912
Ref: 1458137912
Ref: 1459137912
Ref: 1460137912
Ref: 1461137912
Ref: 1462138382
Ref: 1463138550
Ref: 1464138692
Ref: 1465139920
Ref: 1466140019
Ref: 1467140021
Ref: 1468140199
Ref: 1469140201
Ref: 1470140890
Ref: 1471140890
Ref: 1472142068
Node: 3.3.1142907
Ref: 1473143024
Ref: 1474143024
Ref: 1475143024
Ref: 1476143188
Ref: 1477143190
Ref: 1478143190
Ref: 1479143397
Ref: S0032143397
Ref: 1480143411
Ref: 1481143459
Ref: 1482143488
Ref: 1483143514
Ref: 1484143546
Ref: 1485143594
Ref: 1486143622
Ref: 1487143648
Ref: 1488143680
Ref: 1489143728
Ref: 1490143760
Ref: 1491143786
Ref: 1492143818
Ref: 1493143851
Ref: 1494143912
Ref: S0033143912
Ref: 1495143924
Ref: 1496143947
Ref: 1497144020
Ref: 1498144161
Ref: 1499144221
Ref: 1500144637
Ref: 1501144727
Ref: 1502145410
Ref: 1503145631
Ref: 1504145969
Ref: 1505146264
Ref: 1506146325
Ref: 1507146327
Ref: 1508146429
Ref: 1509146431
Ref: 1510146518
Ref: 1511147105
Ref: 1512147656
Ref: 1513148202
Ref: 1514148918
Ref: 1515149054
Ref: 1516149300
Ref: 1517149302
Ref: 1518149525
Ref: 1519149705
Ref: 1520150736
Ref: 1521151166
Ref: 1522151166
Node: 3.3.2152957
Ref: 1523153185
Ref: S0034153185
Ref: 1524153200
Ref: 1525153248
Ref: 1526153312
Ref: 1527153989
Ref: 1528154042
Node: 3.4154604
Ref: 1529154735
Ref: 1530154910
Ref: 1531154920
Ref: 1532154920
Ref: 1533155590
Ref: S0035155590
Ref: 1534155638
Ref: 1535155663
Ref: 1536155685
Ref: 1537155758
Ref: 1538155758
Ref: 1539156253
Ref: 1540156852
Ref: 1541156902
Ref: 1542156902
Ref: 1543157080
Ref: 1544157551
Ref: 1545159132
Ref: 1546159133
Ref: 1547159509
Ref: 1548159510
Ref: 1549159510
Ref: 1550160146
Ref: 1551160491
Ref: 1552161060
Ref: 1553161567
Ref: 1554162514
Ref: 1555163206
Ref: 1556163682
Ref: 1557164078
Ref: 1558164781
Ref: 1559164806
Ref: 1560165296
Node: 3.4.1167550
Ref: 1561167810
Ref: 1562168126
Ref: 1563168128
Ref: 1564168128
Ref: 1565168484
Ref: 1566168751
Ref: 1567169378
Ref: 1568170151
Ref: 1569170476
Ref: 1570170476
Ref: 1571170476
Ref: 1572170476
Ref: 1573171551
Ref: 1574171551
Ref: 1575171710
Ref: 1576171834
Ref: 1577172200
Ref: 1578172291
Ref: 1579172293
Ref: 1580172461
Node: 3.5173427
Ref: 1581173530
Ref: 1582173603
Ref: 1583173670
Ref: 1584173750
Ref: 1585173971
Ref: S0036173971
Ref: 1586173983
Ref: 1587174002
Ref: S0037174002
Ref: 1588174008
Ref: 1589174044
Ref: 1590174065
Ref: 1591174086
Ref: 1592174086
Ref: 1593174086
Ref: 1594174086
Ref: 1595174293
Ref: 1596174493
Ref: 1597174613
Ref: 1598174692
Ref: 1599174853
Ref: 1600175082
Ref: 1601175334
Ref: 1602175629
Ref: 1603175629
Ref: 1604175702
Ref: 1605175941
Ref: 1606176091
Ref: 1607176210
Ref: 1608176288
Ref: 1609176542
Ref: 1610176542
Ref: 1611176773
Ref: 1612176788
Ref: 1613176914
Ref: 1614176929
Ref: 1615177055
Ref: 1616177070
Ref: 1617177136
Ref: 1618177151
Ref: 1619177307
Ref: 1620177320
Ref: 1621177335
Ref: 1622177623
Ref: 1623177638
Ref: 1624177928
Ref: 1625177943
Ref: 1626178114
Ref: 1627178281
Ref: 1628178282
Ref: 1629178776
Ref: 1630178777
Ref: 1631178866
Ref: 1632178881
Ref: 1633179052
Ref: 1634179219
Ref: 1635179220
Ref: 1636179728
Ref: 1637179729
Ref: 1638179833
Ref: 1639179848
Ref: 1640180059
Ref: 1641180557
Ref: 1642182517
Ref: 1643182532
Ref: 1644182722
Ref: 1645183325
Ref: 1646183340
Ref: 1647184055
Ref: 1648184070
Ref: 1649184350
Ref: 1650184365
Ref: 1651184624
Ref: 1652184639
Ref: 1653184898
Ref: 1654184913
Ref: 1655185299
Ref: 1656185314
Ref: 1657185820
Ref: 1658185821
Ref: 1659185868
Ref: 1660186403
Ref: 1661186404
Ref: 1662186991
Ref: 1663187221
Ref: 1664187222
Ref: 1665187412
Ref: 1666187427
Ref: 1667187783
Ref: 1668187798
Ref: 1669188264
Ref: 1670188265
Ref: 1671188661
Ref: 1672188676
Ref: 1673188997
Ref: 1674189012
Ref: 1675189468
Ref: 1676189469
Ref: 1677189914
Ref: 1678189929
Ref: 1679190112
Ref: 1680190127
Ref: 1681190295
Ref: 1682190310
Ref: 1683191569
Ref: 1684191569
Ref: 1685191937
Node: 3.5.1193485
Ref: 1686193596
Ref: 1687193732
Ref: S0038193732
Ref: 1688193746
Ref: 1689193783
Ref: 1690193866
Ref: S0039193866
Ref: 1691193872
Ref: 1692193894
Ref: 1693193961
Ref: S0040193961
Ref: 1694193965
Ref: 1695194220
Ref: 1696194678
Ref: 1697195016
Ref: 1698195460
Ref: 1699195460
Ref: 1700195460
Node: 3.5.2196748
Ref: 1701196915
Ref: 1702197041
Ref: 1703197041
Ref: 1704197041
Ref: 1705197041
Ref: 1706197720
Ref: 1707197722
Ref: 1708197728
Ref: 1709197728
Ref: 1710197728
Ref: 1711198188
Ref: 1712198188
Node: 3.5.3199689
Ref: 1713199852
Ref: 1714199955
Ref: 1715199957
Ref: 1716200047
Node: 3.5.4200124
Ref: 1717200241
Ref: 1718200241
Ref: 1719200241
Ref: 1720200623
Ref: 1721200698
Ref: S0041200698
Ref: 1722200702
Ref: 1723200736
Ref: 1724200804
Ref: S0042200804
Ref: 1725200824
Ref: 1726200860
Ref: 1727200909
Ref: S0043200909
Ref: 1728200927
Ref: 1729200990
Ref: 1730201122
Ref: 1731201416
Ref: 1732201416
Ref: 1733201416
Ref: 1734202001
Ref: 1735202202
Ref: 1736202204
Ref: 1737202409
Ref: 1738202523
Ref: 1739202525
Ref: 1740202669
Ref: 1741202833
Ref: 1742202833
Ref: 1743203044
Ref: 1744203044
Ref: 1745203044
Ref: 1746203406
Ref: 1747203408
Ref: 1748203609
Ref: 1749203761
Ref: 1750203776
Ref: 1751204083
Ref: 1752204098
Ref: 1753204255
Ref: 1754204597
Ref: 1755204597
Ref: 1756204597
Ref: 1757204786
Ref: 1758204788
Ref: 1759204788
Ref: 1760204962
Ref: 1761205056
Ref: 1762205502
Ref: 1763205502
Ref: 1764206241
Ref: 1765207081
Ref: 1766207674
Ref: 1767207997
Ref: 1768208222
Ref: 1769208222
Node: 3.5.5209735
Ref: 1770210005
Ref: 1771210020
Ref: 1772210344
Ref: 1773210359
Ref: 1774210539
Ref: 1775210554
Ref: 1776210664
Ref: 1777210666
Ref: 1778211056
Ref: 1779211071
Ref: 1780211264
Ref: 1781211279
Ref: 1782211946
Ref: 1783212204
Node: 3.5.6213811
Ref: 1784213922
Ref: 1785214151
Ref: S0044214151
Ref: 1786214164
Ref: 1787214192
Ref: 1788214264
Ref: 1789214508
Ref: 1790214508
Ref: 1791214692
Ref: 1792215004
Ref: 1793215751
Node: 3.5.7216989
Ref: 1794217120
Ref: 1795217342
Ref: S0045217342
Ref: 1796217370
Ref: 1797217382
Ref: 1798217440
Ref: S0046217440
Ref: 1799217467
Ref: 1800217497
Ref: 1801217567
Ref: 1802217779
Ref: 1803217839
Ref: 1804218008
Ref: 1805218225
Ref: 1806218643
Ref: 1807218795
Ref: 1808218963
Ref: 1809219099
Ref: 1810219288
Ref: 1811219423
Ref: 1812219425
Ref: 1813220040
Ref: 1814220042
Ref: 1815220310
Ref: 1816220485
Ref: 1817220643
Ref: 1818220802
Ref: 1819220967
Ref: 1820220967
Ref: 1821221750
Node: 3.5.8222585
Ref: 1822222875
Ref: 1823222890
Ref: 1824223445
Node: 3.5.9224083
Ref: 1825224209
Ref: 1826224209
Ref: 1827224209
Ref: 1828224298
Ref: 1829224488
Ref: S0047224488
Ref: 1830224492
Ref: 1831224527
Ref: 1832224603
Ref: S0048224603
Ref: 1833224631
Ref: 1834224643
Ref: 1835224706
Ref: S0049224706
Ref: 1836224734
Ref: 1837224761
Ref: 1838224773
Ref: 1839224832
Ref: S0050224832
Ref: 1840224861
Ref: 1841224880
Ref: 1842224950
Ref: 1843225154
Ref: 1844225156
Ref: 1845225156
Ref: 1846225773
Ref: 1847225888
Ref: 1848226037
Ref: 1849227012
Ref: 1850227166
Ref: 1851227458
Ref: 1852227460
Ref: 1853227762
Ref: 1854227820
Ref: 1855227989
Ref: 1856227991
Ref: 1857228242
Ref: 1858228397
Ref: 1859228749
Ref: 1860229006
Ref: 1861229105
Ref: 1862229107
Ref: 1863229347
Node: 3.5.10231019
Ref: 1864231290
Ref: 1865231305
Ref: 1866231426
Ref: 1867231428
Ref: 1868231677
Ref: 1869231677
Ref: 1870231689
Ref: 1871231704
Ref: 1872231863
Ref: 1873231878
Ref: 1874232429
Ref: 1875232444
Ref: 1876233046
Ref: 1877233061
Ref: 1878233390
Ref: 1879234194
Ref: 1880234209
Ref: 1881234324
Ref: 1882234576
Ref: 1883234591
Ref: 1884235273
Node: 3.6235861
Ref: 1885235962
Ref: 1886235962
Ref: 1887236332
Ref: S0051236332
Ref: 1888236345
Ref: 1889236378
Ref: 1890236445
Ref: S0052236445
Ref: 1891236464
Ref: 1892236492
Ref: 1893236522
Ref: 1894236581
Ref: S0053236581
Ref: 1895236585
Ref: 1896236644
Ref: S0054236644
Ref: 1897236664
Ref: 1898236695
Ref: 1899236734
Ref: 1900236790
Ref: S0055236790
Ref: 1901236806
Ref: 1902236827
Ref: 1903236869
Ref: S0056236869
Ref: 1904236892
Ref: 1905236929
Ref: 1906236999
Ref: 1907237329
Ref: 1908237445
Ref: 1909237497
Ref: 1910237710
Ref: 1911237710
Ref: 1912237710
Ref: 1913238325
Ref: 1914238375
Ref: 1915238437
Ref: 1916238563
Ref: 1917239036
Ref: 1918239036
Ref: 1919239288
Ref: 1920239461
Ref: 1921239461
Ref: 1922239718
Ref: 1923240244
Ref: 1924240387
Ref: 1925240669
Ref: 1926240903
Ref: 1927241268
Ref: 1928241655
Ref: 1929242180
Ref: 1930242180
Ref: 1931242596
Node: 3.6.1244473
Ref: 1932244830
Ref: S0057244830
Ref: 1933244837
Ref: 1934244855
Ref: 1935244894
Ref: S0058244894
Ref: 1936244910
Ref: 1937244931
Ref: 1938244989
Ref: 1939245105
Ref: 1940245634
Ref: 1941245820
Ref: 1942246023
Ref: 1943246144
Ref: 1944246291
Ref: 1945246405
Node: 3.6.2247796
Ref: 1946248427
Ref: 1947248442
Ref: 1948248571
Ref: 1949248586
Ref: 1950248713
Ref: 1951248728
Ref: 1952248855
Ref: 1953248870
Ref: 1954248997
Ref: 1955249012
Ref: 1956249145
Ref: 1957249160
Ref: 1958249314
Ref: 1959249329
Ref: 1960249496
Ref: 1961249511
Ref: 1962250580
Node: 3.6.3251679
Ref: 1963251826
Node: 3.7253341
Ref: 1964253448
Ref: 1965253448
Ref: 1966253448
Ref: 1967254012
Ref: S0059254012
Ref: 1968254016
Ref: 1969254045
Ref: 1970254108
Ref: S0060254108
Ref: 1971254149
Ref: S0061254149
Ref: 1972254163
Ref: 1973254193
Ref: 1974254258
Ref: S0062254258
Ref: 1975254271
Ref: 1976254299
Ref: 1977254315
Ref: 1978254332
Ref: 1979254366
Ref: 1980254393
Ref: 1981254415
Ref: 1982254467
Ref: S0063254467
Ref: 1983254471
Ref: 1984254535
Ref: 1985254939
Ref: 1986255209
Ref: 1987255982
Ref: 1988257145
Ref: 1989257449
Ref: 1990257637
Ref: 1991257958
Ref: 1992258706
Ref: 1993258706
Ref: 1994258706
Ref: 1995258706
Ref: 1996258827
Ref: 1997258829
Ref: 1998259192
Ref: 1999259194
Ref: 2000259636
Node: 3.7.1261972
Ref: 2001262269
Ref: S0064262269
Ref: 2002262283
Ref: 2003262311
Ref: 2004262370
Ref: S0065262370
Ref: 2005262399
Ref: 2006262431
Ref: 2007262456
Ref: 2008262470
Ref: 2009262581
Ref: 2010262931
Ref: 2011263019
Ref: 2012263303
Ref: 2013264066
Ref: 2014264406
Ref: 2015264581
Ref: 2016264751
Ref: 2017265105
Node: 3.7.2265926
Ref: 2018266622
Ref: 2019266637
Ref: 2020266839
Node: 3.8267170
Ref: 2021267273
Ref: 2022267273
Ref: 2023267436
Ref: 2024267510
Ref: S0066267510
Ref: 2025267545
Ref: 2026267594
Ref: S0067267594
Ref: 2027267627
Ref: 2028267705
Ref: S0068267705
Ref: 2029267721
Ref: 2030267737
Ref: 2031267764
Ref: 2032267780
Ref: 2033267834
Ref: S0069267834
Ref: 2034267838
Ref: 2035267863
Ref: 2036267908
Ref: S0070267908
Ref: 2037267921
Ref: 2038267948
Ref: 2039267973
Ref: 2040268013
Ref: 2041268088
Ref: 2042268284
Ref: 2043269526
Ref: 2044269864
Ref: 2045269864
Ref: 2046269988
Ref: 2047270209
Ref: 2048270533
Ref: 2049270681
Ref: 2050270785
Ref: 2051270932
Ref: 2052271040
Ref: 2053271040
Ref: 2054271040
Ref: 2055271456
Ref: 2056272368
Ref: 2057273726
Node: 3.8.1274717
Ref: 2058275104
Ref: S0071275104
Ref: 2059275137
Ref: 2060275164
Ref: 2061275184
Ref: 2062275226
Ref: S0072275226
Ref: 2063275244
Ref: 2064275279
Ref: 2065275322
Ref: S0073275322
Ref: 2066275326
Ref: 2067275346
Ref: 2068275388
Ref: S0074275388
Ref: 2069275392
Ref: 2070275424
Ref: 2071275451
Ref: 2072275518
Ref: 2073275737
Ref: 2074276259
Ref: 2075276983
Ref: 2076278121
Ref: 2077278121
Ref: 2078279179
Node: 3.9280116
Ref: 2079280260
Ref: 2080280260
Ref: 2081280260
Ref: 2082280260
Ref: 2083280260
Ref: 2084280421
Ref: 2085280423
Ref: 2086280423
Ref: 2087280475
Ref: 2088280876
Ref: 2089280878
Ref: 2090280980
Ref: 2091280980
Ref: 2092280980
Ref: 2093281559
Ref: 2094281896
Ref: 2095281966
Ref: 2096281968
Ref: 2097281968
Ref: 2098281968
Ref: 2099282610
Ref: 2100282674
Ref: 2101282749
Ref: 2102282827
Ref: 2103282878
Ref: 2104282934
Ref: 2105283000
Ref: 2106283076
Ref: 2107283131
Ref: 2108283200
Ref: 2109283280
Ref: 2110283390
Ref: 2111283444
Ref: 2112283516
Ref: 2113283593
Ref: 2114283638
Ref: 2115286353
Ref: 2116286959
Ref: 2117287188
Ref: 2118287203
Ref: 2119287458
Ref: 2120287473
Ref: 2121287661
Ref: 2122287676
Ref: 2123288006
Ref: 2124288021
Ref: 2125288180
Ref: 2126289025
Ref: 2127289147
Ref: 2128289285
Ref: 2129289390
Ref: 2130289515
Ref: 2131289629
Ref: 2132290520
Ref: 2133292164
Ref: 2134292164
Node: 3.9.1292610
Ref: 2135292719
Ref: 2136292719
Ref: 2137292719
Ref: 2138292719
Ref: 2139292719
Ref: 2140292719
Ref: 2141292952
Ref: S0075292952
Ref: 2142292962
Ref: 2143293293
Ref: 2144293721
Ref: 2145293928
Node: 3.9.2296506
Ref: 2146296675
Ref: 2147296675
Ref: 2148296675
Ref: 2149296675
Ref: 2150296675
Ref: 2151296675
Ref: 2152296675
Ref: 2153296675
Ref: 2154297664
Ref: 2155297666
Ref: 2156297666
Ref: 2157297666
Ref: 2158297666
Ref: 2159297718
Ref: 2160297718
Ref: 2161297836
Ref: 2162298038
Ref: 2163298293
Ref: 2164298295
Ref: 2165298728
Ref: 2166298728
Ref: 2167299267
Ref: 2168299509
Ref: 2169299740
Ref: 2170301452
Ref: 2171301579
Ref: 2172302948
Ref: 2173302948
Ref: 2174303151
Ref: 2175303505
Ref: 2176303507
Ref: 2177303631
Ref: 2178304957
Node: 3.9.3307688
Ref: 2179307841
Ref: 2180307841
Ref: 2181307841
Ref: 2182307841
Ref: 2183307977
Ref: 2184307979
Ref: 2185308329
Ref: S0076308329
Ref: 2186308344
Ref: 2187308375
Ref: 2188308426
Ref: 2189308502
Ref: 2190308502
Ref: 2191308894
Ref: 2192308894
Ref: 2193310059
Ref: 2194312175
Node: 3.9.4313731
Ref: 2195314114
Ref: S0077314114
Ref: 2196314187
Ref: 2197314233
Ref: S0078314233
Ref: 2198314250
Ref: 2199314280
Ref: 2200314400
Ref: 2201314400
Ref: 2202314720
Ref: 2203314720
Ref: 2204314721
Ref: 2205314721
Ref: 2206314721
Ref: 2207314721
Ref: 2208314721
Ref: 2209314721
Ref: 2210314721
Ref: 2211314721
Ref: 2212314845
Ref: 2213314845
Ref: 2214314845
Ref: 2215314845
Ref: 2216314845
Ref: 2217314845
Ref: 2218314845
Ref: 2219315235
Ref: 2220315235
Ref: 2221316972
Node: 3.10321340
Ref: 2222321447
Ref: 2223321447
Ref: 2224321447
Ref: 2225321745
Ref: 2226321747
Ref: 2227321821
Ref: S0079321821
Ref: 2228321836
Ref: 2229321852
Ref: 2230321890
Ref: 2231321906
Ref: 2232321973
Ref: S0080321973
Ref: 2233321995
Ref: 2234322020
Ref: 2235322070
Ref: S0081322070
Ref: 2236322129
Ref: S0082322129
Ref: 2237322172
Ref: 2238322228
Ref: 2239322283
Ref: S0083322283
Ref: 2240322324
Ref: S0084322324
Ref: 2241322339
Ref: 2242322373
Ref: 2243322396
Ref: 2244322441
Ref: 2245322469
Ref: 2246322513
Ref: 2247322599
Ref: 2248322599
Ref: 2249322599
Ref: 2250322599
Ref: 2251322763
Ref: 2252322943
Ref: 2253323166
Ref: 2254323166
Ref: 2255323539
Ref: 2256324345
Ref: 2257324346
Ref: 2258324550
Ref: 2259324715
Ref: 2260325068
Ref: 2261325162
Ref: 2262325269
Ref: 2263325612
Ref: 2264325612
Ref: 2265325612
Ref: 2266326113
Ref: 2267326120
Ref: 2268326859
Ref: 2269327399
Ref: 2270327399
Ref: 2271328237
Ref: 2272328445
Ref: 2273328738
Ref: 2274328974
Node: 3.10.1330811
Ref: 2275331459
Ref: S0085331459
Ref: 2276331469
Ref: 2277331490
Ref: 2278331581
Ref: 2279331581
Ref: 2280331875
Ref: 2281331875
Ref: 2282333041
Ref: 2283334434
Ref: 2284337056
Ref: 2285337146
Node: 3.10.2339022
Ref: 2286339459
Ref: 2287340037
Ref: 2288340039
Ref: 2289340217
Ref: 2290340217
Ref: 2291340217
Ref: 2292340217
Ref: 2293340217
Ref: 2294340217
Ref: 2295341151
Ref: 2296341151
Ref: 2297343378
Ref: 2298343378
Ref: 2299343378
Ref: 2300348773
Ref: 2301350009
Ref: 2302351721
Ref: 2303351721
Ref: 2304354579
Ref: 2305354579
Ref: 2306354860
Ref: 2307354875
Ref: 2308355129
Ref: 2309356706
Ref: 2310357122
Ref: 2311357361
Ref: 2312357366
Ref: 2313357381
Ref: 2314357381
Ref: 2315357560
Ref: 2316357982
Ref: 2317357997
Ref: 2318358214
Ref: 2319358308
Ref: 2320358653
Ref: 2321359266
Ref: 2322359266
Ref: 2323360530
Ref: 2324360887
Ref: 2325361419
Ref: 2326361419
Node: 3.11362771
Ref: 2327363004
Ref: S0086363004
Ref: 2328363010
Ref: 2329363052
Ref: S0087363052
Ref: 2330363066
Ref: 2331363091
Ref: 2332363128
Ref: S0088363128
Ref: 2333363142
Ref: 2334363162
Ref: 2335363178
Ref: 2336363201
Ref: S0089363201
Ref: 2337363205
Ref: 2338363220
Ref: 2339363249
Ref: S0090363249
Ref: 2340363263
Ref: 2341363281
Ref: 2342363296
Ref: 2343363308
Ref: 2344363485
Ref: 2345363536
Ref: 2346363701
Ref: 2347363849
Ref: 2348363849
Ref: 2349364197
Ref: 2350364545
Ref: 2351365198
Ref: 2352365203
Node: 3.11.1365324
Ref: 2353365488
Ref: 2354365564
Ref: 2355365716
Ref: 2356366460
Ref: 2357366565
Ref: 2358366903
Node: 4367884
Node: 4.1368418
Ref: 2359368975
Ref: S0091368975
Ref: 2360368990
Ref: 2361369006
Ref: 2362369037
Ref: 2363369059
Ref: 2364369075
Ref: 2365369098
Ref: 2366369128
Ref: 2367369148
Ref: 2368369172
Ref: 2369369194
Ref: 2370369225
Ref: 2371369251
Ref: 2372369291
Ref: S0092369291
Ref: 2373369295
Ref: 2374369309
Ref: 2375369339
Ref: S0093369339
Ref: 2376369343
Ref: 2377369351
Ref: 2378369400
Ref: S0094369400
Ref: 2379369404
Ref: 2380369442
Ref: S0095369442
Ref: 2381369446
Ref: 2382369770
Ref: 2383369770
Ref: 2384369947
Ref: 2385370502
Ref: 2386370751
Ref: 2387370916
Ref: 2388370997
Ref: 2389371178
Ref: 2390371343
Ref: 2391371345
Ref: 2392371417
Node: 4.1.1372665
Ref: 2393372873
Ref: 2394372942
Ref: S0096372942
Ref: 2395372946
Ref: 2396372954
Ref: 2397372968
Ref: 2398373347
Ref: 2399373592
Ref: 2400373880
Ref: 2401373991
Ref: 2402374067
Ref: 2403374069
Ref: 2404374069
Ref: 2405374199
Node: 4.1.2375328
Ref: 2406375431
Ref: 2407375706
Ref: S0097375706
Ref: 2408375710
Ref: 2409375718
Ref: 2410375893
Ref: 2411376386
Ref: 2412376487
Ref: 2413376487
Ref: 2414376489
Ref: 2415376489
Ref: 2416376696
Node: 4.1.3377824
Ref: 2417378138
Ref: 2418378208
Ref: S0098378208
Ref: 2419378212
Ref: 2420378222
Ref: 2421378257
Ref: S0099378257
Ref: 2422378261
Ref: 2423378275
Ref: 2424378295
Ref: 2425378363
Ref: 2426381026
Ref: 2427381031
Ref: 2428382810
Ref: 2429382892
Ref: 2430382892
Ref: 2431383084
Ref: 2432383086
Node: 4.1.4384633
Ref: 2433384744
Ref: 2434384983
Ref: S0100384983
Ref: 2435384987
Ref: 2436384995
Ref: 2437385046
Ref: S0101385046
Ref: 2438385060
Ref: 2439385081
Ref: 2440385166
Ref: S0102385166
Ref: 2441385170
Ref: 2442385178
Ref: 2443385239
Ref: S0103385239
Ref: 2444385260
Ref: 2445386025
Ref: 2446386025
Ref: 2447387527
Ref: 2448387527
Ref: 2449388644
Node: 4.1.5389430
Ref: 2450389864
Ref: 2451389864
Ref: 2452389956
Ref: 2453390012
Ref: 2454390146
Ref: 2455390393
Ref: S0104390393
Ref: 2456390417
Ref: 2457390575
Ref: 2458391491
Ref: 2459391710
Ref: 2460391712
Ref: 2461391802
Node: 4.1.6392701
Ref: 2462393423
Ref: 2463393423
Ref: 2464394060
Ref: 2465394060
Ref: 2466394305
Ref: 2467394383
Ref: 2468394734
Ref: S0105394734
Ref: 2469394768
Ref: 2470394775
Ref: 2471394978
Ref: 2472395217
Ref: 2473395217
Ref: 2474395618
Ref: 2475395618
Node: 4.2397165
Ref: 2476397260
Ref: 2477397451
Ref: 2478397541
Ref: 2479397541
Ref: 2480398121
Ref: 2481398826
Ref: 2482398826
Ref: 2483398826
Ref: 2484398877
Ref: 2485398877
Ref: 2486398877
Ref: 2487398877
Ref: 2488398969
Ref: 2489399384
Ref: 2490399384
Ref: 2491399699
Node: 4.3400334
Ref: 2492400433
Ref: 2493400548
Ref: 2494400609
Ref: S0106400609
Ref: 2495400613
Ref: 2496400633
Ref: 2497400655
Ref: 2498400731
Ref: 2499400976
Ref: 2500401265
Ref: 2501401336
Ref: 2502401397
Ref: 2503401397
Ref: 2504401506
Node: 4.3.1401665
Ref: 2505401995
Ref: S0107401995
Ref: 2506402001
Ref: 2507402077
Ref: S0108402077
Ref: 2508402091
Ref: 2509402123
Ref: 2510402212
Ref: S0109402212
Ref: 2511402227
Ref: 2512402253
Ref: 2513402274
Ref: 2514402331
Ref: S0110402331
Ref: 2515402358
Ref: 2516402387
Ref: 2517402422
Ref: 2518402554
Ref: 2519403058
Ref: 2520403153
Ref: 2521403669
Ref: 2522403807
Ref: 2523405678
Ref: 2524405810
Ref: 2525406091
Ref: 2526406471
Node: 4.3.2408407
Ref: 2527408828
Ref: S0111408828
Ref: 2528408843
Ref: 2529408862
Ref: 2530408918
Ref: S0112408918
Ref: 2531408922
Ref: 2532408936
Ref: 2533409003
Ref: 2534409098
Ref: 2535409502
Ref: 2536410239
Ref: 2537410725
Ref: 2538411338
Ref: 2539411344
Ref: 2540411344
Ref: 2541411782
Node: 4.3.3412727
Ref: 2542413275
Ref: S0113413275
Ref: 2543413287
Ref: 2544413316
Ref: 2545413374
Ref: S0114413374
Ref: 2546413389
Ref: 2547413401
Ref: 2548413415
Ref: 2549413438
Ref: 2550413452
Ref: 2551413475
Ref: 2552413497
Ref: 2553413511
Ref: 2554413567
Ref: S0115413567
Ref: 2555413582
Ref: 2556413613
Ref: 2557413680
Ref: S0116413680
Ref: 2558413694
Ref: 2559413718
Ref: 2560413738
Ref: 2561413768
Ref: 2562413918
Ref: 2563414110
Ref: 2564414363
Ref: 2565414462
Ref: 2566414586
Ref: 2567414725
Ref: 2568415255
Ref: 2569418637
Ref: 2570418889
Ref: 2571418889
Ref: 2572419157
Ref: 2573419159
Ref: 2574419582
Ref: 2575420443
Ref: 2576420443
Ref: 2577420584
Ref: 2578420584
Ref: 2579420773
Ref: 2580420773
Ref: 2581420912
Node: 4.4423061
Ref: 2582423164
Ref: 2583423534
Ref: 2584423536
Ref: 2585423536
Ref: 2586423536
Ref: 2587423536
Ref: 2588423536
Ref: 2589423536
Ref: 2590423536
Ref: 2591423536
Ref: 2592423536
Ref: 2593423536
Ref: 2594423536
Ref: 2595423536
Ref: 2596423536
Ref: 2597423536
Ref: 2598423536
Ref: 2599423536
Ref: 2600423536
Ref: 2601423536
Ref: 2602423536
Ref: 2603423536
Ref: 2604423536
Ref: 2605423536
Ref: 2606423536
Ref: 2607423536
Ref: 2608423536
Ref: 2609423536
Ref: 2610423536
Ref: 2611423536
Ref: 2612423536
Ref: 2613423536
Ref: 2614423536
Ref: 2615423536
Ref: 2616423536
Ref: 2617423536
Ref: 2618423536
Ref: 2619423536
Ref: 2620423536
Ref: 2621423536
Ref: 2622423536
Ref: 2623423536
Ref: 2624423536
Ref: 2625423536
Ref: 2626423536
Ref: 2627423536
Ref: 2628423536
Ref: 2629423536
Ref: 2630423536
Ref: 2631423536
Ref: 2632423536
Ref: 2633423536
Ref: 2634423536
Ref: 2635423536
Ref: 2636423536
Ref: 2637423536
Ref: 2638423536
Ref: 2639423536
Ref: 2640423536
Ref: 2641423536
Ref: 2642423536
Ref: 2643423536
Ref: 2644423536
Ref: 2645423536
Ref: 2646423536
Ref: 2647423536
Ref: 2648423536
Ref: 2649423536
Ref: 2650423536
Ref: 2651423536
Ref: 2652423536
Ref: 2653423536
Ref: 2654423536
Ref: 2655423596
Ref: S0117423596
Ref: 2656423611
Ref: 2657423625
Ref: 2658423640
Ref: 2659423659
Ref: 2660423679
Ref: 2661423692
Ref: 2662423707
Ref: 2663423725
Ref: 2664423745
Ref: 2665423759
Ref: 2666423798
Ref: S0118423798
Ref: 2667423813
Ref: 2668423834
Ref: 2669423861
Ref: 2670423881
Ref: 2671423908
Ref: 2672423929
Ref: 2673423956
Ref: 2674423982
Ref: 2675424009
Ref: 2676424034
Ref: 2677424078
Ref: S0119424078
Ref: 2678424093
Ref: 2679424112
Ref: 2680424132
Ref: 2681424169
Ref: S0120424169
Ref: 2682424184
Ref: 2683424203
Ref: 2684424223
Ref: 2685424261
Ref: 2686424288
Ref: 2687424321
Ref: 2688424372
Ref: S0121424372
Ref: 2689424376
Ref: 2690424398
Ref: 2691424446
Ref: S0122424446
Ref: 2692424460
Ref: 2693424480
Ref: 2694424488
Ref: 2695424532
Ref: S0123424532
Ref: 2696424538
Ref: 2697424561
Ref: 2698424567
Ref: 2699424596
Ref: 2700424614
Ref: S0124424614
Ref: 2701424618
Ref: 2702424627
Ref: 2703424648
Ref: 2704424670
Ref: S0125424670
Ref: 2705424674
Ref: 2706424687
Ref: 2707424702
Ref: 2708424716
Ref: 2709424741
Ref: S0126424741
Ref: 2710424754
Ref: 2711424779
Ref: 2712424796
Ref: 2713424814
Ref: 2714424821
Ref: 2715424834
Ref: 2716424855
Ref: 2717424882
Ref: 2718425223
Ref: 2719425363
Ref: 2720425363
Ref: 2721425363
Node: 4.5426860
Ref: 2722427009
Ref: 2723427009
Ref: 2724427375
Ref: S0127427375
Ref: 2725427427
Ref: S0128427427
Ref: 2726427496
Ref: S0129427496
Ref: 2727427548
Ref: S0130427548
Ref: 2728427593
Ref: S0131427593
Ref: 2729427659
Ref: S0132427659
Ref: 2730427937
Ref: 2731427937
Ref: 2732428096
Ref: 2733428098
Ref: 2734428098
Ref: 2735428098
Ref: 2736428666
Ref: 2737429047
Ref: 2738429244
Node: 4.5.1430964
Ref: 2739431188
Ref: 2740431188
Ref: 2741431188
Ref: 2742431337
Ref: 2743431451
Ref: 2744431451
Ref: 2745431451
Ref: 2746431451
Ref: 2747431451
Ref: 2748431451
Ref: 2749431451
Ref: 2750431451
Ref: 2751431638
Ref: 2752432714
Ref: 2753433017
Ref: 2754433017
Ref: 2755433181
Ref: 2756433183
Ref: 2757433272
Node: 4.5.2434100
Ref: 2758434273
Ref: 2759434273
Ref: 2760434273
Ref: 2761434273
Ref: 2762434273
Ref: 2763434365
Ref: 2764434367
Ref: 2765434516
Ref: 2766434518
Ref: 2767434518
Ref: 2768434518
Ref: 2769434518
Ref: 2770434518
Ref: 2771434518
Ref: 2772434518
Ref: 2773434518
Ref: 2774434518
Ref: 2775434518
Ref: 2776434518
Ref: 2777434518
Ref: 2778434518
Ref: 2779434518
Ref: 2780434518
Ref: 2781434518
Ref: 2782434518
Ref: 2783434518
Ref: 2784434518
Ref: 2785434518
Ref: 2786434518
Ref: 2787434518
Ref: 2788434518
Ref: 2789434518
Ref: 2790434689
Ref: 2791434689
Ref: 2792434689
Ref: 2793435086
Ref: 2794435086
Ref: 2795438936
Ref: 2796439917
Ref: 2797440100
Ref: 2798440813
Ref: 2799442801
Ref: 2800442904
Ref: 2801443695
Ref: 2802443702
Ref: 2803443991
Ref: 2804445135
Node: 4.5.3448100
Ref: 2805448283
Ref: 2806448283
Ref: 2807448283
Ref: 2808448283
Ref: 2809448283
Ref: 2810448283
Ref: 2811448283
Ref: 2812448283
Ref: 2813448283
Ref: 2814448283
Ref: 2815448571
Ref: 2816448571
Ref: 2817448571
Ref: 2818448571
Ref: 2819448571
Ref: 2820448571
Ref: 2821448571
Ref: 2822449004
Ref: 2823449902
Ref: 2824449904
Ref: 2825450053
Ref: 2826450422
Ref: 2827450429
Node: 4.5.4451181
Ref: 2828451362
Ref: 2829451362
Ref: 2830451362
Ref: 2831451362
Ref: 2832451362
Ref: 2833451362
Ref: 2834451362
Ref: 2835451362
Ref: 2836451362
Ref: 2837451362
Node: 4.5.5451873
Ref: 2838452052
Ref: 2839452052
Ref: 2840452052
Ref: 2841452052
Ref: 2842452052
Ref: 2843452052
Ref: 2844452052
Ref: 2845452052
Ref: 2846452052
Ref: 2847452052
Ref: 2848452052
Ref: 2849452052
Ref: 2850452052
Ref: 2851452052
Ref: 2852452052
Ref: 2853452052
Ref: 2854456421
Ref: 2855456428
Ref: 2856456428
Ref: 2857456428
Node: 4.5.6459323
Ref: 2858459516
Ref: 2859459516
Ref: 2860459516
Ref: 2861459516
Ref: 2862459516
Ref: 2863459710
Ref: 2864459710
Ref: 2865459710
Ref: 2866460596
Ref: 2867460598
Ref: 2868460598
Ref: 2869460747
Ref: 2870460747
Ref: 2871460747
Ref: 2872460747
Ref: 2873461207
Ref: 2874461722
Ref: 2875462118
Ref: 2876462118
Ref: 2877462261
Node: 4.5.7462312
Ref: 2878463079
Ref: S0133463079
Ref: 2879463083
Ref: 2880463100
Ref: 2881463139
Ref: S0134463139
Ref: 2882463155
Ref: 2883463182
Ref: 2884463208
Ref: 2885463235
Ref: 2886463273
Ref: 2887463304
Ref: S0135463304
Ref: 2888463319
Ref: 2889463355
Ref: S0136463355
Ref: 2890463386
Ref: 2891463409
Ref: 2892463449
Ref: 2893463515
Ref: S0137463515
Ref: 2894463534
Ref: 2895463583
Ref: 2896464301
Ref: 2897465026
Ref: 2898465202
Ref: 2899465202
Ref: 2900465204
Ref: 2901466715
Ref: 2902467117
Ref: 2903467117
Ref: 2904467117
Ref: 2905467257
Node: 4.5.8467259
Ref: 2906467582
Ref: S0138467582
Ref: 2907467591
Ref: 2908467602
Ref: 2909467640
Ref: 2910467663
Ref: 2911467674
Ref: 2912467700
Ref: 2913467730
Ref: S0139467730
Ref: 2914467765
Ref: S0140467765
Ref: 2915467780
Ref: 2916468032
Ref: 2917468175
Ref: 2918468587
Node: 4.6469788
Ref: 2919470192
Ref: 2920470194
Ref: 2921470194
Ref: 2922470194
Ref: 2923470194
Ref: 2924470194
Ref: 2925470259
Ref: S0141470259
Ref: 2926470273
Ref: 2927470286
Ref: 2928470307
Ref: 2929470320
Ref: 2930470329
Ref: 2931470414
Ref: 2932470500
Ref: 2933470538
Ref: 2934470793
Ref: 2935470793
Ref: 2936471006
Ref: 2937471006
Ref: 2938471060
Ref: 2939471115
Ref: 2940471538
Ref: 2941471538
Ref: 2942471759
Ref: 2943471759
Ref: 2944472367
Ref: 2945472367
Ref: 2946472470
Ref: 2947472470
Ref: 2948472707
Ref: 2949472778
Ref: 2950472993
Ref: 2951473492
Ref: 2952473492
Ref: 2953474020
Ref: 2954474242
Ref: 2955474514
Ref: 2956474988
Ref: 2957474988
Ref: 2958475119
Ref: 2959475119
Ref: 2960475397
Ref: 2961475424
Ref: 2962475698
Ref: 2963476285
Ref: 2964476400
Ref: 2965476400
Ref: 2966476400
Ref: 2967476597
Ref: 2968476599
Ref: 2969476599
Ref: 2970476874
Ref: 2971476874
Ref: 2972477390
Ref: 2973477916
Ref: 2974477916
Ref: 2975478090
Ref: 2976478090
Ref: 2977478131
Ref: 2978478131
Ref: 2979478478
Ref: 2980478478
Ref: 2981478727
Ref: 2982479317
Ref: 2983479319
Ref: 2984479329
Ref: 2985479329
Ref: 2986479579
Ref: 2987479581
Ref: 2988480007
Ref: 2989480008
Ref: 2990480658
Ref: 2991480658
Ref: 2992480981
Ref: 2993480981
Ref: 2994481097
Ref: 2995481097
Ref: 2996481788
Ref: 2997481790
Ref: 2998482322
Ref: 2999482322
Ref: 3000482322
Ref: 3001482322
Ref: 3002482322
Ref: 3003482322
Ref: 3004482322
Ref: 3005482322
Ref: 3006482720
Ref: 3007482720
Ref: 3008482725
Ref: 3009482891
Ref: 3010482892
Ref: 3011482892
Ref: 3012482892
Ref: 3013482892
Ref: 3014482892
Ref: 3015483897
Ref: 3016484409
Ref: 3017484418
Ref: 3018484418
Ref: 3019484418
Ref: 3020485464
Ref: 3021485593
Ref: 3022486166
Ref: 3023486171
Node: 4.7488103
Ref: 3024488371
Ref: 3025488443
Ref: S0142488443
Ref: 3026488456
Ref: 3027488470
Ref: 3028488484
Ref: 3029488497
Ref: 3030488559
Ref: 3031489046
Ref: 3032489046
Ref: 3033489046
Ref: 3034489046
Ref: 3035489046
Ref: 3036489046
Ref: 3037489046
Ref: 3038489271
Ref: 3039489273
Node: 4.8490530
Ref: 3040490732
Ref: 3041490734
Ref: 3042490734
Ref: 3043490795
Ref: S0143490795
Ref: 3044490813
Ref: 3045490836
Ref: 3046490868
Ref: 3047490891
Ref: 3048490945
Ref: S0144490945
Ref: 3049490968
Ref: 3050491148
Ref: 3051491685
Ref: 3052491734
Ref: 3053491805
Ref: 3054492102
Ref: 3055493337
Ref: 3056494040
Ref: 3057494095
Ref: 3058494205
Ref: 3059494207
Ref: 3060494359
Ref: 3061494365
Ref: 3062494494
Ref: 3063494942
Ref: 3064494944
Ref: 3065494944
Ref: 3066494944
Ref: 3067495028
Ref: 3068495173
Ref: 3069495905
Ref: 3070495905
Ref: 3071495905
Ref: 3072496121
Ref: 3073496121
Ref: 3074496121
Ref: 3075496359
Ref: 3076496359
Ref: 3077496359
Ref: 3078496615
Ref: 3079496615
Ref: 3080496615
Ref: 3081496615
Ref: 3082496615
Ref: 3083496617
Ref: 3084496835
Ref: 3085497525
Node: 4.9498705
Ref: 3086499055
Ref: 3087499166
Ref: 3088499172
Ref: 3089500860
Ref: 3090501266
Ref: 3091501814
Ref: 3092502191
Ref: 3093502344
Ref: 3094502626
Ref: 3095502710
Ref: 3096502929
Ref: 3097503380
Ref: 3098503501
Ref: 3099503501
Ref: 3100503501
Ref: 3101503604
Ref: 3102503748
Ref: 3103504003
Ref: 3104504332
Ref: 3105506403
Node: 4.9.1508537
Ref: 3106508736
Ref: 3107509245
Ref: 3108509855
Ref: 3109510018
Ref: 3110510208
Ref: 3111510383
Node: 5511202
Node: 5.1512427
Ref: 3112512853
Ref: S0145512853
Ref: 3113512857
Ref: 3114512869
Ref: 3115512881
Ref: 3116512905
Ref: S0146512905
Ref: 3117512919
Ref: 3118512926
Ref: 3119512946
Ref: 3120512953
Ref: 3121512998
Ref: S0147512998
Ref: 3122513002
Ref: 3123513028
Ref: 3124513053
Ref: 3125513078
Ref: 3126513097
Ref: 3127513132
Ref: 3128513160
Ref: 3129513191
Ref: 3130513213
Ref: 3131513239
Ref: 3132513259
Ref: 3133513285
Ref: 3134513328
Ref: S0148513328
Ref: 3135513343
Ref: 3136513360
Ref: 3137513385
Ref: 3138513404
Ref: 3139513430
Ref: 3140513466
Ref: 3141513487
Ref: 3142513526
Ref: S0149513526
Ref: 3143513550
Ref: S0150513550
Ref: 3144513565
Ref: 3145513616
Ref: S0151513616
Ref: 3146513620
Ref: 3147514841
Ref: 3148514896
Ref: 3149515386
Node: 5.2516249
Ref: 3150516549
Ref: S0152516549
Ref: 3151516573
Ref: 3152516581
Ref: 3153516749
Ref: 3154516751
Ref: 3155516937
Ref: 3156516937
Ref: 3157517199
Ref: 3158517276
Ref: 3159517699
Ref: 3160517826
Ref: 3161517881
Ref: 3162518036
Ref: 3163518036
Ref: 3164518036
Ref: 3165518373
Ref: 3166518594
Ref: 3167518594
Ref: 3168518901
Node: 5.3520443
Ref: 3169520772
Ref: S0153520772
Ref: 3170520789
Ref: 3171520815
Ref: 3172520853
Ref: 3173520879
Ref: 3174520928
Ref: 3175521057
Node: 5.4521953
Ref: 3176522287
Ref: S0154522287
Ref: 3177522317
Ref: 3178522343
Ref: 3179522382
Ref: 3180522462
Ref: S0155522462
Ref: 3181522480
Ref: 3182522515
Ref: 3183522592
Ref: 3184522592
Ref: 3185522658
Ref: 3186524073
Ref: 3187524413
Ref: 3188524413
Ref: 3189524413
Node: 5.5525593
Ref: 3190525871
Ref: S0156525871
Ref: 3191525892
Ref: 3192525927
Ref: 3193525964
Ref: 3194526016
Ref: 3195526055
Ref: S0157526055
Ref: 3196526066
Ref: 3197526090
Ref: 3198526133
Ref: 3199526192
Ref: S0158526192
Ref: 3200526205
Ref: 3201526238
Ref: 3202526510
Ref: 3203526655
Ref: 3204526705
Ref: 3205527022
Ref: 3206527374
Ref: 3207527374
Ref: 3208528119
Node: 5.5.1530363
Ref: 3209530610
Ref: 3210530815
Ref: 3211530871
Ref: 3212530949
Ref: 3213531057
Ref: 3214531137
Ref: 3215531217
Ref: 3216531479
Ref: 3217531615
Ref: 3218531671
Ref: 3219531747
Ref: 3220531887
Ref: 3221532585
Ref: 3222532663
Ref: 3223532797
Ref: 3224532797
Ref: 3225532797
Ref: 3226532956
Ref: 3227532956
Ref: 3228532956
Ref: 3229533168
Ref: 3230533303
Ref: 3231533379
Ref: 3232533475
Ref: 3233534298
Ref: 3234534923
Node: 5.5.2534925
Ref: 3235535208
Ref: S0159535208
Ref: 3236535222
Ref: 3237535266
Ref: 3238535280
Ref: 3239535303
Ref: 3240535353
Ref: 3241535490
Ref: 3242535490
Ref: 3243535554
Ref: 3244535685
Ref: 3245535802
Ref: 3246535802
Ref: 3247535857
Ref: 3248535857
Ref: 3249535997
Ref: 3250535997
Ref: 3251536035
Ref: 3252536035
Ref: 3253537672
Ref: 3254539118
Ref: 3255540037
Ref: 3256540302
Ref: 3257541174
Ref: 3258541346
Ref: 3259541419
Node: 5.6543190
Ref: 3260543468
Ref: S0160543468
Ref: 3261543490
Ref: 3262543551
Ref: 3263543605
Ref: 3264543662
Ref: 3265544057
Node: 5.7544439
Ref: 3266544769
Ref: S0161544769
Ref: 3267544795
Ref: 3268544807
Ref: 3269545007
Ref: 3270545796
Node: 5.8546657
Ref: 3271546938
Ref: S0162546938
Ref: 3272546956
Ref: 3273547014
Ref: 3274547483
Node: 6548361
Ref: 3275548454
Ref: 3276548454
Ref: 3277548454
Ref: 3278548917
Ref: 3279548978
Ref: 3280549063
Node: 6.1549498
Ref: 3281549743
Ref: S0163549743
Ref: 3282549758
Ref: 3283549789
Ref: 3284549828
Ref: 3285549925
Ref: S0164549925
Ref: 3286549939
Ref: 3287549972
Ref: 3288550030
Ref: S0165550030
Ref: 3289550045
Ref: 3290550072
Ref: 3291550130
Ref: S0166550130
Ref: 3292550144
Ref: 3293550164
Ref: 3294550217
Ref: S0167550217
Ref: 3295550223
Ref: 3296550243
Ref: 3297550256
Ref: 3298550299
Ref: S0168550299
Ref: 3299550303
Ref: 3300550333
Ref: 3301550398
Ref: S0169550398
Ref: 3302550404
Ref: 3303550424
Ref: 3304550572
Ref: S0170550572
Ref: 3305550576
Ref: 3306550881
Ref: S0171550881
Ref: 3307550885
Ref: 3308550928
Ref: S0172550928
Ref: 3309550934
Ref: 3310550986
Ref: S0173550986
Ref: 3311551001
Ref: 3312551022
Ref: 3313551038
Ref: 3314551061
Ref: 3315551081
Ref: 3316551119
Ref: S0174551119
Ref: 3317551133
Ref: 3318551160
Ref: 3319551220
Ref: S0175551220
Ref: 3320551234
Ref: 3321551271
Ref: 3322551277
Ref: 3323551293
Ref: 3324551316
Ref: 3325551345
Ref: 3326551372
Ref: 3327551394
Ref: 3328551433
Ref: S0176551433
Ref: 3329551511
Ref: 3330551704
Ref: 3331551816
Ref: 3332551870
Ref: 3333552205
Ref: 3334552205
Ref: 3335552858
Ref: 3336553490
Ref: 3337553874
Ref: 3338553885
Ref: 3339553885
Ref: 3340554013
Ref: 3341554094
Ref: 3342554521
Ref: 3343555238
Ref: 3344556094
Node: 6.1.1558053
Ref: 3345558561
Ref: 3346558561
Ref: 3347558724
Ref: 3348558724
Ref: 3349558989
Ref: 3350558989
Ref: 3351559218
Ref: 3352559218
Ref: 3353559429
Ref: 3354559429
Ref: 3355559593
Ref: 3356559593
Ref: 3357559861
Ref: 3358559861
Ref: 3359560012
Ref: 3360560012
Ref: 3361560152
Ref: 3362560152
Ref: 3363562110
Ref: 3364562742
Ref: 3365563298
Ref: 3366563298
Ref: 3367564036
Ref: 3368564036
Ref: 3369564106
Ref: 3370564548
Ref: 3371564563
Ref: 3372566808
Ref: 3373566823
Ref: 3374568158
Ref: 3375568158
Ref: 3376568158
Ref: 3377568457
Ref: 3378568457
Ref: 3379568457
Ref: 3380569027
Ref: 3381569027
Ref: 3382569780
Ref: 3383569780
Ref: 3384569780
Ref: 3385569780
Ref: 3386569780
Node: 6.2572713
Ref: 3387572967
Ref: 3388572967
Ref: 3389572967
Ref: 3390572967
Ref: 3391572967
Ref: 3392572967
Ref: 3393573458
Ref: 3394573696
Ref: 3395574124
Ref: 3396574607
Ref: 3397574761
Ref: 3398574761
Ref: 3399574761
Ref: 3400574761
Ref: 3401575431
Node: 6.3576001
Ref: 3402576239
Ref: S0177576239
Ref: 3403576254
Ref: 3404576285
Ref: 3405576323
Ref: 3406576360
Ref: 3407576405
Ref: 3408576450
Ref: 3409577033
Ref: 3410577286
Ref: 3411577461
Node: 6.3.1578402
Ref: 3412578513
Ref: 3413578513
Ref: 3414578513
Ref: 3415578513
Ref: 3416578513
Ref: 3417578751
Ref: 3418578751
Ref: 3419579129
Ref: 3420579129
Ref: 3421579326
Ref: 3422579326
Ref: 3423580322
Ref: 3424580322
Ref: 3425580607
Ref: 3426580607
Ref: 3427581534
Ref: 3428581534
Ref: 3429581858
Ref: 3430581867
Ref: 3431581867
Ref: 3432582306
Ref: 3433582315
Ref: 3434582315
Ref: 3435582584
Ref: 3436582593
Ref: 3437582593
Ref: 3438583126
Ref: 3439584198
Ref: 3440584455
Ref: 3441584462
Ref: 3442584714
Node: 6.3.2585235
Ref: 3443586085
Ref: 3444586085
Node: 6.4586467
Ref: 3445586578
Ref: 3446586889
Ref: S0178586889
Ref: 3447586915
Ref: 3448586942
Ref: 3449586949
Ref: 3450586993
Ref: S0179586993
Ref: 3451587018
Ref: 3452587043
Ref: 3453587050
Ref: 3454587101
Ref: S0180587101
Ref: 3455587116
Ref: 3456587141
Ref: 3457587194
Ref: S0181587194
Ref: 3458587227
Ref: 3459587245
Ref: 3460587304
Ref: S0182587304
Ref: 3461587308
Ref: 3462587333
Ref: 3463587341
Ref: 3464587346
Ref: 3465588639
Ref: 3466589291
Ref: 3467589725
Ref: 3468590028
Ref: 3469590030
Node: 6.4.1592322
Ref: 3470592429
Ref: 3471592768
Ref: 3472592769
Ref: 3473592769
Ref: 3474592769
Ref: 3475592996
Ref: 3476593224
Ref: 3477594061
Ref: 3478594692
Ref: 3479595127
Ref: 3480596417
Ref: 3481598684
Ref: 3482599149
Ref: 3483599161
Ref: 3484599413
Ref: 3485600465
Ref: 3486601340
Ref: 3487601340
Ref: 3488601489
Ref: 3489601489
Ref: 3490601489
Ref: 3491601489
Ref: 3492601489
Ref: 3493601726
Ref: 3494601790
Ref: 3495601845
Node: 6.5602182
Ref: 3496602434
Ref: 3497602685
Ref: S0183602685
Ref: S0184602685
Ref: 3498602698
Ref: 3499602757
Ref: S0185602757
Ref: 3500602771
Ref: 3501602813
Ref: 3502602849
Ref: 3503602898
Ref: S0186602898
Ref: 3504602919
Ref: 3505602971
Ref: 3506603061
Ref: S0187603061
Ref: 3507603065
Ref: 3508603087
Ref: 3509603165
Ref: 3510603343
Ref: 3511603489
Ref: 3512603672
Ref: 3513604946
Ref: 3514606839
Ref: 3515607236
Ref: 3516607537
Ref: 3517607860
Ref: 3518607860
Ref: 3519608002
Ref: 3520608002
Ref: 3521608004
Ref: 3522608010
Ref: 3523608209
Ref: 3524608211
Ref: 3525608977
Ref: 3526608977
Ref: 3527608979
Ref: 3528608987
Ref: 3529608987
Ref: 3530609217
Ref: 3531609850
Ref: 3532609852
Ref: 3533609852
Node: 6.5.1612191
Ref: 3534612895
Ref: 3535612895
Ref: 3536612895
Ref: 3537613639
Ref: 3538614114
Node: 6.6614337
Ref: 3539614464
Ref: 3540614464
Ref: 3541614464
Ref: 3542615747
Node: 6.7616272
Ref: 3543616553
Ref: S0188616553
Ref: 3544616567
Ref: 3545616597
Ref: 3546616642
Ref: 3547616977
Ref: 3548617086
Ref: 3549617086
Ref: 3550617462
Node: 6.8617851
Ref: 3551618170
Ref: S0189618170
Ref: 3552618184
Ref: 3553618214
Ref: 3554618253
Ref: 3555618278
Ref: 3556618310
Ref: 3557618340
Ref: 3558618378
Ref: 3559618401
Ref: 3560618639
Ref: 3561619002
Ref: 3562619537
Ref: 3563619537
Ref: 3564619562
Ref: 3565620230
Node: 7620585
Ref: 3566620672
Ref: 3567621042
Ref: 3568621044
Ref: 3569621044
Ref: 3570621044
Node: 7.1621293
Ref: 3571621682
Ref: S0190621682
Ref: 3572621686
Ref: 3573621741
Ref: S0191621741
Ref: 3574621763
Ref: 3575621804
Ref: 3576621841
Ref: 3577621894
Ref: 3578621934
Ref: 3579621952
Ref: 3580622211
Ref: 3581622211
Ref: 3582622474
Ref: 3583622636
Ref: 3584622993
Ref: 3585623457
Node: 7.2624760
Ref: 3586625310
Ref: S0192625310
Ref: 3587625337
Ref: 3588625378
Ref: 3589625415
Ref: 3590625460
Ref: 3591625507
Ref: 3592625525
Ref: 3593626851
Ref: 3594627142
Node: 7.3629297
Ref: 3595629849
Ref: 3596629851
Ref: 3597629851
Ref: 3598629851
Ref: 3599629851
Ref: 3600629927
Ref: S0193629927
Ref: 3601629945
Ref: 3602629966
Ref: 3603630044
Ref: 3604630106
Ref: S0194630106
Ref: 3605630124
Ref: 3606630145
Ref: 3607630228
Ref: 3608630268
Ref: 3609630310
Ref: 3610630381
Ref: 3611630381
Ref: 3612632605
Ref: 3613633096
Ref: 3614633574
Ref: 3615634704
Ref: 3616634757
Ref: 3617634830
Ref: 3618636298
Ref: 3619636377
Node: 7.3.1638753
Ref: 3620639061
Ref: 3621640627
Ref: 3622640627
Ref: 3623640627
Ref: 3624641035
Ref: 3625643314
Ref: 3626643329
Node: 7.3.2647086
Ref: 3627647487
Ref: 3628647823
Ref: 3629647823
Ref: 3630648237
Ref: 3631648237
Ref: 3632648334
Ref: 3633648334
Ref: 3634648334
Ref: 3635648455
Ref: 3636650064
Ref: 3637650064
Ref: 3638653359
Ref: 3639653646
Node: 7.4655215
Ref: 3640655637
Ref: 3641655761
Ref: 3642655852
Ref: 3643656099
Ref: 3644657694
Node: 7.5658504
Ref: 3645660317
Ref: 3646660708
Ref: 3647660876
Ref: 3648660876
Ref: 3649661937
Ref: 3650661937
Ref: 3651661937
Node: 7.6664366
Ref: 3652664487
Ref: 3653664487
Ref: 3654665056
Ref: 3655665058
Ref: 3656665058
Ref: 3657665154
Ref: 3658665240
Ref: 3659665242
Ref: 3660665242
Ref: 3661665790
Ref: 3662665846
Ref: 3663665967
Ref: 3664666035
Ref: 3665666103
Ref: 3666666171
Ref: 3667666316
Ref: 3668666392
Ref: 3669666542
Ref: 3670667011
Ref: 3671667011
Ref: 3672668119
Ref: 3673668678
Ref: 3674668925
Ref: 3675668925
Ref: 3676668970
Ref: 3677668970
Ref: 3678669165
Ref: 3679669307
Ref: 3680670258
Ref: 3681670258
Ref: 3682670805
Ref: 3683670829
Ref: 3684671163
Node: 7.6.1674023
Ref: 3685674492
Ref: 3686674494
Ref: 3687674547
Ref: 3688674547
Ref: 3689674723
Ref: 3690674725
Ref: 3691674725
Ref: 3692674725
Ref: 3693675091
Ref: 3694675091
Ref: 3695675264
Ref: 3696675740
Ref: 3697676243
Ref: 3698676998
Ref: 3699677520
Ref: 3700678163
Ref: 3701678163
Ref: 3702678165
Ref: 3703678237
Ref: 3704678590
Ref: 3705679015
Ref: 3706680166
Ref: 3707680404
Ref: 3708680858
Ref: 3709681033
Ref: 3710681275
Ref: 3711681510
Ref: 3712683047
Node: 8684309
Node: 8.1685411
Ref: 3713685560
Ref: 3714686840
Ref: 3715686840
Ref: 3716686840
Ref: 3717686840
Ref: 3718686840
Ref: 3719687123
Ref: 3720687375
Node: 8.2688776
Ref: 3721689361
Ref: 3722690200
Ref: 3723690206
Ref: 3724690348
Ref: 3725690707
Ref: 3726690779
Ref: 3727690982
Ref: 3728691560
Ref: 3729691980
Ref: 3730692227
Ref: 3731692232
Ref: 3732692347
Ref: 3733692557
Node: 8.3693230
Ref: 3734693329
Ref: 3735693581
Ref: 3736693581
Ref: 3737693581
Ref: 3738693891
Ref: 3739694301
Ref: 3740694301
Ref: 3741694387
Ref: 3742694511
Ref: 3743694642
Ref: 3744694762
Ref: 3745694875
Ref: 3746695003
Ref: 3747695146
Ref: 3748695286
Ref: 3749695423
Ref: 3750695649
Ref: 3751695681
Ref: 3752697346
Ref: 3753697976
Ref: 3754697976
Ref: 3755698081
Ref: 3756698199
Ref: 3757699131
Ref: 3758699670
Ref: 3759700838
Ref: 3760700838
Ref: 3761700838
Ref: 3762700838
Ref: 3763700985
Ref: 3764701052
Ref: 3765701240
Ref: 3766701339
Ref: 3767701396
Ref: 3768701492
Ref: 3769701612
Ref: 3770702761
Ref: 3771703105
Node: 8.3.1704010
Ref: 3772704315
Ref: S0195704315
Ref: 3773705213
Node: 8.4706648
Ref: 3774707001
Ref: S0196707001
Ref: 3775707005
Ref: 3776707027
Ref: 3777707069
Ref: S0197707069
Ref: 3778707088
Ref: 3779707106
Ref: 3780707138
Ref: S0198707138
Ref: 3781707158
Ref: 3782707174
Ref: 3783707374
Ref: 3784708385
Ref: 3785708391
Ref: 3786709507
Ref: 3787709507
Ref: 3788709985
Node: 8.5710316
Ref: 3789710750
Ref: S0199710750
Ref: 3790710766
Ref: 3791710805
Ref: 3792710847
Ref: 3793710887
Ref: 3794710930
Ref: 3795711009
Ref: 3796711172
Ref: 3797711173
Node: 8.5.1712419
Ref: 3798712690
Ref: S0200712690
Ref: 3799712704
Ref: 3800712727
Ref: 3801712743
Ref: 3802712779
Ref: 3803712798
Ref: 3804712830
Ref: 3805712852
Ref: 3806712887
Ref: 3807712906
Ref: 3808713908
Ref: 3809714012
Ref: 3810714541
Ref: 3811714991
Node: 8.5.2715909
Ref: 3812716209
Ref: S0201716209
Ref: 3813716213
Ref: 3814716271
Ref: 3815716285
Node: 8.5.3716692
Ref: 3816716980
Ref: S0202716980
Ref: 3817716993
Ref: 3818717044
Ref: 3819717058
Node: 8.5.4717979
Ref: 3820718226
Ref: 3821718286
Ref: 3822718550
Ref: S0203718550
Ref: 3823718565
Ref: 3824718596
Ref: 3825718647
Ref: 3826718666
Ref: 3827718741
Ref: 3828719005
Ref: 3829719683
Ref: 3830719958
Ref: 3831720092
Ref: 3832720375
Ref: 3833722297
Ref: 3834722297
Node: 8.5.5725258
Ref: 3835725537
Ref: S0204725537
Ref: 3836725569
Ref: 3837725628
Ref: 3838725647
Ref: 3839725699
Ref: 3840725760
Ref: 3841725779
Ref: 3842725830
Ref: 3843725890
Ref: 3844725909
Node: 8.6726740
Ref: 3845726877
Ref: 3846727153
Ref: 3847727756
Ref: 3848728147
Ref: 3849728522
Ref: 3850728522
Ref: 3851729167
Ref: 3852729255
Ref: 3853729257
Ref: 3854729257
Ref: 3855729493
Ref: 3856729797
Ref: 3857729994
Ref: 3858731319
Ref: 3859731708
Ref: 3860731909
Ref: 3861732062
Ref: 3862732062
Ref: 3863732319
Ref: 3864733275
Ref: 3865733414
Ref: 3866733545
Ref: 3867733599
Ref: 3868734345
Ref: 3869734345
Ref: 3870734892
Ref: 3871735723
Ref: 3872736017
Ref: 3873736421
Node: 9737224
Ref: 3874737348
Ref: 3875737429
Ref: 3876737431
Ref: 3877737665
Ref: 3878737666
Ref: 3879737666
Ref: 3880737666
Ref: 3881737725
Ref: 3882738888
Ref: 3883739136
Ref: 3884739138
Ref: 3885739138
Ref: 3886739138
Ref: 3887739138
Ref: 3888739138
Ref: 3889739138
Ref: 3890739138
Ref: 3891739294
Node: 9.1740369
Ref: 3892740490
Ref: 3893740901
Ref: S0205740901
Ref: 3894740924
Ref: 3895740945
Ref: 3896740984
Ref: 3897741025
Ref: 3898741056
Ref: 3899741107
Ref: S0206741107
Ref: 3900741125
Ref: 3901741160
Ref: 3902741200
Ref: 3903741231
Ref: 3904741272
Ref: S0207741272
Ref: 3905741288
Ref: 3906741327
Ref: 3907741358
Ref: 3908741389
Ref: S0208741389
Ref: 3909741393
Ref: 3910741414
Ref: 3911741447
Ref: S0209741447
Ref: 3912741470
Ref: 3913741504
Ref: 3914741539
Ref: 3915741580
Ref: 3916741631
Ref: 3917741912
Ref: 3918742100
Ref: 3919743142
Ref: 3920743143
Ref: 3921743143
Ref: 3922743196
Ref: 3923743839
Ref: 3924744203
Ref: 3925744398
Ref: 3926744479
Ref: 3927744689
Ref: 3928744758
Ref: 3929744880
Ref: 3930745047
Ref: 3931745298
Node: 9.2748152
Ref: 3932748342
Ref: 3933748444
Ref: 3934748446
Ref: 3935748446
Ref: 3936748446
Ref: 3937748593
Ref: 3938750544
Ref: 3939750544
Ref: 3940750703
Node: 9.3752310
Ref: 3941752512
Ref: 3942752512
Ref: 3943752512
Ref: 3944752512
Ref: 3945753335
Ref: 3946753837
Node: 9.4756757
Ref: 3947756910
Ref: 3948756910
Ref: 3949756910
Ref: 3950756910
Ref: 3951757088
Ref: 3952757090
Ref: 3953757090
Ref: 3954757475
Ref: 3955757555
Ref: S0210757555
Ref: 3956757582
Ref: 3957757603
Ref: 3958757642
Ref: 3959757682
Ref: 3960757713
Ref: 3961757773
Ref: S0211757773
Ref: 3962757795
Ref: 3963757829
Ref: 3964757869
Ref: 3965757900
Ref: 3966757950
Ref: S0212757950
Ref: 3967757966
Ref: 3968758026
Ref: 3969758084
Ref: 3970758137
Ref: S0213758137
Ref: 3971758141
Ref: 3972758177
Ref: 3973758207
Ref: 3974758258
Ref: S0214758258
Ref: 3975758262
Ref: 3976758307
Ref: 3977758353
Ref: S0215758353
Ref: 3978758380
Ref: 3979758414
Ref: 3980758449
Ref: 3981758500
Ref: 3982758547
Ref: S0216758547
Ref: 3983758551
Ref: 3984758587
Ref: 3985758615
Ref: 3986758654
Ref: 3987758698
Ref: 3988758721
Ref: 3989759037
Ref: 3990759270
Ref: 3991760333
Ref: 3992760334
Ref: 3993760334
Ref: 3994760334
Ref: 3995760390
Ref: 3996761143
Ref: 3997761519
Ref: 3998761768
Ref: 3999761850
Ref: 4000762779
Ref: 4001762989
Ref: 4002763068
Ref: 4003763201
Ref: 4004763417
Ref: 4005763535
Ref: 4006763948
Ref: 4007764406
Ref: 4008764406
Ref: 4009764713
Node: 9.5767354
Ref: 4010767479
Ref: 4011767479
Ref: 4012767988
Ref: 4013768491
Ref: 4014768737
Ref: 4015769685
Ref: 4016769685
Ref: 4017769685
Ref: 4018770681
Ref: S0217770681
Ref: 4019771104
Ref: 4020771104
Ref: 4021772291
Node: 9.5.1772745
Ref: 4022772908
Ref: 4023772908
Ref: 4024772908
Ref: 4025774073
Ref: 4026774073
Ref: 4027774398
Ref: 4028774581
Ref: 4029775250
Ref: 4030775575
Ref: 4031775575
Ref: 4032775903
Ref: 4033775903
Ref: 4034776277
Ref: 4035776380
Ref: 4036776382
Ref: 4037776872
Node: 9.5.2779189
Ref: 4038779565
Ref: S0218779565
Ref: 4039779579
Ref: 4040779615
Ref: 4041779637
Ref: 4042779667
Ref: 4043779703
Ref: 4044779750
Ref: S0219779750
Ref: 4045779778
Ref: 4046779792
Ref: 4047779806
Ref: 4048779838
Ref: 4049779890
Ref: 4050779923
Ref: S0220779923
Ref: 4051779927
Ref: 4052779957
Ref: S0221779957
Ref: 4053779975
Ref: 4054779996
Ref: 4055780020
Ref: 4056780052
Ref: 4057780091
Ref: 4058780142
Ref: 4059780185
Ref: S0222780185
Ref: 4060780192
Ref: 4061780220
Ref: 4062780265
Ref: S0223780265
Ref: 4063780275
Ref: 4064780318
Ref: S0224780318
Ref: 4065780327
Ref: 4066780350
Ref: 4067780953
Ref: 4068781081
Ref: 4069782342
Ref: 4070782871
Ref: 4071783337
Ref: 4072783430
Ref: 4073783564
Ref: 4074783679
Ref: 4075784127
Ref: 4076784485
Ref: 4077784485
Ref: 4078784485
Ref: 4079784947
Ref: 4080784949
Ref: 4081785230
Ref: 4082785370
Ref: 4083785905
Ref: 4084786105
Ref: 4085786107
Ref: 4086786107
Ref: 4087786733
Ref: 4088787119
Node: 9.5.3789372
Ref: 4089789485
Ref: 4090789558
Ref: 4091789560
Ref: 4092789845
Ref: S0225789845
Ref: 4093789858
Ref: 4094789864
Ref: 4095790421
Ref: 4096790421
Ref: 4097790421
Ref: 4098790421
Ref: 4099790568
Ref: 4100790568
Ref: 4101790855
Ref: 4102790855
Ref: 4103791017
Ref: 4104791197
Ref: 4105791346
Ref: 4106791545
Ref: 4107792558
Ref: 4108792699
Ref: 4109792699
Ref: 4110793293
Ref: 4111793586
Ref: 4112793690
Ref: 4113793692
Ref: 4114794199
Ref: 4115794581
Ref: 4116795366
Node: 9.5.4798611
Ref: 4117798885
Ref: 4118799033
Ref: 4119799035
Ref: 4120799104
Ref: S0226799104
Ref: 4121799138
Ref: 4122799217
Ref: 4123799618
Ref: 4124800021
Ref: 4125801602
Ref: 4126802299
Ref: 4127802766
Ref: 4128803038
Ref: 4129804195
Ref: 4130805128
Node: 9.6805485
Ref: 4131805636
Ref: 4132806111
Ref: 4133806178
Ref: S0227806178
Ref: 4134806182
Ref: 4135806207
Ref: 4136806267
Ref: S0228806267
Ref: 4137806292
Ref: 4138806336
Ref: S0229806336
Ref: 4139806355
Ref: 4140806419
Ref: 4141806526
Ref: 4142806670
Ref: 4143806670
Ref: 4144806670
Ref: 4145807598
Ref: 4146807640
Ref: 4147807678
Ref: 4148807737
Ref: 4149807791
Ref: 4150807845
Ref: 4151807913
Ref: 4152807952
Ref: 4153808009
Ref: 4154808067
Ref: 4155808123
Ref: 4156808186
Ref: 4157808436
Ref: 4158809143
Ref: 4159809310
Ref: 4160809392
Ref: 4161809557
Ref: 4162809809
Ref: 4163809950
Ref: 4164810150
Ref: 4165813639
Ref: 4166813639
Ref: 4167814221
Ref: 4168814221
Node: 9.6.1814714
Ref: 4169814991
Ref: 4170815091
Ref: 4171815137
Ref: 4172815196
Ref: 4173815299
Ref: 4174815397
Ref: 4175815563
Ref: 4176815638
Ref: 4177816162
Ref: 4178816293
Ref: 4179816306
Ref: 4180816314
Ref: 4181816323
Ref: 4182816334
Ref: 4183816351
Ref: 4184816364
Ref: 4185816374
Ref: 4186816406
Ref: 4187816520
Ref: 4188816582
Ref: 4189816644
Ref: 4190816706
Ref: 4191816783
Ref: 4192816954
Ref: 4193817126
Ref: 4194817296
Ref: 4195817467
Ref: 4196817640
Ref: 4197817742
Ref: 4198817846
Ref: 4199818115
Ref: 4200818404
Ref: 4201818961
Ref: 4202819356
Ref: 4203819873
Ref: 4204820441
Ref: 4205820873
Ref: 4206821063
Ref: 4207821187
Ref: 4208821323
Node: 9.7835041
Ref: 4209835441
Ref: S0230835441
Ref: 4210835454
Ref: 4211835480
Ref: 4212835506
Ref: 4213835538
Node: 9.7.1835923
Ref: 4214836246
Ref: 4215836311
Ref: S0231836311
Ref: 4216836339
Ref: 4217836356
Ref: 4218836394
Ref: 4219836411
Ref: 4220836452
Ref: 4221836509
Ref: S0232836509
Ref: 4222836519
Ref: 4223836558
Ref: S0233836558
Ref: 4224836571
Ref: 4225836599
Ref: 4226836626
Ref: 4227836674
Ref: S0234836674
Ref: 4228836686
Ref: 4229836704
Ref: 4230836753
Ref: S0235836753
Ref: 4231836765
Ref: 4232836782
Ref: 4233836835
Ref: S0236836835
Ref: 4234837074
Ref: 4235837533
Ref: 4236837714
Ref: 4237838363
Ref: 4238839012
Ref: 4239840167
Node: 9.7.2841081
Ref: 4240841489
Ref: 4241841557
Ref: S0237841557
Ref: 4242841584
Ref: 4243841625
Ref: 4244841694
Ref: S0238841694
Ref: 4245841706
Ref: 4246841731
Ref: 4247841790
Ref: S0239841790
Ref: 4248841802
Ref: 4249841829
Ref: 4250842285
Node: 9.7.3843771
Ref: 4251844273
Ref: S0240844273
Ref: 4252844300
Ref: 4253844343
Ref: 4254844435
Node: 9.7.4845230
Ref: 4255845577
Ref: S0241845577
Ref: 4256845604
Ref: 4257845653
Ref: 4258845717
Ref: S0242845717
Ref: 4259845721
Ref: 4260845744
Ref: 4261845804
Ref: S0243845804
Ref: 4262845808
Ref: 4263845835
Ref: 4264845873
Ref: S0244845873
Ref: 4265845877
Ref: 4266845953
Ref: 4267845953
Ref: 4268846837
Ref: 4269847895
Ref: 4270847895
Ref: 4271847895
Ref: 4272848331
Ref: 4273848332
Ref: 4274848332
Ref: 4275848332
Ref: 4276848332
Node: 9.8848738
Ref: 4277849263
Ref: S0245849263
Ref: 4278849281
Ref: 4279849296
Ref: 4280849355
Ref: 4281849502
Ref: 4282849602
Ref: 4283849602
Ref: 4284849604
Ref: 4285849604
Ref: 4286849778
Ref: 4287849778
Ref: 4288850208
Ref: 4289850906
Ref: 4290851894
Ref: 4291852407
Ref: 4292852690
Ref: 4293853012
Ref: 4294853012
Ref: 4295853012
Ref: 4296853012
Node: 9.9853603
Ref: 4297853904
Ref: 4298853919
Ref: 4299854018
Ref: 4300854019
Ref: 4301854184
Ref: 4302854199
Ref: 4303854703
Ref: 4304854718
Node: 9.10855761
Ref: 4305855924
Ref: 4306855924
Ref: 4307856617
Ref: 4308857091
Ref: 4309858633
Ref: 4310858897
Node: 9.11859411
Node: 10862946
Ref: 4311863341
Ref: 4312863341
Ref: 4313863341
Ref: 4314863650
Node: 10.1864139
Ref: 4315864251
Ref: 4316864251
Ref: 4317864251
Ref: 4318864568
Ref: 4319864872
Ref: 4320865119
Node: 10.1.1865669
Ref: 4321866028
Ref: 4322866225
Ref: S0246866225
Ref: 4323866231
Ref: 4324866273
Ref: S0247866273
Ref: 4325866287
Ref: 4326866302
Ref: 4327866324
Ref: 4328866339
Ref: 4329866367
Ref: S0248866367
Ref: 4330866382
Ref: 4331866416
Ref: 4332866453
Ref: 4333866519
Ref: S0249866519
Ref: 4334866534
Ref: 4335866561
Ref: 4336866591
Ref: 4337866615
Ref: 4338866678
Ref: S0250866678
Ref: 4339866691
Ref: 4340866728
Ref: 4341866765
Ref: 4342866822
Ref: S0251866822
Ref: 4343866826
Ref: 4344866845
Ref: 4345866882
Ref: S0252866882
Ref: 4346866886
Ref: 4347867073
Ref: 4348867073
Ref: 4349867073
Ref: 4350867073
Ref: 4351867073
Ref: 4352867382
Ref: 4353867701
Ref: 4354867701
Ref: 4355867927
Ref: 4356868224
Ref: 4357868456
Ref: 4358868596
Ref: 4359868669
Ref: 4360868669
Ref: 4361868669
Ref: 4362868669
Ref: 4363868936
Ref: 4364869060
Ref: 4365869253
Ref: 4366873141
Ref: 4367873141
Node: 10.1.2876280
Ref: 4368876604
Ref: S0253876604
Ref: 4369876610
Ref: 4370876644
Ref: S0254876644
Ref: 4371876648
Ref: 4372876663
Ref: 4373876695
Ref: S0255876695
Ref: 4374876699
Ref: 4375876722
Ref: 4376876776
Ref: S0256876776
Ref: 4377876819
Ref: 4378876848
Ref: 4379876889
Ref: S0257876889
Ref: 4380876924
Ref: 4381876953
Ref: 4382877012
Ref: 4383877378
Ref: 4384877378
Ref: 4385877440
Ref: 4386877441
Node: 10.1.3882739
Ref: 4387883269
Ref: S0258883269
Ref: 4388883273
Ref: 4389883297
Ref: 4390883317
Ref: 4391883340
Ref: 4392883390
Ref: S0259883390
Ref: 4393883404
Ref: 4394883434
Ref: 4395883483
Ref: 4396883533
Ref: S0260883533
Ref: 4397883559
Ref: 4398883603
Ref: 4399883650
Ref: S0261883650
Ref: 4400883673
Ref: 4401883717
Ref: 4402883769
Ref: S0262883769
Ref: 4403883797
Ref: 4404883841
Ref: 4405883879
Ref: S0263883879
Ref: 4406883894
Ref: 4407883912
Ref: 4408883974
Ref: 4409884069
Ref: 4410884338
Ref: 4411885220
Ref: 4412885466
Node: 10.1.4887272
Ref: 4413887415
Ref: 4414887415
Ref: 4415889087
Ref: 4416889271
Ref: 4417890920
Ref: 4418891339
Node: 10.1.5891665
Ref: 4419891956
Ref: 4420891956
Ref: 4421892013
Ref: 4422893877
Ref: 4423893877
Ref: 4424893877
Ref: 4425893877
Ref: 4426894295
Ref: 4427894295
Node: 10.1.6895409
Ref: 4428895832
Ref: 4429895832
Ref: 4430895832
Ref: 4431895832
Ref: 4432896484
Ref: 4433896484
Ref: 4434896484
Ref: 4435896484
Ref: 4436896956
Ref: 4437896956
Ref: 4438897179
Ref: 4439897179
Ref: 4440897378
Node: 10.2897733
Ref: 4441897839
Ref: 4442897839
Ref: 4443897839
Ref: 4444898066
Ref: 4445898066
Ref: 4446898271
Ref: 4447898760
Ref: 4448898761
Ref: 4449898761
Ref: 4450899287
Ref: 4451899478
Ref: 4452899850
Ref: 4453899852
Ref: 4454900752
Ref: 4455902434
Ref: 4456902555
Ref: 4457903119
Ref: 4458903119
Ref: 4459903383
Ref: 4460903791
Node: 10.2.1905894
Ref: 4461905999
Ref: 4462906202
Ref: 4463906203
Ref: 4464906232
Ref: 4465906243
Ref: 4466906248
Ref: 4467906393
Ref: 4468906394
Ref: 4469906423
Ref: 4470906485
Ref: 4471907366
Ref: 4472907907
Ref: 4473908053
Ref: 4474908053
Ref: 4475908439
Ref: 4476908599
Ref: 4477908770
Ref: 4478911101
Ref: 4479912047
Ref: 4480912048
Ref: 4481912069
Ref: 4482912081
Ref: 4483912086
Ref: 4484912180
Ref: 4485913584
Ref: 4486913684
Ref: 4487913684
Ref: 4488914116
Ref: 4489915782
Ref: 4490915783
Ref: 4491915808
Ref: 4492915830
Ref: 4493915855
Ref: 4494915856
Ref: 4495915885
Ref: 4496915907
Ref: 4497915932
Ref: 4498915933
Ref: 4499915964
Ref: 4500916067
Ref: 4501916072
Ref: 4502916173
Ref: 4503916328
Ref: 4504917046
Ref: 4505917046
Node: 11917244
Ref: 4506917469
Ref: 4507917471
Ref: 4508917471
Ref: 4509917471
Ref: 4510917471
Ref: 4511917471
Ref: 4512917614
Ref: 4513917759
Node: 11.1918537
Ref: 4514918653
Ref: 4515918784
Ref: S0264918784
Ref: 4516918788
Ref: 4517918835
Ref: 4518919386
Ref: 4519919386
Ref: 4520919386
Ref: 4521919386
Ref: 4522919386
Ref: 4523919652
Ref: 4524919714
Ref: 4525919714
Ref: 4526919714
Ref: 4527919818
Node: 11.2920089
Ref: 4528920366
Ref: S0265920366
Ref: 4529920381
Ref: 4530920432
Ref: 4531920460
Ref: 4532920505
Ref: S0266920505
Ref: 4533920523
Ref: 4534920556
Ref: 4535920576
Ref: 4536920613
Ref: 4537920674
Ref: S0267920674
Ref: 4538920678
Ref: 4539920723
Ref: S0268920723
Ref: 4540920740
Ref: 4541920879
Ref: 4542921516
Ref: 4543921861
Node: 11.3922467
Ref: 4544922733
Ref: S0269922733
Ref: 4545922776
Ref: 4546922796
Ref: 4547922837
Ref: S0270922837
Ref: 4548922860
Ref: 4549922880
Ref: 4550923537
Ref: 4551924011
Ref: 4552924112
Ref: 4553924473
Node: 11.4925182
Ref: 4554925451
Ref: 4555925528
Ref: 4556925737
Ref: 4557925737
Ref: 4558925994
Ref: 4559926135
Ref: 4560926746
Ref: 4561926916
Ref: 4562926916
Ref: 4563926916
Node: 11.4.1927601
Ref: 4564927833
Ref: 4565927943
Ref: 4566928032
Ref: 4567928088
Ref: 4568928155
Ref: 4569928232
Ref: 4570928333
Ref: 4571928456
Ref: 4572928524
Ref: 4573928602
Ref: 4574928748
Ref: 4575928826
Ref: 4576928898
Ref: 4577929019
Ref: 4578929158
Ref: 4579929325
Ref: 4580929507
Ref: 4581929594
Ref: 4582929733
Ref: 4583930926
Ref: 4584930941
Ref: 4585931973
Ref: 4586933321
Node: 11.4.2934993
Ref: 4587935560
Ref: 4588935560
Ref: 4589935854
Ref: 4590935855
Ref: 4591935883
Ref: 4592935923
Ref: 4593936125
Ref: 4594936126
Ref: 4595936152
Ref: 4596936185
Ref: 4597936186
Ref: 4598936230
Ref: 4599936254
Ref: 4600936290
Ref: 4601936314
Ref: 4602936333
Ref: 4603936338
Ref: 4604939203
Ref: 4605939276
Ref: 4606939334
Ref: 4607939380
Ref: 4608940054
Ref: 4609940054
Node: 11.4.3942428
Node: 11.5944965
Ref: 4610945106
Ref: 4611945352
Ref: 4612945352
Ref: 4613945352
Ref: 4614945352
Ref: 4615945352
Ref: 4616945555
Ref: 4617945766
Ref: 4618945767
Ref: 4619945776
Ref: 4620945809
Ref: 4621945810
Ref: 4622945821
Ref: 4623945839
Ref: 4624945844
Ref: 4625945844
Ref: 4626945844
Ref: 4627946950
Ref: 4628947536
Ref: 4629947657
Ref: 4630947928
Ref: 4631948217
Ref: 4632948343
Ref: 4633948909
Ref: 4634949117
Ref: 4635949378
Ref: 4636949954
Ref: 4637950238
Ref: 4638950358
Ref: 4639950453
Ref: 4640950744
Ref: 4641951199
Ref: 4642951199
Ref: 4643951572
Ref: 4644952031
Ref: 4645952499
Ref: 4646952998
Ref: 4647952998
Node: 11.6953717
Ref: 4648953845
Ref: 4649953845
Ref: 4650953845
Ref: 4651953845
Ref: 4652953845
Ref: 4653953845
Ref: 4654954044
Ref: 4655954917
Ref: 4656954917
Ref: 4657955710
Ref: 4658956446
Ref: 4659956623
Ref: 4660956625
Ref: 4661956625
Node: 12957115
Ref: 4662957217
Ref: 4663957309
Ref: 4664957539
Ref: 4665957541
Ref: 4666957541
Node: 12.1958626
Ref: 4667959151
Ref: S0271959151
Ref: 4668959155
Ref: 4669959189
Ref: 4670959263
Ref: S0272959263
Ref: 4671959278
Ref: 4672959299
Ref: 4673959338
Ref: 4674959396
Ref: S0273959396
Ref: 4675959411
Ref: 4676959432
Ref: 4677959482
Ref: S0274959482
Ref: 4678959496
Ref: 4679959541
Ref: 4680959597
Ref: S0275959597
Ref: 4681959613
Ref: 4682959650
Ref: 4683959685
Ref: 4684959726
Ref: 4685960091
Ref: 4686960091
Ref: 4687960091
Ref: 4688960091
Ref: 4689960218
Ref: 4690960668
Node: 12.2963139
Ref: 4691963252
Ref: 4692963460
Node: 12.3965411
Ref: 4693965538
Ref: 4694965680
Ref: S0276965680
Ref: 4695965703
Ref: 4696965769
Ref: 4697965775
Ref: 4698965814
Ref: 4699965848
Ref: 4700965890
Ref: 4701965958
Ref: 4702965964
Ref: 4703966003
Ref: 4704966037
Ref: 4705966078
Ref: 4706966138
Ref: 4707966144
Ref: 4708966183
Ref: 4709966233
Ref: S0277966233
Ref: 4710966247
Ref: 4711966270
Ref: 4712966319
Ref: S0278966319
Ref: 4713966360
Ref: 4714966378
Ref: 4715966459
Ref: S0279966459
Ref: 4716966463
Ref: 4717966488
Ref: 4718966516
Ref: 4719966531
Ref: 4720966538
Ref: 4721966580
Ref: 4722966588
Ref: 4723966593
Ref: 4724966838
Ref: 4725966838
Ref: 4726966838
Ref: 4727969245
Ref: 4728969247
Ref: 4729969247
Ref: 4730969247
Ref: 4731969247
Ref: 4732969247
Ref: 4733969247
Ref: 4734969247
Ref: 4735971035
Ref: 4736972312
Ref: 4737972695
Ref: 4738972760
Node: 12.4974217
Ref: 4739974330
Ref: 4740974330
Ref: 4741974489
Ref: S0280974489
Ref: 4742974503
Ref: 4743974530
Ref: 4744974536
Ref: 4745974552
Ref: 4746974575
Ref: 4747974609
Ref: 4748974642
Ref: 4749974669
Ref: 4750974674
Ref: 4751974696
Ref: 4752974736
Ref: 4753974811
Ref: 4754974921
Ref: 4755975580
Ref: 4756976316
Ref: 4757976420
Ref: 4758977036
Ref: 4759977349
Ref: 4760977496
Ref: 4761977875
Ref: 4762977875
Ref: 4763977875
Ref: 4764978230
Ref: 4765978230
Ref: 4766978506
Node: 12.5978907
Ref: 4767979211
Ref: S0281979211
Ref: 4768979227
Ref: 4769979271
Ref: 4770979350
Ref: S0282979350
Ref: 4771979369
Ref: 4772979389
Ref: 4773979411
Ref: 4774979454
Ref: 4775979523
Ref: S0283979523
Ref: 4776979542
Ref: 4777979562
Ref: 4778979626
Ref: S0284979626
Ref: 4779979642
Ref: 4780979684
Ref: 4781979726
Ref: 4782979769
Ref: 4783979818
Ref: 4784979860
Ref: 4785979904
Ref: 4786979954
Ref: 4787980003
Ref: 4788980043
Ref: 4789980084
Ref: 4790980165
Ref: 4791980165
Ref: 4792980165
Ref: 4793980165
Ref: 4794980323
Ref: 4795980323
Ref: 4796980323
Ref: 4797980323
Ref: 4798980445
Ref: 4799980445
Node: 12.5.1983399
Ref: 4800984131
Ref: S0285984131
Ref: 4801984219
Ref: S0286984219
Ref: 4802984274
Ref: 4803984293
Ref: 4804984516
Ref: 4805984516
Ref: 4806987499
Ref: 4807990259
Ref: 4808990274
Ref: 4809991600
Node: 12.5.2992250
Ref: 4810992726
Ref: S0287992726
Ref: 4811992781
Ref: S0288992781
Ref: 4812992833
Ref: S0289992833
Ref: 4813992885
Ref: S0290992885
Ref: 4814992946
Ref: S0291992946
Ref: 4815993005
Ref: S0292993005
Node: 12.5.3993446
Ref: 4816993742
Ref: S0293993742
Ref: 4817993746
Ref: 4818994460
Ref: 4819994559
Node: 12.5.4995393
Ref: 4820995694
Ref: S0294995694
Ref: 4821995698
Ref: 4822995884
Ref: 4823996371
Node: 12.5.5997011
Ref: 4824997314
Ref: S0295997314
Ref: 4825997318
Node: 12.6998241
Ref: 4826998362
Ref: 4827998362
Ref: 4828998518
Ref: S0296998518
Ref: 4829998522
Ref: 4830998578
Ref: 4831998667
Ref: S0297998667
Ref: 4832998687
Ref: 4833998716
Ref: 4834998750
Ref: 4835998823
Ref: S0298998823
Ref: 4836998843
Ref: 4837998881
Ref: 4838998915
Ref: 4839998966
Ref: S0299998966
Ref: 4840998970
Ref: 4841999016
Ref: S0300999016
Ref: 4842999020
Ref: 4843999218
Ref: 4844999306
Ref: 4845999533
Ref: 4846999604
Ref: 48471000351
Ref: 48481001276
Ref: 48491003525
Node: 12.71007428
Ref: 48501007543
Ref: 48511007543
Ref: 48521007879
Ref: S03011007879
Ref: 48531007906
Ref: 48541007951
Ref: 48551007963
Ref: 48561008004
Ref: 48571008063
Ref: S03021008063
Ref: 48581008104
Ref: 48591008135
Ref: 48601008165
Ref: 48611008255
Ref: S03031008255
Ref: 48621008269
Ref: 48631008325
Ref: 48641008506
Ref: 48651011010
Ref: 48661011407
Node: 12.81013840
Node: 131016345
Node: 13.11017149
Ref: 48671017301
Ref: 48681018108
Ref: 48691018108
Ref: 48701018108
Ref: 48711018587
Ref: 48721019001
Ref: S03041019001
Ref: S03051019001
Ref: 48731019005
Ref: 48741019047
Ref: 48751019094
Ref: 48761019136
Ref: 48771019164
Ref: S03061019164
Ref: 48781019168
Ref: 48791019194
Ref: 48801019206
Ref: 48811019255
Ref: 48821019379
Ref: 48831020941
Ref: 48841020941
Ref: 48851021454
Ref: 48861021693
Ref: 48871021693
Ref: 48881021693
Ref: 48891021969
Ref: 48901021971
Ref: 48911021971
Ref: 48921021971
Ref: 48931022463
Ref: 48941022465
Ref: 48951022465
Ref: 48961022465
Ref: 48971024731
Ref: 48981026493
Ref: 48991026732
Ref: 49001026857
Ref: 49011027311
Ref: 49021027548
Ref: 49031027548
Ref: 49041027550
Ref: 49051027550
Ref: 49061027550
Ref: 49071027604
Ref: 49081027956
Ref: 49091028325
Node: 13.1.11030773
Ref: 49101031169
Ref: 49111031241
Ref: S03071031241
Ref: 49121031259
Ref: 49131031275
Ref: 49141031313
Ref: 49151031329
Ref: 49161031371
Ref: S03081031371
Ref: 49171031385
Ref: 49181031431
Ref: S03091031431
Ref: 49191031435
Ref: 49201031443
Ref: 49211031456
Ref: 49221031633
Ref: 49231031953
Ref: 49241032164
Ref: 49251032164
Ref: 49261032359
Ref: 49271035359
Ref: 49281035534
Ref: 49291035576
Ref: 49301036116
Ref: 49311037334
Ref: 49321037678
Ref: 49331037743
Ref: 49341037743
Ref: 49351037932
Ref: 49361038123
Ref: 49371038880
Node: 13.21040415
Ref: 49381041305
Ref: 49391041307
Ref: 49401041307
Ref: 49411041825
Node: 13.31042925
Ref: 49421043094
Ref: 49431043094
Ref: 49441043243
Ref: 49451043398
Ref: S03101043398
Ref: 49461043418
Ref: 49471043429
Ref: 49481043454
Ref: 49491043481
Ref: 49501043492
Ref: 49511043517
Ref: 49521043754
Ref: 49531043922
Ref: 49541044313
Ref: 49551044313
Ref: 49561044515
Ref: 49571044558
Ref: 49581044923
Ref: 49591044977
Ref: 49601044977
Ref: 49611044977
Ref: 49621044977
Ref: 49631044977
Ref: 49641044977
Ref: 49651044977
Ref: 49661044977
Ref: 49671044977
Ref: 49681044977
Ref: 49691044977
Ref: 49701044977
Ref: 49711044977
Ref: 49721044977
Ref: 49731044977
Ref: 49741045130
Ref: 49751045130
Ref: 49761045203
Ref: 49771045425
Ref: 49781046074
Ref: 49791046089
Ref: 49801046655
Ref: 49811046670
Ref: 49821046791
Ref: 49831046791
Ref: 49841046846
Ref: 49851047197
Ref: 49861048371
Ref: 49871048386
Ref: 49881048876
Ref: 49891048891
Ref: 49901049221
Ref: 49911049236
Ref: 49921049578
Ref: 49931049593
Ref: 49941049816
Ref: 49951049816
Ref: 49961049869
Ref: 49971049971
Ref: 49981050270
Ref: 49991051513
Ref: 50001052668
Ref: 50011052683
Ref: 50021052844
Ref: 50031052859
Ref: 50041053045
Ref: 50051053045
Ref: 50061053168
Ref: 50071053493
Ref: 50081053508
Ref: 50091054116
Ref: 50101054118
Ref: 50111054553
Ref: 50121054553
Ref: 50131055202
Ref: 50141057036
Ref: 50151057051
Ref: 50161058228
Ref: 50171058228
Ref: 50181058635
Ref: 50191058635
Ref: 50201058635
Ref: 50211058971
Ref: 50221058986
Ref: 50231059137
Ref: 50241059152
Ref: 50251059377
Ref: 50261059377
Ref: 50271059431
Ref: 50281060212
Ref: 50291060227
Ref: 50301061050
Ref: 50311061065
Ref: 50321062171
Ref: 50331062186
Ref: 50341062186
Ref: 50351062186
Ref: 50361062492
Ref: 50371062492
Node: 13.41065772
Ref: 50381066099
Ref: S03111066099
Ref: 50391066133
Ref: 50401066148
Ref: 50411066200
Ref: S03121066200
Ref: 50421066204
Ref: 50431066273
Ref: 50441067036
Ref: 50451067121
Ref: 50461067266
Ref: 50471067266
Ref: 50481067543
Node: 13.51068529
Ref: 50491068640
Ref: 50501068640
Ref: 50511068640
Ref: 50521068640
Ref: 50531068640
Ref: 50541068640
Ref: 50551068640
Ref: 50561068640
Ref: 50571068640
Node: 13.5.11069011
Ref: 50581069340
Ref: 50591069420
Ref: S03131069420
Ref: 50601069454
Ref: 50611069488
Ref: 50621069514
Ref: 50631069579
Ref: S03141069579
Ref: 50641069605
Ref: 50651069619
Ref: 50661069634
Ref: 50671069647
Ref: 50681069673
Ref: S03151069673
Ref: 50691069687
Ref: 50701069715
Ref: S03161069715
Ref: 50711069729
Ref: 50721069763
Ref: S03171069763
Ref: 50731069777
Ref: 50741069847
Ref: 50751069847
Ref: 50761069847
Ref: 50771069847
Ref: 50781074003
Node: 13.5.21077569
Ref: 50791077760
Ref: 50801077876
Ref: 50811077891
Ref: 50821078296
Ref: 50831078311
Ref: 50841078916
Ref: 50851078931
Ref: 50861079499
Ref: 50871079499
Node: 13.5.31079931
Ref: 50881080172
Ref: 50891080259
Ref: 50901080261
Ref: 50911080261
Ref: 50921080494
Ref: 50931080496
Ref: 50941080496
Ref: 50951080708
Ref: 50961080723
Ref: 50971080838
Ref: 50981080840
Ref: 50991081022
Ref: 51001081022
Ref: 51011081252
Ref: 51021081423
Node: 13.61081868
Ref: 51031082003
Ref: 51041082003
Node: 13.71083495
Ref: 51051083873
Ref: 51061083941
Ref: 51071083995
Ref: 51081084111
Ref: 51091084177
Ref: 51101084245
Ref: 51111084315
Ref: 51121084388
Ref: 51131084452
Ref: 51141084525
Ref: 51151084595
Ref: 51161084669
Ref: 51171084800
Ref: 51181084840
Ref: 51191084885
Ref: 51201084946
Ref: 51211085022
Ref: 51221085098
Ref: 51231085795
Ref: 51241085809
Ref: 51251085827
Ref: 51261085848
Ref: 51271086003
Ref: 51281086075
Ref: 51291086188
Ref: 51301086292
Ref: 51311089286
Node: 13.7.11090041
Ref: 51321090299
Ref: 51331090394
Ref: 51341090463
Ref: 51351090541
Ref: 51361090654
Ref: 51371090815
Ref: 51381091508
Ref: 51391091570
Ref: 51401091679
Ref: 51411091974
Ref: 51421091976
Ref: 51431092713
Node: 13.7.21092777
Ref: 51441093067
Ref: 51451093310
Ref: 51461093418
Ref: 51471093815
Node: 13.81094110
Ref: 51481094241
Ref: 51491094426
Ref: S03181094426
Ref: 51501094430
Ref: 51511095127
Ref: 51521095480
Ref: 51531095480
Node: 13.91096990
Ref: 51541097128
Ref: 51551097128
Ref: 51561097128
Ref: 51571097128
Ref: 51581097128
Ref: 51591097463
Ref: 51601098385
Ref: 51611098385
Ref: 51621099741
Ref: 51631099940
Ref: 51641099940
Node: 13.9.11100385
Ref: 51651100847
Ref: 51661101053
Ref: 51671101053
Ref: 51681101356
Ref: 51691102347
Ref: 51701102593
Ref: 51711102786
Ref: 51721102786
Ref: 51731103047
Ref: 51741103049
Ref: 51751103843
Ref: 51761104514
Node: 13.9.21105273
Ref: 51771105718
Ref: 51781105733
Ref: 51791105956
Node: 13.101107559
Ref: 51801108028
Ref: 51811108043
Ref: 51821108335
Node: 13.111108821
Ref: 51831108947
Ref: 51841108947
Ref: 51851108947
Ref: 51861108947
Ref: 51871109866
Ref: 51881109974
Ref: 51891110158
Ref: 51901110420
Ref: 51911110682
Ref: 51921110884
Ref: 51931110884
Ref: 51941110960
Ref: 51951110962
Ref: 51961110962
Ref: 51971111164
Ref: 51981111179
Ref: 51991111311
Ref: 52001111326
Ref: 52011111592
Ref: 52021111592
Ref: 52031111592
Ref: 52041111592
Ref: 52051111792
Ref: 52061111792
Ref: 52071111792
Ref: 52081111792
Ref: 52091112099
Ref: 52101112285
Ref: 52111112287
Ref: 52121112287
Ref: 52131112789
Ref: 52141113381
Ref: 52151113615
Ref: 52161115969
Ref: 52171115969
Ref: 52181115971
Node: 13.11.11122039
Ref: 52191122459
Ref: 52201122474
Ref: 52211122794
Ref: 52221122809
Node: 13.11.21123354
Ref: 52231123517
Ref: 52241123517
Ref: 52251123517
Ref: 52261123517
Ref: 52271123517
Ref: 52281123902
Ref: 52291124342
Ref: 52301125503
Ref: 52311125503
Ref: 52321125503
Ref: 52331125503
Ref: 52341125741
Ref: 52351125887
Ref: 52361125887
Ref: 52371125976
Ref: 52381125976
Ref: 52391126377
Ref: 52401126377
Ref: 52411126566
Ref: 52421126709
Ref: 52431126711
Ref: 52441126891
Ref: 52451126891
Node: 13.11.31127890
Ref: 52461128343
Ref: 52471128344
Ref: 52481128366
Ref: 52491128425
Ref: S03191128425
Ref: 52501128445
Ref: 52511129388
Ref: 52521129388
Ref: 52531129388
Ref: 52541130271
Ref: 52551130271
Node: 13.11.41132312
Ref: 52561132841
Ref: 52571132945
Ref: 52581133054
Ref: 52591133121
Ref: 52601133239
Ref: 52611133458
Ref: 52621133598
Ref: 52631133756
Ref: 52641134168
Ref: 52651134398
Ref: 52661134572
Ref: 52671134858
Ref: 52681135152
Ref: 52691135424
Ref: 52701135424
Ref: 52711135424
Ref: 52721135424
Ref: 52731135424
Ref: 52741136209
Ref: 52751137448
Ref: 52761137448
Ref: 52771137893
Ref: 52781138504
Ref: 52791138504
Ref: 52801138615
Ref: 52811138615
Ref: 52821138677
Ref: 52831139081
Ref: 52841139081
Ref: 52851139081
Ref: 52861139214
Node: 13.11.51141367
Ref: 52871141740
Ref: 52881142231
Ref: 52891142305
Node: 13.11.61142579
Node: 13.121148988
Ref: 52901149545
Ref: 52911149546
Ref: 52921149559
Ref: 52931149572
Ref: 52941149609
Ref: S03201149609
Ref: 52951149628
Ref: 52961149674
Ref: 52971149688
Ref: 52981149767
Ref: S03211149767
Ref: 52991149771
Ref: 53001149779
Ref: 53011149842
Ref: 53021150208
Ref: 53031150208
Ref: 53041152680
Ref: 53051152681
Ref: 53061152700
Ref: 53071152724
Ref: 53081153235
Ref: 53091153235
Node: 13.12.11154114
Ref: 53101154457
Ref: 53111154457
Ref: 53121154744
Ref: 53131154744
Ref: 53141154973
Ref: 53151154973
Ref: 53161157397
Ref: 53171157397
Ref: 53181157640
Ref: 53191157640
Ref: 53201157968
Ref: 53211157968
Ref: 53221158464
Ref: 53231158464
Ref: 53241158584
Ref: 53251158584
Ref: 53261158753
Ref: 53271158753
Ref: 53281158908
Ref: 53291158908
Ref: 53301160155
Node: 13.131160580
Ref: 53311160684
Ref: 53321160684
Node: 13.13.11161118
Ref: 53331161964
Ref: 53341162021
Ref: 53351162042
Ref: 53361162178
Ref: 53371162240
Ref: 53381162314
Ref: 53391162424
Ref: 53401162548
Ref: 53411162727
Node: 13.13.21163907
Ref: 53421164195
Ref: 53431164195
Ref: 53441164368
Ref: 53451164383
Ref: 53461165106
Ref: 53471165106
Ref: 53481165480
Ref: 53491166102
Ref: 53501166117
Ref: 53511166440
Ref: 53521166455
Ref: 53531169559
Ref: 53541169574
Ref: 53551170020
Ref: 53561170035
Ref: 53571170634
Ref: 53581170649
Ref: 53591171033
Ref: 53601171048
Ref: 53611173026
Ref: 53621173041
Ref: 53631173808
Ref: 53641173823
Ref: 53651174665
Ref: 53661174665
Ref: 53671174912
Ref: 53681175666
Ref: 53691175916
Ref: 53701176094
Ref: 53711176094
Ref: 53721176094
Ref: 53731176094
Ref: 53741176094
Ref: 53751176094
Ref: 53761176094
Ref: 53771176094
Ref: 53781176641
Ref: 53791176643
Ref: 53801176643
Ref: 53811176643
Ref: 53821176643
Ref: 53831176643
Ref: 53841176643
Ref: 53851176643
Ref: 53861176643
Ref: 53871176643
Ref: 53881176643
Ref: 53891176643
Ref: 53901176643
Ref: 53911176643
Ref: 53921176643
Ref: 53931176643
Ref: 53941177216
Ref: 53951178664
Ref: 53961179659
Ref: 53971179659
Ref: 53981180518
Node: 13.141183440
Ref: 53991183916
Ref: 54001183916
Ref: 54011184241
Ref: 54021184571
Ref: 54031184777
Ref: 54041185063
Ref: 54051185205
Ref: 54061185355
Ref: 54071186114
Ref: 54081186221
Ref: 54091186799
Ref: 54101186895
Ref: 54111187305
Ref: 54121187493
Ref: 54131187744
Ref: 54141188046
Ref: 54151188046
Ref: 54161188402
Ref: 54171188402
Ref: 54181188804
Ref: 54191189024
Ref: 54201189167
Ref: 54211189293
Ref: 54221189439
Ref: 54231189530
Ref: 54241189736
Ref: 54251189947
Ref: 54261190006
Ref: 54271190008
Ref: 54281190251
Ref: 54291190253
Ref: 54301191347
Node: Annex A1191349
Ref: 54311191507
Ref: 54321191507
Ref: 54331202187
Node: A.11204095
Ref: 54341204330
Ref: 54351204538
Ref: 54361204792
Ref: 54371204864
Ref: 54381205985
Ref: 54391206048
Ref: 54401206109
Ref: 54411207993
Ref: 54421210678
Ref: 54431214579
Ref: 54441214900
Ref: 54451215043
Ref: 54461215101
Ref: 54471215161
Ref: 54481216048
Ref: 54491216237
Ref: 54501216451
Ref: 54511216702
Ref: 54521216739
Ref: 54531216776
Ref: 54541216813
Ref: 54551217575
Node: A.21219711
Ref: 54561219930
Node: A.31220247
Node: A.3.11221181
Ref: 54571221501
Ref: 54581221666
Ref: 54591221851
Node: A.3.21222410
Ref: 54601222762
Ref: 54611222861
Ref: 54621222936
Ref: 54631223011
Ref: 54641223086
Ref: 54651223161
Ref: 54661223236
Ref: 54671223311
Ref: 54681223386
Ref: 54691223504
Ref: 54701223579
Ref: 54711223654
Ref: 54721223729
Ref: 54731223804
Ref: 54741223879
Ref: 54751223954
Ref: 54761224033
Ref: 54771224169
Ref: 54781224234
Ref: 54791224299
Ref: 54801224367
Ref: 54811224426
Ref: 54821224485
Ref: 54831224623
Ref: 54841224719
Ref: 54851224784
Ref: 54861224853
Ref: 54871224997
Ref: 54881225726
Ref: 54891225919
Ref: 54901226114
Ref: 54911226367
Ref: 54921226610
Ref: 54931226855
Ref: 54941227116
Ref: 54951227309
Ref: 54961227545
Ref: 54971227741
Node: A.3.31231718
Ref: 54981232109
Ref: 54991232173
Ref: 55001232181
Ref: 55011232253
Ref: 55021232325
Ref: 55031232397
Ref: 55041232469
Ref: 55051232541
Ref: 55061232613
Ref: 55071232685
Ref: 55081232757
Ref: 55091232829
Ref: 55101232901
Ref: 55111232974
Ref: 55121233047
Ref: 55131233120
Ref: 55141233193
Ref: 55151233266
Ref: 55161233342
Ref: 55171233415
Ref: 55181233488
Ref: 55191233561
Ref: 55201233634
Ref: 55211233707
Ref: 55221233780
Ref: 55231233853
Ref: 55241233926
Ref: 55251233999
Ref: 55261234072
Ref: 55271234145
Ref: 55281234218
Ref: 55291234291
Ref: 55301234364
Ref: 55311234437
Ref: 55321234554
Ref: 55331234637
Ref: 55341234720
Ref: 55351234803
Ref: 55361234886
Ref: 55371234969
Ref: 55381235052
Ref: 55391235135
Ref: 55401235218
Ref: 55411235301
Ref: 55421235384
Ref: 55431235467
Ref: 55441235550
Ref: 55451235633
Ref: 55461235716
Ref: 55471235774
Ref: 55481235857
Ref: 55491236022
Ref: 55501236105
Ref: 55511236188
Ref: 55521236271
Ref: 55531236354
Ref: 55541236437
Ref: 55551236520
Ref: 55561236680
Ref: 55571236763
Ref: 55581236846
Ref: 55591236929
Ref: 55601237012
Ref: 55611237099
Ref: 55621237182
Ref: 55631237265
Ref: 55641237348
Ref: 55651237431
Ref: 55661237515
Ref: 55671237599
Ref: 55681237683
Ref: 55691237767
Ref: 55701237851
Ref: 55711237935
Ref: 55721238019
Ref: 55731238103
Ref: 55741238187
Ref: 55751238271
Ref: 55761238355
Ref: 55771238443
Ref: 55781238527
Ref: 55791238611
Ref: 55801238695
Ref: 55811238779
Ref: 55821238863
Ref: 55831238947
Ref: 55841239031
Ref: 55851239115
Ref: 55861239199
Ref: 55871239283
Ref: 55881239367
Ref: 55891239451
Ref: 55901239535
Ref: 55911239619
Ref: 55921239703
Ref: 55931239815
Ref: 55941239824
Ref: 55951239878
Ref: 55961239932
Ref: 55971239986
Ref: 55981240044
Ref: 55991240118
Ref: 56001240192
Ref: 56011240266
Ref: 56021240340
Ref: 56031240414
Ref: 56041240488
Ref: 56051240562
Ref: 56061240636
Ref: 56071240710
Ref: 56081240784
Ref: 56091240858
Ref: 56101240932
Ref: 56111241006
Ref: 56121241080
Ref: 56131241154
Ref: 56141241232
Ref: 56151241306
Ref: 56161241380
Ref: 56171241454
Ref: 56181241528
Ref: 56191241602
Ref: 56201241676
Ref: 56211241750
Ref: 56221241828
Ref: 56231241902
Ref: 56241241976
Ref: 56251242050
Ref: 56261242124
Ref: 56271242198
Ref: 56281242272
Ref: 56291242346
Ref: 56301242526
Ref: 56311242614
Ref: 56321242686
Ref: 56331242774
Ref: 56341242862
Ref: 56351242950
Ref: 56361243038
Ref: 56371243126
Ref: 56381243214
Ref: 56391243302
Ref: 56401243390
Ref: 56411243478
Ref: 56421243566
Ref: 56431243654
Ref: 56441243742
Ref: 56451243822
Ref: 56461243910
Ref: 56471244062
Ref: 56481244150
Ref: 56491244219
Ref: 56501244307
Ref: 56511244395
Ref: 56521244483
Ref: 56531244571
Ref: 56541244659
Ref: 56551244747
Ref: 56561244817
Ref: 56571244905
Ref: 56581244993
Ref: 56591245081
Ref: 56601245169
Ref: 56611245257
Ref: 56621245345
Ref: 56631245433
Ref: 56641245521
Ref: 56651245673
Ref: 56661245761
Ref: 56671245849
Ref: 56681245937
Ref: 56691246025
Ref: 56701246113
Ref: 56711246201
Ref: 56721246289
Ref: 56731246377
Ref: 56741246465
Ref: 56751246553
Ref: 56761246641
Ref: 56771246729
Ref: 56781246817
Ref: 56791246905
Ref: 56801246993
Ref: 56811247145
Ref: 56821247233
Ref: 56831247321
Ref: 56841247409
Ref: 56851247497
Ref: 56861247585
Ref: 56871247673
Ref: 56881247761
Ref: 56891247849
Ref: 56901247937
Ref: 56911248025
Ref: 56921248113
Ref: 56931248201
Ref: 56941248289
Ref: 56951248377
Ref: 56961248465
Ref: 56971248617
Ref: 56981248705
Ref: 56991248793
Ref: 57001248881
Ref: 57011248969
Ref: 57021249057
Ref: 57031249145
Ref: 57041249233
Ref: 57051249321
Ref: 57061249409
Ref: 57071249497
Ref: 57081249585
Ref: 57091249673
Ref: 57101249761
Ref: 57111249849
Ref: 57121249937
Ref: 57131250089
Ref: 57141250177
Ref: 57151250265
Ref: 57161250353
Ref: 57171250441
Ref: 57181250529
Ref: 57191250617
Ref: 57201250705
Ref: 57211250793
Ref: 57221250881
Ref: 57231250969
Ref: 57241251057
Ref: 57251251145
Ref: 57261251233
Ref: 57271251321
Ref: 57281251409
Node: A.3.41251748
Ref: 57291252076
Ref: 57301252133
Ref: 57311252211
Ref: 57321252289
Ref: 57331252367
Ref: 57341252445
Ref: 57351252539
Ref: 57361252635
Ref: 57371252715
Ref: 57381252792
Ref: 57391252893
Ref: 57401252988
Ref: 57411253094
Ref: 57421253199
Ref: 57431253355
Ref: 57441253506
Ref: 57451253668
Ref: 57461253824
Ref: 57471254006
Node: A.3.51258355
Ref: 57481258823
Ref: 57491258877
Ref: 57501258936
Ref: 57511259009
Ref: 57521259081
Ref: 57531259152
Ref: 57541259223
Ref: 57551259295
Ref: 57561259403
Ref: 57571259487
Ref: 57581259566
Ref: 57591259640
Ref: 57601259722
Ref: 57611259793
Ref: 57621259872
Ref: 57631259960
Ref: 57641260032
Ref: 57651260106
Ref: 57661260179
Ref: 57671260258
Ref: 57681260325
Node: A.3.61266584
Ref: 57691266786
Node: A.41266988
Node: A.4.11268061
Ref: 57701268369
Ref: 57711268435
Ref: 57721268488
Ref: 57731268541
Ref: 57741268607
Ref: 57751268626
Ref: 57761268641
Ref: 57771268654
Ref: 57781268701
Ref: 57791268751
Ref: 57801268800
Ref: 57811268846
Ref: 57821268894
Node: A.4.21268952
Ref: 57831269347
Ref: 57841269484
Ref: 57851269576
Ref: 57861269632
Ref: 57871269818
Ref: 57881269904
Ref: 57891269986
Ref: 57901270068
Ref: 57911270623
Ref: 57921270754
Ref: 57931271116
Ref: 57941271167
Ref: 57951271252
Ref: 57961271333
Ref: 57971271483
Ref: 57981271598
Ref: 57991271721
Ref: 58001271786
Ref: 58011271890
Ref: 58021271984
Ref: 58031272078
Ref: 58041275666
Ref: 58051275785
Ref: 58061277392
Node: A.4.31277937
Ref: 58071279248
Ref: 58081279411
Ref: 58091279718
Ref: 58101280026
Ref: 58111280322
Ref: 58121280621
Ref: 58131280879
Ref: 58141281177
Ref: 58151281429
Ref: 58161281638
Ref: 58171281791
Ref: 58181282031
Ref: 58191282225
Ref: 58201282365
Ref: 58211282693
Ref: 58221283013
Ref: 58231283158
Ref: 58241283282
Ref: 58251283436
Ref: 58261283617
Ref: 58271283867
Ref: 58281284301
Ref: 58291284475
Ref: 58301284690
Ref: 58311284873
Ref: 58321285100
Ref: 58331285272
Ref: 58341285579
Ref: 58351285698
Ref: 58361285911
Ref: 58371286095
Ref: 58381286383
Ref: 58391286556
Ref: 58401286768
Ref: 58411286941
Ref: 58421304142
Node: A.4.41304270
Ref: 58431305207
Ref: 58441305388
Ref: 58451305423
Ref: 58461305486
Ref: 58471305522
Ref: 58481305596
Ref: 58491305666
Ref: 58501305815
Ref: 58511305987
Ref: 58521306070
Ref: 58531306252
Ref: 58541306421
Ref: 58551306624
Ref: 58561306827
Ref: 58571307033
Ref: 58581307240
Ref: 58591307432
Ref: 58601307616
Ref: 58611308351
Ref: 58621308496
Ref: 58631308691
Ref: 58641308880
Ref: 58651309080
Ref: 58661310771
Ref: 58671311106
Ref: 58681311429
Ref: 58691311752
Ref: 58701312033
Ref: 58711312357
Ref: 58721312632
Ref: 58731312861
Ref: 58741313031
Ref: 58751313293
Ref: 58761313507
Ref: 58771313664
Ref: 58781314018
Ref: 58791314364
Ref: 58801314534
Ref: 58811314672
Ref: 58821314851
Ref: 58831315049
Ref: 58841315400
Ref: 58851315722
Ref: 58861315987
Ref: 58871316222
Ref: 58881316503
Ref: 58891316754
Ref: 58901316954
Ref: 58911317167
Ref: 58921317307
Ref: 58931317419
Ref: 58941317631
Ref: 58951317812
Ref: 58961318073
Ref: 58971318304
Ref: 58981318565
Ref: 58991319244
Ref: 59001319452
Ref: 59011319657
Node: A.4.51325867
Ref: 59021326699
Ref: 59031326795
Ref: 59041326893
Ref: 59051326969
Ref: 59061327039
Ref: 59071327093
Ref: 59081327210
Ref: 59091327308
Ref: 59101327407
Ref: 59111327489
Ref: 59121327613
Ref: 59131327738
Ref: 59141327853
Ref: 59151328509
Ref: 59161328647
Ref: 59171328835
Ref: 59181329014
Ref: 59191329205
Ref: 59201330841
Ref: 59211331160
Ref: 59221331467
Ref: 59231331776
Ref: 59241332044
Ref: 59251332353
Ref: 59261332604
Ref: 59271332823
Ref: 59281332986
Ref: 59291333235
Ref: 59301333439
Ref: 59311333589
Ref: 59321333927
Ref: 59331334257
Ref: 59341334422
Ref: 59351334556
Ref: 59361334730
Ref: 59371334921
Ref: 59381335191
Ref: 59391335432
Ref: 59401335626
Ref: 59411335790
Ref: 59421335996
Ref: 59431336172
Ref: 59441336364
Ref: 59451336526
Ref: 59461336665
Ref: 59471336773
Ref: 59481336977
Ref: 59491337151
Ref: 59501337344
Ref: 59511337507
Ref: 59521337700
Ref: 59531338372
Node: A.4.61342092
Ref: 59541342573
Ref: 59551342654
Ref: 59561342710
Ref: 59571342766
Ref: 59581342822
Ref: 59591342878
Ref: 59601342934
Ref: 59611342990
Ref: 59621343046
Ref: 59631343102
Ref: 59641343158
Ref: 59651343214
Ref: 59661343273
Ref: 59671343393
Ref: 59681343513
Node: A.4.71344119
Ref: 59691345106
Ref: 59701345108
Ref: 59711345108
Ref: 59721345108
Ref: 59731345108
Ref: 59741345108
Ref: 59751345108
Ref: 59761345108
Ref: 59771345108
Ref: 59781345108
Ref: 59791345108
Ref: 59801345108
Ref: 59811345108
Ref: 59821345108
Ref: 59831345108
Ref: 59841345108
Ref: 59851345222
Ref: 59861345382
Ref: 59871345484
Ref: 59881345545
Ref: 59891345753
Ref: 59901345860
Ref: 59911345964
Ref: 59921346068
Ref: 59931346747
Ref: 59941346888
Ref: 59951347275
Ref: 59961347336
Ref: 59971347443
Ref: 59981347541
Ref: 59991347722
Ref: 60001347847
Ref: 60011347985
Ref: 60021348055
Ref: 60031348169
Ref: 60041348277
Ref: 60051348381
Ref: 60061350463
Ref: 60071351077
Node: A.4.81351220
Ref: 60081352357
Ref: 60091352359
Ref: 60101352359
Ref: 60111352359
Ref: 60121352359
Ref: 60131352359
Ref: 60141352359
Ref: 60151352359
Ref: 60161352359
Ref: 60171352359
Ref: 60181352359
Ref: 60191352359
Ref: 60201352359
Ref: 60211352359
Ref: 60221352359
Ref: 60231352359
Ref: 60241352532
Ref: 60251352665
Ref: 60261352779
Ref: 60271352847
Ref: 60281353079
Ref: 60291353201
Ref: 60301353317
Ref: 60311353431
Ref: 60321354191
Ref: 60331354347
Ref: 60341354769
Ref: 60351354842
Ref: 60361354963
Ref: 60371355076
Ref: 60381355292
Ref: 60391355429
Ref: 60401355587
Ref: 60411355664
Ref: 60421355793
Ref: 60431355916
Ref: 60441356034
Ref: 60451356287
Ref: 60461358322
Ref: 60471358515
Ref: 60481359196
Node: A.4.91359349
Ref: 60491359687
Ref: 60501360290
Ref: 60511360792
Ref: 60521361132
Ref: 60531361785
Ref: 60541362169
Ref: 60551362598
Node: A.4.101363052
Ref: 60561363388
Ref: 60571364063
Ref: 60581364439
Ref: 60591364860
Ref: 60601365264
Ref: 60611365654
Ref: 60621366029
Ref: 60631366447
Node: A.4.111366685
Ref: 60641367203
Ref: 60651367363
Ref: 60661367432
Ref: 60671367475
Ref: 60681367520
Ref: 60691367563
Ref: 60701367604
Ref: 60711367788
Ref: 60721367925
Ref: 60731368062
Ref: 60741368189
Ref: 60751368366
Ref: 60761368535
Ref: 60771368792
Ref: 60781369009
Ref: 60791369169
Ref: 60801369375
Ref: 60811369560
Ref: 60821369740
Ref: 60831369932
Ref: 60841370062
Ref: 60851370209
Ref: 60861370339
Ref: 60871370406
Ref: 60881370511
Ref: 60891370706
Ref: 60901370903
Ref: 60911371038
Ref: 60921371190
Ref: 60931371325
Ref: 60941371397
Ref: 60951371512
Ref: 60961371722
Ref: 60971371924
Ref: 60981372064
Ref: 60991372221
Ref: 61001372361
Ref: 61011372438
Ref: 61021372900
Ref: 61031372900
Ref: 61041372900
Ref: 61051372900
Node: A.51382660
Ref: 61061383350
Ref: 61071383385
Ref: 61081383421
Ref: 61091383554
Node: A.5.11384223
Ref: 61101384857
Ref: 61111384987
Ref: 61121385068
Ref: 61131385149
Ref: 61141385230
Ref: 61151385395
Ref: 61161385476
Ref: 61171385557
Ref: 61181385638
Ref: 61191385719
Ref: 61201385800
Ref: 61211385881
Ref: 61221385962
Ref: 61231386046
Ref: 61241386127
Ref: 61251386208
Ref: 61261386289
Ref: 61271386370
Ref: 61281386572
Ref: 61291386774
Ref: 61301386976
Ref: 61311387181
Ref: 61321387262
Ref: 61331387343
Ref: 61341387424
Ref: 61351387505
Ref: 61361387586
Ref: 61371387667
Ref: 61381387748
Ref: 61391387872
Ref: 61401392144
Ref: 61411392144
Ref: 61421392144
Ref: 61431392940
Ref: 61441393190
Ref: 61451393748
Node: A.5.21396084
Ref: 61461396509
Ref: 61471397603
Ref: 61481397653
Ref: 61491397702
Ref: 61501397768
Ref: 61511397844
Ref: 61521397945
Ref: 61531398033
Ref: 61541398073
Ref: 61551398176
Ref: 61561398268
Ref: 61571398364
Ref: 61581398425
Ref: 61591398613
Ref: 61601398725
Ref: 61611398872
Ref: 61621398923
Ref: 61631398993
Ref: 61641399094
Ref: 61651399182
Ref: 61661399222
Ref: 61671399325
Ref: 61681399417
Ref: 61691399513
Ref: 61701399574
Ref: 61711399765
Ref: 61721400076
Ref: 61731401750
Ref: 61741401986
Ref: 61751403048
Ref: 61761403048
Ref: 61771403048
Ref: 61781403342
Ref: 61791403344
Node: A.5.31411164
Ref: 61801411369
Ref: 61811411501
Ref: 61821411516
Ref: 61831411679
Ref: 61841412227
Ref: 61851412242
Ref: 61861412659
Ref: 61871412674
Ref: 61881413072
Ref: 61891413087
Ref: 61901413478
Ref: 61911413493
Ref: 61921414024
Ref: 61931414124
Ref: 61941414210
Ref: 61951414212
Ref: 61961414505
Ref: 61971414520
Ref: 61981414835
Ref: 61991414850
Ref: 62001415203
Ref: 62011415218
Ref: 62021415666
Ref: 62031416001
Ref: 62041416122
Ref: 62051416137
Ref: 62061416407
Ref: 62071416422
Ref: 62081416848
Ref: 62091416863
Ref: 62101417114
Ref: 62111417512
Ref: 62121417514
Ref: 62131417721
Ref: 62141417736
Ref: 62151417982
Ref: 62161418303
Ref: 62171418305
Ref: 62181418487
Ref: 62191418502
Ref: 62201418958
Ref: 62211418973
Ref: 62221419483
Ref: 62231419498
Ref: 62241419947
Ref: 62251419962
Ref: 62261420441
Ref: 62271420456
Ref: 62281421111
Ref: 62291421129
Ref: 62301421144
Ref: 62311421540
Ref: 62321421555
Ref: 62331421734
Ref: 62341422081
Ref: 62351422083
Ref: 62361422236
Ref: 62371422251
Ref: 62381422434
Ref: 62391422672
Ref: 62401422674
Ref: 62411422946
Ref: 62421422961
Ref: 62431423147
Ref: 62441423362
Ref: 62451423364
Ref: 62461423579
Ref: 62471423594
Ref: 62481424287
Ref: 62491424302
Ref: 62501424302
Ref: 62511424490
Ref: 62521424505
Ref: 62531424675
Ref: 62541424936
Ref: 62551424938
Ref: 62561425210
Ref: 62571425333
Ref: 62581425348
Ref: 62591425951
Ref: 62601425966
Ref: 62611426389
Ref: 62621426404
Ref: 62631426571
Ref: 62641426586
Ref: 62651426743
Ref: 62661426758
Ref: 62671427198
Ref: 62681427213
Ref: 62691427654
Ref: 62701427669
Node: A.5.41428095
Ref: 62711428280
Ref: 62721428409
Ref: 62731428424
Ref: 62741428604
Ref: 62751428619
Ref: 62761428933
Ref: 62771428948
Node: A.61429283
Ref: 62781429394
Ref: 62791429394
Node: A.71430085
Ref: 62801430278
Ref: 62811430278
Ref: 62821430278
Ref: 62831430860
Ref: 62841432590
Ref: 62851432592
Ref: 62861432592
Ref: 62871432655
Ref: 62881433925
Ref: 62891433927
Node: A.81434719
Ref: 62901434906
Ref: 62911434906
Ref: 62921434906
Ref: 62931435345
Ref: 62941435764
Ref: 62951435764
Ref: 62961435764
Ref: 62971436324
Node: A.8.11436825
Ref: 62981437207
Ref: 62991437224
Ref: 63001437270
Ref: 63011437370
Ref: 63021437580
Ref: 63031437772
Ref: 63041437823
Ref: 63051437874
Ref: 63061437946
Ref: 63071437999
Ref: 63081438063
Ref: 63091438124
Ref: 63101438189
Ref: 63111438260
Ref: 63121438356
Ref: 63131438428
Ref: 63141438502
Ref: 63151438586
Ref: 63161438655
Ref: 63171438722
Ref: 63181438789
Ref: 63191438855
Ref: 63201438924
Ref: 63211438990
Ref: 63221439189
Node: A.8.21439250
Node: A.8.31447357
Node: A.8.41449129
Ref: 63231449505
Ref: 63241449522
Ref: 63251449568
Ref: 63261449627
Ref: 63271449693
Ref: 63281449793
Ref: 63291450005
Ref: 63301450197
Ref: 63311450248
Ref: 63321450299
Ref: 63331450371
Ref: 63341450424
Ref: 63351450488
Ref: 63361450549
Ref: 63371450614
Ref: 63381450685
Ref: 63391450781
Ref: 63401450923
Ref: 63411450998
Ref: 63421451140
Ref: 63431451214
Ref: 63441451291
Ref: 63451451358
Ref: 63461451420
Ref: 63471451504
Ref: 63481451573
Ref: 63491451640
Ref: 63501451707
Ref: 63511451773
Ref: 63521451842
Ref: 63531451908
Ref: 63541452103
Node: A.8.51452160
Node: A.91455514
Ref: 63551456107
Ref: 63561456155
Ref: 63571456277
Ref: 63581456423
Ref: 63591456502
Ref: 63601456593
Node: A.101457349
Ref: 63611459575
Ref: 63621459575
Ref: 63631459966
Ref: 63641460290
Ref: 63651460290
Ref: 63661460290
Ref: 63671461590
Ref: 63681461596
Ref: 63691461596
Ref: 63701461596
Ref: 63711461596
Ref: 63721462413
Ref: 63731462413
Node: A.10.11463862
Ref: 63741464146
Ref: 63751464163
Ref: 63761464209
Ref: 63771464272
Ref: 63781464334
Ref: 63791464384
Ref: 63801464467
Ref: 63811464543
Ref: 63821464597
Ref: 63831464688
Ref: 63841464909
Ref: 63851465106
Ref: 63861465158
Ref: 63871465210
Ref: 63881465283
Ref: 63891465339
Ref: 63901465404
Ref: 63911465466
Ref: 63921465532
Ref: 63931465658
Ref: 63941465709
Ref: 63951465760
Ref: 63961465814
Ref: 63971465865
Ref: 63981465916
Ref: 63991465971
Ref: 64001466022
Ref: 64011466073
Ref: 64021466124
Ref: 64031466187
Ref: 64041466240
Ref: 64051466293
Ref: 64061466350
Ref: 64071466403
Ref: 64081466456
Ref: 64091466540
Ref: 64101466587
Ref: 64111466672
Ref: 64121466743
Ref: 64131466799
Ref: 64141466870
Ref: 64151466926
Ref: 64161466991
Ref: 64171467039
Ref: 64181467104
Ref: 64191467200
Ref: 64201467319
Ref: 64211467388
Ref: 64221467507
Ref: 64231467576
Ref: 64241467643
Ref: 64251467693
Ref: 64261467745
Ref: 64271467777
Ref: 64281467829
Ref: 64291467862
Ref: 64301467929
Ref: 64311467979
Ref: 64321468046
Ref: 64331468096
Ref: 64341468169
Ref: 64351468227
Ref: 64361468300
Ref: 64371468357
Ref: 64381468423
Ref: 64391468472
Ref: 64401468538
Ref: 64411468587
Ref: 64421468653
Ref: 64431468743
Ref: 64441468810
Ref: 64451468859
Ref: 64461468925
Ref: 64471468974
Ref: 64481469150
Ref: 64491469271
Ref: 64501469390
Ref: 64511469454
Ref: 64521469630
Ref: 64531469788
Ref: 64541469852
Ref: 64551469898
Ref: 64561469961
Ref: 64571470007
Ref: 64581470150
Ref: 64591470224
Ref: 64601470287
Ref: 64611470333
Ref: 64621470401
Ref: 64631470564
Ref: 64641470588
Ref: 64651470635
Ref: 64661470700
Ref: 64671470839
Ref: 64681470935
Ref: 64691471149
Ref: 64701471316
Ref: 64711471448
Ref: 64721471671
Ref: 64731471695
Ref: 64741471742
Ref: 64751471807
Ref: 64761471946
Ref: 64771472042
Ref: 64781472256
Ref: 64791472423
Ref: 64801472555
Ref: 64811472846
Ref: 64821472868
Ref: 64831472906
Ref: 64841472955
Ref: 64851473012
Ref: 64861473152
Ref: 64871473248
Ref: 64881473507
Ref: 64891473724
Ref: 64901473855
Ref: 64911474124
Ref: 64921474146
Ref: 64931474191
Ref: 64941474235
Ref: 64951474292
Ref: 64961474432
Ref: 64971474528
Ref: 64981474787
Ref: 64991475004
Ref: 65001475136
Ref: 65011475415
Ref: 65021475439
Ref: 65031475484
Ref: 65041475528
Ref: 65051475585
Ref: 65061475725
Ref: 65071475821
Ref: 65081476080
Ref: 65091476297
Ref: 65101476429
Ref: 65111476768
Ref: 65121476796
Ref: 65131476837
Ref: 65141476909
Ref: 65151476999
Ref: 65161477046
Ref: 65171477264
Ref: 65181477439
Ref: 65191477572
Ref: 65201477763
Ref: 65211477832
Ref: 65221477899
Ref: 65231477966
Ref: 65241478032
Ref: 65251478101
Ref: 65261478167
Ref: 65271478234
Ref: 65281478425
Node: A.10.21478446
Node: A.10.31480868
Ref: 65291484202
Node: A.10.41484822
Node: A.10.51487355
Node: A.10.61497385
Ref: 65301499473
Node: A.10.71503505
Ref: 65311505265
Ref: 65321506620
Ref: 65331508454
Ref: 65341509167
Node: A.10.81511233
Ref: 65351515746
Node: A.10.91516636
Ref: 65361523342
Node: A.10.101525002
Node: A.10.111529587
Ref: 65371530179
Ref: 65381530203
Ref: 65391530310
Ref: 65401530384
Ref: 65411530496
Ref: 65421530574
Ref: 65431530680
Ref: 65441530755
Ref: 65451530857
Node: A.10.121532274
Ref: 65461532732
Ref: 65471532756
Ref: 65481532875
Ref: 65491532961
Ref: 65501533085
Ref: 65511533175
Ref: 65521533293
Ref: 65531533380
Ref: 65541533494
Node: A.111535127
Ref: 65551535660
Ref: 65561535943
Ref: 65571535943
Ref: 65581536217
Ref: 65591536514
Ref: 65601536516
Ref: 65611536820
Ref: 65621536820
Ref: 65631537346
Ref: 65641537346
Node: A.121537892
Node: A.12.11538394
Ref: 65651538534
Ref: 65661539494
Ref: 65671539494
Ref: 65681539600
Ref: 65691539697
Ref: 65701539768
Ref: 65711539872
Ref: 65721539939
Ref: 65731540011
Ref: 65741540133
Ref: 65751540357
Ref: 65761540550
Ref: 65771540603
Ref: 65781540656
Ref: 65791540730
Ref: 65801540786
Ref: 65811540849
Ref: 65821540909
Ref: 65831540973
Ref: 65841541041
Ref: 65851541113
Ref: 65861541355
Ref: 65871541576
Ref: 65881541841
Ref: 65891542003
Ref: 65901542207
Ref: 65911542285
Ref: 65921542353
Ref: 65931542417
Ref: 65941542498
Ref: 65951542559
Ref: 65961542629
Ref: 65971542697
Ref: 65981542765
Ref: 65991542832
Ref: 66001542902
Ref: 66011542969
Ref: 66021543174
Ref: 66031546568
Node: A.12.21546901
Ref: 66041547299
Ref: 66051547354
Ref: 66061547434
Node: A.12.31548058
Ref: 66071548481
Ref: 66081548541
Ref: 66091548621
Node: A.12.41548808
Ref: 66101549247
Ref: 66111549312
Ref: 66121549394
Node: A.131549588
Ref: 66131549977
Ref: 66141550020
Ref: 66151550054
Ref: 66161550088
Ref: 66171550122
Ref: 66181550156
Ref: 66191550190
Ref: 66201550224
Ref: 66211550258
Ref: 66221553765
Ref: 66231554096
Ref: 66241554098
Node: A.141554100
Ref: 66251554261
Node: A.151554965
Ref: 66261555405
Ref: 66271555467
Ref: 66281555517
Ref: 66291555583
Ref: 66301555626
Ref: 66311555685
Ref: 66321555724
Ref: 66331555781
Ref: 66341556584
Node: A.161558451
Ref: 66351558893
Ref: 66361558965
Ref: 66371559021
Ref: 66381559083
Ref: 66391559221
Ref: 66401559286
Ref: 66411559415
Ref: 66421559476
Ref: 66431559532
Ref: 66441559597
Ref: 66451559814
Ref: 66461559881
Ref: 66471559950
Ref: 66481560028
Ref: 66491560095
Ref: 66501560162
Ref: 66511560373
Ref: 66521560489
Ref: 66531560619
Ref: 66541560693
Ref: 66551560766
Ref: 66561560831
Ref: 66571560896
Ref: 66581560961
Ref: 66591561083
Ref: 66601561143
Ref: 66611561207
Ref: 66621561263
Ref: 66631561524
Ref: 66641561589
Ref: 66651561668
Ref: 66661562138
Ref: 66671562244
Ref: 66681562348
Ref: 66691562450
Ref: 66701562552
Ref: 66711562661
Ref: 66721562734
Ref: 66731562805
Ref: 66741562875
Ref: 66751563410
Ref: 66761563412
Ref: 66771563412
Ref: 66781563623
Ref: 66791563625
Ref: 66801564291
Ref: 66811564293
Ref: 66821564484
Ref: 66831564623
Ref: 66841578985
Ref: 66851585833
Node: A.16.11587837
Ref: 66861588399
Ref: 66871588422
Ref: 66881588494
Ref: 66891588574
Ref: 66901588656
Ref: 66911588739
Ref: 66921588809
Ref: 66931588884
Ref: 66941589000
Ref: 66951589134
Ref: 66961589209
Ref: 66971589280
Node: A.171593868
Ref: 66981594026
Ref: 66991594506
Ref: 67001594581
Ref: 67011594645
Ref: 67021594728
Ref: 67031594793
Ref: 67041594859
Ref: 67051594903
Ref: 67061594933
Ref: 67071598027
Ref: 67081598403
Node: A.181600058
Ref: 67091600673
Ref: 67101600673
Ref: 67111601132
Ref: 67121601133
Ref: 67131601524
Ref: 67141602179
Node: A.18.11605157
Ref: 67151605497
Ref: 67161605549
Ref: 67171605610
Ref: 67181605671
Node: A.18.21606109
Ref: 67191606678
Ref: 67201606678
Ref: 67211606686
Ref: 67221606686
Ref: 67231607213
Ref: 67241607692
Ref: 67251607790
Ref: 67261607958
Ref: 67271608041
Ref: 67281608339
Ref: 67291608420
Ref: 67301608466
Ref: 67311608526
Ref: 67321608598
Ref: 67331608780
Ref: 67341608850
Ref: 67351609311
Ref: 67361609384
Ref: 67371609520
Ref: 67381609591
Ref: 67391609715
Ref: 67401609785
Ref: 67411609843
Ref: 67421609968
Ref: 67431610044
Ref: 67441610178
Ref: 67451610251
Ref: 67461610454
Ref: 67471610653
Ref: 67481610842
Ref: 67491610991
Ref: 67501611220
Ref: 67511611611
Ref: 67521611752
Ref: 67531611935
Ref: 67541612095
Ref: 67551612274
Ref: 67561612431
Ref: 67571612509
Ref: 67581612610
Ref: 67591612713
Ref: 67601612887
Ref: 67611613053
Ref: 67621613272
Ref: 67631613514
Ref: 67641613748
Ref: 67651614035
Ref: 67661614218
Ref: 67671614446
Ref: 67681614561
Ref: 67691614745
Ref: 67701614858
Ref: 67711615039
Ref: 67721615240
Ref: 67731615492
Ref: 67741615675
Ref: 67751615850
Ref: 67761615984
Ref: 67771616116
Ref: 67781616186
Ref: 67791616299
Ref: 67801616407
Ref: 67811616482
Ref: 67821616547
Ref: 67831616637
Ref: 67841616715
Ref: 67851616779
Ref: 67861616868
Ref: 67871616932
Ref: 67881616988
Ref: 67891617056
Ref: 67901617116
Ref: 67911617333
Ref: 67921617514
Ref: 67931617754
Ref: 67941617959
Ref: 67951618124
Ref: 67961618264
Ref: 67971618797
Ref: 67981618842
Ref: 67991618916
Ref: 68001618977
Ref: 68011619667
Ref: 68021619755
Ref: 68031621656
Ref: 68041622083
Ref: 68051622445
Ref: 68061622445
Ref: 68071632834
Ref: 68081657106
Ref: 68091658614
Ref: 68101659001
Ref: 68111660078
Ref: 68121660078
Ref: 68131660673
Ref: 68141661295
Ref: 68151661295
Ref: 68161661912
Ref: 68171662035
Node: A.18.31664214
Ref: 68181664634
Ref: 68191664636
Ref: 68201664642
Ref: 68211665157
Ref: 68221665528
Ref: 68231665647
Ref: 68241665941
Ref: 68251666021
Ref: 68261666062
Ref: 68271666121
Ref: 68281666192
Ref: 68291666370
Ref: 68301666438
Ref: 68311666506
Ref: 68321666562
Ref: 68331666646
Ref: 68341666843
Ref: 68351666992
Ref: 68361667381
Ref: 68371667522
Ref: 68381667699
Ref: 68391667854
Ref: 68401667928
Ref: 68411667986
Ref: 68421668085
Ref: 68431668317
Ref: 68441668602
Ref: 68451668828
Ref: 68461669010
Ref: 68471669189
Ref: 68481669362
Ref: 68491669494
Ref: 68501669624
Ref: 68511669692
Ref: 68521669799
Ref: 68531669918
Ref: 68541670077
Ref: 68551670288
Ref: 68561670448
Ref: 68571670511
Ref: 68581670599
Ref: 68591670661
Ref: 68601670748
Ref: 68611670811
Ref: 68621670879
Ref: 68631670936
Ref: 68641670996
Ref: 68651671175
Ref: 68661671378
Ref: 68671671540
Ref: 68681671678
Ref: 68691672201
Ref: 68701672246
Ref: 68711672318
Ref: 68721672377
Ref: 68731673125
Ref: 68741673207
Ref: 68751674672
Ref: 68761675310
Ref: 68771675575
Ref: 68781675575
Ref: 68791679857
Ref: 68801697486
Ref: 68811699004
Ref: 68821699299
Ref: 68831699689
Ref: 68841700223
Ref: 68851700223
Ref: 68861700956
Ref: 68871700958
Node: A.18.41702623
Ref: 68881703123
Ref: 68891703125
Ref: 68901703895
Ref: 68911703973
Ref: 68921703998
Ref: 68931704450
Ref: 68941704456
Ref: 68951704456
Ref: 68961704456
Ref: 68971705401
Ref: 68981705909
Ref: 68991706176
Ref: 69001706176
Ref: 69011712078
Ref: 69021721278
Ref: 69031721665
Ref: 69041722180
Ref: 69051722180
Ref: 69061722763
Ref: 69071722917
Node: A.18.51723813
Ref: 69081724531
Ref: 69091724634
Ref: 69101724926
Ref: 69111725006
Ref: 69121725045
Ref: 69131725104
Ref: 69141725175
Ref: 69151725349
Ref: 69161725418
Ref: 69171725551
Ref: 69181725618
Ref: 69191725685
Ref: 69201725740
Ref: 69211725804
Ref: 69221725877
Ref: 69231726073
Ref: 69241726294
Ref: 69251726737
Ref: 69261726878
Ref: 69271727054
Ref: 69281727207
Ref: 69291727385
Ref: 69301727541
Ref: 69311727613
Ref: 69321727697
Ref: 69331727794
Ref: 69341728072
Ref: 69351728291
Ref: 69361728462
Ref: 69371728636
Ref: 69381728810
Ref: 69391728924
Ref: 69401729036
Ref: 69411729145
Ref: 69421729218
Ref: 69431729283
Ref: 69441729340
Ref: 69451729457
Ref: 69461729586
Ref: 69471729742
Ref: 69481729831
Ref: 69491729966
Ref: 69501730102
Ref: 69511730716
Ref: 69521730723
Ref: 69531731262
Ref: 69541731766
Ref: 69551731993
Ref: 69561732000
Ref: 69571732000
Ref: 69581732000
Ref: 69591732186
Node: A.18.61736253
Ref: 69601736885
Ref: 69611736994
Ref: 69621737069
Ref: 69631737361
Ref: 69641737441
Ref: 69651737480
Ref: 69661737539
Ref: 69671737610
Ref: 69681737784
Ref: 69691737851
Ref: 69701737918
Ref: 69711737973
Ref: 69721738037
Ref: 69731738110
Ref: 69741738306
Ref: 69751738527
Ref: 69761738970
Ref: 69771739111
Ref: 69781739287
Ref: 69791739440
Ref: 69801739618
Ref: 69811739774
Ref: 69821739846
Ref: 69831739902
Ref: 69841739999
Ref: 69851740277
Ref: 69861740496
Ref: 69871740667
Ref: 69881740841
Ref: 69891741015
Ref: 69901741129
Ref: 69911741241
Ref: 69921741351
Ref: 69931741414
Ref: 69941741475
Ref: 69951741537
Ref: 69961741613
Ref: 69971741681
Ref: 69981741742
Ref: 69991741817
Ref: 70001741884
Ref: 70011741948
Ref: 70021742004
Ref: 70031742072
Ref: 70041742132
Ref: 70051742238
Ref: 70061742356
Ref: 70071742464
Ref: 70081742576
Ref: 70091743173
Ref: 70101743310
Ref: 70111743818
Ref: 70121744491
Ref: 70131744695
Ref: 70141744702
Ref: 70151744702
Ref: 70161744702
Ref: 70171744702
Node: A.18.71751337
Ref: 70181751820
Ref: 70191751820
Ref: 70201752592
Ref: 70211752670
Ref: 70221752984
Ref: 70231752990
Ref: 70241752990
Ref: 70251752990
Ref: 70261753965
Ref: 70271754486
Ref: 70281754608
Ref: 70291754608
Ref: 70301759832
Ref: 70311769271
Ref: 70321769478
Ref: 70331771571
Ref: 70341773947
Ref: 70351774335
Ref: 70361774850
Ref: 70371774850
Ref: 70381775450
Ref: 70391775604
Node: A.18.81776505
Ref: 70401777205
Ref: 70411777308
Ref: 70421777552
Ref: 70431777632
Ref: 70441777671
Ref: 70451777730
Ref: 70461777801
Ref: 70471777975
Ref: 70481778049
Ref: 70491778117
Ref: 70501778187
Ref: 70511778320
Ref: 70521778387
Ref: 70531778454
Ref: 70541778509
Ref: 70551778582
Ref: 70561778778
Ref: 70571779097
Ref: 70581779274
Ref: 70591779346
Ref: 70601779430
Ref: 70611779527
Ref: 70621779750
Ref: 70631779866
Ref: 70641779984
Ref: 70651780102
Ref: 70661780220
Ref: 70671780336
Ref: 70681780446
Ref: 70691780544
Ref: 70701780680
Ref: 70711780792
Ref: 70721780943
Ref: 70731781051
Ref: 70741781196
Ref: 70751781324
Ref: 70761781500
Ref: 70771781567
Ref: 70781781673
Ref: 70791781735
Ref: 70801781799
Ref: 70811781855
Ref: 70821781965
Ref: 70831782125
Ref: 70841782217
Ref: 70851782363
Ref: 70861782510
Ref: 70871783083
Ref: 70881783125
Ref: 70891783192
Ref: 70901783330
Ref: 70911783513
Ref: 70921783633
Ref: 70931783750
Ref: 70941783876
Ref: 70951784012
Ref: 70961784261
Ref: 70971784425
Ref: 70981784617
Ref: 70991784804
Ref: 71001785123
Ref: 71011785396
Ref: 71021785945
Ref: 71031786446
Ref: 71041786630
Ref: 71051786856
Ref: 71061786863
Ref: 71071786863
Ref: 71081786863
Ref: 71091787064
Ref: 71101791355
Ref: 71111791743
Node: A.18.91792148
Ref: 71121792751
Ref: 71131792860
Ref: 71141792943
Ref: 71151793187
Ref: 71161793267
Ref: 71171793306
Ref: 71181793365
Ref: 71191793436
Ref: 71201793610
Ref: 71211793685
Ref: 71221793753
Ref: 71231793820
Ref: 71241793887
Ref: 71251793942
Ref: 71261794015
Ref: 71271794211
Ref: 71281794530
Ref: 71291794707
Ref: 71301794779
Ref: 71311794835
Ref: 71321794932
Ref: 71331795155
Ref: 71341795271
Ref: 71351795389
Ref: 71361795507
Ref: 71371795625
Ref: 71381795741
Ref: 71391795851
Ref: 71401795914
Ref: 71411795976
Ref: 71421796074
Ref: 71431796210
Ref: 71441796322
Ref: 71451796473
Ref: 71461796581
Ref: 71471796726
Ref: 71481796854
Ref: 71491797031
Ref: 71501797098
Ref: 71511797204
Ref: 71521797266
Ref: 71531797342
Ref: 71541797403
Ref: 71551797478
Ref: 71561797542
Ref: 71571797598
Ref: 71581797666
Ref: 71591797726
Ref: 71601797847
Ref: 71611797970
Ref: 71621798097
Ref: 71631798758
Ref: 71641798895
Ref: 71651799522
Ref: 71661799565
Ref: 71671799664
Ref: 71681799732
Ref: 71691799874
Ref: 71701800060
Ref: 71711800182
Ref: 71721800301
Ref: 71731800430
Ref: 71741800561
Ref: 71751800696
Ref: 71761800820
Ref: 71771801073
Ref: 71781801237
Ref: 71791801429
Ref: 71801801616
Ref: 71811802081
Ref: 71821802625
Ref: 71831802809
Ref: 71841803018
Ref: 71851803025
Ref: 71861803025
Ref: 71871803025
Ref: 71881803025
Ref: 71891809376
Node: A.18.101810273
Ref: 71901810774
Ref: 71911810774
Ref: 71921810787
Ref: 71931810974
Ref: 71941811398
Ref: 71951811400
Ref: 71961811400
Ref: 71971811726
Ref: 71981811872
Ref: 71991811994
Ref: 72001812259
Ref: 72011812609
Ref: 72021812718
Ref: 72031813012
Ref: 72041813093
Ref: 72051813135
Ref: 72061813193
Ref: 72071813263
Ref: 72081813376
Ref: 72091813574
Ref: 72101813641
Ref: 72111813713
Ref: 72121813794
Ref: 72131813862
Ref: 72141813929
Ref: 72151813996
Ref: 72161814059
Ref: 72171814115
Ref: 72181814188
Ref: 72191814385
Ref: 72201814534
Ref: 72211814752
Ref: 72221814919
Ref: 72231815058
Ref: 72241815233
Ref: 72251815386
Ref: 72261815458
Ref: 72271815516
Ref: 72281815615
Ref: 72291815736
Ref: 72301815863
Ref: 72311815969
Ref: 72321816091
Ref: 72331816235
Ref: 72341816375
Ref: 72351816496
Ref: 72361816634
Ref: 72371816781
Ref: 72381816901
Ref: 72391817030
Ref: 72401817102
Ref: 72411817182
Ref: 72421817497
Ref: 72431817871
Ref: 72441818180
Ref: 72451818440
Ref: 72461818696
Ref: 72471818825
Ref: 72481819062
Ref: 72491819365
Ref: 72501819610
Ref: 72511819953
Ref: 72521820229
Ref: 72531820294
Ref: 72541820362
Ref: 72551820444
Ref: 72561820511
Ref: 72571820592
Ref: 72581820663
Ref: 72591820739
Ref: 72601820804
Ref: 72611820873
Ref: 72621821018
Ref: 72631821170
Ref: 72641821943
Ref: 72651822025
Ref: 72661823543
Ref: 72671824133
Ref: 72681824396
Ref: 72691824396
Ref: 72701831371
Ref: 72711862443
Ref: 72721862831
Ref: 72731863360
Ref: 72741863360
Ref: 72751863949
Node: A.18.111865335
Ref: 72761865948
Node: A.18.121866877
Ref: 72771867573
Node: A.18.131868320
Ref: 72781868924
Node: A.18.141869710
Ref: 72791870319
Node: A.18.151871106
Ref: 72801871695
Node: A.18.161872181
Ref: 72811872775
Node: A.18.171873262
Ref: 72821873872
Node: A.18.181874712
Ref: 72831875346
Ref: 72841875674
Ref: 72851875791
Ref: 72861875879
Ref: 72871876003
Ref: 72881876077
Ref: 72891876147
Ref: 72901876205
Ref: 72911876279
Ref: 72921876416
Ref: 72931876561
Ref: 72941876710
Ref: 72951876871
Ref: 72961877007
Ref: 72971877121
Ref: 72981877222
Ref: 72991877298
Ref: 73001877360
Ref: 73011878098
Ref: 73021878642
Ref: 73031879068
Ref: 73041879068
Ref: 73051882483
Ref: 73061884939
Ref: 73071885334
Ref: 73081886005
Node: A.18.191886663
Ref: 73091888141
Ref: 73101888676
Node: A.18.201889768
Ref: 73111891197
Ref: 73121892002
Ref: 73131892531
Node: A.18.211893530
Ref: 73141895045
Ref: 73151895367
Ref: 73161896174
Ref: 73171896700
Node: A.18.221897790
Ref: 73181899179
Ref: 73191899673
Ref: 73201900199
Node: A.18.231901292
Ref: 73211902790
Ref: 73221903112
Ref: 73231903915
Ref: 73241904441
Node: A.18.241905426
Ref: 73251906813
Ref: 73261907303
Ref: 73271907829
Node: A.18.251908817
Ref: 73281911142
Ref: 73291911671
Node: A.18.261912660
Ref: 73301913446
Ref: 73311914305
Ref: 73321914714
Ref: 73331915675
Ref: 73341915994
Ref: 73351917354
Node: A.18.271918159
Ref: 73361918854
Ref: 73371918925
Ref: 73381918981
Ref: 73391919151
Ref: 73401919320
Ref: 73411919400
Ref: 73421919745
Node: A.18.281921095
Ref: 73431921867
Ref: 73441922073
Ref: 73451922276
Ref: 73461922370
Ref: 73471922472
Ref: 73481922545
Node: A.18.291922916
Ref: 73491923720
Ref: 73501923924
Ref: 73511924185
Ref: 73521924279
Ref: 73531924381
Ref: 73541924454
Node: A.18.301925041
Ref: 73551926045
Ref: 73561926247
Ref: 73571926450
Ref: 73581926544
Ref: 73591926651
Ref: 73601926878
Ref: 73611926951
Node: A.18.311928500
Ref: 73621929536
Ref: 73631929736
Ref: 73641929995
Ref: 73651930089
Ref: 73661930196
Ref: 73671930423
Ref: 73681930496
Node: A.18.321931085
Node: A.191935877
Ref: 73691936004
Ref: 73701936301
Ref: 73711936396
Ref: 73721936546
Ref: 73731936690
Ref: 73741936750
Ref: 73751936826
Ref: 73761936874
Ref: 73771936954
Ref: 73781936954
Node: Annex B1937707
Ref: 73791937864
Ref: 73801937864
Ref: 73811937864
Node: B.11938976
Ref: 73821939225
Ref: 73831939225
Ref: 73841939231
Ref: 73851939231
Ref: 73861939498
Ref: 73871939499
Ref: 73881940070
Ref: 73891940070
Ref: 73901940070
Ref: 73911940070
Ref: 73921940070
Ref: 73931940072
Ref: 73941940072
Ref: 73951940072
Ref: 73961940072
Ref: 73971940099
Ref: 73981940099
Ref: 73991940841
Ref: 74001940842
Ref: 74011940866
Ref: 74021941191
Ref: 74031941226
Ref: 74041941324
Ref: 74051941771
Ref: 74061941842
Ref: 74071942260
Ref: 74081943621
Ref: 74091943738
Ref: 74101943738
Ref: 74111945458
Ref: 74121945656
Ref: 74131946539
Ref: 74141946539
Ref: 74151946851
Ref: 74161947696
Ref: 74171947698
Ref: 74181947698
Ref: 74191947698
Node: B.21949916
Ref: 74201950464
Ref: 74211951194
Ref: 74221951194
Ref: 74231951194
Ref: 74241951194
Ref: 74251951194
Ref: 74261951702
Ref: 74271951702
Ref: 74281951711
Ref: 74291951711
Node: B.31953382
Ref: 74301953521
Ref: 74311953521
Ref: 74321954243
Ref: 74331954327
Ref: 74341954403
Ref: 74351954482
Ref: 74361954560
Ref: 74371954693
Ref: 74381954747
Ref: 74391954801
Ref: 74401954858
Ref: 74411954962
Ref: 74421955023
Ref: 74431955084
Ref: 74441955149
Ref: 74451955250
Ref: 74461955307
Ref: 74471955369
Ref: 74481955458
Ref: 74491955523
Ref: 74501955588
Ref: 74511955694
Ref: 74521955754
Ref: 74531955829
Ref: 74541955892
Ref: 74551955953
Ref: 74561956102
Ref: 74571956180
Ref: 74581956321
Ref: 74591956459
Ref: 74601956673
Ref: 74611956933
Ref: 74621956996
Ref: 74631957079
Ref: 74641957146
Ref: 74651957222
Ref: 74661957364
Ref: 74671957443
Ref: 74681957590
Ref: 74691957734
Ref: 74701957954
Ref: 74711958265
Ref: 74721958331
Ref: 74731958421
Ref: 74741958487
Ref: 74751958559
Ref: 74761958709
Ref: 74771958785
Ref: 74781958933
Ref: 74791959082
Ref: 74801959308
Ref: 74811959530
Ref: 74821959597
Ref: 74831959688
Ref: 74841959759
Ref: 74851959837
Ref: 74861959989
Ref: 74871960065
Ref: 74881960219
Ref: 74891960374
Ref: 74901960605
Ref: 74911960817
Ref: 74921963955
Ref: 74931964396
Ref: 74941969915
Ref: 74951969915
Node: B.3.11975185
Ref: 74961975924
Ref: 74971975979
Ref: 74981976041
Ref: 74991976137
Ref: 75001976208
Ref: 75011976264
Ref: 75021976425
Ref: 75031976505
Ref: 75041976574
Ref: 75051976613
Ref: 75061976670
Ref: 75071976738
Ref: 75081976837
Ref: 75091976901
Ref: 75101976996
Ref: 75111977062
Ref: 75121977267
Ref: 75131977453
Ref: 75141981929
Ref: 75151982194
Ref: 75161982306
Ref: 75171982363
Node: B.3.21982976
Ref: 75181984256
Ref: 75191984312
Ref: 75201984363
Ref: 75211984517
Ref: 75221984629
Ref: 75231985218
Ref: 75241985310
Ref: 75251985446
Ref: 75261985618
Ref: 75271985854
Ref: 75281988893
Ref: 75291988982
Ref: 75301989126
Ref: 75311989344
Ref: 75321989497
Ref: 75331989824
Node: B.3.31991587
Ref: 75341991708
Ref: 75351992529
Ref: 75361992529
Ref: 75371992616
Ref: 75381992616
Ref: 75391992616
Ref: 75401993574
Ref: 75411995644
Ref: 75421995914
Node: B.41997564
Ref: 75431997695
Ref: 75441997695
Ref: 75451998708
Ref: 75461998829
Ref: 75471998892
Ref: 75481998959
Ref: 75491999019
Ref: 75501999073
Ref: 75511999144
Ref: 75521999231
Ref: 75531999294
Ref: 75541999396
Ref: 75551999463
Ref: 75561999556
Ref: 75571999661
Ref: 75581999765
Ref: 75591999831
Ref: 75601999902
Ref: 75612000072
Ref: 75622000227
Ref: 75632000375
Ref: 75642000409
Ref: 75652000465
Ref: 75662000521
Ref: 75672000577
Ref: 75682000633
Ref: 75692000703
Ref: 75702000736
Ref: 75712000788
Ref: 75722000840
Ref: 75732000906
Ref: 75742000939
Ref: 75752000991
Ref: 75762001128
Ref: 75772001178
Ref: 75782001255
Ref: 75792001369
Ref: 75802001492
Ref: 75812001615
Ref: 75822001691
Ref: 75832001820
Ref: 75842002031
Ref: 75852002160
Ref: 75862002235
Ref: 75872002370
Ref: 75882002590
Ref: 75892002715
Ref: 75902002786
Ref: 75912002917
Ref: 75922003135
Ref: 75932003202
Ref: 75942003273
Ref: 75952003340
Ref: 75962005103
Node: B.52016699
Ref: 75972016822
Ref: 75982016822
Ref: 75992017641
Ref: 76002017688
Ref: 76012017755
Ref: 76022017821
Ref: 76032017890
Ref: 76042017933
Ref: 76052018041
Ref: 76062018116
Ref: 76072018174
Ref: 76082018238
Ref: 76092018316
Ref: 76102018393
Ref: 76112018500
Ref: 76122018572
Ref: 76132018644
Ref: 76142018717
Ref: 76152018795
Ref: 76162018976
Node: Annex C2022815
Ref: 76172022954
Ref: 76182022954
Ref: 76192022954
Ref: 76202022954
Ref: 76212022954
Ref: 76222022954
Node: C.12023437
Ref: 76232023723
Ref: 76242024210
Ref: 76252024210
Ref: 76262024210
Ref: 76272024210
Node: C.22026563
Ref: 76282026877
Node: C.32027005
Ref: 76292027252
Ref: 76302027305
Ref: 76312027406
Ref: 76322027513
Ref: 76332027642
Ref: 76342027742
Ref: 76352027830
Ref: 76362027972
Ref: 76372027974
Ref: 76382028252
Ref: 76392028254
Ref: 76402028878
Node: C.3.12034428
Ref: 76412035111
Ref: 76422035111
Ref: 76432035303
Ref: 76442035303
Ref: 76452035654
Ref: 76462036139
Ref: 76472036139
Ref: 76482036474
Ref: 76492036476
Ref: 76502036541
Ref: 76512036655
Ref: 76522036655
Ref: 76532036655
Ref: 76542037010
Ref: 76552037063
Ref: 76562037863
Ref: 76572038130
Ref: 76582039914
Node: C.3.22041193
Ref: 76592041429
Ref: 76602041508
Ref: 76612041563
Ref: 76622041687
Ref: 76632041773
Ref: 76642041859
Ref: 76652041964
Ref: 76662042096
Ref: 76672042283
Ref: 76682042361
Ref: 76692042457
Ref: 76702042673
Ref: 76712043703
Ref: 76722044479
Ref: 76732044772
Ref: 76742045093
Node: C.42047038
Ref: 76752047526
Ref: 76762047906
Node: C.52049572
Ref: 76772050007
Ref: 76782050007
Ref: 76792050392
Ref: 76802050392
Ref: 76812050508
Ref: 76822050509
Ref: 76832050532
Ref: 76842050716
Ref: 76852050718
Ref: 76862051444
Ref: 76872051444
Node: C.62052736
Ref: 76882053308
Ref: 76892053308
Ref: 76902053385
Ref: 76912053385
Ref: 76922053456
Ref: 76932053456
Ref: 76942053738
Ref: 76952053738
Ref: 76962053831
Ref: 76972053831
Ref: 76982054105
Ref: 76992054105
Ref: 77002054297
Ref: 77012054634
Ref: 77022055416
Ref: 77032055416
Ref: 77042055693
Ref: 77052058345
Ref: 77062058452
Ref: 77072058863
Node: C.72059881
Node: C.7.12060420
Ref: 77082060704
Ref: 77092060768
Ref: 77102060846
Ref: 77112060969
Ref: 77122061039
Ref: 77132061090
Ref: 77142061141
Ref: 77152061205
Ref: 77162061276
Ref: 77172061347
Ref: 77182062944
Ref: 77192062959
Ref: 77202063153
Ref: 77212063168
Ref: 77222063485
Ref: 77232063612
Ref: 77242063612
Ref: 77252063737
Ref: 77262063868
Ref: 77272064014
Node: C.7.22064843
Ref: 77282065285
Ref: 77292065302
Ref: 77302065364
Ref: 77312065447
Ref: 77322065542
Ref: 77332065651
Ref: 77342066831
Ref: 77352066946
Ref: 77362067348
Ref: 77372067833
Ref: 77382068033
Ref: 77392068233
Node: C.7.32073181
Ref: 77402073519
Ref: 77412073585
Ref: 77422073668
Ref: 77432073900
Ref: 77442073994
Ref: 77452074075
Ref: 77462074216
Ref: 77472074398
Ref: 77482074398
Ref: 77492075497
Ref: 77502075497
Ref: 77512075497
Ref: 77522075497
Ref: 77532075497
Ref: 77542075497
Node: Annex D2077746
Ref: 77552077881
Ref: 77562077881
Node: D.12081165
Ref: 77572081912
Ref: 77582081912
Ref: 77592082048
Ref: 77602082048
Ref: 77612083579
Ref: 77622083579
Ref: 77632083579
Ref: 77642083579
Ref: 77652083579
Ref: 77662084566
Ref: 77672084972
Ref: 77682084974
Node: D.22087636
Node: D.2.12088155
Ref: 77692088537
Ref: 77702088603
Ref: 77712088619
Ref: 77722089210
Ref: 77732089210
Ref: 77742089210
Ref: 77752089210
Ref: 77762089604
Ref: 77772089604
Ref: 77782089604
Ref: 77792089604
Ref: 77802089604
Ref: 77812089604
Ref: 77822090399
Ref: 77832091871
Node: D.2.22093567
Ref: 77842094027
Ref: 77852094028
Ref: 77862094061
Ref: 77872094172
Ref: 77882094173
Ref: 77892094224
Ref: 77902094253
Ref: 77912094286
Ref: 77922095855
Ref: 77932095855
Ref: 77942095981
Ref: 77952095983
Ref: 77962096350
Ref: 77972096765
Node: D.2.32098157
Ref: 77982098482
Ref: 77992098482
Ref: 78002099571
Ref: 78012099571
Ref: 78022099985
Ref: 78032100313
Node: D.2.42101405
Ref: 78042101757
Ref: 78052101757
Ref: 78062101873
Ref: 78072101935
Ref: 78082101969
Ref: 78092103577
Ref: 78102103577
Node: D.2.52104770
Ref: 78112105153
Ref: 78122105153
Ref: 78132105305
Ref: 78142105308
Ref: 78152105428
Ref: 78162105557
Ref: 78172105689
Ref: 78182105794
Node: D.2.62108753
Ref: 78192109537
Ref: 78202109537
Ref: 78212109698
Ref: 78222109714
Ref: 78232109748
Ref: 78242109854
Ref: 78252110021
Ref: 78262110195
Ref: 78272110666
Ref: 78282110666
Ref: 78292115087
Ref: 78302115463
Node: D.32116514
Ref: 78312116962
Ref: 78322116963
Ref: 78332116987
Ref: 78342117061
Ref: 78352117132
Ref: 78362117197
Ref: 78372117197
Ref: 78382117300
Ref: 78392118108
Ref: 78402118605
Ref: 78412118607
Ref: 78422118702
Ref: 78432118702
Ref: 78442118713
Ref: 78452120090
Ref: 78462120090
Ref: 78472120090
Ref: 78482120564
Ref: 78492120716
Ref: 78502121012
Node: D.42123721
Ref: 78512123852
Ref: 78522124133
Ref: 78532124134
Ref: 78542124158
Ref: 78552124232
Ref: 78562124318
Ref: 78572124383
Ref: 78582124383
Ref: 78592124484
Ref: 78602124930
Ref: 78612124930
Ref: 78622125061
Ref: 78632125061
Ref: 78642125070
Node: D.52127757
Node: D.5.12128084
Ref: 78652128539
Ref: 78662128612
Ref: 78672128826
Ref: 78682129318
Ref: 78692129373
Ref: 78702129744
Node: D.5.22132556
Ref: 78712132969
Ref: 78722132984
Ref: 78732134050
Node: D.62134991
Node: D.72138070
Ref: 78742138490
Ref: 78752138490
Ref: 78762138608
Ref: 78772138608
Ref: 78782139041
Ref: 78792139041
Ref: 78802139196
Ref: 78812139196
Ref: 78822139315
Ref: 78832139315
Ref: 78842139767
Ref: 78852139771
Ref: 78862139771
Ref: 78872140248
Ref: 78882140250
Ref: 78892140257
Ref: 78902140257
Ref: 78912140544
Ref: 78922140544
Ref: 78932141116
Ref: 78942141116
Ref: 78952141220
Ref: 78962141220
Ref: 78972141316
Ref: 78982141316
Ref: 78992141799
Ref: 79002141808
Ref: 79012141808
Ref: 79022142035
Ref: 79032142035
Ref: 79042142113
Ref: 79052142113
Ref: 79062142189
Ref: 79072142189
Ref: 79082142390
Ref: 79092142390
Ref: 79102142910
Ref: 79112142910
Ref: 79122143207
Ref: 79132143207
Ref: 79142143333
Ref: 79152143333
Ref: 79162144008
Ref: 79172144010
Ref: 79182144132
Ref: 79192144132
Ref: 79202144545
Ref: 79212144545
Ref: 79222144850
Ref: 79232144851
Ref: 79242144851
Ref: 79252144924
Ref: 79262144924
Ref: 79272145432
Ref: 79282145433
Ref: 79292145433
Ref: 79302145505
Ref: 79312145505
Ref: 79322145980
Ref: 79332145981
Ref: 79342145981
Ref: 79352146055
Ref: 79362146055
Ref: 79372146333
Ref: 79382146342
Ref: 79392146342
Ref: 79402147052
Node: D.82147608
Ref: 79412147928
Ref: 79422147944
Ref: 79432147963
Ref: 79442147998
Ref: 79452148032
Ref: 79462148114
Ref: 79472148138
Ref: 79482148183
Ref: 79492148227
Ref: 79502148271
Ref: 79512148318
Ref: 79522148366
Ref: 79532149732
Ref: 79542149794
Ref: 79552149862
Ref: 79562149924
Ref: 79572149986
Ref: 79582150048
Ref: 79592150110
Ref: 79602150172
Ref: 79612150242
Ref: 79622150322
Ref: 79632150471
Ref: 79642150882
Ref: 79652150882
Ref: 79662152377
Ref: 79672154902
Ref: 79682156416
Node: D.92158130
Ref: 79692159128
Ref: 79702159128
Ref: 79712160705
Ref: 79722160705
Node: D.102162129
Ref: 79732162618
Ref: 79742162688
Ref: 79752162743
Ref: 79762162800
Ref: 79772162857
Ref: 79782162927
Ref: 79792163241
Ref: 79802163260
Ref: 79812164030
Ref: 79822164030
Ref: 79832164030
Node: D.10.12165133
Ref: 79842165555
Ref: 79852165628
Ref: 79862165709
Ref: 79872165808
Node: D.112167447
Ref: 79882167957
Ref: 79892168030
Ref: 79902168093
Ref: 79912168159
Ref: 79922168320
Ref: 79932168320
Ref: 79942168320
Ref: 79952169293
Ref: 79962169338
Ref: 79972169449
Node: D.122171662
Node: D.132174487
Ref: 79982174666
Node: D.142177720
Ref: 79992178143
Ref: 80002178162
Ref: 80012178186
Ref: 80022178230
Ref: 80032178274
Ref: 80042178349
Ref: 80052178407
Ref: 80062179133
Ref: 80072179234
Ref: 80082179350
Ref: 80092179440
Ref: 80102179563
Ref: 80112179702
Ref: 80122179702
Ref: 80132181190
Ref: 80142182597
Node: D.14.12184686
Ref: 80152185132
Ref: 80162185151
Ref: 80172185304
Ref: 80182185388
Ref: 80192185504
Ref: 80202185674
Ref: 80212185842
Ref: 80222185911
Ref: 80232186038
Ref: 80242186092
Ref: 80252186651
Ref: 80262186653
Ref: 80272186827
Ref: 80282187984
Ref: 80292189486
Node: D.14.22190413
Ref: 80302190884
Ref: 80312190902
Ref: 80322191072
Ref: 80332191180
Ref: 80342191302
Ref: 80352191418
Ref: 80362191540
Ref: 80372191666
Ref: 80382191792
Ref: 80392191890
Ref: 80402191959
Ref: 80412192033
Ref: 80422192106
Ref: 80432192177
Ref: 80442192255
Ref: 80452192381
Ref: 80462192473
Ref: 80472192589
Ref: 80482192870
Ref: 80492193333
Ref: 80502193333
Ref: 80512193333
Ref: 80522193597
Ref: 80532193599
Ref: 80542197458
Node: D.14.32198341
Ref: 80552198784
Ref: 80562198802
Ref: 80572198897
Node: D.152200084
Ref: 80582200536
Ref: 80592200554
Ref: 80602200606
Ref: 80612200722
Ref: 80622200898
Ref: 80632201078
Ref: 80642201175
Ref: 80652201304
Ref: 80662201583
Ref: 80672201802
Ref: 80682201804
Ref: 80692201991
Node: D.162205164
Ref: 80702205534
Ref: 80712205599
Ref: 80722205652
Ref: 80732205719
Ref: 80742205785
Ref: 80752206312
Ref: 80762206312
Node: D.16.12207808
Ref: 80772208316
Ref: 80782208325
Ref: 80792208386
Ref: 80802208438
Ref: 80812208522
Ref: 80822208610
Ref: 80832208688
Ref: 80842208770
Ref: 80852208837
Ref: 80862208911
Ref: 80872208992
Ref: 80882209195
Ref: 80892209464
Ref: 80902209644
Ref: 80912209823
Ref: 80922210069
Ref: 80932210934
Ref: 80942210934
Node: Annex E2216428
Ref: 80952216787
Ref: 80962216787
Ref: 80972216787
Ref: 80982217094
Ref: 80992217237
Node: E.12218536
Ref: 81002218765
Ref: 81012218765
Ref: 81022219546
Ref: 81032219691
Ref: 81042219984
Ref: 81052219984
Ref: 81062219984
Ref: 81072219984
Ref: 81082220578
Ref: 81092220593
Ref: 81102220972
Ref: 81112221103
Node: E.22222814
Ref: 81122223227
Ref: 81132223227
Ref: 81142223227
Ref: 81152223227
Ref: 81162223227
Ref: 81172223227
Ref: 81182223922
Ref: 81192224058
Ref: 81202224190
Ref: 81212224300
Node: E.2.12225857
Ref: 81222226365
Ref: 81232226370
Ref: 81242226437
Ref: 81252226438
Ref: 81262226469
Ref: 81272226527
Ref: 81282226663
Ref: 81292226663
Ref: 81302227464
Ref: 81312227464
Ref: 81322227783
Ref: 81332227985
Ref: 81342227985
Ref: 81352227985
Node: E.2.22228285
Ref: 81362228594
Ref: 81372228599
Ref: 81382228664
Ref: 81392228665
Ref: 81402228694
Ref: 81412228752
Ref: 81422228882
Ref: 81432228882
Ref: 81442229575
Ref: 81452229713
Ref: 81462229715
Node: E.2.32233562
Ref: 81472233906
Ref: 81482233911
Ref: 81492233985
Ref: 81502233986
Ref: 81512234024
Ref: 81522234109
Ref: 81532234110
Ref: 81542234143
Ref: 81552234154
Ref: 81562234159
Ref: 81572234261
Ref: 81582234261
Ref: 81592234261
Ref: 81602234261
Ref: 81612234261
Ref: 81622234411
Ref: 81632234411
Ref: 81642235795
Ref: 81652235796
Ref: 81662236266
Ref: 81672236266
Ref: 81682236266
Node: E.32237636
Ref: 81692238062
Ref: 81702238077
Ref: 81712238273
Ref: 81722238288
Ref: 81732238502
Ref: 81742238845
Ref: 81752239233
Ref: 81762239233
Ref: 81772239647
Node: E.42239813
Ref: 81782239944
Ref: 81792239944
Ref: 81802239944
Ref: 81812239944
Ref: 81822239944
Ref: 81832241458
Ref: 81842241458
Ref: 81852241458
Ref: 81862242148
Ref: 81872242148
Ref: 81882242453
Ref: 81892242893
Ref: 81902243895
Ref: 81912243895
Ref: 81922243995
Ref: 81932243995
Ref: 81942244286
Ref: 81952244444
Ref: 81962244444
Ref: 81972244797
Node: E.4.12246293
Ref: 81982247031
Ref: 81992247031
Ref: 82002247890
Ref: 82012247890
Node: E.4.22248508
Node: E.52252518
Ref: 82022252659
Ref: 82032252659
Ref: 82042253059
Ref: 82052253076
Ref: 82062253135
Ref: 82072253189
Ref: 82082253352
Ref: 82092253540
Ref: 82102253701
Ref: 82112253906
Ref: 82122254067
Ref: 82132254226
Ref: 82142255524
Ref: 82152255901
Ref: 82162256570
Ref: 82172256570
Node: Annex F2259263
Ref: 82182259402
Node: F.12261263
Ref: 82192261464
Ref: 82202261464
Ref: 82212261746
Ref: 82222261746
Node: F.22262095
Ref: 82232262353
Ref: 82242262390
Ref: 82252262448
Ref: 82262262509
Ref: 82272262561
Ref: 82282262616
Ref: 82292262935
Node: F.32264630
Ref: 82302264922
Node: F.3.12269840
Ref: 82312269967
Ref: 82322269967
Node: F.3.22277025
Ref: 82332278266
Node: F.3.32289263
Ref: 82342290018
Ref: 82352290035
Ref: 82362290075
Ref: 82372290210
Ref: 82382290366
Ref: 82392290433
Ref: 82402290490
Ref: 82412290561
Ref: 82422290606
Ref: 82432290663
Ref: 82442290720
Ref: 82452290777
Ref: 82462291307
Ref: 82472291345
Ref: 82482291500
Ref: 82492291699
Ref: 82502292128
Ref: 82512292575
Ref: 82522292969
Node: F.3.42300088
Ref: 82532300289
Ref: 82542300289
Node: F.3.52300926
Ref: 82552301125
Ref: 82562301125
Node: Annex G2301812
Ref: 82572301929
Node: G.12303506
Node: G.1.12304445
Ref: 82582304701
Ref: 82592304845
Ref: 82602304949
Ref: 82612305033
Ref: 82622305065
Ref: 82632305114
Ref: 82642305168
Ref: 82652305222
Ref: 82662305280
Ref: 82672305377
Ref: 82682305474
Ref: 82692305575
Ref: 82702305652
Ref: 82712305729
Ref: 82722305809
Ref: 82732305951
Ref: 82742306015
Ref: 82752306127
Ref: 82762306229
Ref: 82772306457
Ref: 82782306976
Ref: 82792309718
Ref: 82802313414
Ref: 82812313414
Ref: 82822313414
Ref: 82832313756
Ref: 82842314111
Node: G.1.22320184
Ref: 82852320545
Ref: 82862320815
Ref: 82872320869
Ref: 82882320923
Ref: 82892320977
Ref: 82902321262
Ref: 82912321313
Ref: 82922321364
Ref: 82932321415
Ref: 82942321469
Ref: 82952321523
Ref: 82962321577
Ref: 82972321631
Ref: 82982321688
Ref: 82992321740
Ref: 83002321792
Ref: 83012321844
Ref: 83022321899
Ref: 83032321954
Ref: 83042322009
Ref: 83052322064
Ref: 83062322170
Ref: 83072326681
Ref: 83082326681
Ref: 83092326681
Ref: 83102327635
Ref: 83112328020
Ref: 83122330594
Ref: 83132331396
Node: G.1.32332275
Ref: 83142332953
Ref: 83152333126
Ref: 83162333161
Ref: 83172333210
Ref: 83182333263
Ref: 83192333401
Ref: 83202333496
Ref: 83212333749
Ref: 83222333961
Ref: 83232334091
Ref: 83242334314
Node: G.1.42340986
Ref: 83252341193
Ref: 83262341193
Node: G.1.52341604
Ref: 83272341809
Ref: 83282341809
Node: G.22342240
Ref: 83292342441
Ref: 83302342441
Ref: 83312342923
Node: G.2.12343518
Ref: 83322344540
Ref: 83332344834
Ref: 83342344937
Ref: 83352345326
Ref: 83362345719
Ref: 83372346682
Ref: 83382346682
Ref: 83392346961
Node: G.2.22347925
Ref: 83402348466
Ref: 83412348466
Ref: 83422349197
Ref: 83432349197
Ref: 83442349545
Ref: 83452349545
Ref: 83462350365
Ref: 83472350365
Ref: 83482351183
Ref: 83492351185
Ref: 83502351185
Ref: 83512351533
Ref: 83522351535
Node: G.2.32352994
Ref: 83532354358
Ref: 83542354528
Ref: 83552360172
Ref: 83562360174
Ref: 83572360325
Node: G.2.42360544
Ref: 83582360895
Ref: 83592360895
Ref: 83602361375
Ref: 83612361377
Ref: 83622361531
Ref: 83632362556
Node: G.2.52366266
Node: G.2.62368033
Ref: 83642368707
Ref: 83652369182
Ref: 83662369456
Ref: 83672369854
Ref: 83682369856
Ref: 83692370105
Node: G.32375626
Node: G.3.12376384
Ref: 83702376745
Ref: 83712376830
Ref: 83722376897
Ref: 83732378048
Ref: 83742378534
Ref: 83752379489
Ref: 83762379567
Ref: 83772379631
Ref: 83782379694
Ref: 83792379835
Ref: 83802379909
Ref: 83812380137
Ref: 83822380366
Ref: 83832381829
Ref: 83842384098
Ref: 83852391483
Node: G.3.22394127
Ref: 83862394790
Ref: 83872394878
Ref: 83882394946
Ref: 83892395216
Ref: 83902395277
Ref: 83912395344
Ref: 83922395450
Ref: 83932395560
Ref: 83942395657
Ref: 83952395760
Ref: 83962395972
Ref: 83972396043
Ref: 83982396171
Ref: 83992396275
Ref: 84002396661
Ref: 84012398581
Ref: 84022398896
Ref: 84032398957
Ref: 84042399025
Ref: 84052399131
Ref: 84062399242
Ref: 84072399339
Ref: 84082399442
Ref: 84092399660
Ref: 84102399731
Ref: 84112399859
Ref: 84122399963
Ref: 84132400347
Ref: 84142400422
Ref: 84152403319
Ref: 84162403417
Ref: 84172403487
Ref: 84182403556
Ref: 84192403693
Ref: 84202403769
Ref: 84212404003
Ref: 84222404238
Ref: 84232405998
Ref: 84242413405
Ref: 84252428400
Node: Annex H2431637
Ref: 84262431784
Ref: 84272431784
Ref: 84282432445
Ref: 84292432575
Ref: 84302432576
Node: H.12433059
Ref: 84312433426
Ref: 84322433427
Ref: 84332433498
Ref: 84342433498
Node: H.22434871
Ref: 84352435089
Node: H.32435888
Node: H.3.12436190
Ref: 84362436685
Ref: 84372436686
Ref: 84382436750
Ref: 84392436750
Node: H.3.22439545
Ref: 84402440071
Ref: 84412440072
Ref: 84422440099
Ref: 84432440116
Ref: 84442440388
Ref: 84452440525
Node: H.42442254
Ref: 84462442789
Ref: 84472442789
Ref: 84482442951
Ref: 84492442951
Ref: 84502443027
Ref: 84512443027
Ref: 84522443172
Ref: 84532443172
Ref: 84542443269
Ref: 84552443269
Ref: 84562443355
Ref: 84572443355
Ref: 84582443877
Ref: 84592443879
Ref: 84602443919
Ref: 84612443919
Ref: 84622444209
Ref: 84632444209
Ref: 84642444395
Ref: 84652444395
Ref: 84662444722
Ref: 84672444724
Ref: 84682444729
Ref: 84692444729
Ref: 84702444767
Ref: 84712444768
Ref: 84722444815
Ref: 84732444815
Ref: 84742444931
Ref: 84752444931
Ref: 84762445131
Ref: 84772445131
Ref: 84782445252
Ref: 84792445252
Ref: 84802445377
Ref: 84812445377
Ref: 84822446941
Ref: 84832447126
Node: H.52447781
Ref: 84842448151
Ref: 84852448152
Ref: 84862448223
Ref: 84872448223
Node: H.62448893
Ref: 84882449246
Ref: 84892449247
Ref: 84902449286
Ref: 84912449472
Ref: 84922449472
Ref: 84932449874
Node: Annex J2452084
Ref: 84942452227
Node: J.12453185
Node: J.22454285
Node: J.32455450
Ref: 84952455967
Ref: S03222455967
Ref: 84962455987
Ref: 84972456006
Ref: 84982456084
Ref: 84992456394
Ref: 85002457598
Ref: 85012457824
Ref: 85022458065
Node: J.42458165
Ref: 85032458416
Ref: 85042458416
Node: J.52458946
Node: J.62461622
Node: J.72461913
Ref: 85052462073
Ref: S03232462073
Ref: 85062462082
Ref: 85072462101
Node: J.7.12462340
Ref: 85082462869
Ref: 85092462871
Ref: 85102462871
Ref: 85112463275
Ref: 85122463435
Ref: 85132463710
Ref: 85142463860
Ref: 85152464529
Node: J.82467066
Ref: 85162467229
Ref: S03242467229
Ref: 85172467250
Node: J.92467571
Ref: 85182467820
Ref: 85192467820
Ref: 85202468033
Node: J.102468337
Ref: 85212468680
Ref: 85222468681
Ref: 85232468690
Ref: 85242468709
Node: J.112469974
Ref: 85252470352
Ref: 85262470352
Node: J.122470663
Node: J.132471009
Ref: 85272471453
Ref: 85282471600
Ref: 85292471751
Node: J.142471903
Node: J.152473167
Node: J.15.12473871
Ref: 85302474128
Ref: 85312474128
Ref: 85322474148
Ref: 85332474149
Ref: 85342474157
Ref: 85352474163
Node: J.15.22474877
Ref: 85362475158
Ref: 85372475158
Ref: 85382475178
Ref: 85392475179
Ref: 85402475202
Ref: 85412475227
Node: J.15.32475692
Ref: 85422475958
Ref: 85432475958
Ref: 85442475978
Ref: 85452475979
Ref: 85462476001
Node: J.15.42476331
Ref: 85472476581
Ref: 85482476582
Ref: 85492476596
Ref: 85502476832
Node: J.15.52477068
Ref: 85512477246
Ref: 85522477251
Ref: 85532477251
Ref: 85542477251
Ref: 85552477251
Ref: 85562477251
Ref: 85572477251
Ref: 85582477251
Ref: 85592477251
Ref: 85602477251
Ref: 85612477251
Ref: 85622477251
Ref: 85632477251
Ref: 85642477417
Ref: 85652477418
Ref: 85662477465
Ref: 85672477488
Ref: 85682477557
Ref: 85692477613
Ref: 85702477645
Ref: 85712477646
Ref: 85722477693
Ref: 85732477716
Ref: 85742477785
Ref: 85752477841
Ref: 85762477873
Ref: 85772477874
Ref: 85782477914
Ref: 85792477941
Ref: 85802478195
Ref: 85812478195
Ref: 85822478544
Node: J.15.62480136
Ref: 85832480435
Ref: 85842480435
Ref: 85852480455
Ref: 85862480456
Ref: 85872480489
Node: J.15.72480903
Ref: 85882481208
Ref: 85892481209
Ref: 85902481238
Ref: 85912481324
Ref: 85922481325
Ref: 85932481351
Ref: 85942481356
Ref: 85952481693
Ref: 85962482068
Node: J.15.82482728
Ref: 85972483085
Ref: 85982483086
Ref: 85992483094
Ref: 86002483125
Ref: 86012483126
Ref: 86022483136
Ref: 86032483167
Ref: 86042483168
Ref: 86052483193
Ref: 86062483224
Ref: 86072483225
Ref: 86082483252
Ref: 86092483283
Ref: 86102483284
Ref: 86112483313
Ref: 86122483344
Ref: 86132483345
Ref: 86142483369
Ref: 86152484314
Ref: 86162484316
Ref: 86172484316
Ref: 86182484316
Ref: 86192484316
Ref: 86202484316
Ref: 86212484316
Ref: 86222484316
Ref: 86232484316
Ref: 86242484316
Ref: 86252484316
Ref: 86262484316
Node: J.15.92484488
Ref: 86272484712
Ref: 86282484713
Ref: 86292484718
Ref: 86302484874
Node: J.15.102485581
Ref: 86312485853
Ref: 86322485854
Ref: 86332486043
Node: J.15.112486495
Ref: 86342486786
Ref: 86352486787
Ref: 86362486893
Ref: 86372486894
Ref: 86382487074
Ref: 86392487074
Node: J.15.122488514
Ref: 86402488784
Ref: 86412488785
Ref: 86422488969
Node: J.15.132489604
Ref: 86432489883
Ref: 86442489883
Ref: 86452489903
Ref: 86462489904
Ref: 86472489918
Node: Annex K2490339
Node: K.12490769
Ref: 86482490892
Node: K.22501441
Ref: 86492501570
Ref: 86502503195
Ref: 86512503433
Ref: 86522503435
Ref: 86532507853
Ref: 86542507868
Ref: 86552509262
Ref: 86562509660
Ref: 86572509662
Ref: 86582510497
Ref: 86592510712
Ref: 86602510714
Ref: 86612513709
Ref: 86622513724
Ref: 86632514030
Ref: 86642514030
Ref: 86652524327
Ref: 86662524342
Ref: 86672524342
Ref: 86682525545
Ref: 86692525806
Ref: 86702525808
Ref: 86712529975
Ref: 86722539703
Ref: 86732539870
Ref: 86742539871
Ref: 86752540379
Ref: 86762540380
Ref: 86772543113
Ref: 86782543460
Ref: 86792543462
Ref: 86802546792
Ref: 86812547401
Ref: 86822547722
Ref: 86832547724
Ref: 86842551781
Ref: 86852551948
Ref: 86862551949
Ref: 86872552443
Ref: 86882552444
Ref: 86892555289
Ref: 86902555304
Ref: 86912555816
Ref: 86922556976
Ref: 86932558186
Node: Annex L2561296
Ref: 86942561445
Ref: 86952561541
Ref: 86962561542
Ref: 86972561575
Ref: 86982561618
Ref: 86992561619
Ref: 87002561647
Ref: 87012561682
Ref: 87022561733
Ref: 87032561734
Ref: 87042561760
Ref: 87052561809
Ref: 87062561810
Ref: 87072561849
Ref: 87082561873
Ref: 87092561904
Ref: 87102561928
Ref: 87112562014
Ref: 87122562015
Ref: 87132562029
Ref: 87142562115
Ref: 87152562116
Ref: 87162562124
Ref: 87172562209
Ref: 87182562210
Ref: 87192562237
Ref: 87202562322
Ref: 87212562323
Ref: 87222562349
Ref: 87232562354
Ref: 87242562476
Ref: 87252562477
Ref: 87262562517
Ref: 87272562539
Ref: 87282562589
Ref: 87292562590
Ref: 87302562595
Ref: 87312562644
Ref: 87322562645
Ref: 87332562667
Ref: 87342562729
Ref: 87352562730
Ref: 87362562776
Ref: 87372562777
Ref: 87382562800
Ref: 87392562848
Ref: 87402562849
Ref: 87412562916
Ref: 87422562917
Ref: 87432562942
Ref: 87442562964
Ref: 87452563005
Ref: 87462563006
Ref: 87472563035
Ref: 87482563057
Ref: 87492563098
Ref: 87502563099
Ref: 87512563130
Ref: 87522563212
Ref: 87532563213
Ref: 87542563255
Ref: 87552563278
Ref: 87562563337
Ref: 87572563388
Ref: 87582563476
Ref: 87592563477
Ref: 87602563519
Ref: 87612563542
Ref: 87622563601
Ref: 87632563652
Ref: 87642563703
Ref: 87652563704
Ref: 87662563729
Ref: 87672563779
Ref: 87682563780
Ref: 87692563804
Ref: 87702563891
Ref: 87712563892
Ref: 87722563900
Ref: 87732563906
Ref: 87742563948
Ref: 87752563949
Ref: 87762563976
Ref: 87772563993
Ref: 87782564075
Ref: 87792564076
Ref: 87802564105
Ref: 87812564186
Ref: 87822564187
Ref: 87832564256
Ref: 87842564257
Ref: 87852564281
Ref: 87862564324
Ref: 87872564325
Ref: 87882564330
Ref: 87892564373
Ref: 87902564374
Ref: 87912564398
Ref: 87922564484
Ref: 87932564485
Ref: 87942564508
Ref: 87952564533
Ref: 87962564580
Ref: 87972564581
Ref: 87982564630
Ref: 87992564631
Ref: 88002564640
Ref: 88012564724
Ref: 88022564725
Ref: 88032564747
Ref: 88042564793
Ref: 88052564794
Ref: 88062564834
Ref: 88072564835
Ref: 88082564874
Ref: 88092564921
Ref: 88102564922
Ref: 88112564951
Ref: 88122564998
Ref: 88132564999
Ref: 88142565028
Ref: 88152565110
Ref: 88162565111
Ref: 88172565172
Ref: 88182565173
Ref: 88192565219
Ref: 88202565248
Ref: 88212565276
Ref: 88222565326
Ref: 88232565327
Ref: 88242565346
Ref: 88252565370
Ref: 88262565473
Ref: 88272565474
Ref: 88282565495
Ref: 88292565536
Ref: 88302565537
Ref: 88312565561
Ref: 88322565647
Ref: 88332565648
Ref: 88342565734
Ref: 88352565735
Ref: 88362565773
Ref: 88372565813
Ref: 88382565814
Ref: 88392565843
Ref: 88402565883
Ref: 88412565884
Ref: 88422565897
Ref: 88432565910
Ref: 88442565958
Ref: 88452565959
Ref: 88462566003
Ref: 88472566004
Ref: 88482566035
Ref: 88492566116
Ref: 88502566117
Ref: 88512566131
Ref: 88522566177
Ref: 88532566178
Ref: 88542566187
Ref: 88552566231
Ref: 88562566232
Ref: 88572566265
Ref: 88582566353
Ref: 88592566354
Ref: 88602566387
Ref: 88612566437
Ref: 88622566438
Ref: 88632566449
Ref: 88642566534
Ref: 88652566535
Ref: 88662566545
Ref: 88672566632
Ref: 88682566633
Ref: 88692566662
Node: Annex M2566699
Ref: 88702566876
Node: M.12567621
Ref: 88712567766
Ref: 88722567766
Node: M.22575035
Ref: 88732575198
Ref: 88742575277
Ref: 88752589844
Node: M.32596433
Ref: 88762596550
Ref: 88772596550
Node: Annex N2627063
Ref: 88782627182
Ref: 88792627404
Ref: 88802627558
Ref: 88812627722
Ref: 88822628039
Ref: 88832628282
Ref: 88842628417
Ref: 88852628617
Ref: 88862628901
Ref: 88872629111
Ref: 88882629206
Ref: 88892629223
Ref: 88902629488
Ref: 88912629748
Ref: 88922629806
Ref: 88932629949
Ref: 88942630179
Ref: 88952630324
Ref: 88962630428
Ref: 88972630430
Ref: 88982630698
Ref: 88992631233
Ref: 89002631400
Ref: 89012631571
Ref: 89022631838
Ref: 89032631990
Ref: 89042632057
Ref: 89052632205
Ref: 89062632354
Ref: 89072632509
Ref: 89082632654
Ref: 89092632763
Ref: 89102632859
Ref: 89112632861
Ref: 89122632983
Ref: 89132633099
Ref: 89142633742
Ref: 89152633995
Ref: 89162634162
Ref: 89172634625
Ref: 89182634967
Ref: 89192635131
Ref: 89202635300
Ref: 89212635515
Ref: 89222635777
Ref: 89232635882
Ref: 89242636056
Ref: 89252636304
Ref: 89262636480
Ref: 89272636869
Ref: 89282637047
Ref: 89292637381
Ref: 89302637503
Ref: 89312637728
Ref: 89322637845
Ref: 89332637953
Ref: 89342638570
Ref: 89352638709
Ref: 89362638988
Ref: 89372639113
Ref: 89382639357
Ref: 89392639546
Ref: 89402639881
Ref: 89412640071
Ref: 89422640209
Ref: 89432640320
Ref: 89442640450
Ref: 89452640586
Ref: 89462640726
Ref: 89472640804
Ref: 89482641109
Ref: 89492641288
Ref: 89502641603
Ref: 89512641848
Ref: 89522642096
Ref: 89532642545
Ref: 89542642774
Ref: 89552643060
Ref: 89562643098
Node: Annex P2643221
Ref: 89572643348
Ref: 89582643348
Ref: 89592643348
Ref: 89602643348
Ref: 89612643348
Ref: 89622643514
Ref: 89632643532
Ref: 89642643551
Ref: 89652643626
Ref: 89662643653
Ref: 89672643680
Ref: 89682643707
Ref: 89692643733
Ref: 89702643756
Ref: 89712643827
Ref: 89722643854
Ref: 89732643887
Ref: 89742643912
Ref: 89752643978
Ref: 89762643996
Ref: 89772644056
Ref: 89782644066
Ref: 89792644076
Ref: 89802644124
Ref: 89812644132
Ref: 89822644143
Ref: 89832644195
Ref: 89842644209
Ref: 89852644344
Ref: 89862644351
Ref: 89872644367
Ref: 89882644385
Ref: 89892644430
Ref: 89902644491
Ref: 89912644508
Ref: 89922644519
Ref: 89932644580
Ref: 89942644657
Ref: 89952644721
Ref: 89962644807
Ref: 89972644882
Ref: 89982644944
Ref: 89992644957
Ref: 90002644988
Ref: 90012645112
Ref: 90022645127
Ref: 90032645161
Ref: 90042645176
Ref: 90052645215
Ref: 90062645231
Ref: 90072645264
Ref: 90082645280
Ref: 90092645348
Ref: 90102645369
Ref: 90112645399
Ref: 90122645422
Ref: 90132645451
Ref: 90142645478
Ref: 90152645520
Ref: 90162645551
Ref: 90172645593
Ref: 90182645617
Ref: 90192645648
Ref: 90202645674
Ref: 90212645704
Ref: 90222645774
Ref: 90232645833
Ref: 90242645865
Ref: 90252645903
Ref: 90262645938
Ref: 90272646036
Ref: 90282646057
Ref: 90292646085
Ref: 90302646121
Ref: 90312646154
Ref: 90322646186
Ref: 90332646270
Ref: 90342646302
Ref: 90352646336
Ref: 90362646361
Ref: 90372646393
Ref: 90382646420
Ref: 90392646453
Ref: 90402646481
Ref: 90412646574
Ref: 90422646597
Ref: 90432646630
Ref: 90442646704
Ref: 90452646720
Ref: 90462646734
Ref: 90472646799
Ref: 90482646845
Ref: 90492646865
Ref: 90502646945
Ref: 90512646964
Ref: 90522646984
Ref: 90532647063
Ref: 90542647082
Ref: 90552647165
Ref: 90562647213
Ref: 90572647242
Ref: 90582647268
Ref: 90592647300
Ref: 90602647348
Ref: 90612647376
Ref: 90622647402
Ref: 90632647434
Ref: 90642647482
Ref: 90652647514
Ref: 90662647540
Ref: 90672647572
Ref: 90682647605
Ref: 90692647697
Ref: 90702647720
Ref: 90712647801
Ref: 90722647849
Ref: 90732647957
Ref: 90742647982
Ref: 90752648004
Ref: 90762648079
Ref: 90772648120
Ref: 90782648156
Ref: 90792648177
Ref: 90802648263
Ref: 90812648300
Ref: 90822648407
Ref: 90832648429
Ref: 90842648519
Ref: 90852648591
Ref: 90862648624
Ref: 90872648730
Ref: 90882648766
Ref: 90892648851
Ref: 90902648922
Ref: 90912648950
Ref: 90922649053
Ref: 90932649065
Ref: 90942649169
Ref: 90952649199
Ref: 90962649270
Ref: 90972649304
Ref: 90982649427
Ref: 90992649439
Ref: 91002649549
Ref: 91012649576
Ref: 91022649588
Ref: 91032649693
Ref: 91042649712
Ref: 91052649789
Ref: 91062649822
Ref: 91072649925
Ref: 91082649953
Ref: 91092649983
Ref: 91102650063
Ref: 91112650158
Ref: 91122650189
Ref: 91132650228
Ref: 91142650316
Ref: 91152650337
Ref: 91162650417
Ref: 91172650454
Ref: 91182650521
Ref: 91192650539
Ref: 91202650612
Ref: 91212650633
Ref: 91222650685
Ref: 91232650713
Ref: 91242650864
Ref: 91252650894
Ref: 91262650987
Ref: 91272651015
Ref: 91282651031
Ref: 91292651048
Ref: 91302651082
Ref: 91312651109
Ref: 91322651131
Ref: 91332651204
Ref: 91342651279
Ref: 91352651307
Ref: 91362651414
Ref: 91372651446
Ref: 91382651471
Ref: 91392651563
Ref: 91402651662
Ref: 91412651773
Ref: 91422651789
Ref: 91432651816
Ref: 91442651832
Ref: 91452651905
Ref: 91462651929
Ref: 91472652002
Ref: 91482652029
Ref: 91492652054
Ref: 91502652094
Ref: 91512652189
Ref: 91522652216
Ref: 91532652236
Ref: 91542652315
Ref: 91552652350
Ref: 91562652416
Ref: 91572652435
Ref: 91582652498
Ref: 91592652529
Ref: 91602652556
Ref: 91612652628
Ref: 91622652719
Ref: 91632652750
Ref: 91642652801
Ref: 91652652949
Ref: 91662653028
Ref: 91672653058
Ref: 91682653141
Ref: 91692653157
Ref: 91702653195
Ref: 91712653211
Ref: 91722653318
Ref: 91732653343
Ref: 91742653530
Ref: 91752653586
Ref: 91762653726
Ref: 91772653760
Ref: 91782653783
Ref: 91792653828
Ref: 91802653856
Ref: 91812653900
Ref: 91822653999
Ref: 91832654020
Ref: 91842654105
Ref: 91852654179
Ref: 91862654204
Ref: 91872654271
Ref: 91882654291
Ref: 91892654307
Ref: 91902654352
Ref: 91912654366
Ref: 91922654427
Ref: 91932654445
Ref: 91942654460
Ref: 91952654472
Ref: 91962654531
Ref: 91972654547
Ref: 91982654578
Ref: 91992654600
Ref: 92002654616
Ref: 92012654639
Ref: 92022654669
Ref: 92032654689
Ref: 92042654713
Ref: 92052654735
Ref: 92062654766
Ref: 92072654792
Ref: 92082654853
Ref: 92092654866
Ref: 92102654917
Ref: 92112654924
Ref: 92122654994
Ref: 92132655052
Ref: 92142655105
Ref: 92152655112
Ref: 92162655126
Ref: 92172655175
Ref: 92182655182
Ref: 92192655247
Ref: 92202655256
Ref: 92212655314
Ref: 92222655327
Ref: 92232655347
Ref: 92242655413
Ref: 92252655420
Ref: 92262655502
Ref: 92272655523
Ref: 92282655631
Ref: 92292655638
Ref: 92302655738
Ref: 92312655822
Ref: 92322655907
Ref: 92332655914
Ref: 92342655980
Ref: 92352655999
Ref: 92362656021
Ref: 92372656091
Ref: 92382656200
Ref: 92392656232
Ref: 92402656353
Ref: 92412656379
Ref: 92422656400
Ref: 92432656503
Ref: 92442656532
Ref: 92452656625
Ref: 92462656644
Ref: 92472656723
Ref: 92482656736
Ref: 92492656803
Ref: 92502656832
Ref: 92512656922
Ref: 92522656934
Ref: 92532656948
Ref: 92542656971
Ref: 92552656985
Ref: 92562657008
Ref: 92572657030
Ref: 92582657044
Ref: 92592657134
Ref: 92602657165
Ref: 92612657263
Ref: 92622657287
Ref: 92632657307
Ref: 92642657384
Ref: 92652657398
Ref: 92662657413
Ref: 92672657432
Ref: 92682657452
Ref: 92692657465
Ref: 92702657480
Ref: 92712657498
Ref: 92722657518
Ref: 92732657532
Ref: 92742657599
Ref: 92752657620
Ref: 92762657647
Ref: 92772657667
Ref: 92782657694
Ref: 92792657715
Ref: 92802657742
Ref: 92812657768
Ref: 92822657795
Ref: 92832657820
Ref: 92842657892
Ref: 92852657911
Ref: 92862657931
Ref: 92872657998
Ref: 92882658017
Ref: 92892658037
Ref: 92902658075
Ref: 92912658102
Ref: 92922658135
Ref: 92932658203
Ref: 92942658224
Ref: 92952658298
Ref: 92962658318
Ref: 92972658326
Ref: 92982658392
Ref: 92992658415
Ref: 93002658421
Ref: 93012658450
Ref: 93022658489
Ref: 93032658497
Ref: 93042658518
Ref: 93052658561
Ref: 93062658573
Ref: 93072658588
Ref: 93082658602
Ref: 93092658655
Ref: 93102658680
Ref: 93112658697
Ref: 93122658715
Ref: 93132658722
Ref: 93142658735
Ref: 93152658756
Ref: 93162658783
Ref: 93172659288
Ref: 93182659304
Ref: 93192659376
Ref: 93202659403
Ref: 93212659429
Ref: 93222659456
Ref: 93232659494
Ref: 93242659556
Ref: 93252659640
Ref: 93262659663
Ref: 93272659703
Ref: 93282659805
Ref: 93292659854
Ref: 93302659921
Ref: 93312659932
Ref: 93322659970
Ref: 93332659993
Ref: 93342660004
Ref: 93352660030
Ref: 93362660142
Ref: 93372660207
Ref: 93382660220
Ref: 93392660241
Ref: 93402660254
Ref: 93412660318
Ref: 93422660332
Ref: 93432660346
Ref: 93442660359
Ref: 93452660421
Ref: 93462660444
Ref: 93472660476
Ref: 93482660499
Ref: 93492660588
Ref: 93502660645
Ref: 93512660656
Ref: 93522660668
Ref: 93532660723
Ref: 93542660730
Ref: 93552660750
Ref: 93562660757
Ref: 93572660821
Ref: 93582660846
Ref: 93592660871
Ref: 93602660896
Ref: 93612660915
Ref: 93622660950
Ref: 93632660978
Ref: 93642661009
Ref: 93652661031
Ref: 93662661057
Ref: 93672661077
Ref: 93682661103
Ref: 93692661176
Ref: 93702661193
Ref: 93712661218
Ref: 93722661237
Ref: 93732661263
Ref: 93742661299
Ref: 93752661320
Ref: 93762661430
Ref: 93772661502
Ref: 93782661583
Ref: 93792661591
Ref: 93802661657
Ref: 93812661683
Ref: 93822661721
Ref: 93832661747
Ref: 93842661796
Ref: 93852661906
Ref: 93862661932
Ref: 93872661971
Ref: 93882662086
Ref: 93892662121
Ref: 93902662204
Ref: 93912662239
Ref: 93922662276
Ref: 93932662328
Ref: 93942662392
Ref: 93952662416
Ref: 93962662459
Ref: 93972662548
Ref: 93982662581
Ref: 93992662672
Ref: 94002662716
Ref: 94012662730
Ref: 94022662753
Ref: 94032662803
Ref: 94042662870
Ref: 94052662931
Ref: 94062662985
Ref: 94072663042
Ref: 94082663120
Ref: 94092663132
Ref: 94102663200
Ref: 94112663268
Ref: 94122663299
Ref: 94132663338
Ref: 94142663424
Ref: 94152663457
Ref: 94162663542
Ref: 94172663569
Ref: 94182663653
Ref: 94192663673
Ref: 94202663748
Ref: 94212663768
Ref: 94222663781
Ref: 94232663845
Ref: 94242663874
Ref: 94252663961
Ref: 94262663981
Ref: 94272664051
Ref: 94282664119
Ref: 94292664182
Ref: 94302664263
Ref: 94312664284
Ref: 94322664300
Ref: 94332664323
Ref: 94342664343
Ref: 94352664411
Ref: 94362664438
Ref: 94372664526
Ref: 94382664563
Ref: 94392664569
Ref: 94402664585
Ref: 94412664608
Ref: 94422664637
Ref: 94432664664
Ref: 94442664686
Ref: 94452664820
Ref: 94462664851
Ref: 94472664889
Ref: 94482664926
Ref: 94492664971
Ref: 94502665016
Ref: 94512665104
Ref: 94522665131
Ref: 94532665138
Ref: 94542665224
Ref: 94552665249
Ref: 94562665256
Ref: 94572665339
Ref: 94582665364
Ref: 94592665467
Ref: 94602665485
Ref: 94612665565
Ref: 94622665589
Ref: 94632665654
Ref: 94642665740
Ref: 94652665782
Ref: 94662665818
Ref: 94672665901
Ref: 94682665953
Ref: 94692666060
Ref: 94702666081
Ref: 94712666170
Ref: 94722666200
Ref: 94732666245
Ref: 94742666338
Ref: 94752666368
Ref: 94762666407
Ref: 94772666432
Ref: 94782666464
Ref: 94792666494
Ref: 94802666532
Ref: 94812666555
Ref: 94822666626
Ref: 94832666717
Ref: 94842666758
Ref: 94852666795
Ref: 94862666848
Ref: 94872666888
Ref: 94882666906
Ref: 94892666982
Ref: 94902667023
Ref: 94912667060
Ref: 94922667105
Ref: 94932667152
Ref: 94942667170
Ref: 94952667250
Ref: 94962667271
Ref: 94972667349
Ref: 94982667444
Ref: 94992667465
Ref: 95002667548
Ref: 95012667588
Ref: 95022667630
Ref: 95032667760
Ref: 95042667781
Ref: 95052667858
Ref: 95062667876
Ref: 95072667942
Ref: 95082667958
Ref: 95092668034
Ref: 95102668073
Ref: 95112668115
Ref: 95122668155
Ref: 95132668198
Ref: 95142668295
Ref: 95152668318
Ref: 95162668334
Ref: 95172668370
Ref: 95182668389
Ref: 95192668421
Ref: 95202668443
Ref: 95212668478
Ref: 95222668497
Ref: 95232668581
Ref: 95242668639
Ref: 95252668653
Ref: 95262668743
Ref: 95272668794
Ref: 95282668808
Ref: 95292668904
Ref: 95302668935
Ref: 95312668986
Ref: 95322669005
Ref: 95332669115
Ref: 95342669174
Ref: 95352669193
Ref: 95362669245
Ref: 95372669306
Ref: 95382669325
Ref: 95392669376
Ref: 95402669436
Ref: 95412669455
Ref: 95422669547
Ref: 95432669568
Ref: 95442669607
Ref: 95452669648
Ref: 95462669679
Ref: 95472669763
Ref: 95482669798
Ref: 95492669838
Ref: 95502669869
Ref: 95512669943
Ref: 95522669982
Ref: 95532670013
Ref: 95542670063
Ref: 95552670083
Ref: 95562670154
Ref: 95572670188
Ref: 95582670223
Ref: 95592670264
Ref: 95602670315
Ref: 95612670406
Ref: 95622670427
Ref: 95632670466
Ref: 95642670506
Ref: 95652670537
Ref: 95662670634
Ref: 95672670668
Ref: 95682670708
Ref: 95692670739
Ref: 95702670822
Ref: 95712670882
Ref: 95722670940
Ref: 95732671012
Ref: 95742671047
Ref: 95752671077
Ref: 95762671149
Ref: 95772671193
Ref: 95782671281
Ref: 95792671315
Ref: 95802671350
Ref: 95812671401
Ref: 95822671467
Ref: 95832671502
Ref: 95842671530
Ref: 95852671569
Ref: 95862671613
Ref: 95872671636
Ref: 95882671802
Ref: 95892671838
Ref: 95902671860
Ref: 95912671890
Ref: 95922671926
Ref: 95932672020
Ref: 95942672034
Ref: 95952672048
Ref: 95962672080
Ref: 95972672132
Ref: 95982672188
Ref: 95992672254
Ref: 96002672275
Ref: 96012672299
Ref: 96022672331
Ref: 96032672370
Ref: 96042672421
Ref: 96052672489
Ref: 96062672517
Ref: 96072672590
Ref: 96082672660
Ref: 96092672683
Ref: 96102672776
Ref: 96112672782
Ref: 96122672883
Ref: 96132672952
Ref: 96142672976
Ref: 96152673077
Ref: 96162673156
Ref: 96172673222
Ref: 96182673248
Ref: 96192673274
Ref: 96202673306
Ref: 96212673397
Ref: 96222673414
Ref: 96232673452
Ref: 96242673469
Ref: 96252673510
Ref: 96262673595
Ref: 96272673666
Ref: 96282673694
Ref: 96292673721
Ref: 96302673800
Ref: 96312673818
Ref: 96322673898
Ref: 96332673915
Ref: 96342674072
Ref: 96352674113
Ref: 96362674211
Ref: 96372674236
Ref: 96382674322
Ref: 96392674349
Ref: 96402674446
Ref: 96412674489
Ref: 96422674604
Ref: 96432674653
Ref: 96442674740
Ref: 96452674762
Ref: 96462674843
Ref: 96472674869
Ref: 96482674930
Ref: 96492675010
Ref: 96502675025
Ref: 96512675076
Ref: 96522675152
Ref: 96532675167
Ref: 96542675189
Ref: 96552675204
Ref: 96562675266
Ref: 96572675300
Ref: 96582675337
Ref: 96592675438
Ref: 96602675465
Ref: 96612675495
Ref: 96622675519
Ref: 96632675615
Ref: 96642675652
Ref: 96652675689
Ref: 96662675770
Ref: 96672675788
Ref: 96682675849
Ref: 96692675901
Ref: 96702675959
Ref: 96712675973
Ref: 96722676027
Ref: 96732676049
Ref: 96742676161
Ref: 96752676190
Ref: 96762676281
Ref: 96772676310
Ref: 96782676358
Ref: 96792676381
Ref: 96802676401
Ref: 96812676424
Ref: 96822676506
Ref: 96832676536
Ref: 96842676585
Ref: 96852676679
Ref: 96862676723
Ref: 96872676811
Ref: 96882676855
Ref: 96892676953
Ref: 96902676997
Ref: 96912677069
Ref: 96922677087
Ref: 96932677150
Ref: 96942677196
Ref: 96952677290
Ref: 96962677341
Ref: 96972677369
Ref: 96982677450
Ref: 96992677483
Ref: 97002677503
Ref: 97012677540
Ref: 97022677623
Ref: 97032677701
Ref: 97042677798
Ref: 97052677818
Ref: 97062677895
Ref: 97072677915
Ref: 97082677989
Ref: 97092678022
Ref: 97102678127
Ref: 97112678148
Ref: 97122678187
Ref: 97132678278
Ref: 97142678299
Ref: 97152678380
Ref: 97162678425
Ref: 97172678515
Ref: 97182678552
Ref: 97192678587
Ref: 97202678628
Ref: 97212678725
Ref: 97222678791
Ref: 97232678797
Ref: 97242678836
Ref: 97252678870
Ref: 97262678912
Ref: 97272678980
Ref: 97282678986
Ref: 97292679025
Ref: 97302679059
Ref: 97312679100
Ref: 97322679160
Ref: 97332679166
Ref: 97342679205
Ref: 97352679287
Ref: 97362679310
Ref: 97372679418
Ref: 97382679436
Ref: 97392679539
Ref: 97402679563
Ref: 97412679591
Ref: 97422679606
Ref: 97432679613
Ref: 97442679655
Ref: 97452679725
Ref: 97462679752
Ref: 97472679758
Ref: 97482679774
Ref: 97492679797
Ref: 97502679831
Ref: 97512679864
Ref: 97522679891
Ref: 97532679896
Ref: 97542679918
Ref: 97552679958
Ref: 97562680046
Ref: 97572680090
Ref: 97582680202
Ref: 97592680222
Ref: 97602680244
Ref: 97612680287
Ref: 97622680389
Ref: 97632680409
Ref: 97642680505
Ref: 97652680547
Ref: 97662680589
Ref: 97672680632
Ref: 97682680681
Ref: 97692680723
Ref: 97702680767
Ref: 97712680817
Ref: 97722680866
Ref: 97732680906
Ref: 97742680947
Ref: 97752681193
Ref: 97762681212
Ref: 97772681763
Ref: 97782681846
Ref: 97792681933
Ref: 97802682018
Ref: 97812682074
Ref: 97822682197
Ref: 97832682226
Ref: 97842682260
Ref: 97852682367
Ref: 97862682405
Ref: 97872682439
Ref: 97882682510
Ref: 97892682577
Ref: 97902682661
Ref: 97912682706
Ref: 97922682718
Ref: 97932682759
Ref: 97942682875
Ref: 97952682906
Ref: 97962682936
Ref: 97972683054
Ref: 97982683110
Ref: 97992683173
Ref: 98002683214
Ref: 98012683261
Ref: 98022683303
Ref: 98032683353
Ref: 98042683378
Ref: 98052683390
Ref: 98062683439
Ref: 98072683510
Ref: 98082683526
Ref: 98092683564
Ref: 98102683580
Ref: 98112683653
Ref: 98122683721
Ref: 98132683728
Ref: 98142683741
Ref: 98152683825
Ref: 98162683836
Ref: 98172683861
Ref: 98182683888
Ref: 98192683899
Ref: 98202683924
Ref: 98212684023
Ref: 98222684038
Ref: 98232684112
Ref: 98242684218
Ref: 98252684252
Ref: 98262684278
Ref: 98272684389
Ref: 98282684403
Ref: 98292684418
Ref: 98302684431
Ref: 98312684490
Ref: 98322684551
Ref: 98332684618
Ref: 98342684680
Ref: 98352684772
Ref: 98362684851
Ref: 98372684897
Ref: 98382684911
Ref: 98392685009
Ref: 98402685016
Ref: 98412685087
Ref: 98422685106
Ref: 98432685172
Ref: 98442685191
Ref: 98452685258
Ref: 98462685295
Ref: 98472685295
Ref: 98482685295
Ref: 98492685295
Ref: 98502685295
Node: Annex Q2730843
Node: Q.12731409
Ref: 98512731585
Node: Q.22743278
Ref: 98522743496
Ref: 98532743496
Node: Q.32759969
Ref: 98542760166
Node: Q.42829070
Ref: 98552829264
Node: Q.52833049
Ref: 98562833276
Ref: 98572833276
Ref: 98582833276
Node: Index2857740
Node: operators2858034
Node: A2859482
Node: B2897415
Node: C2905257
Node: D2940942
Node: E2962558
Node: F2994333
Node: G3007994
Node: H3015656
Node: I3019876
Node: J3046555
Node: K3046749
Node: L3047541
Node: M3063230
Node: N3072894
Node: O3087495
Node: P3094747
Node: Q3121600
Node: R3123439
Node: S3145799
Node: T3175554
Node: U3193847
Node: V3204999
Node: W3209100
Node: X3215441
Node: Y3215575

End Tag Table


Local Variables:
coding: iso-8859-1
End:
